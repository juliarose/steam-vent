// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_clientmetrics.steamclient.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:CClientMetrics_AppInterfaceCreation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientMetrics_AppInterfaceCreation {
    // message fields
    // @@protoc_insertion_point(field:CClientMetrics_AppInterfaceCreation.raw_version)
    pub raw_version: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientMetrics_AppInterfaceCreation.requested_interface_type)
    pub requested_interface_type: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientMetrics_AppInterfaceCreation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_AppInterfaceCreation {
    fn default() -> &'a CClientMetrics_AppInterfaceCreation {
        <CClientMetrics_AppInterfaceCreation as ::protobuf::Message>::default_instance()
    }
}

impl CClientMetrics_AppInterfaceCreation {
    pub fn new() -> CClientMetrics_AppInterfaceCreation {
        ::std::default::Default::default()
    }

    // optional string raw_version = 1;

    pub fn raw_version(&self) -> &str {
        match self.raw_version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_raw_version(&mut self) {
        self.raw_version = ::std::option::Option::None;
    }

    pub fn has_raw_version(&self) -> bool {
        self.raw_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_version(&mut self, v: ::std::string::String) {
        self.raw_version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_raw_version(&mut self) -> &mut ::std::string::String {
        if self.raw_version.is_none() {
            self.raw_version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.raw_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_raw_version(&mut self) -> ::std::string::String {
        self.raw_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string requested_interface_type = 2;

    pub fn requested_interface_type(&self) -> &str {
        match self.requested_interface_type.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_requested_interface_type(&mut self) {
        self.requested_interface_type = ::std::option::Option::None;
    }

    pub fn has_requested_interface_type(&self) -> bool {
        self.requested_interface_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requested_interface_type(&mut self, v: ::std::string::String) {
        self.requested_interface_type = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_requested_interface_type(&mut self) -> &mut ::std::string::String {
        if self.requested_interface_type.is_none() {
            self.requested_interface_type = ::std::option::Option::Some(::std::string::String::new());
        }
        self.requested_interface_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_requested_interface_type(&mut self) -> ::std::string::String {
        self.requested_interface_type.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CClientMetrics_AppInterfaceCreation {
    const NAME: &'static str = "CClientMetrics_AppInterfaceCreation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.raw_version = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.requested_interface_type = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.raw_version.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.requested_interface_type.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.raw_version.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.requested_interface_type.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientMetrics_AppInterfaceCreation {
        CClientMetrics_AppInterfaceCreation::new()
    }

    fn clear(&mut self) {
        self.raw_version = ::std::option::Option::None;
        self.requested_interface_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientMetrics_AppInterfaceCreation {
        static instance: CClientMetrics_AppInterfaceCreation = CClientMetrics_AppInterfaceCreation {
            raw_version: ::std::option::Option::None,
            requested_interface_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CClientMetrics_AppInterfaceMethodCounts)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientMetrics_AppInterfaceMethodCounts {
    // message fields
    // @@protoc_insertion_point(field:CClientMetrics_AppInterfaceMethodCounts.interface_name)
    pub interface_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientMetrics_AppInterfaceMethodCounts.method_name)
    pub method_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientMetrics_AppInterfaceMethodCounts.call_count)
    pub call_count: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientMetrics_AppInterfaceMethodCounts.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_AppInterfaceMethodCounts {
    fn default() -> &'a CClientMetrics_AppInterfaceMethodCounts {
        <CClientMetrics_AppInterfaceMethodCounts as ::protobuf::Message>::default_instance()
    }
}

impl CClientMetrics_AppInterfaceMethodCounts {
    pub fn new() -> CClientMetrics_AppInterfaceMethodCounts {
        ::std::default::Default::default()
    }

    // optional string interface_name = 1;

    pub fn interface_name(&self) -> &str {
        match self.interface_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_interface_name(&mut self) {
        self.interface_name = ::std::option::Option::None;
    }

    pub fn has_interface_name(&self) -> bool {
        self.interface_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_interface_name(&mut self, v: ::std::string::String) {
        self.interface_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_interface_name(&mut self) -> &mut ::std::string::String {
        if self.interface_name.is_none() {
            self.interface_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.interface_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_interface_name(&mut self) -> ::std::string::String {
        self.interface_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string method_name = 2;

    pub fn method_name(&self) -> &str {
        match self.method_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_method_name(&mut self) {
        self.method_name = ::std::option::Option::None;
    }

    pub fn has_method_name(&self) -> bool {
        self.method_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_method_name(&mut self, v: ::std::string::String) {
        self.method_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_method_name(&mut self) -> &mut ::std::string::String {
        if self.method_name.is_none() {
            self.method_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.method_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_method_name(&mut self) -> ::std::string::String {
        self.method_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 call_count = 3;

    pub fn call_count(&self) -> u32 {
        self.call_count.unwrap_or(0)
    }

    pub fn clear_call_count(&mut self) {
        self.call_count = ::std::option::Option::None;
    }

    pub fn has_call_count(&self) -> bool {
        self.call_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_call_count(&mut self, v: u32) {
        self.call_count = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClientMetrics_AppInterfaceMethodCounts {
    const NAME: &'static str = "CClientMetrics_AppInterfaceMethodCounts";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.interface_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.method_name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.call_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.interface_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.method_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.call_count {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.interface_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.method_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.call_count {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientMetrics_AppInterfaceMethodCounts {
        CClientMetrics_AppInterfaceMethodCounts::new()
    }

    fn clear(&mut self) {
        self.interface_name = ::std::option::Option::None;
        self.method_name = ::std::option::Option::None;
        self.call_count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientMetrics_AppInterfaceMethodCounts {
        static instance: CClientMetrics_AppInterfaceMethodCounts = CClientMetrics_AppInterfaceMethodCounts {
            interface_name: ::std::option::Option::None,
            method_name: ::std::option::Option::None,
            call_count: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CClientMetrics_AppInterfaceStats_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientMetrics_AppInterfaceStats_Notification {
    // message fields
    // @@protoc_insertion_point(field:CClientMetrics_AppInterfaceStats_Notification.game_id)
    pub game_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClientMetrics_AppInterfaceStats_Notification.interfaces_created)
    pub interfaces_created: ::std::vec::Vec<CClientMetrics_AppInterfaceCreation>,
    // @@protoc_insertion_point(field:CClientMetrics_AppInterfaceStats_Notification.methods_called)
    pub methods_called: ::std::vec::Vec<CClientMetrics_AppInterfaceMethodCounts>,
    // @@protoc_insertion_point(field:CClientMetrics_AppInterfaceStats_Notification.session_length_seconds)
    pub session_length_seconds: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientMetrics_AppInterfaceStats_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_AppInterfaceStats_Notification {
    fn default() -> &'a CClientMetrics_AppInterfaceStats_Notification {
        <CClientMetrics_AppInterfaceStats_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CClientMetrics_AppInterfaceStats_Notification {
    pub fn new() -> CClientMetrics_AppInterfaceStats_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 game_id = 1;

    pub fn game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    // optional uint32 session_length_seconds = 4;

    pub fn session_length_seconds(&self) -> u32 {
        self.session_length_seconds.unwrap_or(0)
    }

    pub fn clear_session_length_seconds(&mut self) {
        self.session_length_seconds = ::std::option::Option::None;
    }

    pub fn has_session_length_seconds(&self) -> bool {
        self.session_length_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_length_seconds(&mut self, v: u32) {
        self.session_length_seconds = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClientMetrics_AppInterfaceStats_Notification {
    const NAME: &'static str = "CClientMetrics_AppInterfaceStats_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.game_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.interfaces_created.push(is.read_message()?);
                },
                26 => {
                    self.methods_called.push(is.read_message()?);
                },
                32 => {
                    self.session_length_seconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.game_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        for value in &self.interfaces_created {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.methods_called {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.session_length_seconds {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.game_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.interfaces_created {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.methods_called {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.session_length_seconds {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientMetrics_AppInterfaceStats_Notification {
        CClientMetrics_AppInterfaceStats_Notification::new()
    }

    fn clear(&mut self) {
        self.game_id = ::std::option::Option::None;
        self.interfaces_created.clear();
        self.methods_called.clear();
        self.session_length_seconds = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientMetrics_AppInterfaceStats_Notification {
        static instance: CClientMetrics_AppInterfaceStats_Notification = CClientMetrics_AppInterfaceStats_Notification {
            game_id: ::std::option::Option::None,
            interfaces_created: ::std::vec::Vec::new(),
            methods_called: ::std::vec::Vec::new(),
            session_length_seconds: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CClientMetrics_IPv6Connectivity_Result)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientMetrics_IPv6Connectivity_Result {
    // message fields
    // @@protoc_insertion_point(field:CClientMetrics_IPv6Connectivity_Result.protocol_tested)
    pub protocol_tested: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientMetrics_IPv6Connectivity_Result.connectivity_state)
    pub connectivity_state: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientMetrics_IPv6Connectivity_Result.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_IPv6Connectivity_Result {
    fn default() -> &'a CClientMetrics_IPv6Connectivity_Result {
        <CClientMetrics_IPv6Connectivity_Result as ::protobuf::Message>::default_instance()
    }
}

impl CClientMetrics_IPv6Connectivity_Result {
    pub fn new() -> CClientMetrics_IPv6Connectivity_Result {
        ::std::default::Default::default()
    }

    // optional uint32 protocol_tested = 1;

    pub fn protocol_tested(&self) -> u32 {
        self.protocol_tested.unwrap_or(0)
    }

    pub fn clear_protocol_tested(&mut self) {
        self.protocol_tested = ::std::option::Option::None;
    }

    pub fn has_protocol_tested(&self) -> bool {
        self.protocol_tested.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_tested(&mut self, v: u32) {
        self.protocol_tested = ::std::option::Option::Some(v);
    }

    // optional uint32 connectivity_state = 2;

    pub fn connectivity_state(&self) -> u32 {
        self.connectivity_state.unwrap_or(0)
    }

    pub fn clear_connectivity_state(&mut self) {
        self.connectivity_state = ::std::option::Option::None;
    }

    pub fn has_connectivity_state(&self) -> bool {
        self.connectivity_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connectivity_state(&mut self, v: u32) {
        self.connectivity_state = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClientMetrics_IPv6Connectivity_Result {
    const NAME: &'static str = "CClientMetrics_IPv6Connectivity_Result";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.protocol_tested = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.connectivity_state = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.protocol_tested {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.connectivity_state {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.protocol_tested {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.connectivity_state {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientMetrics_IPv6Connectivity_Result {
        CClientMetrics_IPv6Connectivity_Result::new()
    }

    fn clear(&mut self) {
        self.protocol_tested = ::std::option::Option::None;
        self.connectivity_state = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientMetrics_IPv6Connectivity_Result {
        static instance: CClientMetrics_IPv6Connectivity_Result = CClientMetrics_IPv6Connectivity_Result {
            protocol_tested: ::std::option::Option::None,
            connectivity_state: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CClientMetrics_IPv6Connectivity_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientMetrics_IPv6Connectivity_Notification {
    // message fields
    // @@protoc_insertion_point(field:CClientMetrics_IPv6Connectivity_Notification.cell_id)
    pub cell_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientMetrics_IPv6Connectivity_Notification.results)
    pub results: ::std::vec::Vec<CClientMetrics_IPv6Connectivity_Result>,
    // @@protoc_insertion_point(field:CClientMetrics_IPv6Connectivity_Notification.private_ip_is_rfc6598)
    pub private_ip_is_rfc6598: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientMetrics_IPv6Connectivity_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_IPv6Connectivity_Notification {
    fn default() -> &'a CClientMetrics_IPv6Connectivity_Notification {
        <CClientMetrics_IPv6Connectivity_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CClientMetrics_IPv6Connectivity_Notification {
    pub fn new() -> CClientMetrics_IPv6Connectivity_Notification {
        ::std::default::Default::default()
    }

    // optional uint32 cell_id = 1;

    pub fn cell_id(&self) -> u32 {
        self.cell_id.unwrap_or(0)
    }

    pub fn clear_cell_id(&mut self) {
        self.cell_id = ::std::option::Option::None;
    }

    pub fn has_cell_id(&self) -> bool {
        self.cell_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cell_id(&mut self, v: u32) {
        self.cell_id = ::std::option::Option::Some(v);
    }

    // optional bool private_ip_is_rfc6598 = 3;

    pub fn private_ip_is_rfc6598(&self) -> bool {
        self.private_ip_is_rfc6598.unwrap_or(false)
    }

    pub fn clear_private_ip_is_rfc6598(&mut self) {
        self.private_ip_is_rfc6598 = ::std::option::Option::None;
    }

    pub fn has_private_ip_is_rfc6598(&self) -> bool {
        self.private_ip_is_rfc6598.is_some()
    }

    // Param is passed by value, moved
    pub fn set_private_ip_is_rfc6598(&mut self, v: bool) {
        self.private_ip_is_rfc6598 = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClientMetrics_IPv6Connectivity_Notification {
    const NAME: &'static str = "CClientMetrics_IPv6Connectivity_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.cell_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.results.push(is.read_message()?);
                },
                24 => {
                    self.private_ip_is_rfc6598 = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cell_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.private_ip_is_rfc6598 {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cell_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.results {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.private_ip_is_rfc6598 {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientMetrics_IPv6Connectivity_Notification {
        CClientMetrics_IPv6Connectivity_Notification::new()
    }

    fn clear(&mut self) {
        self.cell_id = ::std::option::Option::None;
        self.results.clear();
        self.private_ip_is_rfc6598 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientMetrics_IPv6Connectivity_Notification {
        static instance: CClientMetrics_IPv6Connectivity_Notification = CClientMetrics_IPv6Connectivity_Notification {
            cell_id: ::std::option::Option::None,
            results: ::std::vec::Vec::new(),
            private_ip_is_rfc6598: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CClientMetrics_SteamPipeWorkStats_Operation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientMetrics_SteamPipeWorkStats_Operation {
    // message fields
    // @@protoc_insertion_point(field:CClientMetrics_SteamPipeWorkStats_Operation.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<ESteamPipeOperationType>>,
    // @@protoc_insertion_point(field:CClientMetrics_SteamPipeWorkStats_Operation.num_ops)
    pub num_ops: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientMetrics_SteamPipeWorkStats_Operation.num_bytes)
    pub num_bytes: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClientMetrics_SteamPipeWorkStats_Operation.busy_time_ms)
    pub busy_time_ms: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClientMetrics_SteamPipeWorkStats_Operation.idle_time_ms)
    pub idle_time_ms: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClientMetrics_SteamPipeWorkStats_Operation.sum_run_time_ms)
    pub sum_run_time_ms: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClientMetrics_SteamPipeWorkStats_Operation.sum_wait_time_ms)
    pub sum_wait_time_ms: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientMetrics_SteamPipeWorkStats_Operation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_SteamPipeWorkStats_Operation {
    fn default() -> &'a CClientMetrics_SteamPipeWorkStats_Operation {
        <CClientMetrics_SteamPipeWorkStats_Operation as ::protobuf::Message>::default_instance()
    }
}

impl CClientMetrics_SteamPipeWorkStats_Operation {
    pub fn new() -> CClientMetrics_SteamPipeWorkStats_Operation {
        ::std::default::Default::default()
    }

    // optional .ESteamPipeOperationType type = 1;

    pub fn type_(&self) -> ESteamPipeOperationType {
        match self.type_ {
            Some(e) => e.enum_value_or(ESteamPipeOperationType::k_ESteamPipeOperationType_Invalid),
            None => ESteamPipeOperationType::k_ESteamPipeOperationType_Invalid,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ESteamPipeOperationType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 num_ops = 2;

    pub fn num_ops(&self) -> u32 {
        self.num_ops.unwrap_or(0)
    }

    pub fn clear_num_ops(&mut self) {
        self.num_ops = ::std::option::Option::None;
    }

    pub fn has_num_ops(&self) -> bool {
        self.num_ops.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_ops(&mut self, v: u32) {
        self.num_ops = ::std::option::Option::Some(v);
    }

    // optional uint64 num_bytes = 3;

    pub fn num_bytes(&self) -> u64 {
        self.num_bytes.unwrap_or(0)
    }

    pub fn clear_num_bytes(&mut self) {
        self.num_bytes = ::std::option::Option::None;
    }

    pub fn has_num_bytes(&self) -> bool {
        self.num_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_bytes(&mut self, v: u64) {
        self.num_bytes = ::std::option::Option::Some(v);
    }

    // optional uint64 busy_time_ms = 4;

    pub fn busy_time_ms(&self) -> u64 {
        self.busy_time_ms.unwrap_or(0)
    }

    pub fn clear_busy_time_ms(&mut self) {
        self.busy_time_ms = ::std::option::Option::None;
    }

    pub fn has_busy_time_ms(&self) -> bool {
        self.busy_time_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_busy_time_ms(&mut self, v: u64) {
        self.busy_time_ms = ::std::option::Option::Some(v);
    }

    // optional uint64 idle_time_ms = 5;

    pub fn idle_time_ms(&self) -> u64 {
        self.idle_time_ms.unwrap_or(0)
    }

    pub fn clear_idle_time_ms(&mut self) {
        self.idle_time_ms = ::std::option::Option::None;
    }

    pub fn has_idle_time_ms(&self) -> bool {
        self.idle_time_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_idle_time_ms(&mut self, v: u64) {
        self.idle_time_ms = ::std::option::Option::Some(v);
    }

    // optional uint64 sum_run_time_ms = 6;

    pub fn sum_run_time_ms(&self) -> u64 {
        self.sum_run_time_ms.unwrap_or(0)
    }

    pub fn clear_sum_run_time_ms(&mut self) {
        self.sum_run_time_ms = ::std::option::Option::None;
    }

    pub fn has_sum_run_time_ms(&self) -> bool {
        self.sum_run_time_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sum_run_time_ms(&mut self, v: u64) {
        self.sum_run_time_ms = ::std::option::Option::Some(v);
    }

    // optional uint64 sum_wait_time_ms = 7;

    pub fn sum_wait_time_ms(&self) -> u64 {
        self.sum_wait_time_ms.unwrap_or(0)
    }

    pub fn clear_sum_wait_time_ms(&mut self) {
        self.sum_wait_time_ms = ::std::option::Option::None;
    }

    pub fn has_sum_wait_time_ms(&self) -> bool {
        self.sum_wait_time_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sum_wait_time_ms(&mut self, v: u64) {
        self.sum_wait_time_ms = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClientMetrics_SteamPipeWorkStats_Operation {
    const NAME: &'static str = "CClientMetrics_SteamPipeWorkStats_Operation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.num_ops = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.num_bytes = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.busy_time_ms = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.idle_time_ms = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.sum_run_time_ms = ::std::option::Option::Some(is.read_uint64()?);
                },
                56 => {
                    self.sum_wait_time_ms = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.num_ops {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.num_bytes {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.busy_time_ms {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.idle_time_ms {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.sum_run_time_ms {
            my_size += ::protobuf::rt::uint64_size(6, v);
        }
        if let Some(v) = self.sum_wait_time_ms {
            my_size += ::protobuf::rt::uint64_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.num_ops {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.num_bytes {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.busy_time_ms {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.idle_time_ms {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.sum_run_time_ms {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.sum_wait_time_ms {
            os.write_uint64(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientMetrics_SteamPipeWorkStats_Operation {
        CClientMetrics_SteamPipeWorkStats_Operation::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.num_ops = ::std::option::Option::None;
        self.num_bytes = ::std::option::Option::None;
        self.busy_time_ms = ::std::option::Option::None;
        self.idle_time_ms = ::std::option::Option::None;
        self.sum_run_time_ms = ::std::option::Option::None;
        self.sum_wait_time_ms = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientMetrics_SteamPipeWorkStats_Operation {
        static instance: CClientMetrics_SteamPipeWorkStats_Operation = CClientMetrics_SteamPipeWorkStats_Operation {
            type_: ::std::option::Option::None,
            num_ops: ::std::option::Option::None,
            num_bytes: ::std::option::Option::None,
            busy_time_ms: ::std::option::Option::None,
            idle_time_ms: ::std::option::Option::None,
            sum_run_time_ms: ::std::option::Option::None,
            sum_wait_time_ms: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CClientMetrics_SteamPipeWorkStats_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientMetrics_SteamPipeWorkStats_Notification {
    // message fields
    // @@protoc_insertion_point(field:CClientMetrics_SteamPipeWorkStats_Notification.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientMetrics_SteamPipeWorkStats_Notification.depotid)
    pub depotid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientMetrics_SteamPipeWorkStats_Notification.work_type)
    pub work_type: ::std::option::Option<::protobuf::EnumOrUnknown<ESteamPipeWorkType>>,
    // @@protoc_insertion_point(field:CClientMetrics_SteamPipeWorkStats_Notification.operations)
    pub operations: ::std::vec::Vec<CClientMetrics_SteamPipeWorkStats_Operation>,
    // @@protoc_insertion_point(field:CClientMetrics_SteamPipeWorkStats_Notification.hardware_type)
    pub hardware_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientMetrics_SteamPipeWorkStats_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_SteamPipeWorkStats_Notification {
    fn default() -> &'a CClientMetrics_SteamPipeWorkStats_Notification {
        <CClientMetrics_SteamPipeWorkStats_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CClientMetrics_SteamPipeWorkStats_Notification {
    pub fn new() -> CClientMetrics_SteamPipeWorkStats_Notification {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 depotid = 2;

    pub fn depotid(&self) -> u32 {
        self.depotid.unwrap_or(0)
    }

    pub fn clear_depotid(&mut self) {
        self.depotid = ::std::option::Option::None;
    }

    pub fn has_depotid(&self) -> bool {
        self.depotid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_depotid(&mut self, v: u32) {
        self.depotid = ::std::option::Option::Some(v);
    }

    // optional .ESteamPipeWorkType work_type = 3;

    pub fn work_type(&self) -> ESteamPipeWorkType {
        match self.work_type {
            Some(e) => e.enum_value_or(ESteamPipeWorkType::k_ESteamPipeClientWorkType_Invalid),
            None => ESteamPipeWorkType::k_ESteamPipeClientWorkType_Invalid,
        }
    }

    pub fn clear_work_type(&mut self) {
        self.work_type = ::std::option::Option::None;
    }

    pub fn has_work_type(&self) -> bool {
        self.work_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_work_type(&mut self, v: ESteamPipeWorkType) {
        self.work_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 hardware_type = 5;

    pub fn hardware_type(&self) -> u32 {
        self.hardware_type.unwrap_or(0)
    }

    pub fn clear_hardware_type(&mut self) {
        self.hardware_type = ::std::option::Option::None;
    }

    pub fn has_hardware_type(&self) -> bool {
        self.hardware_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hardware_type(&mut self, v: u32) {
        self.hardware_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClientMetrics_SteamPipeWorkStats_Notification {
    const NAME: &'static str = "CClientMetrics_SteamPipeWorkStats_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.depotid = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.work_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                34 => {
                    self.operations.push(is.read_message()?);
                },
                40 => {
                    self.hardware_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.depotid {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.work_type {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        for value in &self.operations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.hardware_type {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.depotid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.work_type {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.operations {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.hardware_type {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientMetrics_SteamPipeWorkStats_Notification {
        CClientMetrics_SteamPipeWorkStats_Notification::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.depotid = ::std::option::Option::None;
        self.work_type = ::std::option::Option::None;
        self.operations.clear();
        self.hardware_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientMetrics_SteamPipeWorkStats_Notification {
        static instance: CClientMetrics_SteamPipeWorkStats_Notification = CClientMetrics_SteamPipeWorkStats_Notification {
            appid: ::std::option::Option::None,
            depotid: ::std::option::Option::None,
            work_type: ::std::option::Option::None,
            operations: ::std::vec::Vec::new(),
            hardware_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CClientMetrics_ReportReactUsage_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientMetrics_ReportReactUsage_Notification {
    // message fields
    // @@protoc_insertion_point(field:CClientMetrics_ReportReactUsage_Notification.product)
    pub product: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientMetrics_ReportReactUsage_Notification.version)
    pub version: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientMetrics_ReportReactUsage_Notification.routes)
    pub routes: ::std::vec::Vec<cclient_metrics_report_react_usage_notification::RouteData>,
    // @@protoc_insertion_point(field:CClientMetrics_ReportReactUsage_Notification.components)
    pub components: ::std::vec::Vec<cclient_metrics_report_react_usage_notification::ComponentData>,
    // @@protoc_insertion_point(field:CClientMetrics_ReportReactUsage_Notification.actions)
    pub actions: ::std::vec::Vec<cclient_metrics_report_react_usage_notification::ActionData>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientMetrics_ReportReactUsage_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_ReportReactUsage_Notification {
    fn default() -> &'a CClientMetrics_ReportReactUsage_Notification {
        <CClientMetrics_ReportReactUsage_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CClientMetrics_ReportReactUsage_Notification {
    pub fn new() -> CClientMetrics_ReportReactUsage_Notification {
        ::std::default::Default::default()
    }

    // optional string product = 1;

    pub fn product(&self) -> &str {
        match self.product.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_product(&mut self) {
        self.product = ::std::option::Option::None;
    }

    pub fn has_product(&self) -> bool {
        self.product.is_some()
    }

    // Param is passed by value, moved
    pub fn set_product(&mut self, v: ::std::string::String) {
        self.product = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_product(&mut self) -> &mut ::std::string::String {
        if self.product.is_none() {
            self.product = ::std::option::Option::Some(::std::string::String::new());
        }
        self.product.as_mut().unwrap()
    }

    // Take field
    pub fn take_product(&mut self) -> ::std::string::String {
        self.product.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string version = 2;

    pub fn version(&self) -> &str {
        match self.version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        if self.version.is_none() {
            self.version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        self.version.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CClientMetrics_ReportReactUsage_Notification {
    const NAME: &'static str = "CClientMetrics_ReportReactUsage_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.product = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.version = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.routes.push(is.read_message()?);
                },
                34 => {
                    self.components.push(is.read_message()?);
                },
                42 => {
                    self.actions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.product.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.version.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.routes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.components {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.actions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.product.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.version.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.routes {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.components {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.actions {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientMetrics_ReportReactUsage_Notification {
        CClientMetrics_ReportReactUsage_Notification::new()
    }

    fn clear(&mut self) {
        self.product = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.routes.clear();
        self.components.clear();
        self.actions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientMetrics_ReportReactUsage_Notification {
        static instance: CClientMetrics_ReportReactUsage_Notification = CClientMetrics_ReportReactUsage_Notification {
            product: ::std::option::Option::None,
            version: ::std::option::Option::None,
            routes: ::std::vec::Vec::new(),
            components: ::std::vec::Vec::new(),
            actions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CClientMetrics_ReportReactUsage_Notification`
pub mod cclient_metrics_report_react_usage_notification {
    // @@protoc_insertion_point(message:CClientMetrics_ReportReactUsage_Notification.RouteData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RouteData {
        // message fields
        // @@protoc_insertion_point(field:CClientMetrics_ReportReactUsage_Notification.RouteData.route)
        pub route: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CClientMetrics_ReportReactUsage_Notification.RouteData.count)
        pub count: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CClientMetrics_ReportReactUsage_Notification.RouteData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RouteData {
        fn default() -> &'a RouteData {
            <RouteData as ::protobuf::Message>::default_instance()
        }
    }

    impl RouteData {
        pub fn new() -> RouteData {
            ::std::default::Default::default()
        }

        // optional string route = 1;

        pub fn route(&self) -> &str {
            match self.route.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_route(&mut self) {
            self.route = ::std::option::Option::None;
        }

        pub fn has_route(&self) -> bool {
            self.route.is_some()
        }

        // Param is passed by value, moved
        pub fn set_route(&mut self, v: ::std::string::String) {
            self.route = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_route(&mut self) -> &mut ::std::string::String {
            if self.route.is_none() {
                self.route = ::std::option::Option::Some(::std::string::String::new());
            }
            self.route.as_mut().unwrap()
        }

        // Take field
        pub fn take_route(&mut self) -> ::std::string::String {
            self.route.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 count = 2;

        pub fn count(&self) -> u32 {
            self.count.unwrap_or(0)
        }

        pub fn clear_count(&mut self) {
            self.count = ::std::option::Option::None;
        }

        pub fn has_count(&self) -> bool {
            self.count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_count(&mut self, v: u32) {
            self.count = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for RouteData {
        const NAME: &'static str = "RouteData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.route = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.route.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.count {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.route.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.count {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RouteData {
            RouteData::new()
        }

        fn clear(&mut self) {
            self.route = ::std::option::Option::None;
            self.count = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RouteData {
            static instance: RouteData = RouteData {
                route: ::std::option::Option::None,
                count: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CClientMetrics_ReportReactUsage_Notification.ComponentData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ComponentData {
        // message fields
        // @@protoc_insertion_point(field:CClientMetrics_ReportReactUsage_Notification.ComponentData.component)
        pub component: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CClientMetrics_ReportReactUsage_Notification.ComponentData.count)
        pub count: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CClientMetrics_ReportReactUsage_Notification.ComponentData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ComponentData {
        fn default() -> &'a ComponentData {
            <ComponentData as ::protobuf::Message>::default_instance()
        }
    }

    impl ComponentData {
        pub fn new() -> ComponentData {
            ::std::default::Default::default()
        }

        // optional string component = 1;

        pub fn component(&self) -> &str {
            match self.component.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_component(&mut self) {
            self.component = ::std::option::Option::None;
        }

        pub fn has_component(&self) -> bool {
            self.component.is_some()
        }

        // Param is passed by value, moved
        pub fn set_component(&mut self, v: ::std::string::String) {
            self.component = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_component(&mut self) -> &mut ::std::string::String {
            if self.component.is_none() {
                self.component = ::std::option::Option::Some(::std::string::String::new());
            }
            self.component.as_mut().unwrap()
        }

        // Take field
        pub fn take_component(&mut self) -> ::std::string::String {
            self.component.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 count = 2;

        pub fn count(&self) -> u32 {
            self.count.unwrap_or(0)
        }

        pub fn clear_count(&mut self) {
            self.count = ::std::option::Option::None;
        }

        pub fn has_count(&self) -> bool {
            self.count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_count(&mut self, v: u32) {
            self.count = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for ComponentData {
        const NAME: &'static str = "ComponentData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.component = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.component.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.count {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.component.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.count {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ComponentData {
            ComponentData::new()
        }

        fn clear(&mut self) {
            self.component = ::std::option::Option::None;
            self.count = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ComponentData {
            static instance: ComponentData = ComponentData {
                component: ::std::option::Option::None,
                count: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CClientMetrics_ReportReactUsage_Notification.ActionData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ActionData {
        // message fields
        // @@protoc_insertion_point(field:CClientMetrics_ReportReactUsage_Notification.ActionData.action)
        pub action: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CClientMetrics_ReportReactUsage_Notification.ActionData.count)
        pub count: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CClientMetrics_ReportReactUsage_Notification.ActionData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ActionData {
        fn default() -> &'a ActionData {
            <ActionData as ::protobuf::Message>::default_instance()
        }
    }

    impl ActionData {
        pub fn new() -> ActionData {
            ::std::default::Default::default()
        }

        // optional string action = 1;

        pub fn action(&self) -> &str {
            match self.action.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_action(&mut self) {
            self.action = ::std::option::Option::None;
        }

        pub fn has_action(&self) -> bool {
            self.action.is_some()
        }

        // Param is passed by value, moved
        pub fn set_action(&mut self, v: ::std::string::String) {
            self.action = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_action(&mut self) -> &mut ::std::string::String {
            if self.action.is_none() {
                self.action = ::std::option::Option::Some(::std::string::String::new());
            }
            self.action.as_mut().unwrap()
        }

        // Take field
        pub fn take_action(&mut self) -> ::std::string::String {
            self.action.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 count = 2;

        pub fn count(&self) -> u32 {
            self.count.unwrap_or(0)
        }

        pub fn clear_count(&mut self) {
            self.count = ::std::option::Option::None;
        }

        pub fn has_count(&self) -> bool {
            self.count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_count(&mut self, v: u32) {
            self.count = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for ActionData {
        const NAME: &'static str = "ActionData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.action = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.action.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.count {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.action.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.count {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ActionData {
            ActionData::new()
        }

        fn clear(&mut self) {
            self.action = ::std::option::Option::None;
            self.count = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ActionData {
            static instance: ActionData = ActionData {
                action: ::std::option::Option::None,
                count: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CClientMetrics_ReportClientError_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientMetrics_ReportClientError_Notification {
    // message fields
    // @@protoc_insertion_point(field:CClientMetrics_ReportClientError_Notification.product)
    pub product: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientMetrics_ReportClientError_Notification.version)
    pub version: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientMetrics_ReportClientError_Notification.errors)
    pub errors: ::std::vec::Vec<cclient_metrics_report_client_error_notification::Error>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientMetrics_ReportClientError_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_ReportClientError_Notification {
    fn default() -> &'a CClientMetrics_ReportClientError_Notification {
        <CClientMetrics_ReportClientError_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CClientMetrics_ReportClientError_Notification {
    pub fn new() -> CClientMetrics_ReportClientError_Notification {
        ::std::default::Default::default()
    }

    // optional string product = 1;

    pub fn product(&self) -> &str {
        match self.product.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_product(&mut self) {
        self.product = ::std::option::Option::None;
    }

    pub fn has_product(&self) -> bool {
        self.product.is_some()
    }

    // Param is passed by value, moved
    pub fn set_product(&mut self, v: ::std::string::String) {
        self.product = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_product(&mut self) -> &mut ::std::string::String {
        if self.product.is_none() {
            self.product = ::std::option::Option::Some(::std::string::String::new());
        }
        self.product.as_mut().unwrap()
    }

    // Take field
    pub fn take_product(&mut self) -> ::std::string::String {
        self.product.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string version = 2;

    pub fn version(&self) -> &str {
        match self.version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        if self.version.is_none() {
            self.version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        self.version.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CClientMetrics_ReportClientError_Notification {
    const NAME: &'static str = "CClientMetrics_ReportClientError_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.product = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.version = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.errors.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.product.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.version.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.errors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.product.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.version.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.errors {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientMetrics_ReportClientError_Notification {
        CClientMetrics_ReportClientError_Notification::new()
    }

    fn clear(&mut self) {
        self.product = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.errors.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientMetrics_ReportClientError_Notification {
        static instance: CClientMetrics_ReportClientError_Notification = CClientMetrics_ReportClientError_Notification {
            product: ::std::option::Option::None,
            version: ::std::option::Option::None,
            errors: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CClientMetrics_ReportClientError_Notification`
pub mod cclient_metrics_report_client_error_notification {
    // @@protoc_insertion_point(message:CClientMetrics_ReportClientError_Notification.Error)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Error {
        // message fields
        // @@protoc_insertion_point(field:CClientMetrics_ReportClientError_Notification.Error.identifier)
        pub identifier: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CClientMetrics_ReportClientError_Notification.Error.message)
        pub message: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CClientMetrics_ReportClientError_Notification.Error.count)
        pub count: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CClientMetrics_ReportClientError_Notification.Error.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Error {
        fn default() -> &'a Error {
            <Error as ::protobuf::Message>::default_instance()
        }
    }

    impl Error {
        pub fn new() -> Error {
            ::std::default::Default::default()
        }

        // optional string identifier = 1;

        pub fn identifier(&self) -> &str {
            match self.identifier.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_identifier(&mut self) {
            self.identifier = ::std::option::Option::None;
        }

        pub fn has_identifier(&self) -> bool {
            self.identifier.is_some()
        }

        // Param is passed by value, moved
        pub fn set_identifier(&mut self, v: ::std::string::String) {
            self.identifier = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_identifier(&mut self) -> &mut ::std::string::String {
            if self.identifier.is_none() {
                self.identifier = ::std::option::Option::Some(::std::string::String::new());
            }
            self.identifier.as_mut().unwrap()
        }

        // Take field
        pub fn take_identifier(&mut self) -> ::std::string::String {
            self.identifier.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string message = 2;

        pub fn message(&self) -> &str {
            match self.message.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_message(&mut self) {
            self.message = ::std::option::Option::None;
        }

        pub fn has_message(&self) -> bool {
            self.message.is_some()
        }

        // Param is passed by value, moved
        pub fn set_message(&mut self, v: ::std::string::String) {
            self.message = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_message(&mut self) -> &mut ::std::string::String {
            if self.message.is_none() {
                self.message = ::std::option::Option::Some(::std::string::String::new());
            }
            self.message.as_mut().unwrap()
        }

        // Take field
        pub fn take_message(&mut self) -> ::std::string::String {
            self.message.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 count = 3;

        pub fn count(&self) -> u32 {
            self.count.unwrap_or(0)
        }

        pub fn clear_count(&mut self) {
            self.count = ::std::option::Option::None;
        }

        pub fn has_count(&self) -> bool {
            self.count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_count(&mut self, v: u32) {
            self.count = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Error {
        const NAME: &'static str = "Error";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.identifier = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.message = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.identifier.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.message.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.count {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.identifier.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.message.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.count {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Error {
            Error::new()
        }

        fn clear(&mut self) {
            self.identifier = ::std::option::Option::None;
            self.message = ::std::option::Option::None;
            self.count = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Error {
            static instance: Error = Error {
                identifier: ::std::option::Option::None,
                message: ::std::option::Option::None,
                count: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CClientMetrics_ClientBootstrap_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientMetrics_ClientBootstrap_Notification {
    // message fields
    // @@protoc_insertion_point(field:CClientMetrics_ClientBootstrap_Notification.summary)
    pub summary: ::protobuf::MessageField<super::clientmetrics::CClientMetrics_ClientBootstrap_Summary>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientMetrics_ClientBootstrap_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_ClientBootstrap_Notification {
    fn default() -> &'a CClientMetrics_ClientBootstrap_Notification {
        <CClientMetrics_ClientBootstrap_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CClientMetrics_ClientBootstrap_Notification {
    pub fn new() -> CClientMetrics_ClientBootstrap_Notification {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CClientMetrics_ClientBootstrap_Notification {
    const NAME: &'static str = "CClientMetrics_ClientBootstrap_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.summary)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.summary.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientMetrics_ClientBootstrap_Notification {
        CClientMetrics_ClientBootstrap_Notification::new()
    }

    fn clear(&mut self) {
        self.summary.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientMetrics_ClientBootstrap_Notification {
        static instance: CClientMetrics_ClientBootstrap_Notification = CClientMetrics_ClientBootstrap_Notification {
            summary: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CClientMetrics_DownloadRates_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientMetrics_DownloadRates_Notification {
    // message fields
    // @@protoc_insertion_point(field:CClientMetrics_DownloadRates_Notification.cell_id)
    pub cell_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientMetrics_DownloadRates_Notification.stats)
    pub stats: ::std::vec::Vec<cclient_metrics_download_rates_notification::StatsInfo>,
    // @@protoc_insertion_point(field:CClientMetrics_DownloadRates_Notification.throttling_kbps)
    pub throttling_kbps: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientMetrics_DownloadRates_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_DownloadRates_Notification {
    fn default() -> &'a CClientMetrics_DownloadRates_Notification {
        <CClientMetrics_DownloadRates_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CClientMetrics_DownloadRates_Notification {
    pub fn new() -> CClientMetrics_DownloadRates_Notification {
        ::std::default::Default::default()
    }

    // optional uint32 cell_id = 1;

    pub fn cell_id(&self) -> u32 {
        self.cell_id.unwrap_or(0)
    }

    pub fn clear_cell_id(&mut self) {
        self.cell_id = ::std::option::Option::None;
    }

    pub fn has_cell_id(&self) -> bool {
        self.cell_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cell_id(&mut self, v: u32) {
        self.cell_id = ::std::option::Option::Some(v);
    }

    // optional uint32 throttling_kbps = 3;

    pub fn throttling_kbps(&self) -> u32 {
        self.throttling_kbps.unwrap_or(0)
    }

    pub fn clear_throttling_kbps(&mut self) {
        self.throttling_kbps = ::std::option::Option::None;
    }

    pub fn has_throttling_kbps(&self) -> bool {
        self.throttling_kbps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_throttling_kbps(&mut self, v: u32) {
        self.throttling_kbps = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClientMetrics_DownloadRates_Notification {
    const NAME: &'static str = "CClientMetrics_DownloadRates_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.cell_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.stats.push(is.read_message()?);
                },
                24 => {
                    self.throttling_kbps = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cell_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.throttling_kbps {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cell_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.stats {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.throttling_kbps {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientMetrics_DownloadRates_Notification {
        CClientMetrics_DownloadRates_Notification::new()
    }

    fn clear(&mut self) {
        self.cell_id = ::std::option::Option::None;
        self.stats.clear();
        self.throttling_kbps = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientMetrics_DownloadRates_Notification {
        static instance: CClientMetrics_DownloadRates_Notification = CClientMetrics_DownloadRates_Notification {
            cell_id: ::std::option::Option::None,
            stats: ::std::vec::Vec::new(),
            throttling_kbps: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CClientMetrics_DownloadRates_Notification`
pub mod cclient_metrics_download_rates_notification {
    // @@protoc_insertion_point(message:CClientMetrics_DownloadRates_Notification.StatsInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct StatsInfo {
        // message fields
        // @@protoc_insertion_point(field:CClientMetrics_DownloadRates_Notification.StatsInfo.source_type)
        pub source_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CClientMetrics_DownloadRates_Notification.StatsInfo.source_id)
        pub source_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CClientMetrics_DownloadRates_Notification.StatsInfo.bytes)
        pub bytes: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CClientMetrics_DownloadRates_Notification.StatsInfo.host_name)
        pub host_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CClientMetrics_DownloadRates_Notification.StatsInfo.microseconds)
        pub microseconds: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CClientMetrics_DownloadRates_Notification.StatsInfo.used_ipv6)
        pub used_ipv6: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CClientMetrics_DownloadRates_Notification.StatsInfo.proxied)
        pub proxied: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CClientMetrics_DownloadRates_Notification.StatsInfo.used_http2)
        pub used_http2: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CClientMetrics_DownloadRates_Notification.StatsInfo.cache_hits)
        pub cache_hits: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CClientMetrics_DownloadRates_Notification.StatsInfo.cache_misses)
        pub cache_misses: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CClientMetrics_DownloadRates_Notification.StatsInfo.hit_bytes)
        pub hit_bytes: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CClientMetrics_DownloadRates_Notification.StatsInfo.miss_bytes)
        pub miss_bytes: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CClientMetrics_DownloadRates_Notification.StatsInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a StatsInfo {
        fn default() -> &'a StatsInfo {
            <StatsInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl StatsInfo {
        pub fn new() -> StatsInfo {
            ::std::default::Default::default()
        }

        // optional uint32 source_type = 1;

        pub fn source_type(&self) -> u32 {
            self.source_type.unwrap_or(0)
        }

        pub fn clear_source_type(&mut self) {
            self.source_type = ::std::option::Option::None;
        }

        pub fn has_source_type(&self) -> bool {
            self.source_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_source_type(&mut self, v: u32) {
            self.source_type = ::std::option::Option::Some(v);
        }

        // optional uint32 source_id = 2;

        pub fn source_id(&self) -> u32 {
            self.source_id.unwrap_or(0)
        }

        pub fn clear_source_id(&mut self) {
            self.source_id = ::std::option::Option::None;
        }

        pub fn has_source_id(&self) -> bool {
            self.source_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_source_id(&mut self, v: u32) {
            self.source_id = ::std::option::Option::Some(v);
        }

        // optional uint64 bytes = 3;

        pub fn bytes(&self) -> u64 {
            self.bytes.unwrap_or(0)
        }

        pub fn clear_bytes(&mut self) {
            self.bytes = ::std::option::Option::None;
        }

        pub fn has_bytes(&self) -> bool {
            self.bytes.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bytes(&mut self, v: u64) {
            self.bytes = ::std::option::Option::Some(v);
        }

        // optional string host_name = 4;

        pub fn host_name(&self) -> &str {
            match self.host_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_host_name(&mut self) {
            self.host_name = ::std::option::Option::None;
        }

        pub fn has_host_name(&self) -> bool {
            self.host_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_host_name(&mut self, v: ::std::string::String) {
            self.host_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_host_name(&mut self) -> &mut ::std::string::String {
            if self.host_name.is_none() {
                self.host_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.host_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_host_name(&mut self) -> ::std::string::String {
            self.host_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint64 microseconds = 5;

        pub fn microseconds(&self) -> u64 {
            self.microseconds.unwrap_or(0)
        }

        pub fn clear_microseconds(&mut self) {
            self.microseconds = ::std::option::Option::None;
        }

        pub fn has_microseconds(&self) -> bool {
            self.microseconds.is_some()
        }

        // Param is passed by value, moved
        pub fn set_microseconds(&mut self, v: u64) {
            self.microseconds = ::std::option::Option::Some(v);
        }

        // optional bool used_ipv6 = 6;

        pub fn used_ipv6(&self) -> bool {
            self.used_ipv6.unwrap_or(false)
        }

        pub fn clear_used_ipv6(&mut self) {
            self.used_ipv6 = ::std::option::Option::None;
        }

        pub fn has_used_ipv6(&self) -> bool {
            self.used_ipv6.is_some()
        }

        // Param is passed by value, moved
        pub fn set_used_ipv6(&mut self, v: bool) {
            self.used_ipv6 = ::std::option::Option::Some(v);
        }

        // optional bool proxied = 7;

        pub fn proxied(&self) -> bool {
            self.proxied.unwrap_or(false)
        }

        pub fn clear_proxied(&mut self) {
            self.proxied = ::std::option::Option::None;
        }

        pub fn has_proxied(&self) -> bool {
            self.proxied.is_some()
        }

        // Param is passed by value, moved
        pub fn set_proxied(&mut self, v: bool) {
            self.proxied = ::std::option::Option::Some(v);
        }

        // optional bool used_http2 = 8;

        pub fn used_http2(&self) -> bool {
            self.used_http2.unwrap_or(false)
        }

        pub fn clear_used_http2(&mut self) {
            self.used_http2 = ::std::option::Option::None;
        }

        pub fn has_used_http2(&self) -> bool {
            self.used_http2.is_some()
        }

        // Param is passed by value, moved
        pub fn set_used_http2(&mut self, v: bool) {
            self.used_http2 = ::std::option::Option::Some(v);
        }

        // optional uint32 cache_hits = 9;

        pub fn cache_hits(&self) -> u32 {
            self.cache_hits.unwrap_or(0)
        }

        pub fn clear_cache_hits(&mut self) {
            self.cache_hits = ::std::option::Option::None;
        }

        pub fn has_cache_hits(&self) -> bool {
            self.cache_hits.is_some()
        }

        // Param is passed by value, moved
        pub fn set_cache_hits(&mut self, v: u32) {
            self.cache_hits = ::std::option::Option::Some(v);
        }

        // optional uint32 cache_misses = 10;

        pub fn cache_misses(&self) -> u32 {
            self.cache_misses.unwrap_or(0)
        }

        pub fn clear_cache_misses(&mut self) {
            self.cache_misses = ::std::option::Option::None;
        }

        pub fn has_cache_misses(&self) -> bool {
            self.cache_misses.is_some()
        }

        // Param is passed by value, moved
        pub fn set_cache_misses(&mut self, v: u32) {
            self.cache_misses = ::std::option::Option::Some(v);
        }

        // optional uint64 hit_bytes = 11;

        pub fn hit_bytes(&self) -> u64 {
            self.hit_bytes.unwrap_or(0)
        }

        pub fn clear_hit_bytes(&mut self) {
            self.hit_bytes = ::std::option::Option::None;
        }

        pub fn has_hit_bytes(&self) -> bool {
            self.hit_bytes.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hit_bytes(&mut self, v: u64) {
            self.hit_bytes = ::std::option::Option::Some(v);
        }

        // optional uint64 miss_bytes = 12;

        pub fn miss_bytes(&self) -> u64 {
            self.miss_bytes.unwrap_or(0)
        }

        pub fn clear_miss_bytes(&mut self) {
            self.miss_bytes = ::std::option::Option::None;
        }

        pub fn has_miss_bytes(&self) -> bool {
            self.miss_bytes.is_some()
        }

        // Param is passed by value, moved
        pub fn set_miss_bytes(&mut self, v: u64) {
            self.miss_bytes = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for StatsInfo {
        const NAME: &'static str = "StatsInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.source_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.source_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.bytes = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    34 => {
                        self.host_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    40 => {
                        self.microseconds = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    48 => {
                        self.used_ipv6 = ::std::option::Option::Some(is.read_bool()?);
                    },
                    56 => {
                        self.proxied = ::std::option::Option::Some(is.read_bool()?);
                    },
                    64 => {
                        self.used_http2 = ::std::option::Option::Some(is.read_bool()?);
                    },
                    72 => {
                        self.cache_hits = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    80 => {
                        self.cache_misses = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    88 => {
                        self.hit_bytes = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    96 => {
                        self.miss_bytes = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.source_type {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.source_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.bytes {
                my_size += ::protobuf::rt::uint64_size(3, v);
            }
            if let Some(v) = self.host_name.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            if let Some(v) = self.microseconds {
                my_size += ::protobuf::rt::uint64_size(5, v);
            }
            if let Some(v) = self.used_ipv6 {
                my_size += 1 + 1;
            }
            if let Some(v) = self.proxied {
                my_size += 1 + 1;
            }
            if let Some(v) = self.used_http2 {
                my_size += 1 + 1;
            }
            if let Some(v) = self.cache_hits {
                my_size += ::protobuf::rt::uint32_size(9, v);
            }
            if let Some(v) = self.cache_misses {
                my_size += ::protobuf::rt::uint32_size(10, v);
            }
            if let Some(v) = self.hit_bytes {
                my_size += ::protobuf::rt::uint64_size(11, v);
            }
            if let Some(v) = self.miss_bytes {
                my_size += ::protobuf::rt::uint64_size(12, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.source_type {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.source_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.bytes {
                os.write_uint64(3, v)?;
            }
            if let Some(v) = self.host_name.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.microseconds {
                os.write_uint64(5, v)?;
            }
            if let Some(v) = self.used_ipv6 {
                os.write_bool(6, v)?;
            }
            if let Some(v) = self.proxied {
                os.write_bool(7, v)?;
            }
            if let Some(v) = self.used_http2 {
                os.write_bool(8, v)?;
            }
            if let Some(v) = self.cache_hits {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.cache_misses {
                os.write_uint32(10, v)?;
            }
            if let Some(v) = self.hit_bytes {
                os.write_uint64(11, v)?;
            }
            if let Some(v) = self.miss_bytes {
                os.write_uint64(12, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> StatsInfo {
            StatsInfo::new()
        }

        fn clear(&mut self) {
            self.source_type = ::std::option::Option::None;
            self.source_id = ::std::option::Option::None;
            self.bytes = ::std::option::Option::None;
            self.host_name = ::std::option::Option::None;
            self.microseconds = ::std::option::Option::None;
            self.used_ipv6 = ::std::option::Option::None;
            self.proxied = ::std::option::Option::None;
            self.used_http2 = ::std::option::Option::None;
            self.cache_hits = ::std::option::Option::None;
            self.cache_misses = ::std::option::Option::None;
            self.hit_bytes = ::std::option::Option::None;
            self.miss_bytes = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static StatsInfo {
            static instance: StatsInfo = StatsInfo {
                source_type: ::std::option::Option::None,
                source_id: ::std::option::Option::None,
                bytes: ::std::option::Option::None,
                host_name: ::std::option::Option::None,
                microseconds: ::std::option::Option::None,
                used_ipv6: ::std::option::Option::None,
                proxied: ::std::option::Option::None,
                used_http2: ::std::option::Option::None,
                cache_hits: ::std::option::Option::None,
                cache_misses: ::std::option::Option::None,
                hit_bytes: ::std::option::Option::None,
                miss_bytes: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CClientMetrics_ContentValidation_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientMetrics_ContentValidation_Notification {
    // message fields
    // @@protoc_insertion_point(field:CClientMetrics_ContentValidation_Notification.validation_result)
    pub validation_result: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CClientMetrics_ContentValidation_Notification.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientMetrics_ContentValidation_Notification.staged_files)
    pub staged_files: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CClientMetrics_ContentValidation_Notification.user_initiated)
    pub user_initiated: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CClientMetrics_ContentValidation_Notification.early_out)
    pub early_out: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CClientMetrics_ContentValidation_Notification.chunks_scanned)
    pub chunks_scanned: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientMetrics_ContentValidation_Notification.chunks_corrupt)
    pub chunks_corrupt: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientMetrics_ContentValidation_Notification.bytes_scanned)
    pub bytes_scanned: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClientMetrics_ContentValidation_Notification.chunk_bytes_corrupt)
    pub chunk_bytes_corrupt: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClientMetrics_ContentValidation_Notification.total_file_size_corrupt)
    pub total_file_size_corrupt: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientMetrics_ContentValidation_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_ContentValidation_Notification {
    fn default() -> &'a CClientMetrics_ContentValidation_Notification {
        <CClientMetrics_ContentValidation_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CClientMetrics_ContentValidation_Notification {
    pub fn new() -> CClientMetrics_ContentValidation_Notification {
        ::std::default::Default::default()
    }

    // optional int32 validation_result = 1;

    pub fn validation_result(&self) -> i32 {
        self.validation_result.unwrap_or(0)
    }

    pub fn clear_validation_result(&mut self) {
        self.validation_result = ::std::option::Option::None;
    }

    pub fn has_validation_result(&self) -> bool {
        self.validation_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_validation_result(&mut self, v: i32) {
        self.validation_result = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional bool staged_files = 3;

    pub fn staged_files(&self) -> bool {
        self.staged_files.unwrap_or(false)
    }

    pub fn clear_staged_files(&mut self) {
        self.staged_files = ::std::option::Option::None;
    }

    pub fn has_staged_files(&self) -> bool {
        self.staged_files.is_some()
    }

    // Param is passed by value, moved
    pub fn set_staged_files(&mut self, v: bool) {
        self.staged_files = ::std::option::Option::Some(v);
    }

    // optional bool user_initiated = 4;

    pub fn user_initiated(&self) -> bool {
        self.user_initiated.unwrap_or(false)
    }

    pub fn clear_user_initiated(&mut self) {
        self.user_initiated = ::std::option::Option::None;
    }

    pub fn has_user_initiated(&self) -> bool {
        self.user_initiated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_initiated(&mut self, v: bool) {
        self.user_initiated = ::std::option::Option::Some(v);
    }

    // optional bool early_out = 5;

    pub fn early_out(&self) -> bool {
        self.early_out.unwrap_or(false)
    }

    pub fn clear_early_out(&mut self) {
        self.early_out = ::std::option::Option::None;
    }

    pub fn has_early_out(&self) -> bool {
        self.early_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_early_out(&mut self, v: bool) {
        self.early_out = ::std::option::Option::Some(v);
    }

    // optional uint32 chunks_scanned = 6;

    pub fn chunks_scanned(&self) -> u32 {
        self.chunks_scanned.unwrap_or(0)
    }

    pub fn clear_chunks_scanned(&mut self) {
        self.chunks_scanned = ::std::option::Option::None;
    }

    pub fn has_chunks_scanned(&self) -> bool {
        self.chunks_scanned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chunks_scanned(&mut self, v: u32) {
        self.chunks_scanned = ::std::option::Option::Some(v);
    }

    // optional uint32 chunks_corrupt = 7;

    pub fn chunks_corrupt(&self) -> u32 {
        self.chunks_corrupt.unwrap_or(0)
    }

    pub fn clear_chunks_corrupt(&mut self) {
        self.chunks_corrupt = ::std::option::Option::None;
    }

    pub fn has_chunks_corrupt(&self) -> bool {
        self.chunks_corrupt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chunks_corrupt(&mut self, v: u32) {
        self.chunks_corrupt = ::std::option::Option::Some(v);
    }

    // optional uint64 bytes_scanned = 8;

    pub fn bytes_scanned(&self) -> u64 {
        self.bytes_scanned.unwrap_or(0)
    }

    pub fn clear_bytes_scanned(&mut self) {
        self.bytes_scanned = ::std::option::Option::None;
    }

    pub fn has_bytes_scanned(&self) -> bool {
        self.bytes_scanned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_scanned(&mut self, v: u64) {
        self.bytes_scanned = ::std::option::Option::Some(v);
    }

    // optional uint64 chunk_bytes_corrupt = 9;

    pub fn chunk_bytes_corrupt(&self) -> u64 {
        self.chunk_bytes_corrupt.unwrap_or(0)
    }

    pub fn clear_chunk_bytes_corrupt(&mut self) {
        self.chunk_bytes_corrupt = ::std::option::Option::None;
    }

    pub fn has_chunk_bytes_corrupt(&self) -> bool {
        self.chunk_bytes_corrupt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chunk_bytes_corrupt(&mut self, v: u64) {
        self.chunk_bytes_corrupt = ::std::option::Option::Some(v);
    }

    // optional uint64 total_file_size_corrupt = 10;

    pub fn total_file_size_corrupt(&self) -> u64 {
        self.total_file_size_corrupt.unwrap_or(0)
    }

    pub fn clear_total_file_size_corrupt(&mut self) {
        self.total_file_size_corrupt = ::std::option::Option::None;
    }

    pub fn has_total_file_size_corrupt(&self) -> bool {
        self.total_file_size_corrupt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_file_size_corrupt(&mut self, v: u64) {
        self.total_file_size_corrupt = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClientMetrics_ContentValidation_Notification {
    const NAME: &'static str = "CClientMetrics_ContentValidation_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.validation_result = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.staged_files = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.user_initiated = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.early_out = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.chunks_scanned = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.chunks_corrupt = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.bytes_scanned = ::std::option::Option::Some(is.read_uint64()?);
                },
                72 => {
                    self.chunk_bytes_corrupt = ::std::option::Option::Some(is.read_uint64()?);
                },
                80 => {
                    self.total_file_size_corrupt = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.validation_result {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.staged_files {
            my_size += 1 + 1;
        }
        if let Some(v) = self.user_initiated {
            my_size += 1 + 1;
        }
        if let Some(v) = self.early_out {
            my_size += 1 + 1;
        }
        if let Some(v) = self.chunks_scanned {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.chunks_corrupt {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.bytes_scanned {
            my_size += ::protobuf::rt::uint64_size(8, v);
        }
        if let Some(v) = self.chunk_bytes_corrupt {
            my_size += ::protobuf::rt::uint64_size(9, v);
        }
        if let Some(v) = self.total_file_size_corrupt {
            my_size += ::protobuf::rt::uint64_size(10, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.validation_result {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.staged_files {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.user_initiated {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.early_out {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.chunks_scanned {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.chunks_corrupt {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.bytes_scanned {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.chunk_bytes_corrupt {
            os.write_uint64(9, v)?;
        }
        if let Some(v) = self.total_file_size_corrupt {
            os.write_uint64(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientMetrics_ContentValidation_Notification {
        CClientMetrics_ContentValidation_Notification::new()
    }

    fn clear(&mut self) {
        self.validation_result = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.staged_files = ::std::option::Option::None;
        self.user_initiated = ::std::option::Option::None;
        self.early_out = ::std::option::Option::None;
        self.chunks_scanned = ::std::option::Option::None;
        self.chunks_corrupt = ::std::option::Option::None;
        self.bytes_scanned = ::std::option::Option::None;
        self.chunk_bytes_corrupt = ::std::option::Option::None;
        self.total_file_size_corrupt = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientMetrics_ContentValidation_Notification {
        static instance: CClientMetrics_ContentValidation_Notification = CClientMetrics_ContentValidation_Notification {
            validation_result: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            staged_files: ::std::option::Option::None,
            user_initiated: ::std::option::Option::None,
            early_out: ::std::option::Option::None,
            chunks_scanned: ::std::option::Option::None,
            chunks_corrupt: ::std::option::Option::None,
            bytes_scanned: ::std::option::Option::None,
            chunk_bytes_corrupt: ::std::option::Option::None,
            total_file_size_corrupt: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CClientMetrics_CloudAppSyncStats_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientMetrics_CloudAppSyncStats_Notification {
    // message fields
    // @@protoc_insertion_point(field:CClientMetrics_CloudAppSyncStats_Notification.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientMetrics_CloudAppSyncStats_Notification.platform_type)
    pub platform_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientMetrics_CloudAppSyncStats_Notification.preload)
    pub preload: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CClientMetrics_CloudAppSyncStats_Notification.blocking_app_launch)
    pub blocking_app_launch: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CClientMetrics_CloudAppSyncStats_Notification.files_uploaded)
    pub files_uploaded: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientMetrics_CloudAppSyncStats_Notification.files_downloaded)
    pub files_downloaded: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientMetrics_CloudAppSyncStats_Notification.files_deleted)
    pub files_deleted: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientMetrics_CloudAppSyncStats_Notification.bytes_uploaded)
    pub bytes_uploaded: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClientMetrics_CloudAppSyncStats_Notification.bytes_downloaded)
    pub bytes_downloaded: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClientMetrics_CloudAppSyncStats_Notification.microsec_total)
    pub microsec_total: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClientMetrics_CloudAppSyncStats_Notification.microsec_init_caches)
    pub microsec_init_caches: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClientMetrics_CloudAppSyncStats_Notification.microsec_validate_state)
    pub microsec_validate_state: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClientMetrics_CloudAppSyncStats_Notification.microsec_ac_launch)
    pub microsec_ac_launch: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClientMetrics_CloudAppSyncStats_Notification.microsec_ac_prep_user_files)
    pub microsec_ac_prep_user_files: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClientMetrics_CloudAppSyncStats_Notification.microsec_ac_exit)
    pub microsec_ac_exit: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClientMetrics_CloudAppSyncStats_Notification.microsec_build_sync_list)
    pub microsec_build_sync_list: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClientMetrics_CloudAppSyncStats_Notification.microsec_delete_files)
    pub microsec_delete_files: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClientMetrics_CloudAppSyncStats_Notification.microsec_download_files)
    pub microsec_download_files: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClientMetrics_CloudAppSyncStats_Notification.microsec_upload_files)
    pub microsec_upload_files: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClientMetrics_CloudAppSyncStats_Notification.hardware_type)
    pub hardware_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientMetrics_CloudAppSyncStats_Notification.files_managed)
    pub files_managed: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientMetrics_CloudAppSyncStats_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_CloudAppSyncStats_Notification {
    fn default() -> &'a CClientMetrics_CloudAppSyncStats_Notification {
        <CClientMetrics_CloudAppSyncStats_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CClientMetrics_CloudAppSyncStats_Notification {
    pub fn new() -> CClientMetrics_CloudAppSyncStats_Notification {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 platform_type = 2;

    pub fn platform_type(&self) -> u32 {
        self.platform_type.unwrap_or(0)
    }

    pub fn clear_platform_type(&mut self) {
        self.platform_type = ::std::option::Option::None;
    }

    pub fn has_platform_type(&self) -> bool {
        self.platform_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platform_type(&mut self, v: u32) {
        self.platform_type = ::std::option::Option::Some(v);
    }

    // optional bool preload = 3;

    pub fn preload(&self) -> bool {
        self.preload.unwrap_or(false)
    }

    pub fn clear_preload(&mut self) {
        self.preload = ::std::option::Option::None;
    }

    pub fn has_preload(&self) -> bool {
        self.preload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preload(&mut self, v: bool) {
        self.preload = ::std::option::Option::Some(v);
    }

    // optional bool blocking_app_launch = 4;

    pub fn blocking_app_launch(&self) -> bool {
        self.blocking_app_launch.unwrap_or(false)
    }

    pub fn clear_blocking_app_launch(&mut self) {
        self.blocking_app_launch = ::std::option::Option::None;
    }

    pub fn has_blocking_app_launch(&self) -> bool {
        self.blocking_app_launch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blocking_app_launch(&mut self, v: bool) {
        self.blocking_app_launch = ::std::option::Option::Some(v);
    }

    // optional uint32 files_uploaded = 5;

    pub fn files_uploaded(&self) -> u32 {
        self.files_uploaded.unwrap_or(0)
    }

    pub fn clear_files_uploaded(&mut self) {
        self.files_uploaded = ::std::option::Option::None;
    }

    pub fn has_files_uploaded(&self) -> bool {
        self.files_uploaded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_files_uploaded(&mut self, v: u32) {
        self.files_uploaded = ::std::option::Option::Some(v);
    }

    // optional uint32 files_downloaded = 6;

    pub fn files_downloaded(&self) -> u32 {
        self.files_downloaded.unwrap_or(0)
    }

    pub fn clear_files_downloaded(&mut self) {
        self.files_downloaded = ::std::option::Option::None;
    }

    pub fn has_files_downloaded(&self) -> bool {
        self.files_downloaded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_files_downloaded(&mut self, v: u32) {
        self.files_downloaded = ::std::option::Option::Some(v);
    }

    // optional uint32 files_deleted = 7;

    pub fn files_deleted(&self) -> u32 {
        self.files_deleted.unwrap_or(0)
    }

    pub fn clear_files_deleted(&mut self) {
        self.files_deleted = ::std::option::Option::None;
    }

    pub fn has_files_deleted(&self) -> bool {
        self.files_deleted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_files_deleted(&mut self, v: u32) {
        self.files_deleted = ::std::option::Option::Some(v);
    }

    // optional uint64 bytes_uploaded = 8;

    pub fn bytes_uploaded(&self) -> u64 {
        self.bytes_uploaded.unwrap_or(0)
    }

    pub fn clear_bytes_uploaded(&mut self) {
        self.bytes_uploaded = ::std::option::Option::None;
    }

    pub fn has_bytes_uploaded(&self) -> bool {
        self.bytes_uploaded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_uploaded(&mut self, v: u64) {
        self.bytes_uploaded = ::std::option::Option::Some(v);
    }

    // optional uint64 bytes_downloaded = 9;

    pub fn bytes_downloaded(&self) -> u64 {
        self.bytes_downloaded.unwrap_or(0)
    }

    pub fn clear_bytes_downloaded(&mut self) {
        self.bytes_downloaded = ::std::option::Option::None;
    }

    pub fn has_bytes_downloaded(&self) -> bool {
        self.bytes_downloaded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_downloaded(&mut self, v: u64) {
        self.bytes_downloaded = ::std::option::Option::Some(v);
    }

    // optional uint64 microsec_total = 10;

    pub fn microsec_total(&self) -> u64 {
        self.microsec_total.unwrap_or(0)
    }

    pub fn clear_microsec_total(&mut self) {
        self.microsec_total = ::std::option::Option::None;
    }

    pub fn has_microsec_total(&self) -> bool {
        self.microsec_total.is_some()
    }

    // Param is passed by value, moved
    pub fn set_microsec_total(&mut self, v: u64) {
        self.microsec_total = ::std::option::Option::Some(v);
    }

    // optional uint64 microsec_init_caches = 11;

    pub fn microsec_init_caches(&self) -> u64 {
        self.microsec_init_caches.unwrap_or(0)
    }

    pub fn clear_microsec_init_caches(&mut self) {
        self.microsec_init_caches = ::std::option::Option::None;
    }

    pub fn has_microsec_init_caches(&self) -> bool {
        self.microsec_init_caches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_microsec_init_caches(&mut self, v: u64) {
        self.microsec_init_caches = ::std::option::Option::Some(v);
    }

    // optional uint64 microsec_validate_state = 12;

    pub fn microsec_validate_state(&self) -> u64 {
        self.microsec_validate_state.unwrap_or(0)
    }

    pub fn clear_microsec_validate_state(&mut self) {
        self.microsec_validate_state = ::std::option::Option::None;
    }

    pub fn has_microsec_validate_state(&self) -> bool {
        self.microsec_validate_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_microsec_validate_state(&mut self, v: u64) {
        self.microsec_validate_state = ::std::option::Option::Some(v);
    }

    // optional uint64 microsec_ac_launch = 13;

    pub fn microsec_ac_launch(&self) -> u64 {
        self.microsec_ac_launch.unwrap_or(0)
    }

    pub fn clear_microsec_ac_launch(&mut self) {
        self.microsec_ac_launch = ::std::option::Option::None;
    }

    pub fn has_microsec_ac_launch(&self) -> bool {
        self.microsec_ac_launch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_microsec_ac_launch(&mut self, v: u64) {
        self.microsec_ac_launch = ::std::option::Option::Some(v);
    }

    // optional uint64 microsec_ac_prep_user_files = 14;

    pub fn microsec_ac_prep_user_files(&self) -> u64 {
        self.microsec_ac_prep_user_files.unwrap_or(0)
    }

    pub fn clear_microsec_ac_prep_user_files(&mut self) {
        self.microsec_ac_prep_user_files = ::std::option::Option::None;
    }

    pub fn has_microsec_ac_prep_user_files(&self) -> bool {
        self.microsec_ac_prep_user_files.is_some()
    }

    // Param is passed by value, moved
    pub fn set_microsec_ac_prep_user_files(&mut self, v: u64) {
        self.microsec_ac_prep_user_files = ::std::option::Option::Some(v);
    }

    // optional uint64 microsec_ac_exit = 15;

    pub fn microsec_ac_exit(&self) -> u64 {
        self.microsec_ac_exit.unwrap_or(0)
    }

    pub fn clear_microsec_ac_exit(&mut self) {
        self.microsec_ac_exit = ::std::option::Option::None;
    }

    pub fn has_microsec_ac_exit(&self) -> bool {
        self.microsec_ac_exit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_microsec_ac_exit(&mut self, v: u64) {
        self.microsec_ac_exit = ::std::option::Option::Some(v);
    }

    // optional uint64 microsec_build_sync_list = 16;

    pub fn microsec_build_sync_list(&self) -> u64 {
        self.microsec_build_sync_list.unwrap_or(0)
    }

    pub fn clear_microsec_build_sync_list(&mut self) {
        self.microsec_build_sync_list = ::std::option::Option::None;
    }

    pub fn has_microsec_build_sync_list(&self) -> bool {
        self.microsec_build_sync_list.is_some()
    }

    // Param is passed by value, moved
    pub fn set_microsec_build_sync_list(&mut self, v: u64) {
        self.microsec_build_sync_list = ::std::option::Option::Some(v);
    }

    // optional uint64 microsec_delete_files = 17;

    pub fn microsec_delete_files(&self) -> u64 {
        self.microsec_delete_files.unwrap_or(0)
    }

    pub fn clear_microsec_delete_files(&mut self) {
        self.microsec_delete_files = ::std::option::Option::None;
    }

    pub fn has_microsec_delete_files(&self) -> bool {
        self.microsec_delete_files.is_some()
    }

    // Param is passed by value, moved
    pub fn set_microsec_delete_files(&mut self, v: u64) {
        self.microsec_delete_files = ::std::option::Option::Some(v);
    }

    // optional uint64 microsec_download_files = 18;

    pub fn microsec_download_files(&self) -> u64 {
        self.microsec_download_files.unwrap_or(0)
    }

    pub fn clear_microsec_download_files(&mut self) {
        self.microsec_download_files = ::std::option::Option::None;
    }

    pub fn has_microsec_download_files(&self) -> bool {
        self.microsec_download_files.is_some()
    }

    // Param is passed by value, moved
    pub fn set_microsec_download_files(&mut self, v: u64) {
        self.microsec_download_files = ::std::option::Option::Some(v);
    }

    // optional uint64 microsec_upload_files = 19;

    pub fn microsec_upload_files(&self) -> u64 {
        self.microsec_upload_files.unwrap_or(0)
    }

    pub fn clear_microsec_upload_files(&mut self) {
        self.microsec_upload_files = ::std::option::Option::None;
    }

    pub fn has_microsec_upload_files(&self) -> bool {
        self.microsec_upload_files.is_some()
    }

    // Param is passed by value, moved
    pub fn set_microsec_upload_files(&mut self, v: u64) {
        self.microsec_upload_files = ::std::option::Option::Some(v);
    }

    // optional uint32 hardware_type = 20;

    pub fn hardware_type(&self) -> u32 {
        self.hardware_type.unwrap_or(0)
    }

    pub fn clear_hardware_type(&mut self) {
        self.hardware_type = ::std::option::Option::None;
    }

    pub fn has_hardware_type(&self) -> bool {
        self.hardware_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hardware_type(&mut self, v: u32) {
        self.hardware_type = ::std::option::Option::Some(v);
    }

    // optional uint32 files_managed = 21;

    pub fn files_managed(&self) -> u32 {
        self.files_managed.unwrap_or(0)
    }

    pub fn clear_files_managed(&mut self) {
        self.files_managed = ::std::option::Option::None;
    }

    pub fn has_files_managed(&self) -> bool {
        self.files_managed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_files_managed(&mut self, v: u32) {
        self.files_managed = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClientMetrics_CloudAppSyncStats_Notification {
    const NAME: &'static str = "CClientMetrics_CloudAppSyncStats_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.platform_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.preload = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.blocking_app_launch = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.files_uploaded = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.files_downloaded = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.files_deleted = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.bytes_uploaded = ::std::option::Option::Some(is.read_uint64()?);
                },
                72 => {
                    self.bytes_downloaded = ::std::option::Option::Some(is.read_uint64()?);
                },
                80 => {
                    self.microsec_total = ::std::option::Option::Some(is.read_uint64()?);
                },
                88 => {
                    self.microsec_init_caches = ::std::option::Option::Some(is.read_uint64()?);
                },
                96 => {
                    self.microsec_validate_state = ::std::option::Option::Some(is.read_uint64()?);
                },
                104 => {
                    self.microsec_ac_launch = ::std::option::Option::Some(is.read_uint64()?);
                },
                112 => {
                    self.microsec_ac_prep_user_files = ::std::option::Option::Some(is.read_uint64()?);
                },
                120 => {
                    self.microsec_ac_exit = ::std::option::Option::Some(is.read_uint64()?);
                },
                128 => {
                    self.microsec_build_sync_list = ::std::option::Option::Some(is.read_uint64()?);
                },
                136 => {
                    self.microsec_delete_files = ::std::option::Option::Some(is.read_uint64()?);
                },
                144 => {
                    self.microsec_download_files = ::std::option::Option::Some(is.read_uint64()?);
                },
                152 => {
                    self.microsec_upload_files = ::std::option::Option::Some(is.read_uint64()?);
                },
                160 => {
                    self.hardware_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.files_managed = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.platform_type {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.preload {
            my_size += 1 + 1;
        }
        if let Some(v) = self.blocking_app_launch {
            my_size += 1 + 1;
        }
        if let Some(v) = self.files_uploaded {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.files_downloaded {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.files_deleted {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.bytes_uploaded {
            my_size += ::protobuf::rt::uint64_size(8, v);
        }
        if let Some(v) = self.bytes_downloaded {
            my_size += ::protobuf::rt::uint64_size(9, v);
        }
        if let Some(v) = self.microsec_total {
            my_size += ::protobuf::rt::uint64_size(10, v);
        }
        if let Some(v) = self.microsec_init_caches {
            my_size += ::protobuf::rt::uint64_size(11, v);
        }
        if let Some(v) = self.microsec_validate_state {
            my_size += ::protobuf::rt::uint64_size(12, v);
        }
        if let Some(v) = self.microsec_ac_launch {
            my_size += ::protobuf::rt::uint64_size(13, v);
        }
        if let Some(v) = self.microsec_ac_prep_user_files {
            my_size += ::protobuf::rt::uint64_size(14, v);
        }
        if let Some(v) = self.microsec_ac_exit {
            my_size += ::protobuf::rt::uint64_size(15, v);
        }
        if let Some(v) = self.microsec_build_sync_list {
            my_size += ::protobuf::rt::uint64_size(16, v);
        }
        if let Some(v) = self.microsec_delete_files {
            my_size += ::protobuf::rt::uint64_size(17, v);
        }
        if let Some(v) = self.microsec_download_files {
            my_size += ::protobuf::rt::uint64_size(18, v);
        }
        if let Some(v) = self.microsec_upload_files {
            my_size += ::protobuf::rt::uint64_size(19, v);
        }
        if let Some(v) = self.hardware_type {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.files_managed {
            my_size += ::protobuf::rt::uint32_size(21, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.platform_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.preload {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.blocking_app_launch {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.files_uploaded {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.files_downloaded {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.files_deleted {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.bytes_uploaded {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.bytes_downloaded {
            os.write_uint64(9, v)?;
        }
        if let Some(v) = self.microsec_total {
            os.write_uint64(10, v)?;
        }
        if let Some(v) = self.microsec_init_caches {
            os.write_uint64(11, v)?;
        }
        if let Some(v) = self.microsec_validate_state {
            os.write_uint64(12, v)?;
        }
        if let Some(v) = self.microsec_ac_launch {
            os.write_uint64(13, v)?;
        }
        if let Some(v) = self.microsec_ac_prep_user_files {
            os.write_uint64(14, v)?;
        }
        if let Some(v) = self.microsec_ac_exit {
            os.write_uint64(15, v)?;
        }
        if let Some(v) = self.microsec_build_sync_list {
            os.write_uint64(16, v)?;
        }
        if let Some(v) = self.microsec_delete_files {
            os.write_uint64(17, v)?;
        }
        if let Some(v) = self.microsec_download_files {
            os.write_uint64(18, v)?;
        }
        if let Some(v) = self.microsec_upload_files {
            os.write_uint64(19, v)?;
        }
        if let Some(v) = self.hardware_type {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.files_managed {
            os.write_uint32(21, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientMetrics_CloudAppSyncStats_Notification {
        CClientMetrics_CloudAppSyncStats_Notification::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.platform_type = ::std::option::Option::None;
        self.preload = ::std::option::Option::None;
        self.blocking_app_launch = ::std::option::Option::None;
        self.files_uploaded = ::std::option::Option::None;
        self.files_downloaded = ::std::option::Option::None;
        self.files_deleted = ::std::option::Option::None;
        self.bytes_uploaded = ::std::option::Option::None;
        self.bytes_downloaded = ::std::option::Option::None;
        self.microsec_total = ::std::option::Option::None;
        self.microsec_init_caches = ::std::option::Option::None;
        self.microsec_validate_state = ::std::option::Option::None;
        self.microsec_ac_launch = ::std::option::Option::None;
        self.microsec_ac_prep_user_files = ::std::option::Option::None;
        self.microsec_ac_exit = ::std::option::Option::None;
        self.microsec_build_sync_list = ::std::option::Option::None;
        self.microsec_delete_files = ::std::option::Option::None;
        self.microsec_download_files = ::std::option::Option::None;
        self.microsec_upload_files = ::std::option::Option::None;
        self.hardware_type = ::std::option::Option::None;
        self.files_managed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientMetrics_CloudAppSyncStats_Notification {
        static instance: CClientMetrics_CloudAppSyncStats_Notification = CClientMetrics_CloudAppSyncStats_Notification {
            app_id: ::std::option::Option::None,
            platform_type: ::std::option::Option::None,
            preload: ::std::option::Option::None,
            blocking_app_launch: ::std::option::Option::None,
            files_uploaded: ::std::option::Option::None,
            files_downloaded: ::std::option::Option::None,
            files_deleted: ::std::option::Option::None,
            bytes_uploaded: ::std::option::Option::None,
            bytes_downloaded: ::std::option::Option::None,
            microsec_total: ::std::option::Option::None,
            microsec_init_caches: ::std::option::Option::None,
            microsec_validate_state: ::std::option::Option::None,
            microsec_ac_launch: ::std::option::Option::None,
            microsec_ac_prep_user_files: ::std::option::Option::None,
            microsec_ac_exit: ::std::option::Option::None,
            microsec_build_sync_list: ::std::option::Option::None,
            microsec_delete_files: ::std::option::Option::None,
            microsec_download_files: ::std::option::Option::None,
            microsec_upload_files: ::std::option::Option::None,
            hardware_type: ::std::option::Option::None,
            files_managed: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CClientMetrics_ContentDownloadResponse_Counts_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientMetrics_ContentDownloadResponse_Counts_Notification {
    // message fields
    // @@protoc_insertion_point(field:CClientMetrics_ContentDownloadResponse_Counts_Notification.cell_id)
    pub cell_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientMetrics_ContentDownloadResponse_Counts_Notification.data)
    pub data: ::protobuf::MessageField<super::clientmetrics::CClientMetrics_ContentDownloadResponse_Hosts>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientMetrics_ContentDownloadResponse_Counts_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_ContentDownloadResponse_Counts_Notification {
    fn default() -> &'a CClientMetrics_ContentDownloadResponse_Counts_Notification {
        <CClientMetrics_ContentDownloadResponse_Counts_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CClientMetrics_ContentDownloadResponse_Counts_Notification {
    pub fn new() -> CClientMetrics_ContentDownloadResponse_Counts_Notification {
        ::std::default::Default::default()
    }

    // optional uint32 cell_id = 1;

    pub fn cell_id(&self) -> u32 {
        self.cell_id.unwrap_or(0)
    }

    pub fn clear_cell_id(&mut self) {
        self.cell_id = ::std::option::Option::None;
    }

    pub fn has_cell_id(&self) -> bool {
        self.cell_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cell_id(&mut self, v: u32) {
        self.cell_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClientMetrics_ContentDownloadResponse_Counts_Notification {
    const NAME: &'static str = "CClientMetrics_ContentDownloadResponse_Counts_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.cell_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cell_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cell_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientMetrics_ContentDownloadResponse_Counts_Notification {
        CClientMetrics_ContentDownloadResponse_Counts_Notification::new()
    }

    fn clear(&mut self) {
        self.cell_id = ::std::option::Option::None;
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientMetrics_ContentDownloadResponse_Counts_Notification {
        static instance: CClientMetrics_ContentDownloadResponse_Counts_Notification = CClientMetrics_ContentDownloadResponse_Counts_Notification {
            cell_id: ::std::option::Option::None,
            data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CClientMetrics_ReportClientArgs_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientMetrics_ReportClientArgs_Notification {
    // message fields
    // @@protoc_insertion_point(field:CClientMetrics_ReportClientArgs_Notification.client_args)
    pub client_args: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CClientMetrics_ReportClientArgs_Notification.gpu_webview_regkey_disabled)
    pub gpu_webview_regkey_disabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CClientMetrics_ReportClientArgs_Notification.suppress_gpu_chrome)
    pub suppress_gpu_chrome: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CClientMetrics_ReportClientArgs_Notification.browser_not_supported)
    pub browser_not_supported: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CClientMetrics_ReportClientArgs_Notification.hw_accel_video_regkey_disabled)
    pub hw_accel_video_regkey_disabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CClientMetrics_ReportClientArgs_Notification.mini_mode_enabled)
    pub mini_mode_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CClientMetrics_ReportClientArgs_Notification.fps_counter_enabled)
    pub fps_counter_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CClientMetrics_ReportClientArgs_Notification.library_low_bandwidth_mode_enabled)
    pub library_low_bandwidth_mode_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CClientMetrics_ReportClientArgs_Notification.library_low_perf_mode_enabled)
    pub library_low_perf_mode_enabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientMetrics_ReportClientArgs_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_ReportClientArgs_Notification {
    fn default() -> &'a CClientMetrics_ReportClientArgs_Notification {
        <CClientMetrics_ReportClientArgs_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CClientMetrics_ReportClientArgs_Notification {
    pub fn new() -> CClientMetrics_ReportClientArgs_Notification {
        ::std::default::Default::default()
    }

    // optional bool gpu_webview_regkey_disabled = 2;

    pub fn gpu_webview_regkey_disabled(&self) -> bool {
        self.gpu_webview_regkey_disabled.unwrap_or(false)
    }

    pub fn clear_gpu_webview_regkey_disabled(&mut self) {
        self.gpu_webview_regkey_disabled = ::std::option::Option::None;
    }

    pub fn has_gpu_webview_regkey_disabled(&self) -> bool {
        self.gpu_webview_regkey_disabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gpu_webview_regkey_disabled(&mut self, v: bool) {
        self.gpu_webview_regkey_disabled = ::std::option::Option::Some(v);
    }

    // optional bool suppress_gpu_chrome = 3;

    pub fn suppress_gpu_chrome(&self) -> bool {
        self.suppress_gpu_chrome.unwrap_or(false)
    }

    pub fn clear_suppress_gpu_chrome(&mut self) {
        self.suppress_gpu_chrome = ::std::option::Option::None;
    }

    pub fn has_suppress_gpu_chrome(&self) -> bool {
        self.suppress_gpu_chrome.is_some()
    }

    // Param is passed by value, moved
    pub fn set_suppress_gpu_chrome(&mut self, v: bool) {
        self.suppress_gpu_chrome = ::std::option::Option::Some(v);
    }

    // optional bool browser_not_supported = 4;

    pub fn browser_not_supported(&self) -> bool {
        self.browser_not_supported.unwrap_or(false)
    }

    pub fn clear_browser_not_supported(&mut self) {
        self.browser_not_supported = ::std::option::Option::None;
    }

    pub fn has_browser_not_supported(&self) -> bool {
        self.browser_not_supported.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_not_supported(&mut self, v: bool) {
        self.browser_not_supported = ::std::option::Option::Some(v);
    }

    // optional bool hw_accel_video_regkey_disabled = 5;

    pub fn hw_accel_video_regkey_disabled(&self) -> bool {
        self.hw_accel_video_regkey_disabled.unwrap_or(false)
    }

    pub fn clear_hw_accel_video_regkey_disabled(&mut self) {
        self.hw_accel_video_regkey_disabled = ::std::option::Option::None;
    }

    pub fn has_hw_accel_video_regkey_disabled(&self) -> bool {
        self.hw_accel_video_regkey_disabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hw_accel_video_regkey_disabled(&mut self, v: bool) {
        self.hw_accel_video_regkey_disabled = ::std::option::Option::Some(v);
    }

    // optional bool mini_mode_enabled = 6;

    pub fn mini_mode_enabled(&self) -> bool {
        self.mini_mode_enabled.unwrap_or(false)
    }

    pub fn clear_mini_mode_enabled(&mut self) {
        self.mini_mode_enabled = ::std::option::Option::None;
    }

    pub fn has_mini_mode_enabled(&self) -> bool {
        self.mini_mode_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mini_mode_enabled(&mut self, v: bool) {
        self.mini_mode_enabled = ::std::option::Option::Some(v);
    }

    // optional bool fps_counter_enabled = 7;

    pub fn fps_counter_enabled(&self) -> bool {
        self.fps_counter_enabled.unwrap_or(false)
    }

    pub fn clear_fps_counter_enabled(&mut self) {
        self.fps_counter_enabled = ::std::option::Option::None;
    }

    pub fn has_fps_counter_enabled(&self) -> bool {
        self.fps_counter_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fps_counter_enabled(&mut self, v: bool) {
        self.fps_counter_enabled = ::std::option::Option::Some(v);
    }

    // optional bool library_low_bandwidth_mode_enabled = 8;

    pub fn library_low_bandwidth_mode_enabled(&self) -> bool {
        self.library_low_bandwidth_mode_enabled.unwrap_or(false)
    }

    pub fn clear_library_low_bandwidth_mode_enabled(&mut self) {
        self.library_low_bandwidth_mode_enabled = ::std::option::Option::None;
    }

    pub fn has_library_low_bandwidth_mode_enabled(&self) -> bool {
        self.library_low_bandwidth_mode_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_library_low_bandwidth_mode_enabled(&mut self, v: bool) {
        self.library_low_bandwidth_mode_enabled = ::std::option::Option::Some(v);
    }

    // optional bool library_low_perf_mode_enabled = 9;

    pub fn library_low_perf_mode_enabled(&self) -> bool {
        self.library_low_perf_mode_enabled.unwrap_or(false)
    }

    pub fn clear_library_low_perf_mode_enabled(&mut self) {
        self.library_low_perf_mode_enabled = ::std::option::Option::None;
    }

    pub fn has_library_low_perf_mode_enabled(&self) -> bool {
        self.library_low_perf_mode_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_library_low_perf_mode_enabled(&mut self, v: bool) {
        self.library_low_perf_mode_enabled = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClientMetrics_ReportClientArgs_Notification {
    const NAME: &'static str = "CClientMetrics_ReportClientArgs_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.client_args.push(is.read_string()?);
                },
                16 => {
                    self.gpu_webview_regkey_disabled = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.suppress_gpu_chrome = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.browser_not_supported = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.hw_accel_video_regkey_disabled = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.mini_mode_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.fps_counter_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.library_low_bandwidth_mode_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.library_low_perf_mode_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.client_args {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(v) = self.gpu_webview_regkey_disabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.suppress_gpu_chrome {
            my_size += 1 + 1;
        }
        if let Some(v) = self.browser_not_supported {
            my_size += 1 + 1;
        }
        if let Some(v) = self.hw_accel_video_regkey_disabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.mini_mode_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.fps_counter_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.library_low_bandwidth_mode_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.library_low_perf_mode_enabled {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.client_args {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.gpu_webview_regkey_disabled {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.suppress_gpu_chrome {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.browser_not_supported {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.hw_accel_video_regkey_disabled {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.mini_mode_enabled {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.fps_counter_enabled {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.library_low_bandwidth_mode_enabled {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.library_low_perf_mode_enabled {
            os.write_bool(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientMetrics_ReportClientArgs_Notification {
        CClientMetrics_ReportClientArgs_Notification::new()
    }

    fn clear(&mut self) {
        self.client_args.clear();
        self.gpu_webview_regkey_disabled = ::std::option::Option::None;
        self.suppress_gpu_chrome = ::std::option::Option::None;
        self.browser_not_supported = ::std::option::Option::None;
        self.hw_accel_video_regkey_disabled = ::std::option::Option::None;
        self.mini_mode_enabled = ::std::option::Option::None;
        self.fps_counter_enabled = ::std::option::Option::None;
        self.library_low_bandwidth_mode_enabled = ::std::option::Option::None;
        self.library_low_perf_mode_enabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientMetrics_ReportClientArgs_Notification {
        static instance: CClientMetrics_ReportClientArgs_Notification = CClientMetrics_ReportClientArgs_Notification {
            client_args: ::std::vec::Vec::new(),
            gpu_webview_regkey_disabled: ::std::option::Option::None,
            suppress_gpu_chrome: ::std::option::Option::None,
            browser_not_supported: ::std::option::Option::None,
            hw_accel_video_regkey_disabled: ::std::option::Option::None,
            mini_mode_enabled: ::std::option::Option::None,
            fps_counter_enabled: ::std::option::Option::None,
            library_low_bandwidth_mode_enabled: ::std::option::Option::None,
            library_low_perf_mode_enabled: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESteamPipeWorkType)
pub enum ESteamPipeWorkType {
    // @@protoc_insertion_point(enum_value:ESteamPipeWorkType.k_ESteamPipeClientWorkType_Invalid)
    k_ESteamPipeClientWorkType_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ESteamPipeWorkType.k_ESteamPipeClientWorkType_StageFromChunkStores)
    k_ESteamPipeClientWorkType_StageFromChunkStores = 1,
}

impl ::protobuf::Enum for ESteamPipeWorkType {
    const NAME: &'static str = "ESteamPipeWorkType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESteamPipeWorkType> {
        match value {
            0 => ::std::option::Option::Some(ESteamPipeWorkType::k_ESteamPipeClientWorkType_Invalid),
            1 => ::std::option::Option::Some(ESteamPipeWorkType::k_ESteamPipeClientWorkType_StageFromChunkStores),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESteamPipeWorkType> {
        match str {
            "k_ESteamPipeClientWorkType_Invalid" => ::std::option::Option::Some(ESteamPipeWorkType::k_ESteamPipeClientWorkType_Invalid),
            "k_ESteamPipeClientWorkType_StageFromChunkStores" => ::std::option::Option::Some(ESteamPipeWorkType::k_ESteamPipeClientWorkType_StageFromChunkStores),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESteamPipeWorkType] = &[
        ESteamPipeWorkType::k_ESteamPipeClientWorkType_Invalid,
        ESteamPipeWorkType::k_ESteamPipeClientWorkType_StageFromChunkStores,
    ];
}

impl ::std::default::Default for ESteamPipeWorkType {
    fn default() -> Self {
        ESteamPipeWorkType::k_ESteamPipeClientWorkType_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESteamPipeOperationType)
pub enum ESteamPipeOperationType {
    // @@protoc_insertion_point(enum_value:ESteamPipeOperationType.k_ESteamPipeOperationType_Invalid)
    k_ESteamPipeOperationType_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ESteamPipeOperationType.k_ESteamPipeOperationType_DecryptCPU)
    k_ESteamPipeOperationType_DecryptCPU = 1,
    // @@protoc_insertion_point(enum_value:ESteamPipeOperationType.k_ESteamPipeOperationType_DiskRead)
    k_ESteamPipeOperationType_DiskRead = 2,
    // @@protoc_insertion_point(enum_value:ESteamPipeOperationType.k_ESteamPipeOperationType_DiskWrite)
    k_ESteamPipeOperationType_DiskWrite = 3,
}

impl ::protobuf::Enum for ESteamPipeOperationType {
    const NAME: &'static str = "ESteamPipeOperationType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESteamPipeOperationType> {
        match value {
            0 => ::std::option::Option::Some(ESteamPipeOperationType::k_ESteamPipeOperationType_Invalid),
            1 => ::std::option::Option::Some(ESteamPipeOperationType::k_ESteamPipeOperationType_DecryptCPU),
            2 => ::std::option::Option::Some(ESteamPipeOperationType::k_ESteamPipeOperationType_DiskRead),
            3 => ::std::option::Option::Some(ESteamPipeOperationType::k_ESteamPipeOperationType_DiskWrite),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESteamPipeOperationType> {
        match str {
            "k_ESteamPipeOperationType_Invalid" => ::std::option::Option::Some(ESteamPipeOperationType::k_ESteamPipeOperationType_Invalid),
            "k_ESteamPipeOperationType_DecryptCPU" => ::std::option::Option::Some(ESteamPipeOperationType::k_ESteamPipeOperationType_DecryptCPU),
            "k_ESteamPipeOperationType_DiskRead" => ::std::option::Option::Some(ESteamPipeOperationType::k_ESteamPipeOperationType_DiskRead),
            "k_ESteamPipeOperationType_DiskWrite" => ::std::option::Option::Some(ESteamPipeOperationType::k_ESteamPipeOperationType_DiskWrite),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESteamPipeOperationType] = &[
        ESteamPipeOperationType::k_ESteamPipeOperationType_Invalid,
        ESteamPipeOperationType::k_ESteamPipeOperationType_DecryptCPU,
        ESteamPipeOperationType::k_ESteamPipeOperationType_DiskRead,
        ESteamPipeOperationType::k_ESteamPipeOperationType_DiskWrite,
    ];
}

impl ::std::default::Default for ESteamPipeOperationType {
    fn default() -> Self {
        ESteamPipeOperationType::k_ESteamPipeOperationType_Invalid
    }
}

#[allow(unused_imports)]
use crate::steammessages_base::*;
#[allow(unused_imports)]
use crate::steammessages_unified_base_steamclient::*;
#[allow(unused_imports)]
use crate::clientmetrics::*;
impl crate::RpcMessage for CClientMetrics_AppInterfaceCreation {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClientMetrics_AppInterfaceMethodCounts {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClientMetrics_AppInterfaceStats_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClientMetrics_IPv6Connectivity_Result {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClientMetrics_IPv6Connectivity_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClientMetrics_SteamPipeWorkStats_Operation {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClientMetrics_SteamPipeWorkStats_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClientMetrics_ReportReactUsage_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClientMetrics_ReportClientError_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClientMetrics_ClientBootstrap_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClientMetrics_DownloadRates_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClientMetrics_ContentValidation_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClientMetrics_CloudAppSyncStats_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClientMetrics_ContentDownloadResponse_Counts_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClientMetrics_ReportClientArgs_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
///A service for client-reported metrics
struct ClientMetrics {}
impl crate::RpcService for ClientMetrics {
    const SERVICE_NAME: &'static str = "ClientMetrics";
}
impl crate::RpcMethod for CClientMetrics_AppInterfaceStats_Notification {
    const METHOD_NAME: &'static str = "ClientMetrics.ClientAppInterfaceStatsReport#1";
    type Response = ();
}
impl crate::RpcMethod for CClientMetrics_ClientBootstrap_Notification {
    const METHOD_NAME: &'static str = "ClientMetrics.ClientBootstrapReport#1";
    type Response = ();
}
impl crate::RpcMethod for CClientMetrics_CloudAppSyncStats_Notification {
    const METHOD_NAME: &'static str = "ClientMetrics.ClientCloudAppSyncStats#1";
    type Response = ();
}
impl crate::RpcMethod for CClientMetrics_ContentDownloadResponse_Counts_Notification {
    const METHOD_NAME: &'static str = "ClientMetrics.ClientDownloadResponseCodeCounts#1";
    type Response = ();
}
impl crate::RpcMethod for CClientMetrics_ContentValidation_Notification {
    const METHOD_NAME: &'static str = "ClientMetrics.ClientContentValidationReport#1";
    type Response = ();
}
impl crate::RpcMethod for CClientMetrics_DownloadRates_Notification {
    const METHOD_NAME: &'static str = "ClientMetrics.ClientDownloadRatesReport#1";
    type Response = ();
}
impl crate::RpcMethod for CClientMetrics_IPv6Connectivity_Notification {
    const METHOD_NAME: &'static str = "ClientMetrics.ClientIPv6ConnectivityReport#1";
    type Response = ();
}
impl crate::RpcMethod for CClientMetrics_ReportClientArgs_Notification {
    const METHOD_NAME: &'static str = "ClientMetrics.ReportClientArgs#1";
    type Response = ();
}
impl crate::RpcMethod for CClientMetrics_ReportClientError_Notification {
    const METHOD_NAME: &'static str = "ClientMetrics.ReportClientError#1";
    type Response = ();
}
impl crate::RpcMethod for CClientMetrics_ReportReactUsage_Notification {
    const METHOD_NAME: &'static str = "ClientMetrics.ReportReactUsage#1";
    type Response = ();
}
impl crate::RpcMethod for CClientMetrics_SteamPipeWorkStats_Notification {
    const METHOD_NAME: &'static str = "ClientMetrics.SteamPipeWorkStatsReport#1";
    type Response = ();
}
