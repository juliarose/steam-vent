// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_clientserver_2.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:CMsgClientUpdateUserGameInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUpdateUserGameInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUpdateUserGameInfo.steamid_idgs)
    pub steamid_idgs: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUpdateUserGameInfo.gameid)
    pub gameid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUpdateUserGameInfo.game_ip)
    pub game_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUpdateUserGameInfo.game_port)
    pub game_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUpdateUserGameInfo.token)
    pub token: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUpdateUserGameInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUpdateUserGameInfo {
    fn default() -> &'a CMsgClientUpdateUserGameInfo {
        <CMsgClientUpdateUserGameInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUpdateUserGameInfo {
    pub fn new() -> CMsgClientUpdateUserGameInfo {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_idgs = 1;

    pub fn steamid_idgs(&self) -> u64 {
        self.steamid_idgs.unwrap_or(0)
    }

    pub fn clear_steamid_idgs(&mut self) {
        self.steamid_idgs = ::std::option::Option::None;
    }

    pub fn has_steamid_idgs(&self) -> bool {
        self.steamid_idgs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_idgs(&mut self, v: u64) {
        self.steamid_idgs = ::std::option::Option::Some(v);
    }

    // optional fixed64 gameid = 2;

    pub fn gameid(&self) -> u64 {
        self.gameid.unwrap_or(0)
    }

    pub fn clear_gameid(&mut self) {
        self.gameid = ::std::option::Option::None;
    }

    pub fn has_gameid(&self) -> bool {
        self.gameid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameid(&mut self, v: u64) {
        self.gameid = ::std::option::Option::Some(v);
    }

    // optional uint32 game_ip = 3;

    pub fn game_ip(&self) -> u32 {
        self.game_ip.unwrap_or(0)
    }

    pub fn clear_game_ip(&mut self) {
        self.game_ip = ::std::option::Option::None;
    }

    pub fn has_game_ip(&self) -> bool {
        self.game_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_ip(&mut self, v: u32) {
        self.game_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 game_port = 4;

    pub fn game_port(&self) -> u32 {
        self.game_port.unwrap_or(0)
    }

    pub fn clear_game_port(&mut self) {
        self.game_port = ::std::option::Option::None;
    }

    pub fn has_game_port(&self) -> bool {
        self.game_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_port(&mut self, v: u32) {
        self.game_port = ::std::option::Option::Some(v);
    }

    // optional bytes token = 5;

    pub fn token(&self) -> &[u8] {
        match self.token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.token.is_none() {
            self.token = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::vec::Vec<u8> {
        self.token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientUpdateUserGameInfo {
    const NAME: &'static str = "CMsgClientUpdateUserGameInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid_idgs = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.gameid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.game_ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.game_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.token = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_idgs {
            my_size += 1 + 8;
        }
        if let Some(v) = self.gameid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.game_ip {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.game_port {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid_idgs {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.gameid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.game_ip {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.game_port {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.token.as_ref() {
            os.write_bytes(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUpdateUserGameInfo {
        CMsgClientUpdateUserGameInfo::new()
    }

    fn clear(&mut self) {
        self.steamid_idgs = ::std::option::Option::None;
        self.gameid = ::std::option::Option::None;
        self.game_ip = ::std::option::Option::None;
        self.game_port = ::std::option::Option::None;
        self.token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUpdateUserGameInfo {
        static instance: CMsgClientUpdateUserGameInfo = CMsgClientUpdateUserGameInfo {
            steamid_idgs: ::std::option::Option::None,
            gameid: ::std::option::Option::None,
            game_ip: ::std::option::Option::None,
            game_port: ::std::option::Option::None,
            token: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientRichPresenceUpload)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRichPresenceUpload {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRichPresenceUpload.rich_presence_kv)
    pub rich_presence_kv: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientRichPresenceUpload.steamid_broadcast)
    pub steamid_broadcast: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRichPresenceUpload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRichPresenceUpload {
    fn default() -> &'a CMsgClientRichPresenceUpload {
        <CMsgClientRichPresenceUpload as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRichPresenceUpload {
    pub fn new() -> CMsgClientRichPresenceUpload {
        ::std::default::Default::default()
    }

    // optional bytes rich_presence_kv = 1;

    pub fn rich_presence_kv(&self) -> &[u8] {
        match self.rich_presence_kv.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_rich_presence_kv(&mut self) {
        self.rich_presence_kv = ::std::option::Option::None;
    }

    pub fn has_rich_presence_kv(&self) -> bool {
        self.rich_presence_kv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rich_presence_kv(&mut self, v: ::std::vec::Vec<u8>) {
        self.rich_presence_kv = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rich_presence_kv(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.rich_presence_kv.is_none() {
            self.rich_presence_kv = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.rich_presence_kv.as_mut().unwrap()
    }

    // Take field
    pub fn take_rich_presence_kv(&mut self) -> ::std::vec::Vec<u8> {
        self.rich_presence_kv.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientRichPresenceUpload {
    const NAME: &'static str = "CMsgClientRichPresenceUpload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.rich_presence_kv = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    is.read_repeated_packed_fixed64_into(&mut self.steamid_broadcast)?;
                },
                17 => {
                    self.steamid_broadcast.push(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rich_presence_kv.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += 9 * self.steamid_broadcast.len() as u64;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.rich_presence_kv.as_ref() {
            os.write_bytes(1, v)?;
        }
        for v in &self.steamid_broadcast {
            os.write_fixed64(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRichPresenceUpload {
        CMsgClientRichPresenceUpload::new()
    }

    fn clear(&mut self) {
        self.rich_presence_kv = ::std::option::Option::None;
        self.steamid_broadcast.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRichPresenceUpload {
        static instance: CMsgClientRichPresenceUpload = CMsgClientRichPresenceUpload {
            rich_presence_kv: ::std::option::Option::None,
            steamid_broadcast: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientRichPresenceRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRichPresenceRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRichPresenceRequest.steamid_request)
    pub steamid_request: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRichPresenceRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRichPresenceRequest {
    fn default() -> &'a CMsgClientRichPresenceRequest {
        <CMsgClientRichPresenceRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRichPresenceRequest {
    pub fn new() -> CMsgClientRichPresenceRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientRichPresenceRequest {
    const NAME: &'static str = "CMsgClientRichPresenceRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_fixed64_into(&mut self.steamid_request)?;
                },
                9 => {
                    self.steamid_request.push(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += 9 * self.steamid_request.len() as u64;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.steamid_request {
            os.write_fixed64(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRichPresenceRequest {
        CMsgClientRichPresenceRequest::new()
    }

    fn clear(&mut self) {
        self.steamid_request.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRichPresenceRequest {
        static instance: CMsgClientRichPresenceRequest = CMsgClientRichPresenceRequest {
            steamid_request: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientRichPresenceInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRichPresenceInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRichPresenceInfo.rich_presence)
    pub rich_presence: ::std::vec::Vec<cmsg_client_rich_presence_info::RichPresence>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRichPresenceInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRichPresenceInfo {
    fn default() -> &'a CMsgClientRichPresenceInfo {
        <CMsgClientRichPresenceInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRichPresenceInfo {
    pub fn new() -> CMsgClientRichPresenceInfo {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientRichPresenceInfo {
    const NAME: &'static str = "CMsgClientRichPresenceInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.rich_presence.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.rich_presence {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.rich_presence {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRichPresenceInfo {
        CMsgClientRichPresenceInfo::new()
    }

    fn clear(&mut self) {
        self.rich_presence.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRichPresenceInfo {
        static instance: CMsgClientRichPresenceInfo = CMsgClientRichPresenceInfo {
            rich_presence: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientRichPresenceInfo`
pub mod cmsg_client_rich_presence_info {
    // @@protoc_insertion_point(message:CMsgClientRichPresenceInfo.RichPresence)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RichPresence {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientRichPresenceInfo.RichPresence.steamid_user)
        pub steamid_user: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientRichPresenceInfo.RichPresence.rich_presence_kv)
        pub rich_presence_kv: ::std::option::Option<::std::vec::Vec<u8>>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientRichPresenceInfo.RichPresence.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RichPresence {
        fn default() -> &'a RichPresence {
            <RichPresence as ::protobuf::Message>::default_instance()
        }
    }

    impl RichPresence {
        pub fn new() -> RichPresence {
            ::std::default::Default::default()
        }

        // optional fixed64 steamid_user = 1;

        pub fn steamid_user(&self) -> u64 {
            self.steamid_user.unwrap_or(0)
        }

        pub fn clear_steamid_user(&mut self) {
            self.steamid_user = ::std::option::Option::None;
        }

        pub fn has_steamid_user(&self) -> bool {
            self.steamid_user.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steamid_user(&mut self, v: u64) {
            self.steamid_user = ::std::option::Option::Some(v);
        }

        // optional bytes rich_presence_kv = 2;

        pub fn rich_presence_kv(&self) -> &[u8] {
            match self.rich_presence_kv.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_rich_presence_kv(&mut self) {
            self.rich_presence_kv = ::std::option::Option::None;
        }

        pub fn has_rich_presence_kv(&self) -> bool {
            self.rich_presence_kv.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rich_presence_kv(&mut self, v: ::std::vec::Vec<u8>) {
            self.rich_presence_kv = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_rich_presence_kv(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.rich_presence_kv.is_none() {
                self.rich_presence_kv = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.rich_presence_kv.as_mut().unwrap()
        }

        // Take field
        pub fn take_rich_presence_kv(&mut self) -> ::std::vec::Vec<u8> {
            self.rich_presence_kv.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }
    }

    impl ::protobuf::Message for RichPresence {
        const NAME: &'static str = "RichPresence";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steamid_user = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    18 => {
                        self.rich_presence_kv = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steamid_user {
                my_size += 1 + 8;
            }
            if let Some(v) = self.rich_presence_kv.as_ref() {
                my_size += ::protobuf::rt::bytes_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.steamid_user {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.rich_presence_kv.as_ref() {
                os.write_bytes(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RichPresence {
            RichPresence::new()
        }

        fn clear(&mut self) {
            self.steamid_user = ::std::option::Option::None;
            self.rich_presence_kv = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RichPresence {
            static instance: RichPresence = RichPresence {
                steamid_user: ::std::option::Option::None,
                rich_presence_kv: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientCheckFileSignature)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientCheckFileSignature {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientCheckFileSignature.app_id)
    pub app_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientCheckFileSignature.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientCheckFileSignature {
    fn default() -> &'a CMsgClientCheckFileSignature {
        <CMsgClientCheckFileSignature as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientCheckFileSignature {
    pub fn new() -> CMsgClientCheckFileSignature {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientCheckFileSignature {
    const NAME: &'static str = "CMsgClientCheckFileSignature";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientCheckFileSignature {
        CMsgClientCheckFileSignature::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientCheckFileSignature {
        static instance: CMsgClientCheckFileSignature = CMsgClientCheckFileSignature {
            app_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientCheckFileSignatureResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientCheckFileSignatureResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientCheckFileSignatureResponse.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientCheckFileSignatureResponse.pid)
    pub pid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientCheckFileSignatureResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientCheckFileSignatureResponse.filename)
    pub filename: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientCheckFileSignatureResponse.esignatureresult)
    pub esignatureresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientCheckFileSignatureResponse.sha_file)
    pub sha_file: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientCheckFileSignatureResponse.signatureheader)
    pub signatureheader: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientCheckFileSignatureResponse.filesize)
    pub filesize: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientCheckFileSignatureResponse.getlasterror)
    pub getlasterror: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientCheckFileSignatureResponse.evalvesignaturecheckdetail)
    pub evalvesignaturecheckdetail: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientCheckFileSignatureResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientCheckFileSignatureResponse {
    fn default() -> &'a CMsgClientCheckFileSignatureResponse {
        <CMsgClientCheckFileSignatureResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientCheckFileSignatureResponse {
    pub fn new() -> CMsgClientCheckFileSignatureResponse {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 pid = 2;

    pub fn pid(&self) -> u32 {
        self.pid.unwrap_or(0)
    }

    pub fn clear_pid(&mut self) {
        self.pid = ::std::option::Option::None;
    }

    pub fn has_pid(&self) -> bool {
        self.pid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pid(&mut self, v: u32) {
        self.pid = ::std::option::Option::Some(v);
    }

    // optional uint32 eresult = 3;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional string filename = 4;

    pub fn filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename(&mut self) {
        self.filename = ::std::option::Option::None;
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 esignatureresult = 5;

    pub fn esignatureresult(&self) -> u32 {
        self.esignatureresult.unwrap_or(0)
    }

    pub fn clear_esignatureresult(&mut self) {
        self.esignatureresult = ::std::option::Option::None;
    }

    pub fn has_esignatureresult(&self) -> bool {
        self.esignatureresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_esignatureresult(&mut self, v: u32) {
        self.esignatureresult = ::std::option::Option::Some(v);
    }

    // optional bytes sha_file = 6;

    pub fn sha_file(&self) -> &[u8] {
        match self.sha_file.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_sha_file(&mut self) {
        self.sha_file = ::std::option::Option::None;
    }

    pub fn has_sha_file(&self) -> bool {
        self.sha_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_file = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_file(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sha_file.is_none() {
            self.sha_file = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.sha_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_file(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes signatureheader = 7;

    pub fn signatureheader(&self) -> &[u8] {
        match self.signatureheader.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_signatureheader(&mut self) {
        self.signatureheader = ::std::option::Option::None;
    }

    pub fn has_signatureheader(&self) -> bool {
        self.signatureheader.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signatureheader(&mut self, v: ::std::vec::Vec<u8>) {
        self.signatureheader = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signatureheader(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.signatureheader.is_none() {
            self.signatureheader = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.signatureheader.as_mut().unwrap()
    }

    // Take field
    pub fn take_signatureheader(&mut self) -> ::std::vec::Vec<u8> {
        self.signatureheader.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 filesize = 8;

    pub fn filesize(&self) -> u32 {
        self.filesize.unwrap_or(0)
    }

    pub fn clear_filesize(&mut self) {
        self.filesize = ::std::option::Option::None;
    }

    pub fn has_filesize(&self) -> bool {
        self.filesize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesize(&mut self, v: u32) {
        self.filesize = ::std::option::Option::Some(v);
    }

    // optional uint32 getlasterror = 9;

    pub fn getlasterror(&self) -> u32 {
        self.getlasterror.unwrap_or(0)
    }

    pub fn clear_getlasterror(&mut self) {
        self.getlasterror = ::std::option::Option::None;
    }

    pub fn has_getlasterror(&self) -> bool {
        self.getlasterror.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getlasterror(&mut self, v: u32) {
        self.getlasterror = ::std::option::Option::Some(v);
    }

    // optional uint32 evalvesignaturecheckdetail = 10;

    pub fn evalvesignaturecheckdetail(&self) -> u32 {
        self.evalvesignaturecheckdetail.unwrap_or(0)
    }

    pub fn clear_evalvesignaturecheckdetail(&mut self) {
        self.evalvesignaturecheckdetail = ::std::option::Option::None;
    }

    pub fn has_evalvesignaturecheckdetail(&self) -> bool {
        self.evalvesignaturecheckdetail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_evalvesignaturecheckdetail(&mut self, v: u32) {
        self.evalvesignaturecheckdetail = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientCheckFileSignatureResponse {
    const NAME: &'static str = "CMsgClientCheckFileSignatureResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.pid = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.filename = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.esignatureresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    self.sha_file = ::std::option::Option::Some(is.read_bytes()?);
                },
                58 => {
                    self.signatureheader = ::std::option::Option::Some(is.read_bytes()?);
                },
                64 => {
                    self.filesize = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.getlasterror = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.evalvesignaturecheckdetail = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.pid {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.esignatureresult {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.sha_file.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.signatureheader.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.filesize {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.getlasterror {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.evalvesignaturecheckdetail {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.pid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.filename.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.esignatureresult {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.sha_file.as_ref() {
            os.write_bytes(6, v)?;
        }
        if let Some(v) = self.signatureheader.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.filesize {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.getlasterror {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.evalvesignaturecheckdetail {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientCheckFileSignatureResponse {
        CMsgClientCheckFileSignatureResponse::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.pid = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.filename = ::std::option::Option::None;
        self.esignatureresult = ::std::option::Option::None;
        self.sha_file = ::std::option::Option::None;
        self.signatureheader = ::std::option::Option::None;
        self.filesize = ::std::option::Option::None;
        self.getlasterror = ::std::option::Option::None;
        self.evalvesignaturecheckdetail = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientCheckFileSignatureResponse {
        static instance: CMsgClientCheckFileSignatureResponse = CMsgClientCheckFileSignatureResponse {
            app_id: ::std::option::Option::None,
            pid: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            filename: ::std::option::Option::None,
            esignatureresult: ::std::option::Option::None,
            sha_file: ::std::option::Option::None,
            signatureheader: ::std::option::Option::None,
            filesize: ::std::option::Option::None,
            getlasterror: ::std::option::Option::None,
            evalvesignaturecheckdetail: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientReadMachineAuth)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientReadMachineAuth {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientReadMachineAuth.filename)
    pub filename: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientReadMachineAuth.offset)
    pub offset: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientReadMachineAuth.cubtoread)
    pub cubtoread: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientReadMachineAuth.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientReadMachineAuth {
    fn default() -> &'a CMsgClientReadMachineAuth {
        <CMsgClientReadMachineAuth as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientReadMachineAuth {
    pub fn new() -> CMsgClientReadMachineAuth {
        ::std::default::Default::default()
    }

    // optional string filename = 1;

    pub fn filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename(&mut self) {
        self.filename = ::std::option::Option::None;
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 offset = 2;

    pub fn offset(&self) -> u32 {
        self.offset.unwrap_or(0)
    }

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u32) {
        self.offset = ::std::option::Option::Some(v);
    }

    // optional uint32 cubtoread = 3;

    pub fn cubtoread(&self) -> u32 {
        self.cubtoread.unwrap_or(0)
    }

    pub fn clear_cubtoread(&mut self) {
        self.cubtoread = ::std::option::Option::None;
    }

    pub fn has_cubtoread(&self) -> bool {
        self.cubtoread.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cubtoread(&mut self, v: u32) {
        self.cubtoread = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientReadMachineAuth {
    const NAME: &'static str = "CMsgClientReadMachineAuth";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.filename = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.offset = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.cubtoread = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.cubtoread {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.filename.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.offset {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.cubtoread {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientReadMachineAuth {
        CMsgClientReadMachineAuth::new()
    }

    fn clear(&mut self) {
        self.filename = ::std::option::Option::None;
        self.offset = ::std::option::Option::None;
        self.cubtoread = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientReadMachineAuth {
        static instance: CMsgClientReadMachineAuth = CMsgClientReadMachineAuth {
            filename: ::std::option::Option::None,
            offset: ::std::option::Option::None,
            cubtoread: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientReadMachineAuthResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientReadMachineAuthResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientReadMachineAuthResponse.filename)
    pub filename: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientReadMachineAuthResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientReadMachineAuthResponse.filesize)
    pub filesize: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientReadMachineAuthResponse.sha_file)
    pub sha_file: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientReadMachineAuthResponse.getlasterror)
    pub getlasterror: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientReadMachineAuthResponse.offset)
    pub offset: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientReadMachineAuthResponse.cubread)
    pub cubread: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientReadMachineAuthResponse.bytes_read)
    pub bytes_read: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientReadMachineAuthResponse.filename_sentry)
    pub filename_sentry: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientReadMachineAuthResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientReadMachineAuthResponse {
    fn default() -> &'a CMsgClientReadMachineAuthResponse {
        <CMsgClientReadMachineAuthResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientReadMachineAuthResponse {
    pub fn new() -> CMsgClientReadMachineAuthResponse {
        ::std::default::Default::default()
    }

    // optional string filename = 1;

    pub fn filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename(&mut self) {
        self.filename = ::std::option::Option::None;
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 eresult = 2;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 filesize = 3;

    pub fn filesize(&self) -> u32 {
        self.filesize.unwrap_or(0)
    }

    pub fn clear_filesize(&mut self) {
        self.filesize = ::std::option::Option::None;
    }

    pub fn has_filesize(&self) -> bool {
        self.filesize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesize(&mut self, v: u32) {
        self.filesize = ::std::option::Option::Some(v);
    }

    // optional bytes sha_file = 4;

    pub fn sha_file(&self) -> &[u8] {
        match self.sha_file.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_sha_file(&mut self) {
        self.sha_file = ::std::option::Option::None;
    }

    pub fn has_sha_file(&self) -> bool {
        self.sha_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_file = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_file(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sha_file.is_none() {
            self.sha_file = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.sha_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_file(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 getlasterror = 5;

    pub fn getlasterror(&self) -> u32 {
        self.getlasterror.unwrap_or(0)
    }

    pub fn clear_getlasterror(&mut self) {
        self.getlasterror = ::std::option::Option::None;
    }

    pub fn has_getlasterror(&self) -> bool {
        self.getlasterror.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getlasterror(&mut self, v: u32) {
        self.getlasterror = ::std::option::Option::Some(v);
    }

    // optional uint32 offset = 6;

    pub fn offset(&self) -> u32 {
        self.offset.unwrap_or(0)
    }

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u32) {
        self.offset = ::std::option::Option::Some(v);
    }

    // optional uint32 cubread = 7;

    pub fn cubread(&self) -> u32 {
        self.cubread.unwrap_or(0)
    }

    pub fn clear_cubread(&mut self) {
        self.cubread = ::std::option::Option::None;
    }

    pub fn has_cubread(&self) -> bool {
        self.cubread.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cubread(&mut self, v: u32) {
        self.cubread = ::std::option::Option::Some(v);
    }

    // optional bytes bytes_read = 8;

    pub fn bytes_read(&self) -> &[u8] {
        match self.bytes_read.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_bytes_read(&mut self) {
        self.bytes_read = ::std::option::Option::None;
    }

    pub fn has_bytes_read(&self) -> bool {
        self.bytes_read.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_read(&mut self, v: ::std::vec::Vec<u8>) {
        self.bytes_read = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bytes_read(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.bytes_read.is_none() {
            self.bytes_read = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.bytes_read.as_mut().unwrap()
    }

    // Take field
    pub fn take_bytes_read(&mut self) -> ::std::vec::Vec<u8> {
        self.bytes_read.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string filename_sentry = 9;

    pub fn filename_sentry(&self) -> &str {
        match self.filename_sentry.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename_sentry(&mut self) {
        self.filename_sentry = ::std::option::Option::None;
    }

    pub fn has_filename_sentry(&self) -> bool {
        self.filename_sentry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename_sentry(&mut self, v: ::std::string::String) {
        self.filename_sentry = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename_sentry(&mut self) -> &mut ::std::string::String {
        if self.filename_sentry.is_none() {
            self.filename_sentry = ::std::option::Option::Some(::std::string::String::new());
        }
        self.filename_sentry.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename_sentry(&mut self) -> ::std::string::String {
        self.filename_sentry.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientReadMachineAuthResponse {
    const NAME: &'static str = "CMsgClientReadMachineAuthResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.filename = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.filesize = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.sha_file = ::std::option::Option::Some(is.read_bytes()?);
                },
                40 => {
                    self.getlasterror = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.offset = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.cubread = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.bytes_read = ::std::option::Option::Some(is.read_bytes()?);
                },
                74 => {
                    self.filename_sentry = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.filesize {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.sha_file.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.getlasterror {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.cubread {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.bytes_read.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.filename_sentry.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.filename.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.filesize {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.sha_file.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.getlasterror {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.offset {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.cubread {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.bytes_read.as_ref() {
            os.write_bytes(8, v)?;
        }
        if let Some(v) = self.filename_sentry.as_ref() {
            os.write_string(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientReadMachineAuthResponse {
        CMsgClientReadMachineAuthResponse::new()
    }

    fn clear(&mut self) {
        self.filename = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.filesize = ::std::option::Option::None;
        self.sha_file = ::std::option::Option::None;
        self.getlasterror = ::std::option::Option::None;
        self.offset = ::std::option::Option::None;
        self.cubread = ::std::option::Option::None;
        self.bytes_read = ::std::option::Option::None;
        self.filename_sentry = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientReadMachineAuthResponse {
        static instance: CMsgClientReadMachineAuthResponse = CMsgClientReadMachineAuthResponse {
            filename: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            filesize: ::std::option::Option::None,
            sha_file: ::std::option::Option::None,
            getlasterror: ::std::option::Option::None,
            offset: ::std::option::Option::None,
            cubread: ::std::option::Option::None,
            bytes_read: ::std::option::Option::None,
            filename_sentry: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientUpdateMachineAuth)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUpdateMachineAuth {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuth.filename)
    pub filename: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuth.offset)
    pub offset: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuth.cubtowrite)
    pub cubtowrite: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuth.bytes)
    pub bytes: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuth.otp_type)
    pub otp_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuth.otp_identifier)
    pub otp_identifier: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuth.otp_sharedsecret)
    pub otp_sharedsecret: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuth.otp_timedrift)
    pub otp_timedrift: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUpdateMachineAuth.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUpdateMachineAuth {
    fn default() -> &'a CMsgClientUpdateMachineAuth {
        <CMsgClientUpdateMachineAuth as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUpdateMachineAuth {
    pub fn new() -> CMsgClientUpdateMachineAuth {
        ::std::default::Default::default()
    }

    // optional string filename = 1;

    pub fn filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename(&mut self) {
        self.filename = ::std::option::Option::None;
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 offset = 2;

    pub fn offset(&self) -> u32 {
        self.offset.unwrap_or(0)
    }

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u32) {
        self.offset = ::std::option::Option::Some(v);
    }

    // optional uint32 cubtowrite = 3;

    pub fn cubtowrite(&self) -> u32 {
        self.cubtowrite.unwrap_or(0)
    }

    pub fn clear_cubtowrite(&mut self) {
        self.cubtowrite = ::std::option::Option::None;
    }

    pub fn has_cubtowrite(&self) -> bool {
        self.cubtowrite.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cubtowrite(&mut self, v: u32) {
        self.cubtowrite = ::std::option::Option::Some(v);
    }

    // optional bytes bytes = 4;

    pub fn bytes(&self) -> &[u8] {
        match self.bytes.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_bytes(&mut self) {
        self.bytes = ::std::option::Option::None;
    }

    pub fn has_bytes(&self) -> bool {
        self.bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.bytes = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.bytes.is_none() {
            self.bytes = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.bytes.as_mut().unwrap()
    }

    // Take field
    pub fn take_bytes(&mut self) -> ::std::vec::Vec<u8> {
        self.bytes.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 otp_type = 5;

    pub fn otp_type(&self) -> u32 {
        self.otp_type.unwrap_or(0)
    }

    pub fn clear_otp_type(&mut self) {
        self.otp_type = ::std::option::Option::None;
    }

    pub fn has_otp_type(&self) -> bool {
        self.otp_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_type(&mut self, v: u32) {
        self.otp_type = ::std::option::Option::Some(v);
    }

    // optional string otp_identifier = 6;

    pub fn otp_identifier(&self) -> &str {
        match self.otp_identifier.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_otp_identifier(&mut self) {
        self.otp_identifier = ::std::option::Option::None;
    }

    pub fn has_otp_identifier(&self) -> bool {
        self.otp_identifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_identifier(&mut self, v: ::std::string::String) {
        self.otp_identifier = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_otp_identifier(&mut self) -> &mut ::std::string::String {
        if self.otp_identifier.is_none() {
            self.otp_identifier = ::std::option::Option::Some(::std::string::String::new());
        }
        self.otp_identifier.as_mut().unwrap()
    }

    // Take field
    pub fn take_otp_identifier(&mut self) -> ::std::string::String {
        self.otp_identifier.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes otp_sharedsecret = 7;

    pub fn otp_sharedsecret(&self) -> &[u8] {
        match self.otp_sharedsecret.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_otp_sharedsecret(&mut self) {
        self.otp_sharedsecret = ::std::option::Option::None;
    }

    pub fn has_otp_sharedsecret(&self) -> bool {
        self.otp_sharedsecret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_sharedsecret(&mut self, v: ::std::vec::Vec<u8>) {
        self.otp_sharedsecret = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_otp_sharedsecret(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.otp_sharedsecret.is_none() {
            self.otp_sharedsecret = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.otp_sharedsecret.as_mut().unwrap()
    }

    // Take field
    pub fn take_otp_sharedsecret(&mut self) -> ::std::vec::Vec<u8> {
        self.otp_sharedsecret.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 otp_timedrift = 8;

    pub fn otp_timedrift(&self) -> u32 {
        self.otp_timedrift.unwrap_or(0)
    }

    pub fn clear_otp_timedrift(&mut self) {
        self.otp_timedrift = ::std::option::Option::None;
    }

    pub fn has_otp_timedrift(&self) -> bool {
        self.otp_timedrift.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_timedrift(&mut self, v: u32) {
        self.otp_timedrift = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUpdateMachineAuth {
    const NAME: &'static str = "CMsgClientUpdateMachineAuth";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.filename = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.offset = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.cubtowrite = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.bytes = ::std::option::Option::Some(is.read_bytes()?);
                },
                40 => {
                    self.otp_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    self.otp_identifier = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.otp_sharedsecret = ::std::option::Option::Some(is.read_bytes()?);
                },
                64 => {
                    self.otp_timedrift = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.cubtowrite {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.bytes.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.otp_type {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.otp_identifier.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.otp_sharedsecret.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.otp_timedrift {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.filename.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.offset {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.cubtowrite {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.bytes.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.otp_type {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.otp_identifier.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.otp_sharedsecret.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.otp_timedrift {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUpdateMachineAuth {
        CMsgClientUpdateMachineAuth::new()
    }

    fn clear(&mut self) {
        self.filename = ::std::option::Option::None;
        self.offset = ::std::option::Option::None;
        self.cubtowrite = ::std::option::Option::None;
        self.bytes = ::std::option::Option::None;
        self.otp_type = ::std::option::Option::None;
        self.otp_identifier = ::std::option::Option::None;
        self.otp_sharedsecret = ::std::option::Option::None;
        self.otp_timedrift = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUpdateMachineAuth {
        static instance: CMsgClientUpdateMachineAuth = CMsgClientUpdateMachineAuth {
            filename: ::std::option::Option::None,
            offset: ::std::option::Option::None,
            cubtowrite: ::std::option::Option::None,
            bytes: ::std::option::Option::None,
            otp_type: ::std::option::Option::None,
            otp_identifier: ::std::option::Option::None,
            otp_sharedsecret: ::std::option::Option::None,
            otp_timedrift: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientUpdateMachineAuthResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUpdateMachineAuthResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuthResponse.filename)
    pub filename: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuthResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuthResponse.filesize)
    pub filesize: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuthResponse.sha_file)
    pub sha_file: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuthResponse.getlasterror)
    pub getlasterror: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuthResponse.offset)
    pub offset: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuthResponse.cubwrote)
    pub cubwrote: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuthResponse.otp_type)
    pub otp_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuthResponse.otp_value)
    pub otp_value: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuthResponse.otp_identifier)
    pub otp_identifier: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUpdateMachineAuthResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUpdateMachineAuthResponse {
    fn default() -> &'a CMsgClientUpdateMachineAuthResponse {
        <CMsgClientUpdateMachineAuthResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUpdateMachineAuthResponse {
    pub fn new() -> CMsgClientUpdateMachineAuthResponse {
        ::std::default::Default::default()
    }

    // optional string filename = 1;

    pub fn filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename(&mut self) {
        self.filename = ::std::option::Option::None;
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 eresult = 2;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 filesize = 3;

    pub fn filesize(&self) -> u32 {
        self.filesize.unwrap_or(0)
    }

    pub fn clear_filesize(&mut self) {
        self.filesize = ::std::option::Option::None;
    }

    pub fn has_filesize(&self) -> bool {
        self.filesize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesize(&mut self, v: u32) {
        self.filesize = ::std::option::Option::Some(v);
    }

    // optional bytes sha_file = 4;

    pub fn sha_file(&self) -> &[u8] {
        match self.sha_file.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_sha_file(&mut self) {
        self.sha_file = ::std::option::Option::None;
    }

    pub fn has_sha_file(&self) -> bool {
        self.sha_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_file = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_file(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sha_file.is_none() {
            self.sha_file = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.sha_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_file(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 getlasterror = 5;

    pub fn getlasterror(&self) -> u32 {
        self.getlasterror.unwrap_or(0)
    }

    pub fn clear_getlasterror(&mut self) {
        self.getlasterror = ::std::option::Option::None;
    }

    pub fn has_getlasterror(&self) -> bool {
        self.getlasterror.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getlasterror(&mut self, v: u32) {
        self.getlasterror = ::std::option::Option::Some(v);
    }

    // optional uint32 offset = 6;

    pub fn offset(&self) -> u32 {
        self.offset.unwrap_or(0)
    }

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u32) {
        self.offset = ::std::option::Option::Some(v);
    }

    // optional uint32 cubwrote = 7;

    pub fn cubwrote(&self) -> u32 {
        self.cubwrote.unwrap_or(0)
    }

    pub fn clear_cubwrote(&mut self) {
        self.cubwrote = ::std::option::Option::None;
    }

    pub fn has_cubwrote(&self) -> bool {
        self.cubwrote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cubwrote(&mut self, v: u32) {
        self.cubwrote = ::std::option::Option::Some(v);
    }

    // optional int32 otp_type = 8;

    pub fn otp_type(&self) -> i32 {
        self.otp_type.unwrap_or(0)
    }

    pub fn clear_otp_type(&mut self) {
        self.otp_type = ::std::option::Option::None;
    }

    pub fn has_otp_type(&self) -> bool {
        self.otp_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_type(&mut self, v: i32) {
        self.otp_type = ::std::option::Option::Some(v);
    }

    // optional uint32 otp_value = 9;

    pub fn otp_value(&self) -> u32 {
        self.otp_value.unwrap_or(0)
    }

    pub fn clear_otp_value(&mut self) {
        self.otp_value = ::std::option::Option::None;
    }

    pub fn has_otp_value(&self) -> bool {
        self.otp_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_value(&mut self, v: u32) {
        self.otp_value = ::std::option::Option::Some(v);
    }

    // optional string otp_identifier = 10;

    pub fn otp_identifier(&self) -> &str {
        match self.otp_identifier.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_otp_identifier(&mut self) {
        self.otp_identifier = ::std::option::Option::None;
    }

    pub fn has_otp_identifier(&self) -> bool {
        self.otp_identifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_identifier(&mut self, v: ::std::string::String) {
        self.otp_identifier = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_otp_identifier(&mut self) -> &mut ::std::string::String {
        if self.otp_identifier.is_none() {
            self.otp_identifier = ::std::option::Option::Some(::std::string::String::new());
        }
        self.otp_identifier.as_mut().unwrap()
    }

    // Take field
    pub fn take_otp_identifier(&mut self) -> ::std::string::String {
        self.otp_identifier.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientUpdateMachineAuthResponse {
    const NAME: &'static str = "CMsgClientUpdateMachineAuthResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.filename = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.filesize = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.sha_file = ::std::option::Option::Some(is.read_bytes()?);
                },
                40 => {
                    self.getlasterror = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.offset = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.cubwrote = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.otp_type = ::std::option::Option::Some(is.read_int32()?);
                },
                72 => {
                    self.otp_value = ::std::option::Option::Some(is.read_uint32()?);
                },
                82 => {
                    self.otp_identifier = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.filesize {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.sha_file.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.getlasterror {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.cubwrote {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.otp_type {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.otp_value {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.otp_identifier.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.filename.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.filesize {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.sha_file.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.getlasterror {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.offset {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.cubwrote {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.otp_type {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.otp_value {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.otp_identifier.as_ref() {
            os.write_string(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUpdateMachineAuthResponse {
        CMsgClientUpdateMachineAuthResponse::new()
    }

    fn clear(&mut self) {
        self.filename = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.filesize = ::std::option::Option::None;
        self.sha_file = ::std::option::Option::None;
        self.getlasterror = ::std::option::Option::None;
        self.offset = ::std::option::Option::None;
        self.cubwrote = ::std::option::Option::None;
        self.otp_type = ::std::option::Option::None;
        self.otp_value = ::std::option::Option::None;
        self.otp_identifier = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUpdateMachineAuthResponse {
        static instance: CMsgClientUpdateMachineAuthResponse = CMsgClientUpdateMachineAuthResponse {
            filename: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            filesize: ::std::option::Option::None,
            sha_file: ::std::option::Option::None,
            getlasterror: ::std::option::Option::None,
            offset: ::std::option::Option::None,
            cubwrote: ::std::option::Option::None,
            otp_type: ::std::option::Option::None,
            otp_value: ::std::option::Option::None,
            otp_identifier: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientRequestMachineAuth)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRequestMachineAuth {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRequestMachineAuth.filename)
    pub filename: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientRequestMachineAuth.eresult_sentryfile)
    pub eresult_sentryfile: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientRequestMachineAuth.filesize)
    pub filesize: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientRequestMachineAuth.sha_sentryfile)
    pub sha_sentryfile: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientRequestMachineAuth.lock_account_action)
    pub lock_account_action: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientRequestMachineAuth.otp_type)
    pub otp_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientRequestMachineAuth.otp_identifier)
    pub otp_identifier: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientRequestMachineAuth.otp_sharedsecret)
    pub otp_sharedsecret: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientRequestMachineAuth.otp_value)
    pub otp_value: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientRequestMachineAuth.machine_name)
    pub machine_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientRequestMachineAuth.machine_name_userchosen)
    pub machine_name_userchosen: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRequestMachineAuth.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestMachineAuth {
    fn default() -> &'a CMsgClientRequestMachineAuth {
        <CMsgClientRequestMachineAuth as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestMachineAuth {
    pub fn new() -> CMsgClientRequestMachineAuth {
        ::std::default::Default::default()
    }

    // optional string filename = 1;

    pub fn filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename(&mut self) {
        self.filename = ::std::option::Option::None;
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 eresult_sentryfile = 2;

    pub fn eresult_sentryfile(&self) -> u32 {
        self.eresult_sentryfile.unwrap_or(0)
    }

    pub fn clear_eresult_sentryfile(&mut self) {
        self.eresult_sentryfile = ::std::option::Option::None;
    }

    pub fn has_eresult_sentryfile(&self) -> bool {
        self.eresult_sentryfile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult_sentryfile(&mut self, v: u32) {
        self.eresult_sentryfile = ::std::option::Option::Some(v);
    }

    // optional uint32 filesize = 3;

    pub fn filesize(&self) -> u32 {
        self.filesize.unwrap_or(0)
    }

    pub fn clear_filesize(&mut self) {
        self.filesize = ::std::option::Option::None;
    }

    pub fn has_filesize(&self) -> bool {
        self.filesize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesize(&mut self, v: u32) {
        self.filesize = ::std::option::Option::Some(v);
    }

    // optional bytes sha_sentryfile = 4;

    pub fn sha_sentryfile(&self) -> &[u8] {
        match self.sha_sentryfile.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_sha_sentryfile(&mut self) {
        self.sha_sentryfile = ::std::option::Option::None;
    }

    pub fn has_sha_sentryfile(&self) -> bool {
        self.sha_sentryfile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_sentryfile(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_sentryfile = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_sentryfile(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sha_sentryfile.is_none() {
            self.sha_sentryfile = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.sha_sentryfile.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_sentryfile(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_sentryfile.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 lock_account_action = 6;

    pub fn lock_account_action(&self) -> i32 {
        self.lock_account_action.unwrap_or(0)
    }

    pub fn clear_lock_account_action(&mut self) {
        self.lock_account_action = ::std::option::Option::None;
    }

    pub fn has_lock_account_action(&self) -> bool {
        self.lock_account_action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lock_account_action(&mut self, v: i32) {
        self.lock_account_action = ::std::option::Option::Some(v);
    }

    // optional uint32 otp_type = 7;

    pub fn otp_type(&self) -> u32 {
        self.otp_type.unwrap_or(0)
    }

    pub fn clear_otp_type(&mut self) {
        self.otp_type = ::std::option::Option::None;
    }

    pub fn has_otp_type(&self) -> bool {
        self.otp_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_type(&mut self, v: u32) {
        self.otp_type = ::std::option::Option::Some(v);
    }

    // optional string otp_identifier = 8;

    pub fn otp_identifier(&self) -> &str {
        match self.otp_identifier.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_otp_identifier(&mut self) {
        self.otp_identifier = ::std::option::Option::None;
    }

    pub fn has_otp_identifier(&self) -> bool {
        self.otp_identifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_identifier(&mut self, v: ::std::string::String) {
        self.otp_identifier = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_otp_identifier(&mut self) -> &mut ::std::string::String {
        if self.otp_identifier.is_none() {
            self.otp_identifier = ::std::option::Option::Some(::std::string::String::new());
        }
        self.otp_identifier.as_mut().unwrap()
    }

    // Take field
    pub fn take_otp_identifier(&mut self) -> ::std::string::String {
        self.otp_identifier.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes otp_sharedsecret = 9;

    pub fn otp_sharedsecret(&self) -> &[u8] {
        match self.otp_sharedsecret.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_otp_sharedsecret(&mut self) {
        self.otp_sharedsecret = ::std::option::Option::None;
    }

    pub fn has_otp_sharedsecret(&self) -> bool {
        self.otp_sharedsecret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_sharedsecret(&mut self, v: ::std::vec::Vec<u8>) {
        self.otp_sharedsecret = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_otp_sharedsecret(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.otp_sharedsecret.is_none() {
            self.otp_sharedsecret = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.otp_sharedsecret.as_mut().unwrap()
    }

    // Take field
    pub fn take_otp_sharedsecret(&mut self) -> ::std::vec::Vec<u8> {
        self.otp_sharedsecret.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 otp_value = 10;

    pub fn otp_value(&self) -> u32 {
        self.otp_value.unwrap_or(0)
    }

    pub fn clear_otp_value(&mut self) {
        self.otp_value = ::std::option::Option::None;
    }

    pub fn has_otp_value(&self) -> bool {
        self.otp_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_value(&mut self, v: u32) {
        self.otp_value = ::std::option::Option::Some(v);
    }

    // optional string machine_name = 11;

    pub fn machine_name(&self) -> &str {
        match self.machine_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_machine_name(&mut self) {
        self.machine_name = ::std::option::Option::None;
    }

    pub fn has_machine_name(&self) -> bool {
        self.machine_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_machine_name(&mut self, v: ::std::string::String) {
        self.machine_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_machine_name(&mut self) -> &mut ::std::string::String {
        if self.machine_name.is_none() {
            self.machine_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.machine_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_machine_name(&mut self) -> ::std::string::String {
        self.machine_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string machine_name_userchosen = 12;

    pub fn machine_name_userchosen(&self) -> &str {
        match self.machine_name_userchosen.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_machine_name_userchosen(&mut self) {
        self.machine_name_userchosen = ::std::option::Option::None;
    }

    pub fn has_machine_name_userchosen(&self) -> bool {
        self.machine_name_userchosen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_machine_name_userchosen(&mut self, v: ::std::string::String) {
        self.machine_name_userchosen = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_machine_name_userchosen(&mut self) -> &mut ::std::string::String {
        if self.machine_name_userchosen.is_none() {
            self.machine_name_userchosen = ::std::option::Option::Some(::std::string::String::new());
        }
        self.machine_name_userchosen.as_mut().unwrap()
    }

    // Take field
    pub fn take_machine_name_userchosen(&mut self) -> ::std::string::String {
        self.machine_name_userchosen.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientRequestMachineAuth {
    const NAME: &'static str = "CMsgClientRequestMachineAuth";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.filename = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.eresult_sentryfile = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.filesize = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.sha_sentryfile = ::std::option::Option::Some(is.read_bytes()?);
                },
                48 => {
                    self.lock_account_action = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.otp_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.otp_identifier = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.otp_sharedsecret = ::std::option::Option::Some(is.read_bytes()?);
                },
                80 => {
                    self.otp_value = ::std::option::Option::Some(is.read_uint32()?);
                },
                90 => {
                    self.machine_name = ::std::option::Option::Some(is.read_string()?);
                },
                98 => {
                    self.machine_name_userchosen = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.eresult_sentryfile {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.filesize {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.sha_sentryfile.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.lock_account_action {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.otp_type {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.otp_identifier.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.otp_sharedsecret.as_ref() {
            my_size += ::protobuf::rt::bytes_size(9, &v);
        }
        if let Some(v) = self.otp_value {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.machine_name.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.machine_name_userchosen.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.filename.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.eresult_sentryfile {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.filesize {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.sha_sentryfile.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.lock_account_action {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.otp_type {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.otp_identifier.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.otp_sharedsecret.as_ref() {
            os.write_bytes(9, v)?;
        }
        if let Some(v) = self.otp_value {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.machine_name.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.machine_name_userchosen.as_ref() {
            os.write_string(12, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRequestMachineAuth {
        CMsgClientRequestMachineAuth::new()
    }

    fn clear(&mut self) {
        self.filename = ::std::option::Option::None;
        self.eresult_sentryfile = ::std::option::Option::None;
        self.filesize = ::std::option::Option::None;
        self.sha_sentryfile = ::std::option::Option::None;
        self.lock_account_action = ::std::option::Option::None;
        self.otp_type = ::std::option::Option::None;
        self.otp_identifier = ::std::option::Option::None;
        self.otp_sharedsecret = ::std::option::Option::None;
        self.otp_value = ::std::option::Option::None;
        self.machine_name = ::std::option::Option::None;
        self.machine_name_userchosen = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRequestMachineAuth {
        static instance: CMsgClientRequestMachineAuth = CMsgClientRequestMachineAuth {
            filename: ::std::option::Option::None,
            eresult_sentryfile: ::std::option::Option::None,
            filesize: ::std::option::Option::None,
            sha_sentryfile: ::std::option::Option::None,
            lock_account_action: ::std::option::Option::None,
            otp_type: ::std::option::Option::None,
            otp_identifier: ::std::option::Option::None,
            otp_sharedsecret: ::std::option::Option::None,
            otp_value: ::std::option::Option::None,
            machine_name: ::std::option::Option::None,
            machine_name_userchosen: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientRequestMachineAuthResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRequestMachineAuthResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRequestMachineAuthResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRequestMachineAuthResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestMachineAuthResponse {
    fn default() -> &'a CMsgClientRequestMachineAuthResponse {
        <CMsgClientRequestMachineAuthResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestMachineAuthResponse {
    pub fn new() -> CMsgClientRequestMachineAuthResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientRequestMachineAuthResponse {
    const NAME: &'static str = "CMsgClientRequestMachineAuthResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRequestMachineAuthResponse {
        CMsgClientRequestMachineAuthResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRequestMachineAuthResponse {
        static instance: CMsgClientRequestMachineAuthResponse = CMsgClientRequestMachineAuthResponse {
            eresult: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientRegisterKey)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRegisterKey {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRegisterKey.key)
    pub key: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRegisterKey.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRegisterKey {
    fn default() -> &'a CMsgClientRegisterKey {
        <CMsgClientRegisterKey as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRegisterKey {
    pub fn new() -> CMsgClientRegisterKey {
        ::std::default::Default::default()
    }

    // optional string key = 1;

    pub fn key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientRegisterKey {
    const NAME: &'static str = "CMsgClientRegisterKey";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRegisterKey {
        CMsgClientRegisterKey::new()
    }

    fn clear(&mut self) {
        self.key = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRegisterKey {
        static instance: CMsgClientRegisterKey = CMsgClientRegisterKey {
            key: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientPurchaseResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientPurchaseResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientPurchaseResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientPurchaseResponse.purchase_result_details)
    pub purchase_result_details: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientPurchaseResponse.purchase_receipt_info)
    pub purchase_receipt_info: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientPurchaseResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientPurchaseResponse {
    fn default() -> &'a CMsgClientPurchaseResponse {
        <CMsgClientPurchaseResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPurchaseResponse {
    pub fn new() -> CMsgClientPurchaseResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional int32 purchase_result_details = 2;

    pub fn purchase_result_details(&self) -> i32 {
        self.purchase_result_details.unwrap_or(0)
    }

    pub fn clear_purchase_result_details(&mut self) {
        self.purchase_result_details = ::std::option::Option::None;
    }

    pub fn has_purchase_result_details(&self) -> bool {
        self.purchase_result_details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_purchase_result_details(&mut self, v: i32) {
        self.purchase_result_details = ::std::option::Option::Some(v);
    }

    // optional bytes purchase_receipt_info = 3;

    pub fn purchase_receipt_info(&self) -> &[u8] {
        match self.purchase_receipt_info.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_purchase_receipt_info(&mut self) {
        self.purchase_receipt_info = ::std::option::Option::None;
    }

    pub fn has_purchase_receipt_info(&self) -> bool {
        self.purchase_receipt_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_purchase_receipt_info(&mut self, v: ::std::vec::Vec<u8>) {
        self.purchase_receipt_info = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_purchase_receipt_info(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.purchase_receipt_info.is_none() {
            self.purchase_receipt_info = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.purchase_receipt_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_purchase_receipt_info(&mut self) -> ::std::vec::Vec<u8> {
        self.purchase_receipt_info.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientPurchaseResponse {
    const NAME: &'static str = "CMsgClientPurchaseResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.purchase_result_details = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.purchase_receipt_info = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.purchase_result_details {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.purchase_receipt_info.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.purchase_result_details {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.purchase_receipt_info.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientPurchaseResponse {
        CMsgClientPurchaseResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.purchase_result_details = ::std::option::Option::None;
        self.purchase_receipt_info = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientPurchaseResponse {
        static instance: CMsgClientPurchaseResponse = CMsgClientPurchaseResponse {
            eresult: ::std::option::Option::None,
            purchase_result_details: ::std::option::Option::None,
            purchase_receipt_info: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientActivateOEMLicense)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientActivateOEMLicense {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientActivateOEMLicense.bios_manufacturer)
    pub bios_manufacturer: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientActivateOEMLicense.bios_serialnumber)
    pub bios_serialnumber: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientActivateOEMLicense.license_file)
    pub license_file: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientActivateOEMLicense.mainboard_manufacturer)
    pub mainboard_manufacturer: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientActivateOEMLicense.mainboard_product)
    pub mainboard_product: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientActivateOEMLicense.mainboard_serialnumber)
    pub mainboard_serialnumber: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientActivateOEMLicense.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientActivateOEMLicense {
    fn default() -> &'a CMsgClientActivateOEMLicense {
        <CMsgClientActivateOEMLicense as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientActivateOEMLicense {
    pub fn new() -> CMsgClientActivateOEMLicense {
        ::std::default::Default::default()
    }

    // optional string bios_manufacturer = 1;

    pub fn bios_manufacturer(&self) -> &str {
        match self.bios_manufacturer.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_bios_manufacturer(&mut self) {
        self.bios_manufacturer = ::std::option::Option::None;
    }

    pub fn has_bios_manufacturer(&self) -> bool {
        self.bios_manufacturer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bios_manufacturer(&mut self, v: ::std::string::String) {
        self.bios_manufacturer = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bios_manufacturer(&mut self) -> &mut ::std::string::String {
        if self.bios_manufacturer.is_none() {
            self.bios_manufacturer = ::std::option::Option::Some(::std::string::String::new());
        }
        self.bios_manufacturer.as_mut().unwrap()
    }

    // Take field
    pub fn take_bios_manufacturer(&mut self) -> ::std::string::String {
        self.bios_manufacturer.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string bios_serialnumber = 2;

    pub fn bios_serialnumber(&self) -> &str {
        match self.bios_serialnumber.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_bios_serialnumber(&mut self) {
        self.bios_serialnumber = ::std::option::Option::None;
    }

    pub fn has_bios_serialnumber(&self) -> bool {
        self.bios_serialnumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bios_serialnumber(&mut self, v: ::std::string::String) {
        self.bios_serialnumber = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bios_serialnumber(&mut self) -> &mut ::std::string::String {
        if self.bios_serialnumber.is_none() {
            self.bios_serialnumber = ::std::option::Option::Some(::std::string::String::new());
        }
        self.bios_serialnumber.as_mut().unwrap()
    }

    // Take field
    pub fn take_bios_serialnumber(&mut self) -> ::std::string::String {
        self.bios_serialnumber.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes license_file = 3;

    pub fn license_file(&self) -> &[u8] {
        match self.license_file.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_license_file(&mut self) {
        self.license_file = ::std::option::Option::None;
    }

    pub fn has_license_file(&self) -> bool {
        self.license_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_license_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.license_file = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_license_file(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.license_file.is_none() {
            self.license_file = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.license_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_license_file(&mut self) -> ::std::vec::Vec<u8> {
        self.license_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string mainboard_manufacturer = 4;

    pub fn mainboard_manufacturer(&self) -> &str {
        match self.mainboard_manufacturer.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mainboard_manufacturer(&mut self) {
        self.mainboard_manufacturer = ::std::option::Option::None;
    }

    pub fn has_mainboard_manufacturer(&self) -> bool {
        self.mainboard_manufacturer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mainboard_manufacturer(&mut self, v: ::std::string::String) {
        self.mainboard_manufacturer = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mainboard_manufacturer(&mut self) -> &mut ::std::string::String {
        if self.mainboard_manufacturer.is_none() {
            self.mainboard_manufacturer = ::std::option::Option::Some(::std::string::String::new());
        }
        self.mainboard_manufacturer.as_mut().unwrap()
    }

    // Take field
    pub fn take_mainboard_manufacturer(&mut self) -> ::std::string::String {
        self.mainboard_manufacturer.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string mainboard_product = 5;

    pub fn mainboard_product(&self) -> &str {
        match self.mainboard_product.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mainboard_product(&mut self) {
        self.mainboard_product = ::std::option::Option::None;
    }

    pub fn has_mainboard_product(&self) -> bool {
        self.mainboard_product.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mainboard_product(&mut self, v: ::std::string::String) {
        self.mainboard_product = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mainboard_product(&mut self) -> &mut ::std::string::String {
        if self.mainboard_product.is_none() {
            self.mainboard_product = ::std::option::Option::Some(::std::string::String::new());
        }
        self.mainboard_product.as_mut().unwrap()
    }

    // Take field
    pub fn take_mainboard_product(&mut self) -> ::std::string::String {
        self.mainboard_product.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string mainboard_serialnumber = 6;

    pub fn mainboard_serialnumber(&self) -> &str {
        match self.mainboard_serialnumber.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mainboard_serialnumber(&mut self) {
        self.mainboard_serialnumber = ::std::option::Option::None;
    }

    pub fn has_mainboard_serialnumber(&self) -> bool {
        self.mainboard_serialnumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mainboard_serialnumber(&mut self, v: ::std::string::String) {
        self.mainboard_serialnumber = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mainboard_serialnumber(&mut self) -> &mut ::std::string::String {
        if self.mainboard_serialnumber.is_none() {
            self.mainboard_serialnumber = ::std::option::Option::Some(::std::string::String::new());
        }
        self.mainboard_serialnumber.as_mut().unwrap()
    }

    // Take field
    pub fn take_mainboard_serialnumber(&mut self) -> ::std::string::String {
        self.mainboard_serialnumber.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientActivateOEMLicense {
    const NAME: &'static str = "CMsgClientActivateOEMLicense";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.bios_manufacturer = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.bios_serialnumber = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.license_file = ::std::option::Option::Some(is.read_bytes()?);
                },
                34 => {
                    self.mainboard_manufacturer = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.mainboard_product = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.mainboard_serialnumber = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.bios_manufacturer.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.bios_serialnumber.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.license_file.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.mainboard_manufacturer.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.mainboard_product.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.mainboard_serialnumber.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.bios_manufacturer.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.bios_serialnumber.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.license_file.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.mainboard_manufacturer.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.mainboard_product.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.mainboard_serialnumber.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientActivateOEMLicense {
        CMsgClientActivateOEMLicense::new()
    }

    fn clear(&mut self) {
        self.bios_manufacturer = ::std::option::Option::None;
        self.bios_serialnumber = ::std::option::Option::None;
        self.license_file = ::std::option::Option::None;
        self.mainboard_manufacturer = ::std::option::Option::None;
        self.mainboard_product = ::std::option::Option::None;
        self.mainboard_serialnumber = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientActivateOEMLicense {
        static instance: CMsgClientActivateOEMLicense = CMsgClientActivateOEMLicense {
            bios_manufacturer: ::std::option::Option::None,
            bios_serialnumber: ::std::option::Option::None,
            license_file: ::std::option::Option::None,
            mainboard_manufacturer: ::std::option::Option::None,
            mainboard_product: ::std::option::Option::None,
            mainboard_serialnumber: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientRegisterOEMMachine)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRegisterOEMMachine {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRegisterOEMMachine.oem_register_file)
    pub oem_register_file: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRegisterOEMMachine.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRegisterOEMMachine {
    fn default() -> &'a CMsgClientRegisterOEMMachine {
        <CMsgClientRegisterOEMMachine as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRegisterOEMMachine {
    pub fn new() -> CMsgClientRegisterOEMMachine {
        ::std::default::Default::default()
    }

    // optional bytes oem_register_file = 1;

    pub fn oem_register_file(&self) -> &[u8] {
        match self.oem_register_file.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_oem_register_file(&mut self) {
        self.oem_register_file = ::std::option::Option::None;
    }

    pub fn has_oem_register_file(&self) -> bool {
        self.oem_register_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_oem_register_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.oem_register_file = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oem_register_file(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.oem_register_file.is_none() {
            self.oem_register_file = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.oem_register_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_oem_register_file(&mut self) -> ::std::vec::Vec<u8> {
        self.oem_register_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientRegisterOEMMachine {
    const NAME: &'static str = "CMsgClientRegisterOEMMachine";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.oem_register_file = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.oem_register_file.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.oem_register_file.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRegisterOEMMachine {
        CMsgClientRegisterOEMMachine::new()
    }

    fn clear(&mut self) {
        self.oem_register_file = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRegisterOEMMachine {
        static instance: CMsgClientRegisterOEMMachine = CMsgClientRegisterOEMMachine {
            oem_register_file: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientRegisterOEMMachineResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRegisterOEMMachineResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRegisterOEMMachineResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRegisterOEMMachineResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRegisterOEMMachineResponse {
    fn default() -> &'a CMsgClientRegisterOEMMachineResponse {
        <CMsgClientRegisterOEMMachineResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRegisterOEMMachineResponse {
    pub fn new() -> CMsgClientRegisterOEMMachineResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientRegisterOEMMachineResponse {
    const NAME: &'static str = "CMsgClientRegisterOEMMachineResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRegisterOEMMachineResponse {
        CMsgClientRegisterOEMMachineResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRegisterOEMMachineResponse {
        static instance: CMsgClientRegisterOEMMachineResponse = CMsgClientRegisterOEMMachineResponse {
            eresult: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientPurchaseWithMachineID)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientPurchaseWithMachineID {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientPurchaseWithMachineID.package_id)
    pub package_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientPurchaseWithMachineID.machine_info)
    pub machine_info: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientPurchaseWithMachineID.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientPurchaseWithMachineID {
    fn default() -> &'a CMsgClientPurchaseWithMachineID {
        <CMsgClientPurchaseWithMachineID as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPurchaseWithMachineID {
    pub fn new() -> CMsgClientPurchaseWithMachineID {
        ::std::default::Default::default()
    }

    // optional uint32 package_id = 1;

    pub fn package_id(&self) -> u32 {
        self.package_id.unwrap_or(0)
    }

    pub fn clear_package_id(&mut self) {
        self.package_id = ::std::option::Option::None;
    }

    pub fn has_package_id(&self) -> bool {
        self.package_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_package_id(&mut self, v: u32) {
        self.package_id = ::std::option::Option::Some(v);
    }

    // optional bytes machine_info = 2;

    pub fn machine_info(&self) -> &[u8] {
        match self.machine_info.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_machine_info(&mut self) {
        self.machine_info = ::std::option::Option::None;
    }

    pub fn has_machine_info(&self) -> bool {
        self.machine_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_machine_info(&mut self, v: ::std::vec::Vec<u8>) {
        self.machine_info = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_machine_info(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.machine_info.is_none() {
            self.machine_info = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.machine_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_machine_info(&mut self) -> ::std::vec::Vec<u8> {
        self.machine_info.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientPurchaseWithMachineID {
    const NAME: &'static str = "CMsgClientPurchaseWithMachineID";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.package_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.machine_info = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.package_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.machine_info.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.package_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.machine_info.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientPurchaseWithMachineID {
        CMsgClientPurchaseWithMachineID::new()
    }

    fn clear(&mut self) {
        self.package_id = ::std::option::Option::None;
        self.machine_info = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientPurchaseWithMachineID {
        static instance: CMsgClientPurchaseWithMachineID = CMsgClientPurchaseWithMachineID {
            package_id: ::std::option::Option::None,
            machine_info: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTrading_InitiateTradeRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTrading_InitiateTradeRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgTrading_InitiateTradeRequest.trade_request_id)
    pub trade_request_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTrading_InitiateTradeRequest.other_steamid)
    pub other_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgTrading_InitiateTradeRequest.other_name)
    pub other_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTrading_InitiateTradeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTrading_InitiateTradeRequest {
    fn default() -> &'a CMsgTrading_InitiateTradeRequest {
        <CMsgTrading_InitiateTradeRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTrading_InitiateTradeRequest {
    pub fn new() -> CMsgTrading_InitiateTradeRequest {
        ::std::default::Default::default()
    }

    // optional uint32 trade_request_id = 1;

    pub fn trade_request_id(&self) -> u32 {
        self.trade_request_id.unwrap_or(0)
    }

    pub fn clear_trade_request_id(&mut self) {
        self.trade_request_id = ::std::option::Option::None;
    }

    pub fn has_trade_request_id(&self) -> bool {
        self.trade_request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trade_request_id(&mut self, v: u32) {
        self.trade_request_id = ::std::option::Option::Some(v);
    }

    // optional uint64 other_steamid = 2;

    pub fn other_steamid(&self) -> u64 {
        self.other_steamid.unwrap_or(0)
    }

    pub fn clear_other_steamid(&mut self) {
        self.other_steamid = ::std::option::Option::None;
    }

    pub fn has_other_steamid(&self) -> bool {
        self.other_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other_steamid(&mut self, v: u64) {
        self.other_steamid = ::std::option::Option::Some(v);
    }

    // optional string other_name = 3;

    pub fn other_name(&self) -> &str {
        match self.other_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_other_name(&mut self) {
        self.other_name = ::std::option::Option::None;
    }

    pub fn has_other_name(&self) -> bool {
        self.other_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other_name(&mut self, v: ::std::string::String) {
        self.other_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_other_name(&mut self) -> &mut ::std::string::String {
        if self.other_name.is_none() {
            self.other_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.other_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_other_name(&mut self) -> ::std::string::String {
        self.other_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgTrading_InitiateTradeRequest {
    const NAME: &'static str = "CMsgTrading_InitiateTradeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.trade_request_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.other_steamid = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    self.other_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.trade_request_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.other_steamid {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.other_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.trade_request_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.other_steamid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.other_name.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTrading_InitiateTradeRequest {
        CMsgTrading_InitiateTradeRequest::new()
    }

    fn clear(&mut self) {
        self.trade_request_id = ::std::option::Option::None;
        self.other_steamid = ::std::option::Option::None;
        self.other_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTrading_InitiateTradeRequest {
        static instance: CMsgTrading_InitiateTradeRequest = CMsgTrading_InitiateTradeRequest {
            trade_request_id: ::std::option::Option::None,
            other_steamid: ::std::option::Option::None,
            other_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTrading_InitiateTradeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTrading_InitiateTradeResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgTrading_InitiateTradeResponse.response)
    pub response: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTrading_InitiateTradeResponse.trade_request_id)
    pub trade_request_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTrading_InitiateTradeResponse.other_steamid)
    pub other_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgTrading_InitiateTradeResponse.steamguard_required_days)
    pub steamguard_required_days: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTrading_InitiateTradeResponse.new_device_cooldown_days)
    pub new_device_cooldown_days: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTrading_InitiateTradeResponse.default_password_reset_probation_days)
    pub default_password_reset_probation_days: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTrading_InitiateTradeResponse.password_reset_probation_days)
    pub password_reset_probation_days: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTrading_InitiateTradeResponse.default_email_change_probation_days)
    pub default_email_change_probation_days: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTrading_InitiateTradeResponse.email_change_probation_days)
    pub email_change_probation_days: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTrading_InitiateTradeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTrading_InitiateTradeResponse {
    fn default() -> &'a CMsgTrading_InitiateTradeResponse {
        <CMsgTrading_InitiateTradeResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTrading_InitiateTradeResponse {
    pub fn new() -> CMsgTrading_InitiateTradeResponse {
        ::std::default::Default::default()
    }

    // optional uint32 response = 1;

    pub fn response(&self) -> u32 {
        self.response.unwrap_or(0)
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: u32) {
        self.response = ::std::option::Option::Some(v);
    }

    // optional uint32 trade_request_id = 2;

    pub fn trade_request_id(&self) -> u32 {
        self.trade_request_id.unwrap_or(0)
    }

    pub fn clear_trade_request_id(&mut self) {
        self.trade_request_id = ::std::option::Option::None;
    }

    pub fn has_trade_request_id(&self) -> bool {
        self.trade_request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trade_request_id(&mut self, v: u32) {
        self.trade_request_id = ::std::option::Option::Some(v);
    }

    // optional uint64 other_steamid = 3;

    pub fn other_steamid(&self) -> u64 {
        self.other_steamid.unwrap_or(0)
    }

    pub fn clear_other_steamid(&mut self) {
        self.other_steamid = ::std::option::Option::None;
    }

    pub fn has_other_steamid(&self) -> bool {
        self.other_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other_steamid(&mut self, v: u64) {
        self.other_steamid = ::std::option::Option::Some(v);
    }

    // optional uint32 steamguard_required_days = 4;

    pub fn steamguard_required_days(&self) -> u32 {
        self.steamguard_required_days.unwrap_or(0)
    }

    pub fn clear_steamguard_required_days(&mut self) {
        self.steamguard_required_days = ::std::option::Option::None;
    }

    pub fn has_steamguard_required_days(&self) -> bool {
        self.steamguard_required_days.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamguard_required_days(&mut self, v: u32) {
        self.steamguard_required_days = ::std::option::Option::Some(v);
    }

    // optional uint32 new_device_cooldown_days = 5;

    pub fn new_device_cooldown_days(&self) -> u32 {
        self.new_device_cooldown_days.unwrap_or(0)
    }

    pub fn clear_new_device_cooldown_days(&mut self) {
        self.new_device_cooldown_days = ::std::option::Option::None;
    }

    pub fn has_new_device_cooldown_days(&self) -> bool {
        self.new_device_cooldown_days.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_device_cooldown_days(&mut self, v: u32) {
        self.new_device_cooldown_days = ::std::option::Option::Some(v);
    }

    // optional uint32 default_password_reset_probation_days = 6;

    pub fn default_password_reset_probation_days(&self) -> u32 {
        self.default_password_reset_probation_days.unwrap_or(0)
    }

    pub fn clear_default_password_reset_probation_days(&mut self) {
        self.default_password_reset_probation_days = ::std::option::Option::None;
    }

    pub fn has_default_password_reset_probation_days(&self) -> bool {
        self.default_password_reset_probation_days.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_password_reset_probation_days(&mut self, v: u32) {
        self.default_password_reset_probation_days = ::std::option::Option::Some(v);
    }

    // optional uint32 password_reset_probation_days = 7;

    pub fn password_reset_probation_days(&self) -> u32 {
        self.password_reset_probation_days.unwrap_or(0)
    }

    pub fn clear_password_reset_probation_days(&mut self) {
        self.password_reset_probation_days = ::std::option::Option::None;
    }

    pub fn has_password_reset_probation_days(&self) -> bool {
        self.password_reset_probation_days.is_some()
    }

    // Param is passed by value, moved
    pub fn set_password_reset_probation_days(&mut self, v: u32) {
        self.password_reset_probation_days = ::std::option::Option::Some(v);
    }

    // optional uint32 default_email_change_probation_days = 8;

    pub fn default_email_change_probation_days(&self) -> u32 {
        self.default_email_change_probation_days.unwrap_or(0)
    }

    pub fn clear_default_email_change_probation_days(&mut self) {
        self.default_email_change_probation_days = ::std::option::Option::None;
    }

    pub fn has_default_email_change_probation_days(&self) -> bool {
        self.default_email_change_probation_days.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_email_change_probation_days(&mut self, v: u32) {
        self.default_email_change_probation_days = ::std::option::Option::Some(v);
    }

    // optional uint32 email_change_probation_days = 9;

    pub fn email_change_probation_days(&self) -> u32 {
        self.email_change_probation_days.unwrap_or(0)
    }

    pub fn clear_email_change_probation_days(&mut self) {
        self.email_change_probation_days = ::std::option::Option::None;
    }

    pub fn has_email_change_probation_days(&self) -> bool {
        self.email_change_probation_days.is_some()
    }

    // Param is passed by value, moved
    pub fn set_email_change_probation_days(&mut self, v: u32) {
        self.email_change_probation_days = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgTrading_InitiateTradeResponse {
    const NAME: &'static str = "CMsgTrading_InitiateTradeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.trade_request_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.other_steamid = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.steamguard_required_days = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.new_device_cooldown_days = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.default_password_reset_probation_days = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.password_reset_probation_days = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.default_email_change_probation_days = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.email_change_probation_days = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.trade_request_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.other_steamid {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.steamguard_required_days {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.new_device_cooldown_days {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.default_password_reset_probation_days {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.password_reset_probation_days {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.default_email_change_probation_days {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.email_change_probation_days {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.trade_request_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.other_steamid {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.steamguard_required_days {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.new_device_cooldown_days {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.default_password_reset_probation_days {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.password_reset_probation_days {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.default_email_change_probation_days {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.email_change_probation_days {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTrading_InitiateTradeResponse {
        CMsgTrading_InitiateTradeResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.trade_request_id = ::std::option::Option::None;
        self.other_steamid = ::std::option::Option::None;
        self.steamguard_required_days = ::std::option::Option::None;
        self.new_device_cooldown_days = ::std::option::Option::None;
        self.default_password_reset_probation_days = ::std::option::Option::None;
        self.password_reset_probation_days = ::std::option::Option::None;
        self.default_email_change_probation_days = ::std::option::Option::None;
        self.email_change_probation_days = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTrading_InitiateTradeResponse {
        static instance: CMsgTrading_InitiateTradeResponse = CMsgTrading_InitiateTradeResponse {
            response: ::std::option::Option::None,
            trade_request_id: ::std::option::Option::None,
            other_steamid: ::std::option::Option::None,
            steamguard_required_days: ::std::option::Option::None,
            new_device_cooldown_days: ::std::option::Option::None,
            default_password_reset_probation_days: ::std::option::Option::None,
            password_reset_probation_days: ::std::option::Option::None,
            default_email_change_probation_days: ::std::option::Option::None,
            email_change_probation_days: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTrading_CancelTradeRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTrading_CancelTradeRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgTrading_CancelTradeRequest.other_steamid)
    pub other_steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTrading_CancelTradeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTrading_CancelTradeRequest {
    fn default() -> &'a CMsgTrading_CancelTradeRequest {
        <CMsgTrading_CancelTradeRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTrading_CancelTradeRequest {
    pub fn new() -> CMsgTrading_CancelTradeRequest {
        ::std::default::Default::default()
    }

    // optional uint64 other_steamid = 1;

    pub fn other_steamid(&self) -> u64 {
        self.other_steamid.unwrap_or(0)
    }

    pub fn clear_other_steamid(&mut self) {
        self.other_steamid = ::std::option::Option::None;
    }

    pub fn has_other_steamid(&self) -> bool {
        self.other_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other_steamid(&mut self, v: u64) {
        self.other_steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgTrading_CancelTradeRequest {
    const NAME: &'static str = "CMsgTrading_CancelTradeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.other_steamid = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.other_steamid {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.other_steamid {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTrading_CancelTradeRequest {
        CMsgTrading_CancelTradeRequest::new()
    }

    fn clear(&mut self) {
        self.other_steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTrading_CancelTradeRequest {
        static instance: CMsgTrading_CancelTradeRequest = CMsgTrading_CancelTradeRequest {
            other_steamid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTrading_StartSession)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTrading_StartSession {
    // message fields
    // @@protoc_insertion_point(field:CMsgTrading_StartSession.other_steamid)
    pub other_steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTrading_StartSession.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTrading_StartSession {
    fn default() -> &'a CMsgTrading_StartSession {
        <CMsgTrading_StartSession as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTrading_StartSession {
    pub fn new() -> CMsgTrading_StartSession {
        ::std::default::Default::default()
    }

    // optional uint64 other_steamid = 1;

    pub fn other_steamid(&self) -> u64 {
        self.other_steamid.unwrap_or(0)
    }

    pub fn clear_other_steamid(&mut self) {
        self.other_steamid = ::std::option::Option::None;
    }

    pub fn has_other_steamid(&self) -> bool {
        self.other_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other_steamid(&mut self, v: u64) {
        self.other_steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgTrading_StartSession {
    const NAME: &'static str = "CMsgTrading_StartSession";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.other_steamid = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.other_steamid {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.other_steamid {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTrading_StartSession {
        CMsgTrading_StartSession::new()
    }

    fn clear(&mut self) {
        self.other_steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTrading_StartSession {
        static instance: CMsgTrading_StartSession = CMsgTrading_StartSession {
            other_steamid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientGetCDNAuthToken)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGetCDNAuthToken {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGetCDNAuthToken.depot_id)
    pub depot_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientGetCDNAuthToken.host_name)
    pub host_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientGetCDNAuthToken.app_id)
    pub app_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetCDNAuthToken.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetCDNAuthToken {
    fn default() -> &'a CMsgClientGetCDNAuthToken {
        <CMsgClientGetCDNAuthToken as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetCDNAuthToken {
    pub fn new() -> CMsgClientGetCDNAuthToken {
        ::std::default::Default::default()
    }

    // optional uint32 depot_id = 1;

    pub fn depot_id(&self) -> u32 {
        self.depot_id.unwrap_or(0)
    }

    pub fn clear_depot_id(&mut self) {
        self.depot_id = ::std::option::Option::None;
    }

    pub fn has_depot_id(&self) -> bool {
        self.depot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_depot_id(&mut self, v: u32) {
        self.depot_id = ::std::option::Option::Some(v);
    }

    // optional string host_name = 2;

    pub fn host_name(&self) -> &str {
        match self.host_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_host_name(&mut self) {
        self.host_name = ::std::option::Option::None;
    }

    pub fn has_host_name(&self) -> bool {
        self.host_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host_name(&mut self, v: ::std::string::String) {
        self.host_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host_name(&mut self) -> &mut ::std::string::String {
        if self.host_name.is_none() {
            self.host_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.host_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_host_name(&mut self) -> ::std::string::String {
        self.host_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 app_id = 3;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientGetCDNAuthToken {
    const NAME: &'static str = "CMsgClientGetCDNAuthToken";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.depot_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.host_name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.depot_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.host_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.depot_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.host_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetCDNAuthToken {
        CMsgClientGetCDNAuthToken::new()
    }

    fn clear(&mut self) {
        self.depot_id = ::std::option::Option::None;
        self.host_name = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetCDNAuthToken {
        static instance: CMsgClientGetCDNAuthToken = CMsgClientGetCDNAuthToken {
            depot_id: ::std::option::Option::None,
            host_name: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientGetDepotDecryptionKey)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGetDepotDecryptionKey {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGetDepotDecryptionKey.depot_id)
    pub depot_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientGetDepotDecryptionKey.app_id)
    pub app_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetDepotDecryptionKey.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetDepotDecryptionKey {
    fn default() -> &'a CMsgClientGetDepotDecryptionKey {
        <CMsgClientGetDepotDecryptionKey as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetDepotDecryptionKey {
    pub fn new() -> CMsgClientGetDepotDecryptionKey {
        ::std::default::Default::default()
    }

    // optional uint32 depot_id = 1;

    pub fn depot_id(&self) -> u32 {
        self.depot_id.unwrap_or(0)
    }

    pub fn clear_depot_id(&mut self) {
        self.depot_id = ::std::option::Option::None;
    }

    pub fn has_depot_id(&self) -> bool {
        self.depot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_depot_id(&mut self, v: u32) {
        self.depot_id = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientGetDepotDecryptionKey {
    const NAME: &'static str = "CMsgClientGetDepotDecryptionKey";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.depot_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.depot_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.depot_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetDepotDecryptionKey {
        CMsgClientGetDepotDecryptionKey::new()
    }

    fn clear(&mut self) {
        self.depot_id = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetDepotDecryptionKey {
        static instance: CMsgClientGetDepotDecryptionKey = CMsgClientGetDepotDecryptionKey {
            depot_id: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientGetDepotDecryptionKeyResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGetDepotDecryptionKeyResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGetDepotDecryptionKeyResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientGetDepotDecryptionKeyResponse.depot_id)
    pub depot_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientGetDepotDecryptionKeyResponse.depot_encryption_key)
    pub depot_encryption_key: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetDepotDecryptionKeyResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetDepotDecryptionKeyResponse {
    fn default() -> &'a CMsgClientGetDepotDecryptionKeyResponse {
        <CMsgClientGetDepotDecryptionKeyResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetDepotDecryptionKeyResponse {
    pub fn new() -> CMsgClientGetDepotDecryptionKeyResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 depot_id = 2;

    pub fn depot_id(&self) -> u32 {
        self.depot_id.unwrap_or(0)
    }

    pub fn clear_depot_id(&mut self) {
        self.depot_id = ::std::option::Option::None;
    }

    pub fn has_depot_id(&self) -> bool {
        self.depot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_depot_id(&mut self, v: u32) {
        self.depot_id = ::std::option::Option::Some(v);
    }

    // optional bytes depot_encryption_key = 3;

    pub fn depot_encryption_key(&self) -> &[u8] {
        match self.depot_encryption_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_depot_encryption_key(&mut self) {
        self.depot_encryption_key = ::std::option::Option::None;
    }

    pub fn has_depot_encryption_key(&self) -> bool {
        self.depot_encryption_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_depot_encryption_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.depot_encryption_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_depot_encryption_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.depot_encryption_key.is_none() {
            self.depot_encryption_key = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.depot_encryption_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_depot_encryption_key(&mut self) -> ::std::vec::Vec<u8> {
        self.depot_encryption_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientGetDepotDecryptionKeyResponse {
    const NAME: &'static str = "CMsgClientGetDepotDecryptionKeyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.depot_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.depot_encryption_key = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.depot_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.depot_encryption_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.depot_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.depot_encryption_key.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetDepotDecryptionKeyResponse {
        CMsgClientGetDepotDecryptionKeyResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.depot_id = ::std::option::Option::None;
        self.depot_encryption_key = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetDepotDecryptionKeyResponse {
        static instance: CMsgClientGetDepotDecryptionKeyResponse = CMsgClientGetDepotDecryptionKeyResponse {
            eresult: ::std::option::Option::None,
            depot_id: ::std::option::Option::None,
            depot_encryption_key: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientCheckAppBetaPassword)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientCheckAppBetaPassword {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientCheckAppBetaPassword.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientCheckAppBetaPassword.betapassword)
    pub betapassword: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientCheckAppBetaPassword.language)
    pub language: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientCheckAppBetaPassword.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientCheckAppBetaPassword {
    fn default() -> &'a CMsgClientCheckAppBetaPassword {
        <CMsgClientCheckAppBetaPassword as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientCheckAppBetaPassword {
    pub fn new() -> CMsgClientCheckAppBetaPassword {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional string betapassword = 2;

    pub fn betapassword(&self) -> &str {
        match self.betapassword.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_betapassword(&mut self) {
        self.betapassword = ::std::option::Option::None;
    }

    pub fn has_betapassword(&self) -> bool {
        self.betapassword.is_some()
    }

    // Param is passed by value, moved
    pub fn set_betapassword(&mut self, v: ::std::string::String) {
        self.betapassword = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_betapassword(&mut self) -> &mut ::std::string::String {
        if self.betapassword.is_none() {
            self.betapassword = ::std::option::Option::Some(::std::string::String::new());
        }
        self.betapassword.as_mut().unwrap()
    }

    // Take field
    pub fn take_betapassword(&mut self) -> ::std::string::String {
        self.betapassword.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 language = 3;

    pub fn language(&self) -> i32 {
        self.language.unwrap_or(0)
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: i32) {
        self.language = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientCheckAppBetaPassword {
    const NAME: &'static str = "CMsgClientCheckAppBetaPassword";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.betapassword = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.language = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.betapassword.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.betapassword.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.language {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientCheckAppBetaPassword {
        CMsgClientCheckAppBetaPassword::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.betapassword = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientCheckAppBetaPassword {
        static instance: CMsgClientCheckAppBetaPassword = CMsgClientCheckAppBetaPassword {
            app_id: ::std::option::Option::None,
            betapassword: ::std::option::Option::None,
            language: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientCheckAppBetaPasswordResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientCheckAppBetaPasswordResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientCheckAppBetaPasswordResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientCheckAppBetaPasswordResponse.betapasswords)
    pub betapasswords: ::std::vec::Vec<cmsg_client_check_app_beta_password_response::BetaPassword>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientCheckAppBetaPasswordResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientCheckAppBetaPasswordResponse {
    fn default() -> &'a CMsgClientCheckAppBetaPasswordResponse {
        <CMsgClientCheckAppBetaPasswordResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientCheckAppBetaPasswordResponse {
    pub fn new() -> CMsgClientCheckAppBetaPasswordResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientCheckAppBetaPasswordResponse {
    const NAME: &'static str = "CMsgClientCheckAppBetaPasswordResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.betapasswords.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        for value in &self.betapasswords {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        for v in &self.betapasswords {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientCheckAppBetaPasswordResponse {
        CMsgClientCheckAppBetaPasswordResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.betapasswords.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientCheckAppBetaPasswordResponse {
        static instance: CMsgClientCheckAppBetaPasswordResponse = CMsgClientCheckAppBetaPasswordResponse {
            eresult: ::std::option::Option::None,
            betapasswords: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientCheckAppBetaPasswordResponse`
pub mod cmsg_client_check_app_beta_password_response {
    // @@protoc_insertion_point(message:CMsgClientCheckAppBetaPasswordResponse.BetaPassword)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct BetaPassword {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientCheckAppBetaPasswordResponse.BetaPassword.betaname)
        pub betaname: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientCheckAppBetaPasswordResponse.BetaPassword.betapassword)
        pub betapassword: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientCheckAppBetaPasswordResponse.BetaPassword.betadescription)
        pub betadescription: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientCheckAppBetaPasswordResponse.BetaPassword.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BetaPassword {
        fn default() -> &'a BetaPassword {
            <BetaPassword as ::protobuf::Message>::default_instance()
        }
    }

    impl BetaPassword {
        pub fn new() -> BetaPassword {
            ::std::default::Default::default()
        }

        // optional string betaname = 1;

        pub fn betaname(&self) -> &str {
            match self.betaname.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_betaname(&mut self) {
            self.betaname = ::std::option::Option::None;
        }

        pub fn has_betaname(&self) -> bool {
            self.betaname.is_some()
        }

        // Param is passed by value, moved
        pub fn set_betaname(&mut self, v: ::std::string::String) {
            self.betaname = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_betaname(&mut self) -> &mut ::std::string::String {
            if self.betaname.is_none() {
                self.betaname = ::std::option::Option::Some(::std::string::String::new());
            }
            self.betaname.as_mut().unwrap()
        }

        // Take field
        pub fn take_betaname(&mut self) -> ::std::string::String {
            self.betaname.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string betapassword = 2;

        pub fn betapassword(&self) -> &str {
            match self.betapassword.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_betapassword(&mut self) {
            self.betapassword = ::std::option::Option::None;
        }

        pub fn has_betapassword(&self) -> bool {
            self.betapassword.is_some()
        }

        // Param is passed by value, moved
        pub fn set_betapassword(&mut self, v: ::std::string::String) {
            self.betapassword = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_betapassword(&mut self) -> &mut ::std::string::String {
            if self.betapassword.is_none() {
                self.betapassword = ::std::option::Option::Some(::std::string::String::new());
            }
            self.betapassword.as_mut().unwrap()
        }

        // Take field
        pub fn take_betapassword(&mut self) -> ::std::string::String {
            self.betapassword.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string betadescription = 3;

        pub fn betadescription(&self) -> &str {
            match self.betadescription.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_betadescription(&mut self) {
            self.betadescription = ::std::option::Option::None;
        }

        pub fn has_betadescription(&self) -> bool {
            self.betadescription.is_some()
        }

        // Param is passed by value, moved
        pub fn set_betadescription(&mut self, v: ::std::string::String) {
            self.betadescription = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_betadescription(&mut self) -> &mut ::std::string::String {
            if self.betadescription.is_none() {
                self.betadescription = ::std::option::Option::Some(::std::string::String::new());
            }
            self.betadescription.as_mut().unwrap()
        }

        // Take field
        pub fn take_betadescription(&mut self) -> ::std::string::String {
            self.betadescription.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::protobuf::Message for BetaPassword {
        const NAME: &'static str = "BetaPassword";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.betaname = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.betapassword = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.betadescription = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.betaname.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.betapassword.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.betadescription.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.betaname.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.betapassword.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.betadescription.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BetaPassword {
            BetaPassword::new()
        }

        fn clear(&mut self) {
            self.betaname = ::std::option::Option::None;
            self.betapassword = ::std::option::Option::None;
            self.betadescription = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BetaPassword {
            static instance: BetaPassword = BetaPassword {
                betaname: ::std::option::Option::None,
                betapassword: ::std::option::Option::None,
                betadescription: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientGetCDNAuthTokenResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGetCDNAuthTokenResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGetCDNAuthTokenResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientGetCDNAuthTokenResponse.token)
    pub token: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientGetCDNAuthTokenResponse.expiration_time)
    pub expiration_time: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetCDNAuthTokenResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetCDNAuthTokenResponse {
    fn default() -> &'a CMsgClientGetCDNAuthTokenResponse {
        <CMsgClientGetCDNAuthTokenResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetCDNAuthTokenResponse {
    pub fn new() -> CMsgClientGetCDNAuthTokenResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional string token = 2;

    pub fn token(&self) -> &str {
        match self.token.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::string::String) {
        self.token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::string::String {
        if self.token.is_none() {
            self.token = ::std::option::Option::Some(::std::string::String::new());
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::string::String {
        self.token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 expiration_time = 3;

    pub fn expiration_time(&self) -> u32 {
        self.expiration_time.unwrap_or(0)
    }

    pub fn clear_expiration_time(&mut self) {
        self.expiration_time = ::std::option::Option::None;
    }

    pub fn has_expiration_time(&self) -> bool {
        self.expiration_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration_time(&mut self, v: u32) {
        self.expiration_time = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientGetCDNAuthTokenResponse {
    const NAME: &'static str = "CMsgClientGetCDNAuthTokenResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.token = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.expiration_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.token.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.expiration_time {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.token.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.expiration_time {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetCDNAuthTokenResponse {
        CMsgClientGetCDNAuthTokenResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.token = ::std::option::Option::None;
        self.expiration_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetCDNAuthTokenResponse {
        static instance: CMsgClientGetCDNAuthTokenResponse = CMsgClientGetCDNAuthTokenResponse {
            eresult: ::std::option::Option::None,
            token: ::std::option::Option::None,
            expiration_time: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDownloadRateStatistics)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDownloadRateStatistics {
    // message fields
    // @@protoc_insertion_point(field:CMsgDownloadRateStatistics.cell_id)
    pub cell_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDownloadRateStatistics.stats)
    pub stats: ::std::vec::Vec<cmsg_download_rate_statistics::StatsInfo>,
    // @@protoc_insertion_point(field:CMsgDownloadRateStatistics.throttling_kbps)
    pub throttling_kbps: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDownloadRateStatistics.steam_realm)
    pub steam_realm: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDownloadRateStatistics.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDownloadRateStatistics {
    fn default() -> &'a CMsgDownloadRateStatistics {
        <CMsgDownloadRateStatistics as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDownloadRateStatistics {
    pub fn new() -> CMsgDownloadRateStatistics {
        ::std::default::Default::default()
    }

    // optional uint32 cell_id = 1;

    pub fn cell_id(&self) -> u32 {
        self.cell_id.unwrap_or(0)
    }

    pub fn clear_cell_id(&mut self) {
        self.cell_id = ::std::option::Option::None;
    }

    pub fn has_cell_id(&self) -> bool {
        self.cell_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cell_id(&mut self, v: u32) {
        self.cell_id = ::std::option::Option::Some(v);
    }

    // optional uint32 throttling_kbps = 3;

    pub fn throttling_kbps(&self) -> u32 {
        self.throttling_kbps.unwrap_or(0)
    }

    pub fn clear_throttling_kbps(&mut self) {
        self.throttling_kbps = ::std::option::Option::None;
    }

    pub fn has_throttling_kbps(&self) -> bool {
        self.throttling_kbps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_throttling_kbps(&mut self, v: u32) {
        self.throttling_kbps = ::std::option::Option::Some(v);
    }

    // optional uint32 steam_realm = 4;

    pub fn steam_realm(&self) -> u32 {
        self.steam_realm.unwrap_or(0)
    }

    pub fn clear_steam_realm(&mut self) {
        self.steam_realm = ::std::option::Option::None;
    }

    pub fn has_steam_realm(&self) -> bool {
        self.steam_realm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_realm(&mut self, v: u32) {
        self.steam_realm = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgDownloadRateStatistics {
    const NAME: &'static str = "CMsgDownloadRateStatistics";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.cell_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.stats.push(is.read_message()?);
                },
                24 => {
                    self.throttling_kbps = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.steam_realm = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cell_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.throttling_kbps {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.steam_realm {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cell_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.stats {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.throttling_kbps {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.steam_realm {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDownloadRateStatistics {
        CMsgDownloadRateStatistics::new()
    }

    fn clear(&mut self) {
        self.cell_id = ::std::option::Option::None;
        self.stats.clear();
        self.throttling_kbps = ::std::option::Option::None;
        self.steam_realm = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDownloadRateStatistics {
        static instance: CMsgDownloadRateStatistics = CMsgDownloadRateStatistics {
            cell_id: ::std::option::Option::None,
            stats: ::std::vec::Vec::new(),
            throttling_kbps: ::std::option::Option::None,
            steam_realm: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgDownloadRateStatistics`
pub mod cmsg_download_rate_statistics {
    // @@protoc_insertion_point(message:CMsgDownloadRateStatistics.StatsInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct StatsInfo {
        // message fields
        // @@protoc_insertion_point(field:CMsgDownloadRateStatistics.StatsInfo.source_type)
        pub source_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDownloadRateStatistics.StatsInfo.source_id)
        pub source_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDownloadRateStatistics.StatsInfo.seconds)
        pub seconds: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDownloadRateStatistics.StatsInfo.bytes)
        pub bytes: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgDownloadRateStatistics.StatsInfo.host_name)
        pub host_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDownloadRateStatistics.StatsInfo.microseconds)
        pub microseconds: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgDownloadRateStatistics.StatsInfo.used_ipv6)
        pub used_ipv6: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgDownloadRateStatistics.StatsInfo.proxied)
        pub proxied: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDownloadRateStatistics.StatsInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a StatsInfo {
        fn default() -> &'a StatsInfo {
            <StatsInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl StatsInfo {
        pub fn new() -> StatsInfo {
            ::std::default::Default::default()
        }

        // optional uint32 source_type = 1;

        pub fn source_type(&self) -> u32 {
            self.source_type.unwrap_or(0)
        }

        pub fn clear_source_type(&mut self) {
            self.source_type = ::std::option::Option::None;
        }

        pub fn has_source_type(&self) -> bool {
            self.source_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_source_type(&mut self, v: u32) {
            self.source_type = ::std::option::Option::Some(v);
        }

        // optional uint32 source_id = 2;

        pub fn source_id(&self) -> u32 {
            self.source_id.unwrap_or(0)
        }

        pub fn clear_source_id(&mut self) {
            self.source_id = ::std::option::Option::None;
        }

        pub fn has_source_id(&self) -> bool {
            self.source_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_source_id(&mut self, v: u32) {
            self.source_id = ::std::option::Option::Some(v);
        }

        // optional uint32 seconds = 3;

        pub fn seconds(&self) -> u32 {
            self.seconds.unwrap_or(0)
        }

        pub fn clear_seconds(&mut self) {
            self.seconds = ::std::option::Option::None;
        }

        pub fn has_seconds(&self) -> bool {
            self.seconds.is_some()
        }

        // Param is passed by value, moved
        pub fn set_seconds(&mut self, v: u32) {
            self.seconds = ::std::option::Option::Some(v);
        }

        // optional uint64 bytes = 4;

        pub fn bytes(&self) -> u64 {
            self.bytes.unwrap_or(0)
        }

        pub fn clear_bytes(&mut self) {
            self.bytes = ::std::option::Option::None;
        }

        pub fn has_bytes(&self) -> bool {
            self.bytes.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bytes(&mut self, v: u64) {
            self.bytes = ::std::option::Option::Some(v);
        }

        // optional string host_name = 5;

        pub fn host_name(&self) -> &str {
            match self.host_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_host_name(&mut self) {
            self.host_name = ::std::option::Option::None;
        }

        pub fn has_host_name(&self) -> bool {
            self.host_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_host_name(&mut self, v: ::std::string::String) {
            self.host_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_host_name(&mut self) -> &mut ::std::string::String {
            if self.host_name.is_none() {
                self.host_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.host_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_host_name(&mut self) -> ::std::string::String {
            self.host_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint64 microseconds = 6;

        pub fn microseconds(&self) -> u64 {
            self.microseconds.unwrap_or(0)
        }

        pub fn clear_microseconds(&mut self) {
            self.microseconds = ::std::option::Option::None;
        }

        pub fn has_microseconds(&self) -> bool {
            self.microseconds.is_some()
        }

        // Param is passed by value, moved
        pub fn set_microseconds(&mut self, v: u64) {
            self.microseconds = ::std::option::Option::Some(v);
        }

        // optional bool used_ipv6 = 7;

        pub fn used_ipv6(&self) -> bool {
            self.used_ipv6.unwrap_or(false)
        }

        pub fn clear_used_ipv6(&mut self) {
            self.used_ipv6 = ::std::option::Option::None;
        }

        pub fn has_used_ipv6(&self) -> bool {
            self.used_ipv6.is_some()
        }

        // Param is passed by value, moved
        pub fn set_used_ipv6(&mut self, v: bool) {
            self.used_ipv6 = ::std::option::Option::Some(v);
        }

        // optional bool proxied = 8;

        pub fn proxied(&self) -> bool {
            self.proxied.unwrap_or(false)
        }

        pub fn clear_proxied(&mut self) {
            self.proxied = ::std::option::Option::None;
        }

        pub fn has_proxied(&self) -> bool {
            self.proxied.is_some()
        }

        // Param is passed by value, moved
        pub fn set_proxied(&mut self, v: bool) {
            self.proxied = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for StatsInfo {
        const NAME: &'static str = "StatsInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.source_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.source_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.seconds = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.bytes = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    42 => {
                        self.host_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    48 => {
                        self.microseconds = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    56 => {
                        self.used_ipv6 = ::std::option::Option::Some(is.read_bool()?);
                    },
                    64 => {
                        self.proxied = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.source_type {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.source_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.seconds {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.bytes {
                my_size += ::protobuf::rt::uint64_size(4, v);
            }
            if let Some(v) = self.host_name.as_ref() {
                my_size += ::protobuf::rt::string_size(5, &v);
            }
            if let Some(v) = self.microseconds {
                my_size += ::protobuf::rt::uint64_size(6, v);
            }
            if let Some(v) = self.used_ipv6 {
                my_size += 1 + 1;
            }
            if let Some(v) = self.proxied {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.source_type {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.source_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.seconds {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.bytes {
                os.write_uint64(4, v)?;
            }
            if let Some(v) = self.host_name.as_ref() {
                os.write_string(5, v)?;
            }
            if let Some(v) = self.microseconds {
                os.write_uint64(6, v)?;
            }
            if let Some(v) = self.used_ipv6 {
                os.write_bool(7, v)?;
            }
            if let Some(v) = self.proxied {
                os.write_bool(8, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> StatsInfo {
            StatsInfo::new()
        }

        fn clear(&mut self) {
            self.source_type = ::std::option::Option::None;
            self.source_id = ::std::option::Option::None;
            self.seconds = ::std::option::Option::None;
            self.bytes = ::std::option::Option::None;
            self.host_name = ::std::option::Option::None;
            self.microseconds = ::std::option::Option::None;
            self.used_ipv6 = ::std::option::Option::None;
            self.proxied = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static StatsInfo {
            static instance: StatsInfo = StatsInfo {
                source_type: ::std::option::Option::None,
                source_id: ::std::option::Option::None,
                seconds: ::std::option::Option::None,
                bytes: ::std::option::Option::None,
                host_name: ::std::option::Option::None,
                microseconds: ::std::option::Option::None,
                used_ipv6: ::std::option::Option::None,
                proxied: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientRequestAccountData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRequestAccountData {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRequestAccountData.account_or_email)
    pub account_or_email: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientRequestAccountData.action)
    pub action: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRequestAccountData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestAccountData {
    fn default() -> &'a CMsgClientRequestAccountData {
        <CMsgClientRequestAccountData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestAccountData {
    pub fn new() -> CMsgClientRequestAccountData {
        ::std::default::Default::default()
    }

    // optional string account_or_email = 1;

    pub fn account_or_email(&self) -> &str {
        match self.account_or_email.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_account_or_email(&mut self) {
        self.account_or_email = ::std::option::Option::None;
    }

    pub fn has_account_or_email(&self) -> bool {
        self.account_or_email.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_or_email(&mut self, v: ::std::string::String) {
        self.account_or_email = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_or_email(&mut self) -> &mut ::std::string::String {
        if self.account_or_email.is_none() {
            self.account_or_email = ::std::option::Option::Some(::std::string::String::new());
        }
        self.account_or_email.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_or_email(&mut self) -> ::std::string::String {
        self.account_or_email.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 action = 2;

    pub fn action(&self) -> u32 {
        self.action.unwrap_or(0)
    }

    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: u32) {
        self.action = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientRequestAccountData {
    const NAME: &'static str = "CMsgClientRequestAccountData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.account_or_email = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.action = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_or_email.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.action {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_or_email.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.action {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRequestAccountData {
        CMsgClientRequestAccountData::new()
    }

    fn clear(&mut self) {
        self.account_or_email = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRequestAccountData {
        static instance: CMsgClientRequestAccountData = CMsgClientRequestAccountData {
            account_or_email: ::std::option::Option::None,
            action: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientRequestAccountDataResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRequestAccountDataResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRequestAccountDataResponse.action)
    pub action: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientRequestAccountDataResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientRequestAccountDataResponse.account_name)
    pub account_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientRequestAccountDataResponse.ct_matches)
    pub ct_matches: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientRequestAccountDataResponse.account_name_suggestion1)
    pub account_name_suggestion1: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientRequestAccountDataResponse.account_name_suggestion2)
    pub account_name_suggestion2: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientRequestAccountDataResponse.account_name_suggestion3)
    pub account_name_suggestion3: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRequestAccountDataResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestAccountDataResponse {
    fn default() -> &'a CMsgClientRequestAccountDataResponse {
        <CMsgClientRequestAccountDataResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestAccountDataResponse {
    pub fn new() -> CMsgClientRequestAccountDataResponse {
        ::std::default::Default::default()
    }

    // optional uint32 action = 1;

    pub fn action(&self) -> u32 {
        self.action.unwrap_or(0)
    }

    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: u32) {
        self.action = ::std::option::Option::Some(v);
    }

    // optional uint32 eresult = 2;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional string account_name = 3;

    pub fn account_name(&self) -> &str {
        match self.account_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_account_name(&mut self) {
        self.account_name = ::std::option::Option::None;
    }

    pub fn has_account_name(&self) -> bool {
        self.account_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_name(&mut self, v: ::std::string::String) {
        self.account_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_name(&mut self) -> &mut ::std::string::String {
        if self.account_name.is_none() {
            self.account_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.account_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_name(&mut self) -> ::std::string::String {
        self.account_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 ct_matches = 4;

    pub fn ct_matches(&self) -> u32 {
        self.ct_matches.unwrap_or(0)
    }

    pub fn clear_ct_matches(&mut self) {
        self.ct_matches = ::std::option::Option::None;
    }

    pub fn has_ct_matches(&self) -> bool {
        self.ct_matches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ct_matches(&mut self, v: u32) {
        self.ct_matches = ::std::option::Option::Some(v);
    }

    // optional string account_name_suggestion1 = 5;

    pub fn account_name_suggestion1(&self) -> &str {
        match self.account_name_suggestion1.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_account_name_suggestion1(&mut self) {
        self.account_name_suggestion1 = ::std::option::Option::None;
    }

    pub fn has_account_name_suggestion1(&self) -> bool {
        self.account_name_suggestion1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_name_suggestion1(&mut self, v: ::std::string::String) {
        self.account_name_suggestion1 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_name_suggestion1(&mut self) -> &mut ::std::string::String {
        if self.account_name_suggestion1.is_none() {
            self.account_name_suggestion1 = ::std::option::Option::Some(::std::string::String::new());
        }
        self.account_name_suggestion1.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_name_suggestion1(&mut self) -> ::std::string::String {
        self.account_name_suggestion1.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string account_name_suggestion2 = 6;

    pub fn account_name_suggestion2(&self) -> &str {
        match self.account_name_suggestion2.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_account_name_suggestion2(&mut self) {
        self.account_name_suggestion2 = ::std::option::Option::None;
    }

    pub fn has_account_name_suggestion2(&self) -> bool {
        self.account_name_suggestion2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_name_suggestion2(&mut self, v: ::std::string::String) {
        self.account_name_suggestion2 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_name_suggestion2(&mut self) -> &mut ::std::string::String {
        if self.account_name_suggestion2.is_none() {
            self.account_name_suggestion2 = ::std::option::Option::Some(::std::string::String::new());
        }
        self.account_name_suggestion2.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_name_suggestion2(&mut self) -> ::std::string::String {
        self.account_name_suggestion2.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string account_name_suggestion3 = 7;

    pub fn account_name_suggestion3(&self) -> &str {
        match self.account_name_suggestion3.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_account_name_suggestion3(&mut self) {
        self.account_name_suggestion3 = ::std::option::Option::None;
    }

    pub fn has_account_name_suggestion3(&self) -> bool {
        self.account_name_suggestion3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_name_suggestion3(&mut self, v: ::std::string::String) {
        self.account_name_suggestion3 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_name_suggestion3(&mut self) -> &mut ::std::string::String {
        if self.account_name_suggestion3.is_none() {
            self.account_name_suggestion3 = ::std::option::Option::Some(::std::string::String::new());
        }
        self.account_name_suggestion3.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_name_suggestion3(&mut self) -> ::std::string::String {
        self.account_name_suggestion3.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientRequestAccountDataResponse {
    const NAME: &'static str = "CMsgClientRequestAccountDataResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.action = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.account_name = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.ct_matches = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.account_name_suggestion1 = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.account_name_suggestion2 = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.account_name_suggestion3 = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.action {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.account_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.ct_matches {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.account_name_suggestion1.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.account_name_suggestion2.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.account_name_suggestion3.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.action {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.account_name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.ct_matches {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.account_name_suggestion1.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.account_name_suggestion2.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.account_name_suggestion3.as_ref() {
            os.write_string(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRequestAccountDataResponse {
        CMsgClientRequestAccountDataResponse::new()
    }

    fn clear(&mut self) {
        self.action = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.account_name = ::std::option::Option::None;
        self.ct_matches = ::std::option::Option::None;
        self.account_name_suggestion1 = ::std::option::Option::None;
        self.account_name_suggestion2 = ::std::option::Option::None;
        self.account_name_suggestion3 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRequestAccountDataResponse {
        static instance: CMsgClientRequestAccountDataResponse = CMsgClientRequestAccountDataResponse {
            action: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            account_name: ::std::option::Option::None,
            ct_matches: ::std::option::Option::None,
            account_name_suggestion1: ::std::option::Option::None,
            account_name_suggestion2: ::std::option::Option::None,
            account_name_suggestion3: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientUGSGetGlobalStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUGSGetGlobalStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUGSGetGlobalStats.gameid)
    pub gameid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUGSGetGlobalStats.history_days_requested)
    pub history_days_requested: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUGSGetGlobalStats.time_last_requested)
    pub time_last_requested: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUGSGetGlobalStats.first_day_cached)
    pub first_day_cached: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUGSGetGlobalStats.days_cached)
    pub days_cached: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUGSGetGlobalStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUGSGetGlobalStats {
    fn default() -> &'a CMsgClientUGSGetGlobalStats {
        <CMsgClientUGSGetGlobalStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUGSGetGlobalStats {
    pub fn new() -> CMsgClientUGSGetGlobalStats {
        ::std::default::Default::default()
    }

    // optional uint64 gameid = 1;

    pub fn gameid(&self) -> u64 {
        self.gameid.unwrap_or(0)
    }

    pub fn clear_gameid(&mut self) {
        self.gameid = ::std::option::Option::None;
    }

    pub fn has_gameid(&self) -> bool {
        self.gameid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameid(&mut self, v: u64) {
        self.gameid = ::std::option::Option::Some(v);
    }

    // optional uint32 history_days_requested = 2;

    pub fn history_days_requested(&self) -> u32 {
        self.history_days_requested.unwrap_or(0)
    }

    pub fn clear_history_days_requested(&mut self) {
        self.history_days_requested = ::std::option::Option::None;
    }

    pub fn has_history_days_requested(&self) -> bool {
        self.history_days_requested.is_some()
    }

    // Param is passed by value, moved
    pub fn set_history_days_requested(&mut self, v: u32) {
        self.history_days_requested = ::std::option::Option::Some(v);
    }

    // optional fixed32 time_last_requested = 3;

    pub fn time_last_requested(&self) -> u32 {
        self.time_last_requested.unwrap_or(0)
    }

    pub fn clear_time_last_requested(&mut self) {
        self.time_last_requested = ::std::option::Option::None;
    }

    pub fn has_time_last_requested(&self) -> bool {
        self.time_last_requested.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_last_requested(&mut self, v: u32) {
        self.time_last_requested = ::std::option::Option::Some(v);
    }

    // optional uint32 first_day_cached = 4;

    pub fn first_day_cached(&self) -> u32 {
        self.first_day_cached.unwrap_or(0)
    }

    pub fn clear_first_day_cached(&mut self) {
        self.first_day_cached = ::std::option::Option::None;
    }

    pub fn has_first_day_cached(&self) -> bool {
        self.first_day_cached.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_day_cached(&mut self, v: u32) {
        self.first_day_cached = ::std::option::Option::Some(v);
    }

    // optional uint32 days_cached = 5;

    pub fn days_cached(&self) -> u32 {
        self.days_cached.unwrap_or(0)
    }

    pub fn clear_days_cached(&mut self) {
        self.days_cached = ::std::option::Option::None;
    }

    pub fn has_days_cached(&self) -> bool {
        self.days_cached.is_some()
    }

    // Param is passed by value, moved
    pub fn set_days_cached(&mut self, v: u32) {
        self.days_cached = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUGSGetGlobalStats {
    const NAME: &'static str = "CMsgClientUGSGetGlobalStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.gameid = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.history_days_requested = ::std::option::Option::Some(is.read_uint32()?);
                },
                29 => {
                    self.time_last_requested = ::std::option::Option::Some(is.read_fixed32()?);
                },
                32 => {
                    self.first_day_cached = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.days_cached = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gameid {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.history_days_requested {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.time_last_requested {
            my_size += 1 + 4;
        }
        if let Some(v) = self.first_day_cached {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.days_cached {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.gameid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.history_days_requested {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.time_last_requested {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.first_day_cached {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.days_cached {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUGSGetGlobalStats {
        CMsgClientUGSGetGlobalStats::new()
    }

    fn clear(&mut self) {
        self.gameid = ::std::option::Option::None;
        self.history_days_requested = ::std::option::Option::None;
        self.time_last_requested = ::std::option::Option::None;
        self.first_day_cached = ::std::option::Option::None;
        self.days_cached = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUGSGetGlobalStats {
        static instance: CMsgClientUGSGetGlobalStats = CMsgClientUGSGetGlobalStats {
            gameid: ::std::option::Option::None,
            history_days_requested: ::std::option::Option::None,
            time_last_requested: ::std::option::Option::None,
            first_day_cached: ::std::option::Option::None,
            days_cached: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientUGSGetGlobalStatsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUGSGetGlobalStatsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUGSGetGlobalStatsResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUGSGetGlobalStatsResponse.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUGSGetGlobalStatsResponse.day_current)
    pub day_current: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUGSGetGlobalStatsResponse.days)
    pub days: ::std::vec::Vec<cmsg_client_ugsget_global_stats_response::Day>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUGSGetGlobalStatsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUGSGetGlobalStatsResponse {
    fn default() -> &'a CMsgClientUGSGetGlobalStatsResponse {
        <CMsgClientUGSGetGlobalStatsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUGSGetGlobalStatsResponse {
    pub fn new() -> CMsgClientUGSGetGlobalStatsResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional fixed32 timestamp = 2;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional int32 day_current = 3;

    pub fn day_current(&self) -> i32 {
        self.day_current.unwrap_or(0)
    }

    pub fn clear_day_current(&mut self) {
        self.day_current = ::std::option::Option::None;
    }

    pub fn has_day_current(&self) -> bool {
        self.day_current.is_some()
    }

    // Param is passed by value, moved
    pub fn set_day_current(&mut self, v: i32) {
        self.day_current = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUGSGetGlobalStatsResponse {
    const NAME: &'static str = "CMsgClientUGSGetGlobalStatsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                21 => {
                    self.timestamp = ::std::option::Option::Some(is.read_fixed32()?);
                },
                24 => {
                    self.day_current = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.days.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.timestamp {
            my_size += 1 + 4;
        }
        if let Some(v) = self.day_current {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        for value in &self.days {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.day_current {
            os.write_int32(3, v)?;
        }
        for v in &self.days {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUGSGetGlobalStatsResponse {
        CMsgClientUGSGetGlobalStatsResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.day_current = ::std::option::Option::None;
        self.days.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUGSGetGlobalStatsResponse {
        static instance: CMsgClientUGSGetGlobalStatsResponse = CMsgClientUGSGetGlobalStatsResponse {
            eresult: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            day_current: ::std::option::Option::None,
            days: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientUGSGetGlobalStatsResponse`
pub mod cmsg_client_ugsget_global_stats_response {
    // @@protoc_insertion_point(message:CMsgClientUGSGetGlobalStatsResponse.Day)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Day {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientUGSGetGlobalStatsResponse.Day.day_id)
        pub day_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientUGSGetGlobalStatsResponse.Day.stats)
        pub stats: ::std::vec::Vec<day::Stat>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientUGSGetGlobalStatsResponse.Day.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Day {
        fn default() -> &'a Day {
            <Day as ::protobuf::Message>::default_instance()
        }
    }

    impl Day {
        pub fn new() -> Day {
            ::std::default::Default::default()
        }

        // optional uint32 day_id = 1;

        pub fn day_id(&self) -> u32 {
            self.day_id.unwrap_or(0)
        }

        pub fn clear_day_id(&mut self) {
            self.day_id = ::std::option::Option::None;
        }

        pub fn has_day_id(&self) -> bool {
            self.day_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_day_id(&mut self, v: u32) {
            self.day_id = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Day {
        const NAME: &'static str = "Day";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.day_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.stats.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.day_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            for value in &self.stats {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.day_id {
                os.write_uint32(1, v)?;
            }
            for v in &self.stats {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Day {
            Day::new()
        }

        fn clear(&mut self) {
            self.day_id = ::std::option::Option::None;
            self.stats.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Day {
            static instance: Day = Day {
                day_id: ::std::option::Option::None,
                stats: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `Day`
    pub mod day {
        // @@protoc_insertion_point(message:CMsgClientUGSGetGlobalStatsResponse.Day.Stat)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Stat {
            // message fields
            // @@protoc_insertion_point(field:CMsgClientUGSGetGlobalStatsResponse.Day.Stat.stat_id)
            pub stat_id: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:CMsgClientUGSGetGlobalStatsResponse.Day.Stat.data)
            pub data: ::std::option::Option<i64>,
            // special fields
            // @@protoc_insertion_point(special_field:CMsgClientUGSGetGlobalStatsResponse.Day.Stat.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Stat {
            fn default() -> &'a Stat {
                <Stat as ::protobuf::Message>::default_instance()
            }
        }

        impl Stat {
            pub fn new() -> Stat {
                ::std::default::Default::default()
            }

            // optional int32 stat_id = 1;

            pub fn stat_id(&self) -> i32 {
                self.stat_id.unwrap_or(0)
            }

            pub fn clear_stat_id(&mut self) {
                self.stat_id = ::std::option::Option::None;
            }

            pub fn has_stat_id(&self) -> bool {
                self.stat_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_stat_id(&mut self, v: i32) {
                self.stat_id = ::std::option::Option::Some(v);
            }

            // optional int64 data = 2;

            pub fn data(&self) -> i64 {
                self.data.unwrap_or(0)
            }

            pub fn clear_data(&mut self) {
                self.data = ::std::option::Option::None;
            }

            pub fn has_data(&self) -> bool {
                self.data.is_some()
            }

            // Param is passed by value, moved
            pub fn set_data(&mut self, v: i64) {
                self.data = ::std::option::Option::Some(v);
            }
        }

        impl ::protobuf::Message for Stat {
            const NAME: &'static str = "Stat";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.stat_id = ::std::option::Option::Some(is.read_int32()?);
                        },
                        16 => {
                            self.data = ::std::option::Option::Some(is.read_int64()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.stat_id {
                    my_size += ::protobuf::rt::int32_size(1, v);
                }
                if let Some(v) = self.data {
                    my_size += ::protobuf::rt::int64_size(2, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.stat_id {
                    os.write_int32(1, v)?;
                }
                if let Some(v) = self.data {
                    os.write_int64(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Stat {
                Stat::new()
            }

            fn clear(&mut self) {
                self.stat_id = ::std::option::Option::None;
                self.data = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Stat {
                static instance: Stat = Stat {
                    stat_id: ::std::option::Option::None,
                    data: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientRedeemGuestPass)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRedeemGuestPass {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRedeemGuestPass.guest_pass_id)
    pub guest_pass_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRedeemGuestPass.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRedeemGuestPass {
    fn default() -> &'a CMsgClientRedeemGuestPass {
        <CMsgClientRedeemGuestPass as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRedeemGuestPass {
    pub fn new() -> CMsgClientRedeemGuestPass {
        ::std::default::Default::default()
    }

    // optional fixed64 guest_pass_id = 1;

    pub fn guest_pass_id(&self) -> u64 {
        self.guest_pass_id.unwrap_or(0)
    }

    pub fn clear_guest_pass_id(&mut self) {
        self.guest_pass_id = ::std::option::Option::None;
    }

    pub fn has_guest_pass_id(&self) -> bool {
        self.guest_pass_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guest_pass_id(&mut self, v: u64) {
        self.guest_pass_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientRedeemGuestPass {
    const NAME: &'static str = "CMsgClientRedeemGuestPass";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.guest_pass_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guest_pass_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.guest_pass_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRedeemGuestPass {
        CMsgClientRedeemGuestPass::new()
    }

    fn clear(&mut self) {
        self.guest_pass_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRedeemGuestPass {
        static instance: CMsgClientRedeemGuestPass = CMsgClientRedeemGuestPass {
            guest_pass_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientRedeemGuestPassResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRedeemGuestPassResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRedeemGuestPassResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientRedeemGuestPassResponse.package_id)
    pub package_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientRedeemGuestPassResponse.must_own_appid)
    pub must_own_appid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRedeemGuestPassResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRedeemGuestPassResponse {
    fn default() -> &'a CMsgClientRedeemGuestPassResponse {
        <CMsgClientRedeemGuestPassResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRedeemGuestPassResponse {
    pub fn new() -> CMsgClientRedeemGuestPassResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 package_id = 2;

    pub fn package_id(&self) -> u32 {
        self.package_id.unwrap_or(0)
    }

    pub fn clear_package_id(&mut self) {
        self.package_id = ::std::option::Option::None;
    }

    pub fn has_package_id(&self) -> bool {
        self.package_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_package_id(&mut self, v: u32) {
        self.package_id = ::std::option::Option::Some(v);
    }

    // optional uint32 must_own_appid = 3;

    pub fn must_own_appid(&self) -> u32 {
        self.must_own_appid.unwrap_or(0)
    }

    pub fn clear_must_own_appid(&mut self) {
        self.must_own_appid = ::std::option::Option::None;
    }

    pub fn has_must_own_appid(&self) -> bool {
        self.must_own_appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_must_own_appid(&mut self, v: u32) {
        self.must_own_appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientRedeemGuestPassResponse {
    const NAME: &'static str = "CMsgClientRedeemGuestPassResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.package_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.must_own_appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.package_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.must_own_appid {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.package_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.must_own_appid {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRedeemGuestPassResponse {
        CMsgClientRedeemGuestPassResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.package_id = ::std::option::Option::None;
        self.must_own_appid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRedeemGuestPassResponse {
        static instance: CMsgClientRedeemGuestPassResponse = CMsgClientRedeemGuestPassResponse {
            eresult: ::std::option::Option::None,
            package_id: ::std::option::Option::None,
            must_own_appid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientGetClanActivityCounts)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGetClanActivityCounts {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGetClanActivityCounts.steamid_clans)
    pub steamid_clans: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetClanActivityCounts.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetClanActivityCounts {
    fn default() -> &'a CMsgClientGetClanActivityCounts {
        <CMsgClientGetClanActivityCounts as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetClanActivityCounts {
    pub fn new() -> CMsgClientGetClanActivityCounts {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientGetClanActivityCounts {
    const NAME: &'static str = "CMsgClientGetClanActivityCounts";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.steamid_clans)?;
                },
                8 => {
                    self.steamid_clans.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.steamid_clans {
            my_size += ::protobuf::rt::uint64_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.steamid_clans {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetClanActivityCounts {
        CMsgClientGetClanActivityCounts::new()
    }

    fn clear(&mut self) {
        self.steamid_clans.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetClanActivityCounts {
        static instance: CMsgClientGetClanActivityCounts = CMsgClientGetClanActivityCounts {
            steamid_clans: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientGetClanActivityCountsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGetClanActivityCountsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGetClanActivityCountsResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetClanActivityCountsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetClanActivityCountsResponse {
    fn default() -> &'a CMsgClientGetClanActivityCountsResponse {
        <CMsgClientGetClanActivityCountsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetClanActivityCountsResponse {
    pub fn new() -> CMsgClientGetClanActivityCountsResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientGetClanActivityCountsResponse {
    const NAME: &'static str = "CMsgClientGetClanActivityCountsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetClanActivityCountsResponse {
        CMsgClientGetClanActivityCountsResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetClanActivityCountsResponse {
        static instance: CMsgClientGetClanActivityCountsResponse = CMsgClientGetClanActivityCountsResponse {
            eresult: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientOGSReportString)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientOGSReportString {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientOGSReportString.accumulated)
    pub accumulated: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientOGSReportString.sessionid)
    pub sessionid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientOGSReportString.severity)
    pub severity: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientOGSReportString.formatter)
    pub formatter: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientOGSReportString.varargs)
    pub varargs: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientOGSReportString.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientOGSReportString {
    fn default() -> &'a CMsgClientOGSReportString {
        <CMsgClientOGSReportString as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientOGSReportString {
    pub fn new() -> CMsgClientOGSReportString {
        ::std::default::Default::default()
    }

    // optional bool accumulated = 1;

    pub fn accumulated(&self) -> bool {
        self.accumulated.unwrap_or(false)
    }

    pub fn clear_accumulated(&mut self) {
        self.accumulated = ::std::option::Option::None;
    }

    pub fn has_accumulated(&self) -> bool {
        self.accumulated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accumulated(&mut self, v: bool) {
        self.accumulated = ::std::option::Option::Some(v);
    }

    // optional uint64 sessionid = 2;

    pub fn sessionid(&self) -> u64 {
        self.sessionid.unwrap_or(0)
    }

    pub fn clear_sessionid(&mut self) {
        self.sessionid = ::std::option::Option::None;
    }

    pub fn has_sessionid(&self) -> bool {
        self.sessionid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sessionid(&mut self, v: u64) {
        self.sessionid = ::std::option::Option::Some(v);
    }

    // optional int32 severity = 3;

    pub fn severity(&self) -> i32 {
        self.severity.unwrap_or(0)
    }

    pub fn clear_severity(&mut self) {
        self.severity = ::std::option::Option::None;
    }

    pub fn has_severity(&self) -> bool {
        self.severity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_severity(&mut self, v: i32) {
        self.severity = ::std::option::Option::Some(v);
    }

    // optional string formatter = 4;

    pub fn formatter(&self) -> &str {
        match self.formatter.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_formatter(&mut self) {
        self.formatter = ::std::option::Option::None;
    }

    pub fn has_formatter(&self) -> bool {
        self.formatter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_formatter(&mut self, v: ::std::string::String) {
        self.formatter = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_formatter(&mut self) -> &mut ::std::string::String {
        if self.formatter.is_none() {
            self.formatter = ::std::option::Option::Some(::std::string::String::new());
        }
        self.formatter.as_mut().unwrap()
    }

    // Take field
    pub fn take_formatter(&mut self) -> ::std::string::String {
        self.formatter.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes varargs = 5;

    pub fn varargs(&self) -> &[u8] {
        match self.varargs.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_varargs(&mut self) {
        self.varargs = ::std::option::Option::None;
    }

    pub fn has_varargs(&self) -> bool {
        self.varargs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_varargs(&mut self, v: ::std::vec::Vec<u8>) {
        self.varargs = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_varargs(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.varargs.is_none() {
            self.varargs = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.varargs.as_mut().unwrap()
    }

    // Take field
    pub fn take_varargs(&mut self) -> ::std::vec::Vec<u8> {
        self.varargs.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientOGSReportString {
    const NAME: &'static str = "CMsgClientOGSReportString";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.accumulated = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.sessionid = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.severity = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.formatter = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.varargs = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.accumulated {
            my_size += 1 + 1;
        }
        if let Some(v) = self.sessionid {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.severity {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.formatter.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.varargs.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.accumulated {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.sessionid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.severity {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.formatter.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.varargs.as_ref() {
            os.write_bytes(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientOGSReportString {
        CMsgClientOGSReportString::new()
    }

    fn clear(&mut self) {
        self.accumulated = ::std::option::Option::None;
        self.sessionid = ::std::option::Option::None;
        self.severity = ::std::option::Option::None;
        self.formatter = ::std::option::Option::None;
        self.varargs = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientOGSReportString {
        static instance: CMsgClientOGSReportString = CMsgClientOGSReportString {
            accumulated: ::std::option::Option::None,
            sessionid: ::std::option::Option::None,
            severity: ::std::option::Option::None,
            formatter: ::std::option::Option::None,
            varargs: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientOGSReportBug)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientOGSReportBug {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientOGSReportBug.sessionid)
    pub sessionid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientOGSReportBug.bugtext)
    pub bugtext: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientOGSReportBug.screenshot)
    pub screenshot: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientOGSReportBug.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientOGSReportBug {
    fn default() -> &'a CMsgClientOGSReportBug {
        <CMsgClientOGSReportBug as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientOGSReportBug {
    pub fn new() -> CMsgClientOGSReportBug {
        ::std::default::Default::default()
    }

    // optional uint64 sessionid = 1;

    pub fn sessionid(&self) -> u64 {
        self.sessionid.unwrap_or(0)
    }

    pub fn clear_sessionid(&mut self) {
        self.sessionid = ::std::option::Option::None;
    }

    pub fn has_sessionid(&self) -> bool {
        self.sessionid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sessionid(&mut self, v: u64) {
        self.sessionid = ::std::option::Option::Some(v);
    }

    // optional string bugtext = 2;

    pub fn bugtext(&self) -> &str {
        match self.bugtext.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_bugtext(&mut self) {
        self.bugtext = ::std::option::Option::None;
    }

    pub fn has_bugtext(&self) -> bool {
        self.bugtext.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bugtext(&mut self, v: ::std::string::String) {
        self.bugtext = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bugtext(&mut self) -> &mut ::std::string::String {
        if self.bugtext.is_none() {
            self.bugtext = ::std::option::Option::Some(::std::string::String::new());
        }
        self.bugtext.as_mut().unwrap()
    }

    // Take field
    pub fn take_bugtext(&mut self) -> ::std::string::String {
        self.bugtext.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes screenshot = 3;

    pub fn screenshot(&self) -> &[u8] {
        match self.screenshot.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_screenshot(&mut self) {
        self.screenshot = ::std::option::Option::None;
    }

    pub fn has_screenshot(&self) -> bool {
        self.screenshot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screenshot(&mut self, v: ::std::vec::Vec<u8>) {
        self.screenshot = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_screenshot(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.screenshot.is_none() {
            self.screenshot = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.screenshot.as_mut().unwrap()
    }

    // Take field
    pub fn take_screenshot(&mut self) -> ::std::vec::Vec<u8> {
        self.screenshot.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientOGSReportBug {
    const NAME: &'static str = "CMsgClientOGSReportBug";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sessionid = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.bugtext = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.screenshot = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.sessionid {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.bugtext.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.screenshot.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.sessionid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.bugtext.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.screenshot.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientOGSReportBug {
        CMsgClientOGSReportBug::new()
    }

    fn clear(&mut self) {
        self.sessionid = ::std::option::Option::None;
        self.bugtext = ::std::option::Option::None;
        self.screenshot = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientOGSReportBug {
        static instance: CMsgClientOGSReportBug = CMsgClientOGSReportBug {
            sessionid: ::std::option::Option::None,
            bugtext: ::std::option::Option::None,
            screenshot: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientSentLogs)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientSentLogs {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientSentLogs.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientSentLogs {
    fn default() -> &'a CMsgClientSentLogs {
        <CMsgClientSentLogs as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientSentLogs {
    pub fn new() -> CMsgClientSentLogs {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientSentLogs {
    const NAME: &'static str = "CMsgClientSentLogs";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientSentLogs {
        CMsgClientSentLogs::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientSentLogs {
        static instance: CMsgClientSentLogs = CMsgClientSentLogs {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCClient)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCClient {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCClient.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCClient.msgtype)
    pub msgtype: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCClient.payload)
    pub payload: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgGCClient.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCClient.gcname)
    pub gcname: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCClient.ip)
    pub ip: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCClient.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCClient {
    fn default() -> &'a CMsgGCClient {
        <CMsgGCClient as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCClient {
    pub fn new() -> CMsgGCClient {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 msgtype = 2;

    pub fn msgtype(&self) -> u32 {
        self.msgtype.unwrap_or(0)
    }

    pub fn clear_msgtype(&mut self) {
        self.msgtype = ::std::option::Option::None;
    }

    pub fn has_msgtype(&self) -> bool {
        self.msgtype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msgtype(&mut self, v: u32) {
        self.msgtype = ::std::option::Option::Some(v);
    }

    // optional bytes payload = 3;

    pub fn payload(&self) -> &[u8] {
        match self.payload.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_payload(&mut self) {
        self.payload = ::std::option::Option::None;
    }

    pub fn has_payload(&self) -> bool {
        self.payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.payload.is_none() {
            self.payload = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        self.payload.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed64 steamid = 4;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional string gcname = 5;

    pub fn gcname(&self) -> &str {
        match self.gcname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_gcname(&mut self) {
        self.gcname = ::std::option::Option::None;
    }

    pub fn has_gcname(&self) -> bool {
        self.gcname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gcname(&mut self, v: ::std::string::String) {
        self.gcname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gcname(&mut self) -> &mut ::std::string::String {
        if self.gcname.is_none() {
            self.gcname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.gcname.as_mut().unwrap()
    }

    // Take field
    pub fn take_gcname(&mut self) -> ::std::string::String {
        self.gcname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 ip = 6;

    pub fn ip(&self) -> u32 {
        self.ip.unwrap_or(0)
    }

    pub fn clear_ip(&mut self) {
        self.ip = ::std::option::Option::None;
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: u32) {
        self.ip = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCClient {
    const NAME: &'static str = "CMsgGCClient";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.msgtype = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.payload = ::std::option::Option::Some(is.read_bytes()?);
                },
                33 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                42 => {
                    self.gcname = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.msgtype {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.payload.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.gcname.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.ip {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.msgtype {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.payload.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.gcname.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.ip {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCClient {
        CMsgGCClient::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.msgtype = ::std::option::Option::None;
        self.payload = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.gcname = ::std::option::Option::None;
        self.ip = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCClient {
        static instance: CMsgGCClient = CMsgGCClient {
            appid: ::std::option::Option::None,
            msgtype: ::std::option::Option::None,
            payload: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            gcname: ::std::option::Option::None,
            ip: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientRequestFreeLicense)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRequestFreeLicense {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRequestFreeLicense.appids)
    pub appids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRequestFreeLicense.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestFreeLicense {
    fn default() -> &'a CMsgClientRequestFreeLicense {
        <CMsgClientRequestFreeLicense as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestFreeLicense {
    pub fn new() -> CMsgClientRequestFreeLicense {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientRequestFreeLicense {
    const NAME: &'static str = "CMsgClientRequestFreeLicense";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.appids)?;
                },
                16 => {
                    self.appids.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.appids {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.appids {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRequestFreeLicense {
        CMsgClientRequestFreeLicense::new()
    }

    fn clear(&mut self) {
        self.appids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRequestFreeLicense {
        static instance: CMsgClientRequestFreeLicense = CMsgClientRequestFreeLicense {
            appids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientRequestFreeLicenseResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRequestFreeLicenseResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRequestFreeLicenseResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientRequestFreeLicenseResponse.granted_packageids)
    pub granted_packageids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgClientRequestFreeLicenseResponse.granted_appids)
    pub granted_appids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRequestFreeLicenseResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestFreeLicenseResponse {
    fn default() -> &'a CMsgClientRequestFreeLicenseResponse {
        <CMsgClientRequestFreeLicenseResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestFreeLicenseResponse {
    pub fn new() -> CMsgClientRequestFreeLicenseResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientRequestFreeLicenseResponse {
    const NAME: &'static str = "CMsgClientRequestFreeLicenseResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.granted_packageids)?;
                },
                16 => {
                    self.granted_packageids.push(is.read_uint32()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.granted_appids)?;
                },
                24 => {
                    self.granted_appids.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.granted_packageids {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        for value in &self.granted_appids {
            my_size += ::protobuf::rt::uint32_size(3, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        for v in &self.granted_packageids {
            os.write_uint32(2, *v)?;
        };
        for v in &self.granted_appids {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRequestFreeLicenseResponse {
        CMsgClientRequestFreeLicenseResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.granted_packageids.clear();
        self.granted_appids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRequestFreeLicenseResponse {
        static instance: CMsgClientRequestFreeLicenseResponse = CMsgClientRequestFreeLicenseResponse {
            eresult: ::std::option::Option::None,
            granted_packageids: ::std::vec::Vec::new(),
            granted_appids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDRMDownloadRequestWithCrashData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDRMDownloadRequestWithCrashData {
    // message fields
    // @@protoc_insertion_point(field:CMsgDRMDownloadRequestWithCrashData.download_flags)
    pub download_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDRMDownloadRequestWithCrashData.download_types_known)
    pub download_types_known: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDRMDownloadRequestWithCrashData.guid_drm)
    pub guid_drm: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgDRMDownloadRequestWithCrashData.guid_split)
    pub guid_split: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgDRMDownloadRequestWithCrashData.guid_merge)
    pub guid_merge: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgDRMDownloadRequestWithCrashData.module_name)
    pub module_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgDRMDownloadRequestWithCrashData.module_path)
    pub module_path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgDRMDownloadRequestWithCrashData.crash_data)
    pub crash_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDRMDownloadRequestWithCrashData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDRMDownloadRequestWithCrashData {
    fn default() -> &'a CMsgDRMDownloadRequestWithCrashData {
        <CMsgDRMDownloadRequestWithCrashData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDRMDownloadRequestWithCrashData {
    pub fn new() -> CMsgDRMDownloadRequestWithCrashData {
        ::std::default::Default::default()
    }

    // optional uint32 download_flags = 1;

    pub fn download_flags(&self) -> u32 {
        self.download_flags.unwrap_or(0)
    }

    pub fn clear_download_flags(&mut self) {
        self.download_flags = ::std::option::Option::None;
    }

    pub fn has_download_flags(&self) -> bool {
        self.download_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_flags(&mut self, v: u32) {
        self.download_flags = ::std::option::Option::Some(v);
    }

    // optional uint32 download_types_known = 2;

    pub fn download_types_known(&self) -> u32 {
        self.download_types_known.unwrap_or(0)
    }

    pub fn clear_download_types_known(&mut self) {
        self.download_types_known = ::std::option::Option::None;
    }

    pub fn has_download_types_known(&self) -> bool {
        self.download_types_known.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_types_known(&mut self, v: u32) {
        self.download_types_known = ::std::option::Option::Some(v);
    }

    // optional bytes guid_drm = 3;

    pub fn guid_drm(&self) -> &[u8] {
        match self.guid_drm.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_guid_drm(&mut self) {
        self.guid_drm = ::std::option::Option::None;
    }

    pub fn has_guid_drm(&self) -> bool {
        self.guid_drm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guid_drm(&mut self, v: ::std::vec::Vec<u8>) {
        self.guid_drm = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_guid_drm(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.guid_drm.is_none() {
            self.guid_drm = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.guid_drm.as_mut().unwrap()
    }

    // Take field
    pub fn take_guid_drm(&mut self) -> ::std::vec::Vec<u8> {
        self.guid_drm.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes guid_split = 4;

    pub fn guid_split(&self) -> &[u8] {
        match self.guid_split.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_guid_split(&mut self) {
        self.guid_split = ::std::option::Option::None;
    }

    pub fn has_guid_split(&self) -> bool {
        self.guid_split.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guid_split(&mut self, v: ::std::vec::Vec<u8>) {
        self.guid_split = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_guid_split(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.guid_split.is_none() {
            self.guid_split = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.guid_split.as_mut().unwrap()
    }

    // Take field
    pub fn take_guid_split(&mut self) -> ::std::vec::Vec<u8> {
        self.guid_split.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes guid_merge = 5;

    pub fn guid_merge(&self) -> &[u8] {
        match self.guid_merge.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_guid_merge(&mut self) {
        self.guid_merge = ::std::option::Option::None;
    }

    pub fn has_guid_merge(&self) -> bool {
        self.guid_merge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guid_merge(&mut self, v: ::std::vec::Vec<u8>) {
        self.guid_merge = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_guid_merge(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.guid_merge.is_none() {
            self.guid_merge = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.guid_merge.as_mut().unwrap()
    }

    // Take field
    pub fn take_guid_merge(&mut self) -> ::std::vec::Vec<u8> {
        self.guid_merge.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string module_name = 6;

    pub fn module_name(&self) -> &str {
        match self.module_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_module_name(&mut self) {
        self.module_name = ::std::option::Option::None;
    }

    pub fn has_module_name(&self) -> bool {
        self.module_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_name(&mut self, v: ::std::string::String) {
        self.module_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module_name(&mut self) -> &mut ::std::string::String {
        if self.module_name.is_none() {
            self.module_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.module_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_module_name(&mut self) -> ::std::string::String {
        self.module_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string module_path = 7;

    pub fn module_path(&self) -> &str {
        match self.module_path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_module_path(&mut self) {
        self.module_path = ::std::option::Option::None;
    }

    pub fn has_module_path(&self) -> bool {
        self.module_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_path(&mut self, v: ::std::string::String) {
        self.module_path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module_path(&mut self) -> &mut ::std::string::String {
        if self.module_path.is_none() {
            self.module_path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.module_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_module_path(&mut self) -> ::std::string::String {
        self.module_path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes crash_data = 8;

    pub fn crash_data(&self) -> &[u8] {
        match self.crash_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_crash_data(&mut self) {
        self.crash_data = ::std::option::Option::None;
    }

    pub fn has_crash_data(&self) -> bool {
        self.crash_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crash_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.crash_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_crash_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.crash_data.is_none() {
            self.crash_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.crash_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_crash_data(&mut self) -> ::std::vec::Vec<u8> {
        self.crash_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgDRMDownloadRequestWithCrashData {
    const NAME: &'static str = "CMsgDRMDownloadRequestWithCrashData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.download_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.download_types_known = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.guid_drm = ::std::option::Option::Some(is.read_bytes()?);
                },
                34 => {
                    self.guid_split = ::std::option::Option::Some(is.read_bytes()?);
                },
                42 => {
                    self.guid_merge = ::std::option::Option::Some(is.read_bytes()?);
                },
                50 => {
                    self.module_name = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.module_path = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.crash_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.download_flags {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.download_types_known {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.guid_drm.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.guid_split.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.guid_merge.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.module_name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.module_path.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.crash_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.download_flags {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.download_types_known {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.guid_drm.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.guid_split.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.guid_merge.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.module_name.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.module_path.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.crash_data.as_ref() {
            os.write_bytes(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDRMDownloadRequestWithCrashData {
        CMsgDRMDownloadRequestWithCrashData::new()
    }

    fn clear(&mut self) {
        self.download_flags = ::std::option::Option::None;
        self.download_types_known = ::std::option::Option::None;
        self.guid_drm = ::std::option::Option::None;
        self.guid_split = ::std::option::Option::None;
        self.guid_merge = ::std::option::Option::None;
        self.module_name = ::std::option::Option::None;
        self.module_path = ::std::option::Option::None;
        self.crash_data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDRMDownloadRequestWithCrashData {
        static instance: CMsgDRMDownloadRequestWithCrashData = CMsgDRMDownloadRequestWithCrashData {
            download_flags: ::std::option::Option::None,
            download_types_known: ::std::option::Option::None,
            guid_drm: ::std::option::Option::None,
            guid_split: ::std::option::Option::None,
            guid_merge: ::std::option::Option::None,
            module_name: ::std::option::Option::None,
            module_path: ::std::option::Option::None,
            crash_data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDRMDownloadResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDRMDownloadResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgDRMDownloadResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDRMDownloadResponse.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDRMDownloadResponse.blob_download_type)
    pub blob_download_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDRMDownloadResponse.merge_guid)
    pub merge_guid: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgDRMDownloadResponse.download_file_dfs_ip)
    pub download_file_dfs_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDRMDownloadResponse.download_file_dfs_port)
    pub download_file_dfs_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDRMDownloadResponse.download_file_url)
    pub download_file_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgDRMDownloadResponse.module_path)
    pub module_path: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDRMDownloadResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDRMDownloadResponse {
    fn default() -> &'a CMsgDRMDownloadResponse {
        <CMsgDRMDownloadResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDRMDownloadResponse {
    pub fn new() -> CMsgDRMDownloadResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 blob_download_type = 3;

    pub fn blob_download_type(&self) -> u32 {
        self.blob_download_type.unwrap_or(0)
    }

    pub fn clear_blob_download_type(&mut self) {
        self.blob_download_type = ::std::option::Option::None;
    }

    pub fn has_blob_download_type(&self) -> bool {
        self.blob_download_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blob_download_type(&mut self, v: u32) {
        self.blob_download_type = ::std::option::Option::Some(v);
    }

    // optional bytes merge_guid = 4;

    pub fn merge_guid(&self) -> &[u8] {
        match self.merge_guid.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_merge_guid(&mut self) {
        self.merge_guid = ::std::option::Option::None;
    }

    pub fn has_merge_guid(&self) -> bool {
        self.merge_guid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_merge_guid(&mut self, v: ::std::vec::Vec<u8>) {
        self.merge_guid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_merge_guid(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.merge_guid.is_none() {
            self.merge_guid = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.merge_guid.as_mut().unwrap()
    }

    // Take field
    pub fn take_merge_guid(&mut self) -> ::std::vec::Vec<u8> {
        self.merge_guid.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 download_file_dfs_ip = 5;

    pub fn download_file_dfs_ip(&self) -> u32 {
        self.download_file_dfs_ip.unwrap_or(0)
    }

    pub fn clear_download_file_dfs_ip(&mut self) {
        self.download_file_dfs_ip = ::std::option::Option::None;
    }

    pub fn has_download_file_dfs_ip(&self) -> bool {
        self.download_file_dfs_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_file_dfs_ip(&mut self, v: u32) {
        self.download_file_dfs_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 download_file_dfs_port = 6;

    pub fn download_file_dfs_port(&self) -> u32 {
        self.download_file_dfs_port.unwrap_or(0)
    }

    pub fn clear_download_file_dfs_port(&mut self) {
        self.download_file_dfs_port = ::std::option::Option::None;
    }

    pub fn has_download_file_dfs_port(&self) -> bool {
        self.download_file_dfs_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_file_dfs_port(&mut self, v: u32) {
        self.download_file_dfs_port = ::std::option::Option::Some(v);
    }

    // optional string download_file_url = 7;

    pub fn download_file_url(&self) -> &str {
        match self.download_file_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_download_file_url(&mut self) {
        self.download_file_url = ::std::option::Option::None;
    }

    pub fn has_download_file_url(&self) -> bool {
        self.download_file_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_file_url(&mut self, v: ::std::string::String) {
        self.download_file_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_download_file_url(&mut self) -> &mut ::std::string::String {
        if self.download_file_url.is_none() {
            self.download_file_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.download_file_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_download_file_url(&mut self) -> ::std::string::String {
        self.download_file_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string module_path = 8;

    pub fn module_path(&self) -> &str {
        match self.module_path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_module_path(&mut self) {
        self.module_path = ::std::option::Option::None;
    }

    pub fn has_module_path(&self) -> bool {
        self.module_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_path(&mut self, v: ::std::string::String) {
        self.module_path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module_path(&mut self) -> &mut ::std::string::String {
        if self.module_path.is_none() {
            self.module_path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.module_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_module_path(&mut self) -> ::std::string::String {
        self.module_path.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgDRMDownloadResponse {
    const NAME: &'static str = "CMsgDRMDownloadResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.blob_download_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.merge_guid = ::std::option::Option::Some(is.read_bytes()?);
                },
                40 => {
                    self.download_file_dfs_ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.download_file_dfs_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.download_file_url = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.module_path = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.blob_download_type {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.merge_guid.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.download_file_dfs_ip {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.download_file_dfs_port {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.download_file_url.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.module_path.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.blob_download_type {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.merge_guid.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.download_file_dfs_ip {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.download_file_dfs_port {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.download_file_url.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.module_path.as_ref() {
            os.write_string(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDRMDownloadResponse {
        CMsgDRMDownloadResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.blob_download_type = ::std::option::Option::None;
        self.merge_guid = ::std::option::Option::None;
        self.download_file_dfs_ip = ::std::option::Option::None;
        self.download_file_dfs_port = ::std::option::Option::None;
        self.download_file_url = ::std::option::Option::None;
        self.module_path = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDRMDownloadResponse {
        static instance: CMsgDRMDownloadResponse = CMsgDRMDownloadResponse {
            eresult: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            blob_download_type: ::std::option::Option::None,
            merge_guid: ::std::option::Option::None,
            download_file_dfs_ip: ::std::option::Option::None,
            download_file_dfs_port: ::std::option::Option::None,
            download_file_url: ::std::option::Option::None,
            module_path: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDRMFinalResult)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDRMFinalResult {
    // message fields
    // @@protoc_insertion_point(field:CMsgDRMFinalResult.eResult)
    pub eResult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDRMFinalResult.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDRMFinalResult.blob_download_type)
    pub blob_download_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDRMFinalResult.error_detail)
    pub error_detail: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDRMFinalResult.merge_guid)
    pub merge_guid: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgDRMFinalResult.download_file_dfs_ip)
    pub download_file_dfs_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDRMFinalResult.download_file_dfs_port)
    pub download_file_dfs_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDRMFinalResult.download_file_url)
    pub download_file_url: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDRMFinalResult.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDRMFinalResult {
    fn default() -> &'a CMsgDRMFinalResult {
        <CMsgDRMFinalResult as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDRMFinalResult {
    pub fn new() -> CMsgDRMFinalResult {
        ::std::default::Default::default()
    }

    // optional uint32 eResult = 1;

    pub fn eResult(&self) -> u32 {
        self.eResult.unwrap_or(2u32)
    }

    pub fn clear_eResult(&mut self) {
        self.eResult = ::std::option::Option::None;
    }

    pub fn has_eResult(&self) -> bool {
        self.eResult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eResult(&mut self, v: u32) {
        self.eResult = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 blob_download_type = 3;

    pub fn blob_download_type(&self) -> u32 {
        self.blob_download_type.unwrap_or(0)
    }

    pub fn clear_blob_download_type(&mut self) {
        self.blob_download_type = ::std::option::Option::None;
    }

    pub fn has_blob_download_type(&self) -> bool {
        self.blob_download_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blob_download_type(&mut self, v: u32) {
        self.blob_download_type = ::std::option::Option::Some(v);
    }

    // optional uint32 error_detail = 4;

    pub fn error_detail(&self) -> u32 {
        self.error_detail.unwrap_or(0)
    }

    pub fn clear_error_detail(&mut self) {
        self.error_detail = ::std::option::Option::None;
    }

    pub fn has_error_detail(&self) -> bool {
        self.error_detail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_detail(&mut self, v: u32) {
        self.error_detail = ::std::option::Option::Some(v);
    }

    // optional bytes merge_guid = 5;

    pub fn merge_guid(&self) -> &[u8] {
        match self.merge_guid.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_merge_guid(&mut self) {
        self.merge_guid = ::std::option::Option::None;
    }

    pub fn has_merge_guid(&self) -> bool {
        self.merge_guid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_merge_guid(&mut self, v: ::std::vec::Vec<u8>) {
        self.merge_guid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_merge_guid(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.merge_guid.is_none() {
            self.merge_guid = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.merge_guid.as_mut().unwrap()
    }

    // Take field
    pub fn take_merge_guid(&mut self) -> ::std::vec::Vec<u8> {
        self.merge_guid.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 download_file_dfs_ip = 6;

    pub fn download_file_dfs_ip(&self) -> u32 {
        self.download_file_dfs_ip.unwrap_or(0)
    }

    pub fn clear_download_file_dfs_ip(&mut self) {
        self.download_file_dfs_ip = ::std::option::Option::None;
    }

    pub fn has_download_file_dfs_ip(&self) -> bool {
        self.download_file_dfs_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_file_dfs_ip(&mut self, v: u32) {
        self.download_file_dfs_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 download_file_dfs_port = 7;

    pub fn download_file_dfs_port(&self) -> u32 {
        self.download_file_dfs_port.unwrap_or(0)
    }

    pub fn clear_download_file_dfs_port(&mut self) {
        self.download_file_dfs_port = ::std::option::Option::None;
    }

    pub fn has_download_file_dfs_port(&self) -> bool {
        self.download_file_dfs_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_file_dfs_port(&mut self, v: u32) {
        self.download_file_dfs_port = ::std::option::Option::Some(v);
    }

    // optional string download_file_url = 8;

    pub fn download_file_url(&self) -> &str {
        match self.download_file_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_download_file_url(&mut self) {
        self.download_file_url = ::std::option::Option::None;
    }

    pub fn has_download_file_url(&self) -> bool {
        self.download_file_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_file_url(&mut self, v: ::std::string::String) {
        self.download_file_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_download_file_url(&mut self) -> &mut ::std::string::String {
        if self.download_file_url.is_none() {
            self.download_file_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.download_file_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_download_file_url(&mut self) -> ::std::string::String {
        self.download_file_url.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgDRMFinalResult {
    const NAME: &'static str = "CMsgDRMFinalResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eResult = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.blob_download_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.error_detail = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.merge_guid = ::std::option::Option::Some(is.read_bytes()?);
                },
                48 => {
                    self.download_file_dfs_ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.download_file_dfs_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.download_file_url = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eResult {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.blob_download_type {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.error_detail {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.merge_guid.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.download_file_dfs_ip {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.download_file_dfs_port {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.download_file_url.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eResult {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.blob_download_type {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.error_detail {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.merge_guid.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.download_file_dfs_ip {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.download_file_dfs_port {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.download_file_url.as_ref() {
            os.write_string(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDRMFinalResult {
        CMsgDRMFinalResult::new()
    }

    fn clear(&mut self) {
        self.eResult = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.blob_download_type = ::std::option::Option::None;
        self.error_detail = ::std::option::Option::None;
        self.merge_guid = ::std::option::Option::None;
        self.download_file_dfs_ip = ::std::option::Option::None;
        self.download_file_dfs_port = ::std::option::Option::None;
        self.download_file_url = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDRMFinalResult {
        static instance: CMsgDRMFinalResult = CMsgDRMFinalResult {
            eResult: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            blob_download_type: ::std::option::Option::None,
            error_detail: ::std::option::Option::None,
            merge_guid: ::std::option::Option::None,
            download_file_dfs_ip: ::std::option::Option::None,
            download_file_dfs_port: ::std::option::Option::None,
            download_file_url: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientDPCheckSpecialSurvey)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientDPCheckSpecialSurvey {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientDPCheckSpecialSurvey.survey_id)
    pub survey_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientDPCheckSpecialSurvey.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientDPCheckSpecialSurvey {
    fn default() -> &'a CMsgClientDPCheckSpecialSurvey {
        <CMsgClientDPCheckSpecialSurvey as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientDPCheckSpecialSurvey {
    pub fn new() -> CMsgClientDPCheckSpecialSurvey {
        ::std::default::Default::default()
    }

    // optional uint32 survey_id = 1;

    pub fn survey_id(&self) -> u32 {
        self.survey_id.unwrap_or(0)
    }

    pub fn clear_survey_id(&mut self) {
        self.survey_id = ::std::option::Option::None;
    }

    pub fn has_survey_id(&self) -> bool {
        self.survey_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_survey_id(&mut self, v: u32) {
        self.survey_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientDPCheckSpecialSurvey {
    const NAME: &'static str = "CMsgClientDPCheckSpecialSurvey";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.survey_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.survey_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.survey_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientDPCheckSpecialSurvey {
        CMsgClientDPCheckSpecialSurvey::new()
    }

    fn clear(&mut self) {
        self.survey_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientDPCheckSpecialSurvey {
        static instance: CMsgClientDPCheckSpecialSurvey = CMsgClientDPCheckSpecialSurvey {
            survey_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientDPCheckSpecialSurveyResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientDPCheckSpecialSurveyResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientDPCheckSpecialSurveyResponse.eResult)
    pub eResult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientDPCheckSpecialSurveyResponse.state)
    pub state: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientDPCheckSpecialSurveyResponse.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientDPCheckSpecialSurveyResponse.custom_url)
    pub custom_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientDPCheckSpecialSurveyResponse.include_software)
    pub include_software: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientDPCheckSpecialSurveyResponse.token)
    pub token: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientDPCheckSpecialSurveyResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientDPCheckSpecialSurveyResponse {
    fn default() -> &'a CMsgClientDPCheckSpecialSurveyResponse {
        <CMsgClientDPCheckSpecialSurveyResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientDPCheckSpecialSurveyResponse {
    pub fn new() -> CMsgClientDPCheckSpecialSurveyResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eResult = 1;

    pub fn eResult(&self) -> u32 {
        self.eResult.unwrap_or(2u32)
    }

    pub fn clear_eResult(&mut self) {
        self.eResult = ::std::option::Option::None;
    }

    pub fn has_eResult(&self) -> bool {
        self.eResult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eResult(&mut self, v: u32) {
        self.eResult = ::std::option::Option::Some(v);
    }

    // optional uint32 state = 2;

    pub fn state(&self) -> u32 {
        self.state.unwrap_or(0)
    }

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: u32) {
        self.state = ::std::option::Option::Some(v);
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string custom_url = 4;

    pub fn custom_url(&self) -> &str {
        match self.custom_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_custom_url(&mut self) {
        self.custom_url = ::std::option::Option::None;
    }

    pub fn has_custom_url(&self) -> bool {
        self.custom_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_url(&mut self, v: ::std::string::String) {
        self.custom_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_url(&mut self) -> &mut ::std::string::String {
        if self.custom_url.is_none() {
            self.custom_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.custom_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_custom_url(&mut self) -> ::std::string::String {
        self.custom_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool include_software = 5;

    pub fn include_software(&self) -> bool {
        self.include_software.unwrap_or(false)
    }

    pub fn clear_include_software(&mut self) {
        self.include_software = ::std::option::Option::None;
    }

    pub fn has_include_software(&self) -> bool {
        self.include_software.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_software(&mut self, v: bool) {
        self.include_software = ::std::option::Option::Some(v);
    }

    // optional bytes token = 6;

    pub fn token(&self) -> &[u8] {
        match self.token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.token.is_none() {
            self.token = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::vec::Vec<u8> {
        self.token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientDPCheckSpecialSurveyResponse {
    const NAME: &'static str = "CMsgClientDPCheckSpecialSurveyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eResult = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.state = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.custom_url = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.include_software = ::std::option::Option::Some(is.read_bool()?);
                },
                50 => {
                    self.token = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eResult {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.state {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.custom_url.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.include_software {
            my_size += 1 + 1;
        }
        if let Some(v) = self.token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eResult {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.state {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.custom_url.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.include_software {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.token.as_ref() {
            os.write_bytes(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientDPCheckSpecialSurveyResponse {
        CMsgClientDPCheckSpecialSurveyResponse::new()
    }

    fn clear(&mut self) {
        self.eResult = ::std::option::Option::None;
        self.state = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.custom_url = ::std::option::Option::None;
        self.include_software = ::std::option::Option::None;
        self.token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientDPCheckSpecialSurveyResponse {
        static instance: CMsgClientDPCheckSpecialSurveyResponse = CMsgClientDPCheckSpecialSurveyResponse {
            eResult: ::std::option::Option::None,
            state: ::std::option::Option::None,
            name: ::std::option::Option::None,
            custom_url: ::std::option::Option::None,
            include_software: ::std::option::Option::None,
            token: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientDPSendSpecialSurveyResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientDPSendSpecialSurveyResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientDPSendSpecialSurveyResponse.survey_id)
    pub survey_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientDPSendSpecialSurveyResponse.data)
    pub data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientDPSendSpecialSurveyResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientDPSendSpecialSurveyResponse {
    fn default() -> &'a CMsgClientDPSendSpecialSurveyResponse {
        <CMsgClientDPSendSpecialSurveyResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientDPSendSpecialSurveyResponse {
    pub fn new() -> CMsgClientDPSendSpecialSurveyResponse {
        ::std::default::Default::default()
    }

    // optional uint32 survey_id = 1;

    pub fn survey_id(&self) -> u32 {
        self.survey_id.unwrap_or(0)
    }

    pub fn clear_survey_id(&mut self) {
        self.survey_id = ::std::option::Option::None;
    }

    pub fn has_survey_id(&self) -> bool {
        self.survey_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_survey_id(&mut self, v: u32) {
        self.survey_id = ::std::option::Option::Some(v);
    }

    // optional bytes data = 2;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientDPSendSpecialSurveyResponse {
    const NAME: &'static str = "CMsgClientDPSendSpecialSurveyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.survey_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.survey_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.survey_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientDPSendSpecialSurveyResponse {
        CMsgClientDPSendSpecialSurveyResponse::new()
    }

    fn clear(&mut self) {
        self.survey_id = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientDPSendSpecialSurveyResponse {
        static instance: CMsgClientDPSendSpecialSurveyResponse = CMsgClientDPSendSpecialSurveyResponse {
            survey_id: ::std::option::Option::None,
            data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientDPSendSpecialSurveyResponseReply)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientDPSendSpecialSurveyResponseReply {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientDPSendSpecialSurveyResponseReply.eResult)
    pub eResult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientDPSendSpecialSurveyResponseReply.token)
    pub token: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientDPSendSpecialSurveyResponseReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientDPSendSpecialSurveyResponseReply {
    fn default() -> &'a CMsgClientDPSendSpecialSurveyResponseReply {
        <CMsgClientDPSendSpecialSurveyResponseReply as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientDPSendSpecialSurveyResponseReply {
    pub fn new() -> CMsgClientDPSendSpecialSurveyResponseReply {
        ::std::default::Default::default()
    }

    // optional uint32 eResult = 1;

    pub fn eResult(&self) -> u32 {
        self.eResult.unwrap_or(2u32)
    }

    pub fn clear_eResult(&mut self) {
        self.eResult = ::std::option::Option::None;
    }

    pub fn has_eResult(&self) -> bool {
        self.eResult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eResult(&mut self, v: u32) {
        self.eResult = ::std::option::Option::Some(v);
    }

    // optional bytes token = 2;

    pub fn token(&self) -> &[u8] {
        match self.token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.token.is_none() {
            self.token = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::vec::Vec<u8> {
        self.token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientDPSendSpecialSurveyResponseReply {
    const NAME: &'static str = "CMsgClientDPSendSpecialSurveyResponseReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eResult = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.token = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eResult {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eResult {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.token.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientDPSendSpecialSurveyResponseReply {
        CMsgClientDPSendSpecialSurveyResponseReply::new()
    }

    fn clear(&mut self) {
        self.eResult = ::std::option::Option::None;
        self.token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientDPSendSpecialSurveyResponseReply {
        static instance: CMsgClientDPSendSpecialSurveyResponseReply = CMsgClientDPSendSpecialSurveyResponseReply {
            eResult: ::std::option::Option::None,
            token: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientRequestForgottenPasswordEmail)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRequestForgottenPasswordEmail {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRequestForgottenPasswordEmail.account_name)
    pub account_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientRequestForgottenPasswordEmail.password_tried)
    pub password_tried: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRequestForgottenPasswordEmail.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestForgottenPasswordEmail {
    fn default() -> &'a CMsgClientRequestForgottenPasswordEmail {
        <CMsgClientRequestForgottenPasswordEmail as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestForgottenPasswordEmail {
    pub fn new() -> CMsgClientRequestForgottenPasswordEmail {
        ::std::default::Default::default()
    }

    // optional string account_name = 1;

    pub fn account_name(&self) -> &str {
        match self.account_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_account_name(&mut self) {
        self.account_name = ::std::option::Option::None;
    }

    pub fn has_account_name(&self) -> bool {
        self.account_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_name(&mut self, v: ::std::string::String) {
        self.account_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_name(&mut self) -> &mut ::std::string::String {
        if self.account_name.is_none() {
            self.account_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.account_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_name(&mut self) -> ::std::string::String {
        self.account_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string password_tried = 2;

    pub fn password_tried(&self) -> &str {
        match self.password_tried.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_password_tried(&mut self) {
        self.password_tried = ::std::option::Option::None;
    }

    pub fn has_password_tried(&self) -> bool {
        self.password_tried.is_some()
    }

    // Param is passed by value, moved
    pub fn set_password_tried(&mut self, v: ::std::string::String) {
        self.password_tried = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password_tried(&mut self) -> &mut ::std::string::String {
        if self.password_tried.is_none() {
            self.password_tried = ::std::option::Option::Some(::std::string::String::new());
        }
        self.password_tried.as_mut().unwrap()
    }

    // Take field
    pub fn take_password_tried(&mut self) -> ::std::string::String {
        self.password_tried.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientRequestForgottenPasswordEmail {
    const NAME: &'static str = "CMsgClientRequestForgottenPasswordEmail";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.account_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.password_tried = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.password_tried.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.password_tried.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRequestForgottenPasswordEmail {
        CMsgClientRequestForgottenPasswordEmail::new()
    }

    fn clear(&mut self) {
        self.account_name = ::std::option::Option::None;
        self.password_tried = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRequestForgottenPasswordEmail {
        static instance: CMsgClientRequestForgottenPasswordEmail = CMsgClientRequestForgottenPasswordEmail {
            account_name: ::std::option::Option::None,
            password_tried: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientRequestForgottenPasswordEmailResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRequestForgottenPasswordEmailResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRequestForgottenPasswordEmailResponse.eResult)
    pub eResult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientRequestForgottenPasswordEmailResponse.use_secret_question)
    pub use_secret_question: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRequestForgottenPasswordEmailResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestForgottenPasswordEmailResponse {
    fn default() -> &'a CMsgClientRequestForgottenPasswordEmailResponse {
        <CMsgClientRequestForgottenPasswordEmailResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestForgottenPasswordEmailResponse {
    pub fn new() -> CMsgClientRequestForgottenPasswordEmailResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eResult = 1;

    pub fn eResult(&self) -> u32 {
        self.eResult.unwrap_or(0)
    }

    pub fn clear_eResult(&mut self) {
        self.eResult = ::std::option::Option::None;
    }

    pub fn has_eResult(&self) -> bool {
        self.eResult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eResult(&mut self, v: u32) {
        self.eResult = ::std::option::Option::Some(v);
    }

    // optional bool use_secret_question = 2;

    pub fn use_secret_question(&self) -> bool {
        self.use_secret_question.unwrap_or(false)
    }

    pub fn clear_use_secret_question(&mut self) {
        self.use_secret_question = ::std::option::Option::None;
    }

    pub fn has_use_secret_question(&self) -> bool {
        self.use_secret_question.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_secret_question(&mut self, v: bool) {
        self.use_secret_question = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientRequestForgottenPasswordEmailResponse {
    const NAME: &'static str = "CMsgClientRequestForgottenPasswordEmailResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eResult = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.use_secret_question = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eResult {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.use_secret_question {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eResult {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.use_secret_question {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRequestForgottenPasswordEmailResponse {
        CMsgClientRequestForgottenPasswordEmailResponse::new()
    }

    fn clear(&mut self) {
        self.eResult = ::std::option::Option::None;
        self.use_secret_question = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRequestForgottenPasswordEmailResponse {
        static instance: CMsgClientRequestForgottenPasswordEmailResponse = CMsgClientRequestForgottenPasswordEmailResponse {
            eResult: ::std::option::Option::None,
            use_secret_question: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientItemAnnouncements)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientItemAnnouncements {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientItemAnnouncements.count_new_items)
    pub count_new_items: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientItemAnnouncements.unseen_items)
    pub unseen_items: ::std::vec::Vec<cmsg_client_item_announcements::UnseenItem>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientItemAnnouncements.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientItemAnnouncements {
    fn default() -> &'a CMsgClientItemAnnouncements {
        <CMsgClientItemAnnouncements as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientItemAnnouncements {
    pub fn new() -> CMsgClientItemAnnouncements {
        ::std::default::Default::default()
    }

    // optional uint32 count_new_items = 1;

    pub fn count_new_items(&self) -> u32 {
        self.count_new_items.unwrap_or(0)
    }

    pub fn clear_count_new_items(&mut self) {
        self.count_new_items = ::std::option::Option::None;
    }

    pub fn has_count_new_items(&self) -> bool {
        self.count_new_items.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count_new_items(&mut self, v: u32) {
        self.count_new_items = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientItemAnnouncements {
    const NAME: &'static str = "CMsgClientItemAnnouncements";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.count_new_items = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.unseen_items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.count_new_items {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.unseen_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.count_new_items {
            os.write_uint32(1, v)?;
        }
        for v in &self.unseen_items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientItemAnnouncements {
        CMsgClientItemAnnouncements::new()
    }

    fn clear(&mut self) {
        self.count_new_items = ::std::option::Option::None;
        self.unseen_items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientItemAnnouncements {
        static instance: CMsgClientItemAnnouncements = CMsgClientItemAnnouncements {
            count_new_items: ::std::option::Option::None,
            unseen_items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientItemAnnouncements`
pub mod cmsg_client_item_announcements {
    // @@protoc_insertion_point(message:CMsgClientItemAnnouncements.UnseenItem)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct UnseenItem {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientItemAnnouncements.UnseenItem.appid)
        pub appid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientItemAnnouncements.UnseenItem.context_id)
        pub context_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientItemAnnouncements.UnseenItem.asset_id)
        pub asset_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientItemAnnouncements.UnseenItem.amount)
        pub amount: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientItemAnnouncements.UnseenItem.rtime32_gained)
        pub rtime32_gained: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientItemAnnouncements.UnseenItem.source_appid)
        pub source_appid: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientItemAnnouncements.UnseenItem.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a UnseenItem {
        fn default() -> &'a UnseenItem {
            <UnseenItem as ::protobuf::Message>::default_instance()
        }
    }

    impl UnseenItem {
        pub fn new() -> UnseenItem {
            ::std::default::Default::default()
        }

        // optional uint32 appid = 1;

        pub fn appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }

        // optional uint64 context_id = 2;

        pub fn context_id(&self) -> u64 {
            self.context_id.unwrap_or(0)
        }

        pub fn clear_context_id(&mut self) {
            self.context_id = ::std::option::Option::None;
        }

        pub fn has_context_id(&self) -> bool {
            self.context_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_context_id(&mut self, v: u64) {
            self.context_id = ::std::option::Option::Some(v);
        }

        // optional uint64 asset_id = 3;

        pub fn asset_id(&self) -> u64 {
            self.asset_id.unwrap_or(0)
        }

        pub fn clear_asset_id(&mut self) {
            self.asset_id = ::std::option::Option::None;
        }

        pub fn has_asset_id(&self) -> bool {
            self.asset_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_asset_id(&mut self, v: u64) {
            self.asset_id = ::std::option::Option::Some(v);
        }

        // optional uint64 amount = 4;

        pub fn amount(&self) -> u64 {
            self.amount.unwrap_or(0)
        }

        pub fn clear_amount(&mut self) {
            self.amount = ::std::option::Option::None;
        }

        pub fn has_amount(&self) -> bool {
            self.amount.is_some()
        }

        // Param is passed by value, moved
        pub fn set_amount(&mut self, v: u64) {
            self.amount = ::std::option::Option::Some(v);
        }

        // optional fixed32 rtime32_gained = 5;

        pub fn rtime32_gained(&self) -> u32 {
            self.rtime32_gained.unwrap_or(0)
        }

        pub fn clear_rtime32_gained(&mut self) {
            self.rtime32_gained = ::std::option::Option::None;
        }

        pub fn has_rtime32_gained(&self) -> bool {
            self.rtime32_gained.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rtime32_gained(&mut self, v: u32) {
            self.rtime32_gained = ::std::option::Option::Some(v);
        }

        // optional uint32 source_appid = 6;

        pub fn source_appid(&self) -> u32 {
            self.source_appid.unwrap_or(0)
        }

        pub fn clear_source_appid(&mut self) {
            self.source_appid = ::std::option::Option::None;
        }

        pub fn has_source_appid(&self) -> bool {
            self.source_appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_source_appid(&mut self, v: u32) {
            self.source_appid = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for UnseenItem {
        const NAME: &'static str = "UnseenItem";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.context_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    24 => {
                        self.asset_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    32 => {
                        self.amount = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    45 => {
                        self.rtime32_gained = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    48 => {
                        self.source_appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.appid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.context_id {
                my_size += ::protobuf::rt::uint64_size(2, v);
            }
            if let Some(v) = self.asset_id {
                my_size += ::protobuf::rt::uint64_size(3, v);
            }
            if let Some(v) = self.amount {
                my_size += ::protobuf::rt::uint64_size(4, v);
            }
            if let Some(v) = self.rtime32_gained {
                my_size += 1 + 4;
            }
            if let Some(v) = self.source_appid {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.appid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.context_id {
                os.write_uint64(2, v)?;
            }
            if let Some(v) = self.asset_id {
                os.write_uint64(3, v)?;
            }
            if let Some(v) = self.amount {
                os.write_uint64(4, v)?;
            }
            if let Some(v) = self.rtime32_gained {
                os.write_fixed32(5, v)?;
            }
            if let Some(v) = self.source_appid {
                os.write_uint32(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> UnseenItem {
            UnseenItem::new()
        }

        fn clear(&mut self) {
            self.appid = ::std::option::Option::None;
            self.context_id = ::std::option::Option::None;
            self.asset_id = ::std::option::Option::None;
            self.amount = ::std::option::Option::None;
            self.rtime32_gained = ::std::option::Option::None;
            self.source_appid = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static UnseenItem {
            static instance: UnseenItem = UnseenItem {
                appid: ::std::option::Option::None,
                context_id: ::std::option::Option::None,
                asset_id: ::std::option::Option::None,
                amount: ::std::option::Option::None,
                rtime32_gained: ::std::option::Option::None,
                source_appid: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientRequestItemAnnouncements)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRequestItemAnnouncements {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRequestItemAnnouncements.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestItemAnnouncements {
    fn default() -> &'a CMsgClientRequestItemAnnouncements {
        <CMsgClientRequestItemAnnouncements as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestItemAnnouncements {
    pub fn new() -> CMsgClientRequestItemAnnouncements {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientRequestItemAnnouncements {
    const NAME: &'static str = "CMsgClientRequestItemAnnouncements";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRequestItemAnnouncements {
        CMsgClientRequestItemAnnouncements::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRequestItemAnnouncements {
        static instance: CMsgClientRequestItemAnnouncements = CMsgClientRequestItemAnnouncements {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientUserNotifications)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUserNotifications {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUserNotifications.notifications)
    pub notifications: ::std::vec::Vec<cmsg_client_user_notifications::Notification>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUserNotifications.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUserNotifications {
    fn default() -> &'a CMsgClientUserNotifications {
        <CMsgClientUserNotifications as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUserNotifications {
    pub fn new() -> CMsgClientUserNotifications {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientUserNotifications {
    const NAME: &'static str = "CMsgClientUserNotifications";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.notifications.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.notifications {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.notifications {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUserNotifications {
        CMsgClientUserNotifications::new()
    }

    fn clear(&mut self) {
        self.notifications.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUserNotifications {
        static instance: CMsgClientUserNotifications = CMsgClientUserNotifications {
            notifications: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientUserNotifications`
pub mod cmsg_client_user_notifications {
    // @@protoc_insertion_point(message:CMsgClientUserNotifications.Notification)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Notification {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientUserNotifications.Notification.user_notification_type)
        pub user_notification_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientUserNotifications.Notification.count)
        pub count: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientUserNotifications.Notification.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Notification {
        fn default() -> &'a Notification {
            <Notification as ::protobuf::Message>::default_instance()
        }
    }

    impl Notification {
        pub fn new() -> Notification {
            ::std::default::Default::default()
        }

        // optional uint32 user_notification_type = 1;

        pub fn user_notification_type(&self) -> u32 {
            self.user_notification_type.unwrap_or(0)
        }

        pub fn clear_user_notification_type(&mut self) {
            self.user_notification_type = ::std::option::Option::None;
        }

        pub fn has_user_notification_type(&self) -> bool {
            self.user_notification_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_user_notification_type(&mut self, v: u32) {
            self.user_notification_type = ::std::option::Option::Some(v);
        }

        // optional uint32 count = 2;

        pub fn count(&self) -> u32 {
            self.count.unwrap_or(0)
        }

        pub fn clear_count(&mut self) {
            self.count = ::std::option::Option::None;
        }

        pub fn has_count(&self) -> bool {
            self.count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_count(&mut self, v: u32) {
            self.count = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Notification {
        const NAME: &'static str = "Notification";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.user_notification_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.user_notification_type {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.count {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.user_notification_type {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.count {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Notification {
            Notification::new()
        }

        fn clear(&mut self) {
            self.user_notification_type = ::std::option::Option::None;
            self.count = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Notification {
            static instance: Notification = Notification {
                user_notification_type: ::std::option::Option::None,
                count: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientCommentNotifications)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientCommentNotifications {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientCommentNotifications.count_new_comments)
    pub count_new_comments: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientCommentNotifications.count_new_comments_owner)
    pub count_new_comments_owner: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientCommentNotifications.count_new_comments_subscriptions)
    pub count_new_comments_subscriptions: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientCommentNotifications.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientCommentNotifications {
    fn default() -> &'a CMsgClientCommentNotifications {
        <CMsgClientCommentNotifications as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientCommentNotifications {
    pub fn new() -> CMsgClientCommentNotifications {
        ::std::default::Default::default()
    }

    // optional uint32 count_new_comments = 1;

    pub fn count_new_comments(&self) -> u32 {
        self.count_new_comments.unwrap_or(0)
    }

    pub fn clear_count_new_comments(&mut self) {
        self.count_new_comments = ::std::option::Option::None;
    }

    pub fn has_count_new_comments(&self) -> bool {
        self.count_new_comments.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count_new_comments(&mut self, v: u32) {
        self.count_new_comments = ::std::option::Option::Some(v);
    }

    // optional uint32 count_new_comments_owner = 2;

    pub fn count_new_comments_owner(&self) -> u32 {
        self.count_new_comments_owner.unwrap_or(0)
    }

    pub fn clear_count_new_comments_owner(&mut self) {
        self.count_new_comments_owner = ::std::option::Option::None;
    }

    pub fn has_count_new_comments_owner(&self) -> bool {
        self.count_new_comments_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count_new_comments_owner(&mut self, v: u32) {
        self.count_new_comments_owner = ::std::option::Option::Some(v);
    }

    // optional uint32 count_new_comments_subscriptions = 3;

    pub fn count_new_comments_subscriptions(&self) -> u32 {
        self.count_new_comments_subscriptions.unwrap_or(0)
    }

    pub fn clear_count_new_comments_subscriptions(&mut self) {
        self.count_new_comments_subscriptions = ::std::option::Option::None;
    }

    pub fn has_count_new_comments_subscriptions(&self) -> bool {
        self.count_new_comments_subscriptions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count_new_comments_subscriptions(&mut self, v: u32) {
        self.count_new_comments_subscriptions = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientCommentNotifications {
    const NAME: &'static str = "CMsgClientCommentNotifications";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.count_new_comments = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.count_new_comments_owner = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.count_new_comments_subscriptions = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.count_new_comments {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.count_new_comments_owner {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.count_new_comments_subscriptions {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.count_new_comments {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.count_new_comments_owner {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.count_new_comments_subscriptions {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientCommentNotifications {
        CMsgClientCommentNotifications::new()
    }

    fn clear(&mut self) {
        self.count_new_comments = ::std::option::Option::None;
        self.count_new_comments_owner = ::std::option::Option::None;
        self.count_new_comments_subscriptions = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientCommentNotifications {
        static instance: CMsgClientCommentNotifications = CMsgClientCommentNotifications {
            count_new_comments: ::std::option::Option::None,
            count_new_comments_owner: ::std::option::Option::None,
            count_new_comments_subscriptions: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientRequestCommentNotifications)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRequestCommentNotifications {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRequestCommentNotifications.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestCommentNotifications {
    fn default() -> &'a CMsgClientRequestCommentNotifications {
        <CMsgClientRequestCommentNotifications as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestCommentNotifications {
    pub fn new() -> CMsgClientRequestCommentNotifications {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientRequestCommentNotifications {
    const NAME: &'static str = "CMsgClientRequestCommentNotifications";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRequestCommentNotifications {
        CMsgClientRequestCommentNotifications::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRequestCommentNotifications {
        static instance: CMsgClientRequestCommentNotifications = CMsgClientRequestCommentNotifications {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientOfflineMessageNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientOfflineMessageNotification {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientOfflineMessageNotification.offline_messages)
    pub offline_messages: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientOfflineMessageNotification.friends_with_offline_messages)
    pub friends_with_offline_messages: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientOfflineMessageNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientOfflineMessageNotification {
    fn default() -> &'a CMsgClientOfflineMessageNotification {
        <CMsgClientOfflineMessageNotification as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientOfflineMessageNotification {
    pub fn new() -> CMsgClientOfflineMessageNotification {
        ::std::default::Default::default()
    }

    // optional uint32 offline_messages = 1;

    pub fn offline_messages(&self) -> u32 {
        self.offline_messages.unwrap_or(0)
    }

    pub fn clear_offline_messages(&mut self) {
        self.offline_messages = ::std::option::Option::None;
    }

    pub fn has_offline_messages(&self) -> bool {
        self.offline_messages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offline_messages(&mut self, v: u32) {
        self.offline_messages = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientOfflineMessageNotification {
    const NAME: &'static str = "CMsgClientOfflineMessageNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.offline_messages = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.friends_with_offline_messages)?;
                },
                16 => {
                    self.friends_with_offline_messages.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.offline_messages {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.friends_with_offline_messages {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.offline_messages {
            os.write_uint32(1, v)?;
        }
        for v in &self.friends_with_offline_messages {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientOfflineMessageNotification {
        CMsgClientOfflineMessageNotification::new()
    }

    fn clear(&mut self) {
        self.offline_messages = ::std::option::Option::None;
        self.friends_with_offline_messages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientOfflineMessageNotification {
        static instance: CMsgClientOfflineMessageNotification = CMsgClientOfflineMessageNotification {
            offline_messages: ::std::option::Option::None,
            friends_with_offline_messages: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientRequestOfflineMessageCount)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRequestOfflineMessageCount {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRequestOfflineMessageCount.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestOfflineMessageCount {
    fn default() -> &'a CMsgClientRequestOfflineMessageCount {
        <CMsgClientRequestOfflineMessageCount as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestOfflineMessageCount {
    pub fn new() -> CMsgClientRequestOfflineMessageCount {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientRequestOfflineMessageCount {
    const NAME: &'static str = "CMsgClientRequestOfflineMessageCount";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRequestOfflineMessageCount {
        CMsgClientRequestOfflineMessageCount::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRequestOfflineMessageCount {
        static instance: CMsgClientRequestOfflineMessageCount = CMsgClientRequestOfflineMessageCount {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientChatGetFriendMessageHistory)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientChatGetFriendMessageHistory {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientChatGetFriendMessageHistory.steamid)
    pub steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientChatGetFriendMessageHistory.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientChatGetFriendMessageHistory {
    fn default() -> &'a CMsgClientChatGetFriendMessageHistory {
        <CMsgClientChatGetFriendMessageHistory as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientChatGetFriendMessageHistory {
    pub fn new() -> CMsgClientChatGetFriendMessageHistory {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientChatGetFriendMessageHistory {
    const NAME: &'static str = "CMsgClientChatGetFriendMessageHistory";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientChatGetFriendMessageHistory {
        CMsgClientChatGetFriendMessageHistory::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientChatGetFriendMessageHistory {
        static instance: CMsgClientChatGetFriendMessageHistory = CMsgClientChatGetFriendMessageHistory {
            steamid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientChatGetFriendMessageHistoryResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientChatGetFriendMessageHistoryResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientChatGetFriendMessageHistoryResponse.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientChatGetFriendMessageHistoryResponse.success)
    pub success: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientChatGetFriendMessageHistoryResponse.messages)
    pub messages: ::std::vec::Vec<cmsg_client_chat_get_friend_message_history_response::FriendMessage>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientChatGetFriendMessageHistoryResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientChatGetFriendMessageHistoryResponse {
    fn default() -> &'a CMsgClientChatGetFriendMessageHistoryResponse {
        <CMsgClientChatGetFriendMessageHistoryResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientChatGetFriendMessageHistoryResponse {
    pub fn new() -> CMsgClientChatGetFriendMessageHistoryResponse {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional uint32 success = 2;

    pub fn success(&self) -> u32 {
        self.success.unwrap_or(0)
    }

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: u32) {
        self.success = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientChatGetFriendMessageHistoryResponse {
    const NAME: &'static str = "CMsgClientChatGetFriendMessageHistoryResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.success = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.messages.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.success {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.success {
            os.write_uint32(2, v)?;
        }
        for v in &self.messages {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientChatGetFriendMessageHistoryResponse {
        CMsgClientChatGetFriendMessageHistoryResponse::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.success = ::std::option::Option::None;
        self.messages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientChatGetFriendMessageHistoryResponse {
        static instance: CMsgClientChatGetFriendMessageHistoryResponse = CMsgClientChatGetFriendMessageHistoryResponse {
            steamid: ::std::option::Option::None,
            success: ::std::option::Option::None,
            messages: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientChatGetFriendMessageHistoryResponse`
pub mod cmsg_client_chat_get_friend_message_history_response {
    // @@protoc_insertion_point(message:CMsgClientChatGetFriendMessageHistoryResponse.FriendMessage)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct FriendMessage {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientChatGetFriendMessageHistoryResponse.FriendMessage.accountid)
        pub accountid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientChatGetFriendMessageHistoryResponse.FriendMessage.timestamp)
        pub timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientChatGetFriendMessageHistoryResponse.FriendMessage.message)
        pub message: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientChatGetFriendMessageHistoryResponse.FriendMessage.unread)
        pub unread: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientChatGetFriendMessageHistoryResponse.FriendMessage.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FriendMessage {
        fn default() -> &'a FriendMessage {
            <FriendMessage as ::protobuf::Message>::default_instance()
        }
    }

    impl FriendMessage {
        pub fn new() -> FriendMessage {
            ::std::default::Default::default()
        }

        // optional uint32 accountid = 1;

        pub fn accountid(&self) -> u32 {
            self.accountid.unwrap_or(0)
        }

        pub fn clear_accountid(&mut self) {
            self.accountid = ::std::option::Option::None;
        }

        pub fn has_accountid(&self) -> bool {
            self.accountid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_accountid(&mut self, v: u32) {
            self.accountid = ::std::option::Option::Some(v);
        }

        // optional uint32 timestamp = 2;

        pub fn timestamp(&self) -> u32 {
            self.timestamp.unwrap_or(0)
        }

        pub fn clear_timestamp(&mut self) {
            self.timestamp = ::std::option::Option::None;
        }

        pub fn has_timestamp(&self) -> bool {
            self.timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp(&mut self, v: u32) {
            self.timestamp = ::std::option::Option::Some(v);
        }

        // optional string message = 3;

        pub fn message(&self) -> &str {
            match self.message.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_message(&mut self) {
            self.message = ::std::option::Option::None;
        }

        pub fn has_message(&self) -> bool {
            self.message.is_some()
        }

        // Param is passed by value, moved
        pub fn set_message(&mut self, v: ::std::string::String) {
            self.message = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_message(&mut self) -> &mut ::std::string::String {
            if self.message.is_none() {
                self.message = ::std::option::Option::Some(::std::string::String::new());
            }
            self.message.as_mut().unwrap()
        }

        // Take field
        pub fn take_message(&mut self) -> ::std::string::String {
            self.message.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool unread = 4;

        pub fn unread(&self) -> bool {
            self.unread.unwrap_or(false)
        }

        pub fn clear_unread(&mut self) {
            self.unread = ::std::option::Option::None;
        }

        pub fn has_unread(&self) -> bool {
            self.unread.is_some()
        }

        // Param is passed by value, moved
        pub fn set_unread(&mut self, v: bool) {
            self.unread = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for FriendMessage {
        const NAME: &'static str = "FriendMessage";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.message = ::std::option::Option::Some(is.read_string()?);
                    },
                    32 => {
                        self.unread = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.accountid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.timestamp {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.message.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.unread {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.accountid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.timestamp {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.message.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.unread {
                os.write_bool(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FriendMessage {
            FriendMessage::new()
        }

        fn clear(&mut self) {
            self.accountid = ::std::option::Option::None;
            self.timestamp = ::std::option::Option::None;
            self.message = ::std::option::Option::None;
            self.unread = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FriendMessage {
            static instance: FriendMessage = FriendMessage {
                accountid: ::std::option::Option::None,
                timestamp: ::std::option::Option::None,
                message: ::std::option::Option::None,
                unread: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientChatGetFriendMessageHistoryForOfflineMessages)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientChatGetFriendMessageHistoryForOfflineMessages.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
    fn default() -> &'a CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
        <CMsgClientChatGetFriendMessageHistoryForOfflineMessages as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
    pub fn new() -> CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
    const NAME: &'static str = "CMsgClientChatGetFriendMessageHistoryForOfflineMessages";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
        CMsgClientChatGetFriendMessageHistoryForOfflineMessages::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
        static instance: CMsgClientChatGetFriendMessageHistoryForOfflineMessages = CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientFSGetFriendsSteamLevels)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientFSGetFriendsSteamLevels {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientFSGetFriendsSteamLevels.accountids)
    pub accountids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientFSGetFriendsSteamLevels.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientFSGetFriendsSteamLevels {
    fn default() -> &'a CMsgClientFSGetFriendsSteamLevels {
        <CMsgClientFSGetFriendsSteamLevels as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientFSGetFriendsSteamLevels {
    pub fn new() -> CMsgClientFSGetFriendsSteamLevels {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientFSGetFriendsSteamLevels {
    const NAME: &'static str = "CMsgClientFSGetFriendsSteamLevels";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.accountids)?;
                },
                8 => {
                    self.accountids.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.accountids {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.accountids {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientFSGetFriendsSteamLevels {
        CMsgClientFSGetFriendsSteamLevels::new()
    }

    fn clear(&mut self) {
        self.accountids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientFSGetFriendsSteamLevels {
        static instance: CMsgClientFSGetFriendsSteamLevels = CMsgClientFSGetFriendsSteamLevels {
            accountids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientFSGetFriendsSteamLevelsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientFSGetFriendsSteamLevelsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientFSGetFriendsSteamLevelsResponse.friends)
    pub friends: ::std::vec::Vec<cmsg_client_fsget_friends_steam_levels_response::Friend>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientFSGetFriendsSteamLevelsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientFSGetFriendsSteamLevelsResponse {
    fn default() -> &'a CMsgClientFSGetFriendsSteamLevelsResponse {
        <CMsgClientFSGetFriendsSteamLevelsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientFSGetFriendsSteamLevelsResponse {
    pub fn new() -> CMsgClientFSGetFriendsSteamLevelsResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientFSGetFriendsSteamLevelsResponse {
    const NAME: &'static str = "CMsgClientFSGetFriendsSteamLevelsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.friends.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.friends {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.friends {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientFSGetFriendsSteamLevelsResponse {
        CMsgClientFSGetFriendsSteamLevelsResponse::new()
    }

    fn clear(&mut self) {
        self.friends.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientFSGetFriendsSteamLevelsResponse {
        static instance: CMsgClientFSGetFriendsSteamLevelsResponse = CMsgClientFSGetFriendsSteamLevelsResponse {
            friends: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientFSGetFriendsSteamLevelsResponse`
pub mod cmsg_client_fsget_friends_steam_levels_response {
    // @@protoc_insertion_point(message:CMsgClientFSGetFriendsSteamLevelsResponse.Friend)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Friend {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientFSGetFriendsSteamLevelsResponse.Friend.accountid)
        pub accountid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientFSGetFriendsSteamLevelsResponse.Friend.level)
        pub level: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientFSGetFriendsSteamLevelsResponse.Friend.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Friend {
        fn default() -> &'a Friend {
            <Friend as ::protobuf::Message>::default_instance()
        }
    }

    impl Friend {
        pub fn new() -> Friend {
            ::std::default::Default::default()
        }

        // optional uint32 accountid = 1;

        pub fn accountid(&self) -> u32 {
            self.accountid.unwrap_or(0)
        }

        pub fn clear_accountid(&mut self) {
            self.accountid = ::std::option::Option::None;
        }

        pub fn has_accountid(&self) -> bool {
            self.accountid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_accountid(&mut self, v: u32) {
            self.accountid = ::std::option::Option::Some(v);
        }

        // optional uint32 level = 2;

        pub fn level(&self) -> u32 {
            self.level.unwrap_or(0)
        }

        pub fn clear_level(&mut self) {
            self.level = ::std::option::Option::None;
        }

        pub fn has_level(&self) -> bool {
            self.level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_level(&mut self, v: u32) {
            self.level = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Friend {
        const NAME: &'static str = "Friend";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.level = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.accountid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.level {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.accountid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.level {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Friend {
            Friend::new()
        }

        fn clear(&mut self) {
            self.accountid = ::std::option::Option::None;
            self.level = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Friend {
            static instance: Friend = Friend {
                accountid: ::std::option::Option::None,
                level: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientEmailAddrInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientEmailAddrInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientEmailAddrInfo.email_address)
    pub email_address: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientEmailAddrInfo.email_is_validated)
    pub email_is_validated: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientEmailAddrInfo.email_validation_changed)
    pub email_validation_changed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientEmailAddrInfo.credential_change_requires_code)
    pub credential_change_requires_code: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientEmailAddrInfo.password_or_secretqa_change_requires_code)
    pub password_or_secretqa_change_requires_code: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientEmailAddrInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientEmailAddrInfo {
    fn default() -> &'a CMsgClientEmailAddrInfo {
        <CMsgClientEmailAddrInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientEmailAddrInfo {
    pub fn new() -> CMsgClientEmailAddrInfo {
        ::std::default::Default::default()
    }

    // optional string email_address = 1;

    pub fn email_address(&self) -> &str {
        match self.email_address.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_email_address(&mut self) {
        self.email_address = ::std::option::Option::None;
    }

    pub fn has_email_address(&self) -> bool {
        self.email_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_email_address(&mut self, v: ::std::string::String) {
        self.email_address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_email_address(&mut self) -> &mut ::std::string::String {
        if self.email_address.is_none() {
            self.email_address = ::std::option::Option::Some(::std::string::String::new());
        }
        self.email_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_email_address(&mut self) -> ::std::string::String {
        self.email_address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool email_is_validated = 2;

    pub fn email_is_validated(&self) -> bool {
        self.email_is_validated.unwrap_or(false)
    }

    pub fn clear_email_is_validated(&mut self) {
        self.email_is_validated = ::std::option::Option::None;
    }

    pub fn has_email_is_validated(&self) -> bool {
        self.email_is_validated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_email_is_validated(&mut self, v: bool) {
        self.email_is_validated = ::std::option::Option::Some(v);
    }

    // optional bool email_validation_changed = 3;

    pub fn email_validation_changed(&self) -> bool {
        self.email_validation_changed.unwrap_or(false)
    }

    pub fn clear_email_validation_changed(&mut self) {
        self.email_validation_changed = ::std::option::Option::None;
    }

    pub fn has_email_validation_changed(&self) -> bool {
        self.email_validation_changed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_email_validation_changed(&mut self, v: bool) {
        self.email_validation_changed = ::std::option::Option::Some(v);
    }

    // optional bool credential_change_requires_code = 4;

    pub fn credential_change_requires_code(&self) -> bool {
        self.credential_change_requires_code.unwrap_or(false)
    }

    pub fn clear_credential_change_requires_code(&mut self) {
        self.credential_change_requires_code = ::std::option::Option::None;
    }

    pub fn has_credential_change_requires_code(&self) -> bool {
        self.credential_change_requires_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_credential_change_requires_code(&mut self, v: bool) {
        self.credential_change_requires_code = ::std::option::Option::Some(v);
    }

    // optional bool password_or_secretqa_change_requires_code = 5;

    pub fn password_or_secretqa_change_requires_code(&self) -> bool {
        self.password_or_secretqa_change_requires_code.unwrap_or(false)
    }

    pub fn clear_password_or_secretqa_change_requires_code(&mut self) {
        self.password_or_secretqa_change_requires_code = ::std::option::Option::None;
    }

    pub fn has_password_or_secretqa_change_requires_code(&self) -> bool {
        self.password_or_secretqa_change_requires_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_password_or_secretqa_change_requires_code(&mut self, v: bool) {
        self.password_or_secretqa_change_requires_code = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientEmailAddrInfo {
    const NAME: &'static str = "CMsgClientEmailAddrInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.email_address = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.email_is_validated = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.email_validation_changed = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.credential_change_requires_code = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.password_or_secretqa_change_requires_code = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.email_address.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.email_is_validated {
            my_size += 1 + 1;
        }
        if let Some(v) = self.email_validation_changed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.credential_change_requires_code {
            my_size += 1 + 1;
        }
        if let Some(v) = self.password_or_secretqa_change_requires_code {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.email_address.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.email_is_validated {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.email_validation_changed {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.credential_change_requires_code {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.password_or_secretqa_change_requires_code {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientEmailAddrInfo {
        CMsgClientEmailAddrInfo::new()
    }

    fn clear(&mut self) {
        self.email_address = ::std::option::Option::None;
        self.email_is_validated = ::std::option::Option::None;
        self.email_validation_changed = ::std::option::Option::None;
        self.credential_change_requires_code = ::std::option::Option::None;
        self.password_or_secretqa_change_requires_code = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientEmailAddrInfo {
        static instance: CMsgClientEmailAddrInfo = CMsgClientEmailAddrInfo {
            email_address: ::std::option::Option::None,
            email_is_validated: ::std::option::Option::None,
            email_validation_changed: ::std::option::Option::None,
            credential_change_requires_code: ::std::option::Option::None,
            password_or_secretqa_change_requires_code: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgCREItemVoteSummary)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCREItemVoteSummary {
    // message fields
    // @@protoc_insertion_point(field:CMsgCREItemVoteSummary.published_file_ids)
    pub published_file_ids: ::std::vec::Vec<cmsg_creitem_vote_summary::PublishedFileId>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCREItemVoteSummary.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCREItemVoteSummary {
    fn default() -> &'a CMsgCREItemVoteSummary {
        <CMsgCREItemVoteSummary as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCREItemVoteSummary {
    pub fn new() -> CMsgCREItemVoteSummary {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgCREItemVoteSummary {
    const NAME: &'static str = "CMsgCREItemVoteSummary";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.published_file_ids.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.published_file_ids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.published_file_ids {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCREItemVoteSummary {
        CMsgCREItemVoteSummary::new()
    }

    fn clear(&mut self) {
        self.published_file_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCREItemVoteSummary {
        static instance: CMsgCREItemVoteSummary = CMsgCREItemVoteSummary {
            published_file_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgCREItemVoteSummary`
pub mod cmsg_creitem_vote_summary {
    // @@protoc_insertion_point(message:CMsgCREItemVoteSummary.PublishedFileId)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PublishedFileId {
        // message fields
        // @@protoc_insertion_point(field:CMsgCREItemVoteSummary.PublishedFileId.published_file_id)
        pub published_file_id: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgCREItemVoteSummary.PublishedFileId.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PublishedFileId {
        fn default() -> &'a PublishedFileId {
            <PublishedFileId as ::protobuf::Message>::default_instance()
        }
    }

    impl PublishedFileId {
        pub fn new() -> PublishedFileId {
            ::std::default::Default::default()
        }

        // optional fixed64 published_file_id = 1;

        pub fn published_file_id(&self) -> u64 {
            self.published_file_id.unwrap_or(0)
        }

        pub fn clear_published_file_id(&mut self) {
            self.published_file_id = ::std::option::Option::None;
        }

        pub fn has_published_file_id(&self) -> bool {
            self.published_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_published_file_id(&mut self, v: u64) {
            self.published_file_id = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for PublishedFileId {
        const NAME: &'static str = "PublishedFileId";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.published_file_id {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.published_file_id {
                os.write_fixed64(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PublishedFileId {
            PublishedFileId::new()
        }

        fn clear(&mut self) {
            self.published_file_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PublishedFileId {
            static instance: PublishedFileId = PublishedFileId {
                published_file_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgCREItemVoteSummaryResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCREItemVoteSummaryResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgCREItemVoteSummaryResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgCREItemVoteSummaryResponse.item_vote_summaries)
    pub item_vote_summaries: ::std::vec::Vec<cmsg_creitem_vote_summary_response::ItemVoteSummary>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCREItemVoteSummaryResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCREItemVoteSummaryResponse {
    fn default() -> &'a CMsgCREItemVoteSummaryResponse {
        <CMsgCREItemVoteSummaryResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCREItemVoteSummaryResponse {
    pub fn new() -> CMsgCREItemVoteSummaryResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgCREItemVoteSummaryResponse {
    const NAME: &'static str = "CMsgCREItemVoteSummaryResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.item_vote_summaries.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        for value in &self.item_vote_summaries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        for v in &self.item_vote_summaries {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCREItemVoteSummaryResponse {
        CMsgCREItemVoteSummaryResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.item_vote_summaries.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCREItemVoteSummaryResponse {
        static instance: CMsgCREItemVoteSummaryResponse = CMsgCREItemVoteSummaryResponse {
            eresult: ::std::option::Option::None,
            item_vote_summaries: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgCREItemVoteSummaryResponse`
pub mod cmsg_creitem_vote_summary_response {
    // @@protoc_insertion_point(message:CMsgCREItemVoteSummaryResponse.ItemVoteSummary)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ItemVoteSummary {
        // message fields
        // @@protoc_insertion_point(field:CMsgCREItemVoteSummaryResponse.ItemVoteSummary.published_file_id)
        pub published_file_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgCREItemVoteSummaryResponse.ItemVoteSummary.votes_for)
        pub votes_for: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgCREItemVoteSummaryResponse.ItemVoteSummary.votes_against)
        pub votes_against: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgCREItemVoteSummaryResponse.ItemVoteSummary.reports)
        pub reports: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgCREItemVoteSummaryResponse.ItemVoteSummary.score)
        pub score: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgCREItemVoteSummaryResponse.ItemVoteSummary.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ItemVoteSummary {
        fn default() -> &'a ItemVoteSummary {
            <ItemVoteSummary as ::protobuf::Message>::default_instance()
        }
    }

    impl ItemVoteSummary {
        pub fn new() -> ItemVoteSummary {
            ::std::default::Default::default()
        }

        // optional fixed64 published_file_id = 1;

        pub fn published_file_id(&self) -> u64 {
            self.published_file_id.unwrap_or(0)
        }

        pub fn clear_published_file_id(&mut self) {
            self.published_file_id = ::std::option::Option::None;
        }

        pub fn has_published_file_id(&self) -> bool {
            self.published_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_published_file_id(&mut self, v: u64) {
            self.published_file_id = ::std::option::Option::Some(v);
        }

        // optional int32 votes_for = 2;

        pub fn votes_for(&self) -> i32 {
            self.votes_for.unwrap_or(0)
        }

        pub fn clear_votes_for(&mut self) {
            self.votes_for = ::std::option::Option::None;
        }

        pub fn has_votes_for(&self) -> bool {
            self.votes_for.is_some()
        }

        // Param is passed by value, moved
        pub fn set_votes_for(&mut self, v: i32) {
            self.votes_for = ::std::option::Option::Some(v);
        }

        // optional int32 votes_against = 3;

        pub fn votes_against(&self) -> i32 {
            self.votes_against.unwrap_or(0)
        }

        pub fn clear_votes_against(&mut self) {
            self.votes_against = ::std::option::Option::None;
        }

        pub fn has_votes_against(&self) -> bool {
            self.votes_against.is_some()
        }

        // Param is passed by value, moved
        pub fn set_votes_against(&mut self, v: i32) {
            self.votes_against = ::std::option::Option::Some(v);
        }

        // optional int32 reports = 4;

        pub fn reports(&self) -> i32 {
            self.reports.unwrap_or(0)
        }

        pub fn clear_reports(&mut self) {
            self.reports = ::std::option::Option::None;
        }

        pub fn has_reports(&self) -> bool {
            self.reports.is_some()
        }

        // Param is passed by value, moved
        pub fn set_reports(&mut self, v: i32) {
            self.reports = ::std::option::Option::Some(v);
        }

        // optional float score = 5;

        pub fn score(&self) -> f32 {
            self.score.unwrap_or(0.)
        }

        pub fn clear_score(&mut self) {
            self.score = ::std::option::Option::None;
        }

        pub fn has_score(&self) -> bool {
            self.score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score(&mut self, v: f32) {
            self.score = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for ItemVoteSummary {
        const NAME: &'static str = "ItemVoteSummary";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.votes_for = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.votes_against = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.reports = ::std::option::Option::Some(is.read_int32()?);
                    },
                    45 => {
                        self.score = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.published_file_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.votes_for {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.votes_against {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.reports {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.score {
                my_size += 1 + 4;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.published_file_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.votes_for {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.votes_against {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.reports {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.score {
                os.write_float(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ItemVoteSummary {
            ItemVoteSummary::new()
        }

        fn clear(&mut self) {
            self.published_file_id = ::std::option::Option::None;
            self.votes_for = ::std::option::Option::None;
            self.votes_against = ::std::option::Option::None;
            self.reports = ::std::option::Option::None;
            self.score = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ItemVoteSummary {
            static instance: ItemVoteSummary = ItemVoteSummary {
                published_file_id: ::std::option::Option::None,
                votes_for: ::std::option::Option::None,
                votes_against: ::std::option::Option::None,
                reports: ::std::option::Option::None,
                score: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgCREUpdateUserPublishedItemVote)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCREUpdateUserPublishedItemVote {
    // message fields
    // @@protoc_insertion_point(field:CMsgCREUpdateUserPublishedItemVote.published_file_id)
    pub published_file_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgCREUpdateUserPublishedItemVote.vote_up)
    pub vote_up: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCREUpdateUserPublishedItemVote.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCREUpdateUserPublishedItemVote {
    fn default() -> &'a CMsgCREUpdateUserPublishedItemVote {
        <CMsgCREUpdateUserPublishedItemVote as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCREUpdateUserPublishedItemVote {
    pub fn new() -> CMsgCREUpdateUserPublishedItemVote {
        ::std::default::Default::default()
    }

    // optional fixed64 published_file_id = 1;

    pub fn published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(0)
    }

    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }

    // optional bool vote_up = 2;

    pub fn vote_up(&self) -> bool {
        self.vote_up.unwrap_or(false)
    }

    pub fn clear_vote_up(&mut self) {
        self.vote_up = ::std::option::Option::None;
    }

    pub fn has_vote_up(&self) -> bool {
        self.vote_up.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vote_up(&mut self, v: bool) {
        self.vote_up = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgCREUpdateUserPublishedItemVote {
    const NAME: &'static str = "CMsgCREUpdateUserPublishedItemVote";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.vote_up = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.published_file_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.vote_up {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.published_file_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.vote_up {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCREUpdateUserPublishedItemVote {
        CMsgCREUpdateUserPublishedItemVote::new()
    }

    fn clear(&mut self) {
        self.published_file_id = ::std::option::Option::None;
        self.vote_up = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCREUpdateUserPublishedItemVote {
        static instance: CMsgCREUpdateUserPublishedItemVote = CMsgCREUpdateUserPublishedItemVote {
            published_file_id: ::std::option::Option::None,
            vote_up: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgCREUpdateUserPublishedItemVoteResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCREUpdateUserPublishedItemVoteResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgCREUpdateUserPublishedItemVoteResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCREUpdateUserPublishedItemVoteResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCREUpdateUserPublishedItemVoteResponse {
    fn default() -> &'a CMsgCREUpdateUserPublishedItemVoteResponse {
        <CMsgCREUpdateUserPublishedItemVoteResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCREUpdateUserPublishedItemVoteResponse {
    pub fn new() -> CMsgCREUpdateUserPublishedItemVoteResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgCREUpdateUserPublishedItemVoteResponse {
    const NAME: &'static str = "CMsgCREUpdateUserPublishedItemVoteResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCREUpdateUserPublishedItemVoteResponse {
        CMsgCREUpdateUserPublishedItemVoteResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCREUpdateUserPublishedItemVoteResponse {
        static instance: CMsgCREUpdateUserPublishedItemVoteResponse = CMsgCREUpdateUserPublishedItemVoteResponse {
            eresult: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgCREGetUserPublishedItemVoteDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCREGetUserPublishedItemVoteDetails {
    // message fields
    // @@protoc_insertion_point(field:CMsgCREGetUserPublishedItemVoteDetails.published_file_ids)
    pub published_file_ids: ::std::vec::Vec<cmsg_creget_user_published_item_vote_details::PublishedFileId>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCREGetUserPublishedItemVoteDetails.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCREGetUserPublishedItemVoteDetails {
    fn default() -> &'a CMsgCREGetUserPublishedItemVoteDetails {
        <CMsgCREGetUserPublishedItemVoteDetails as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCREGetUserPublishedItemVoteDetails {
    pub fn new() -> CMsgCREGetUserPublishedItemVoteDetails {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgCREGetUserPublishedItemVoteDetails {
    const NAME: &'static str = "CMsgCREGetUserPublishedItemVoteDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.published_file_ids.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.published_file_ids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.published_file_ids {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCREGetUserPublishedItemVoteDetails {
        CMsgCREGetUserPublishedItemVoteDetails::new()
    }

    fn clear(&mut self) {
        self.published_file_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCREGetUserPublishedItemVoteDetails {
        static instance: CMsgCREGetUserPublishedItemVoteDetails = CMsgCREGetUserPublishedItemVoteDetails {
            published_file_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgCREGetUserPublishedItemVoteDetails`
pub mod cmsg_creget_user_published_item_vote_details {
    // @@protoc_insertion_point(message:CMsgCREGetUserPublishedItemVoteDetails.PublishedFileId)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PublishedFileId {
        // message fields
        // @@protoc_insertion_point(field:CMsgCREGetUserPublishedItemVoteDetails.PublishedFileId.published_file_id)
        pub published_file_id: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgCREGetUserPublishedItemVoteDetails.PublishedFileId.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PublishedFileId {
        fn default() -> &'a PublishedFileId {
            <PublishedFileId as ::protobuf::Message>::default_instance()
        }
    }

    impl PublishedFileId {
        pub fn new() -> PublishedFileId {
            ::std::default::Default::default()
        }

        // optional fixed64 published_file_id = 1;

        pub fn published_file_id(&self) -> u64 {
            self.published_file_id.unwrap_or(0)
        }

        pub fn clear_published_file_id(&mut self) {
            self.published_file_id = ::std::option::Option::None;
        }

        pub fn has_published_file_id(&self) -> bool {
            self.published_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_published_file_id(&mut self, v: u64) {
            self.published_file_id = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for PublishedFileId {
        const NAME: &'static str = "PublishedFileId";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.published_file_id {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.published_file_id {
                os.write_fixed64(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PublishedFileId {
            PublishedFileId::new()
        }

        fn clear(&mut self) {
            self.published_file_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PublishedFileId {
            static instance: PublishedFileId = PublishedFileId {
                published_file_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgCREGetUserPublishedItemVoteDetailsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCREGetUserPublishedItemVoteDetailsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgCREGetUserPublishedItemVoteDetailsResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgCREGetUserPublishedItemVoteDetailsResponse.user_item_vote_details)
    pub user_item_vote_details: ::std::vec::Vec<cmsg_creget_user_published_item_vote_details_response::UserItemVoteDetail>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCREGetUserPublishedItemVoteDetailsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCREGetUserPublishedItemVoteDetailsResponse {
    fn default() -> &'a CMsgCREGetUserPublishedItemVoteDetailsResponse {
        <CMsgCREGetUserPublishedItemVoteDetailsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCREGetUserPublishedItemVoteDetailsResponse {
    pub fn new() -> CMsgCREGetUserPublishedItemVoteDetailsResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgCREGetUserPublishedItemVoteDetailsResponse {
    const NAME: &'static str = "CMsgCREGetUserPublishedItemVoteDetailsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.user_item_vote_details.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        for value in &self.user_item_vote_details {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        for v in &self.user_item_vote_details {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCREGetUserPublishedItemVoteDetailsResponse {
        CMsgCREGetUserPublishedItemVoteDetailsResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.user_item_vote_details.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCREGetUserPublishedItemVoteDetailsResponse {
        static instance: CMsgCREGetUserPublishedItemVoteDetailsResponse = CMsgCREGetUserPublishedItemVoteDetailsResponse {
            eresult: ::std::option::Option::None,
            user_item_vote_details: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgCREGetUserPublishedItemVoteDetailsResponse`
pub mod cmsg_creget_user_published_item_vote_details_response {
    // @@protoc_insertion_point(message:CMsgCREGetUserPublishedItemVoteDetailsResponse.UserItemVoteDetail)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct UserItemVoteDetail {
        // message fields
        // @@protoc_insertion_point(field:CMsgCREGetUserPublishedItemVoteDetailsResponse.UserItemVoteDetail.published_file_id)
        pub published_file_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgCREGetUserPublishedItemVoteDetailsResponse.UserItemVoteDetail.vote)
        pub vote: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgCREGetUserPublishedItemVoteDetailsResponse.UserItemVoteDetail.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a UserItemVoteDetail {
        fn default() -> &'a UserItemVoteDetail {
            <UserItemVoteDetail as ::protobuf::Message>::default_instance()
        }
    }

    impl UserItemVoteDetail {
        pub fn new() -> UserItemVoteDetail {
            ::std::default::Default::default()
        }

        // optional fixed64 published_file_id = 1;

        pub fn published_file_id(&self) -> u64 {
            self.published_file_id.unwrap_or(0)
        }

        pub fn clear_published_file_id(&mut self) {
            self.published_file_id = ::std::option::Option::None;
        }

        pub fn has_published_file_id(&self) -> bool {
            self.published_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_published_file_id(&mut self, v: u64) {
            self.published_file_id = ::std::option::Option::Some(v);
        }

        // optional int32 vote = 2;

        pub fn vote(&self) -> i32 {
            self.vote.unwrap_or(0i32)
        }

        pub fn clear_vote(&mut self) {
            self.vote = ::std::option::Option::None;
        }

        pub fn has_vote(&self) -> bool {
            self.vote.is_some()
        }

        // Param is passed by value, moved
        pub fn set_vote(&mut self, v: i32) {
            self.vote = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for UserItemVoteDetail {
        const NAME: &'static str = "UserItemVoteDetail";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.vote = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.published_file_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.vote {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.published_file_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.vote {
                os.write_int32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> UserItemVoteDetail {
            UserItemVoteDetail::new()
        }

        fn clear(&mut self) {
            self.published_file_id = ::std::option::Option::None;
            self.vote = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static UserItemVoteDetail {
            static instance: UserItemVoteDetail = UserItemVoteDetail {
                published_file_id: ::std::option::Option::None,
                vote: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgFSGetFollowerCount)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFSGetFollowerCount {
    // message fields
    // @@protoc_insertion_point(field:CMsgFSGetFollowerCount.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFSGetFollowerCount.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFSGetFollowerCount {
    fn default() -> &'a CMsgFSGetFollowerCount {
        <CMsgFSGetFollowerCount as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFSGetFollowerCount {
    pub fn new() -> CMsgFSGetFollowerCount {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgFSGetFollowerCount {
    const NAME: &'static str = "CMsgFSGetFollowerCount";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFSGetFollowerCount {
        CMsgFSGetFollowerCount::new()
    }

    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFSGetFollowerCount {
        static instance: CMsgFSGetFollowerCount = CMsgFSGetFollowerCount {
            steam_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgFSGetFollowerCountResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFSGetFollowerCountResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgFSGetFollowerCountResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgFSGetFollowerCountResponse.count)
    pub count: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFSGetFollowerCountResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFSGetFollowerCountResponse {
    fn default() -> &'a CMsgFSGetFollowerCountResponse {
        <CMsgFSGetFollowerCountResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFSGetFollowerCountResponse {
    pub fn new() -> CMsgFSGetFollowerCountResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional int32 count = 2;

    pub fn count(&self) -> i32 {
        self.count.unwrap_or(0i32)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i32) {
        self.count = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgFSGetFollowerCountResponse {
    const NAME: &'static str = "CMsgFSGetFollowerCountResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.count = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.count {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFSGetFollowerCountResponse {
        CMsgFSGetFollowerCountResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFSGetFollowerCountResponse {
        static instance: CMsgFSGetFollowerCountResponse = CMsgFSGetFollowerCountResponse {
            eresult: ::std::option::Option::None,
            count: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgFSGetIsFollowing)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFSGetIsFollowing {
    // message fields
    // @@protoc_insertion_point(field:CMsgFSGetIsFollowing.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFSGetIsFollowing.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFSGetIsFollowing {
    fn default() -> &'a CMsgFSGetIsFollowing {
        <CMsgFSGetIsFollowing as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFSGetIsFollowing {
    pub fn new() -> CMsgFSGetIsFollowing {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgFSGetIsFollowing {
    const NAME: &'static str = "CMsgFSGetIsFollowing";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFSGetIsFollowing {
        CMsgFSGetIsFollowing::new()
    }

    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFSGetIsFollowing {
        static instance: CMsgFSGetIsFollowing = CMsgFSGetIsFollowing {
            steam_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgFSGetIsFollowingResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFSGetIsFollowingResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgFSGetIsFollowingResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgFSGetIsFollowingResponse.is_following)
    pub is_following: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFSGetIsFollowingResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFSGetIsFollowingResponse {
    fn default() -> &'a CMsgFSGetIsFollowingResponse {
        <CMsgFSGetIsFollowingResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFSGetIsFollowingResponse {
    pub fn new() -> CMsgFSGetIsFollowingResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional bool is_following = 2;

    pub fn is_following(&self) -> bool {
        self.is_following.unwrap_or(false)
    }

    pub fn clear_is_following(&mut self) {
        self.is_following = ::std::option::Option::None;
    }

    pub fn has_is_following(&self) -> bool {
        self.is_following.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_following(&mut self, v: bool) {
        self.is_following = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgFSGetIsFollowingResponse {
    const NAME: &'static str = "CMsgFSGetIsFollowingResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.is_following = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.is_following {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.is_following {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFSGetIsFollowingResponse {
        CMsgFSGetIsFollowingResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.is_following = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFSGetIsFollowingResponse {
        static instance: CMsgFSGetIsFollowingResponse = CMsgFSGetIsFollowingResponse {
            eresult: ::std::option::Option::None,
            is_following: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgFSEnumerateFollowingList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFSEnumerateFollowingList {
    // message fields
    // @@protoc_insertion_point(field:CMsgFSEnumerateFollowingList.start_index)
    pub start_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFSEnumerateFollowingList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFSEnumerateFollowingList {
    fn default() -> &'a CMsgFSEnumerateFollowingList {
        <CMsgFSEnumerateFollowingList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFSEnumerateFollowingList {
    pub fn new() -> CMsgFSEnumerateFollowingList {
        ::std::default::Default::default()
    }

    // optional uint32 start_index = 1;

    pub fn start_index(&self) -> u32 {
        self.start_index.unwrap_or(0)
    }

    pub fn clear_start_index(&mut self) {
        self.start_index = ::std::option::Option::None;
    }

    pub fn has_start_index(&self) -> bool {
        self.start_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_index(&mut self, v: u32) {
        self.start_index = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgFSEnumerateFollowingList {
    const NAME: &'static str = "CMsgFSEnumerateFollowingList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.start_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.start_index {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.start_index {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFSEnumerateFollowingList {
        CMsgFSEnumerateFollowingList::new()
    }

    fn clear(&mut self) {
        self.start_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFSEnumerateFollowingList {
        static instance: CMsgFSEnumerateFollowingList = CMsgFSEnumerateFollowingList {
            start_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgFSEnumerateFollowingListResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFSEnumerateFollowingListResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgFSEnumerateFollowingListResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgFSEnumerateFollowingListResponse.total_results)
    pub total_results: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgFSEnumerateFollowingListResponse.steam_ids)
    pub steam_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFSEnumerateFollowingListResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFSEnumerateFollowingListResponse {
    fn default() -> &'a CMsgFSEnumerateFollowingListResponse {
        <CMsgFSEnumerateFollowingListResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFSEnumerateFollowingListResponse {
    pub fn new() -> CMsgFSEnumerateFollowingListResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional int32 total_results = 2;

    pub fn total_results(&self) -> i32 {
        self.total_results.unwrap_or(0)
    }

    pub fn clear_total_results(&mut self) {
        self.total_results = ::std::option::Option::None;
    }

    pub fn has_total_results(&self) -> bool {
        self.total_results.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_results(&mut self, v: i32) {
        self.total_results = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgFSEnumerateFollowingListResponse {
    const NAME: &'static str = "CMsgFSEnumerateFollowingListResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.total_results = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    is.read_repeated_packed_fixed64_into(&mut self.steam_ids)?;
                },
                25 => {
                    self.steam_ids.push(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.total_results {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += 9 * self.steam_ids.len() as u64;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.total_results {
            os.write_int32(2, v)?;
        }
        for v in &self.steam_ids {
            os.write_fixed64(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFSEnumerateFollowingListResponse {
        CMsgFSEnumerateFollowingListResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.total_results = ::std::option::Option::None;
        self.steam_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFSEnumerateFollowingListResponse {
        static instance: CMsgFSEnumerateFollowingListResponse = CMsgFSEnumerateFollowingListResponse {
            eresult: ::std::option::Option::None,
            total_results: ::std::option::Option::None,
            steam_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDPGetNumberOfCurrentPlayers)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDPGetNumberOfCurrentPlayers {
    // message fields
    // @@protoc_insertion_point(field:CMsgDPGetNumberOfCurrentPlayers.appid)
    pub appid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDPGetNumberOfCurrentPlayers.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDPGetNumberOfCurrentPlayers {
    fn default() -> &'a CMsgDPGetNumberOfCurrentPlayers {
        <CMsgDPGetNumberOfCurrentPlayers as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDPGetNumberOfCurrentPlayers {
    pub fn new() -> CMsgDPGetNumberOfCurrentPlayers {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgDPGetNumberOfCurrentPlayers {
    const NAME: &'static str = "CMsgDPGetNumberOfCurrentPlayers";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDPGetNumberOfCurrentPlayers {
        CMsgDPGetNumberOfCurrentPlayers::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDPGetNumberOfCurrentPlayers {
        static instance: CMsgDPGetNumberOfCurrentPlayers = CMsgDPGetNumberOfCurrentPlayers {
            appid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDPGetNumberOfCurrentPlayersResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDPGetNumberOfCurrentPlayersResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgDPGetNumberOfCurrentPlayersResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgDPGetNumberOfCurrentPlayersResponse.player_count)
    pub player_count: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDPGetNumberOfCurrentPlayersResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDPGetNumberOfCurrentPlayersResponse {
    fn default() -> &'a CMsgDPGetNumberOfCurrentPlayersResponse {
        <CMsgDPGetNumberOfCurrentPlayersResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDPGetNumberOfCurrentPlayersResponse {
    pub fn new() -> CMsgDPGetNumberOfCurrentPlayersResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional int32 player_count = 2;

    pub fn player_count(&self) -> i32 {
        self.player_count.unwrap_or(0)
    }

    pub fn clear_player_count(&mut self) {
        self.player_count = ::std::option::Option::None;
    }

    pub fn has_player_count(&self) -> bool {
        self.player_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_count(&mut self, v: i32) {
        self.player_count = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgDPGetNumberOfCurrentPlayersResponse {
    const NAME: &'static str = "CMsgDPGetNumberOfCurrentPlayersResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.player_count = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.player_count {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.player_count {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDPGetNumberOfCurrentPlayersResponse {
        CMsgDPGetNumberOfCurrentPlayersResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.player_count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDPGetNumberOfCurrentPlayersResponse {
        static instance: CMsgDPGetNumberOfCurrentPlayersResponse = CMsgDPGetNumberOfCurrentPlayersResponse {
            eresult: ::std::option::Option::None,
            player_count: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientFriendUserStatusPublished)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientFriendUserStatusPublished {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientFriendUserStatusPublished.friend_steamid)
    pub friend_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientFriendUserStatusPublished.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientFriendUserStatusPublished.status_text)
    pub status_text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientFriendUserStatusPublished.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientFriendUserStatusPublished {
    fn default() -> &'a CMsgClientFriendUserStatusPublished {
        <CMsgClientFriendUserStatusPublished as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientFriendUserStatusPublished {
    pub fn new() -> CMsgClientFriendUserStatusPublished {
        ::std::default::Default::default()
    }

    // optional fixed64 friend_steamid = 1;

    pub fn friend_steamid(&self) -> u64 {
        self.friend_steamid.unwrap_or(0)
    }

    pub fn clear_friend_steamid(&mut self) {
        self.friend_steamid = ::std::option::Option::None;
    }

    pub fn has_friend_steamid(&self) -> bool {
        self.friend_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friend_steamid(&mut self, v: u64) {
        self.friend_steamid = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 2;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string status_text = 3;

    pub fn status_text(&self) -> &str {
        match self.status_text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_status_text(&mut self) {
        self.status_text = ::std::option::Option::None;
    }

    pub fn has_status_text(&self) -> bool {
        self.status_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status_text(&mut self, v: ::std::string::String) {
        self.status_text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status_text(&mut self) -> &mut ::std::string::String {
        if self.status_text.is_none() {
            self.status_text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.status_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_status_text(&mut self) -> ::std::string::String {
        self.status_text.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientFriendUserStatusPublished {
    const NAME: &'static str = "CMsgClientFriendUserStatusPublished";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.friend_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.status_text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.friend_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.status_text.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.friend_steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.status_text.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientFriendUserStatusPublished {
        CMsgClientFriendUserStatusPublished::new()
    }

    fn clear(&mut self) {
        self.friend_steamid = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.status_text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientFriendUserStatusPublished {
        static instance: CMsgClientFriendUserStatusPublished = CMsgClientFriendUserStatusPublished {
            friend_steamid: ::std::option::Option::None,
            appid: ::std::option::Option::None,
            status_text: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientServiceMethodLegacy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientServiceMethodLegacy {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientServiceMethodLegacy.method_name)
    pub method_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientServiceMethodLegacy.serialized_method)
    pub serialized_method: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientServiceMethodLegacy.is_notification)
    pub is_notification: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientServiceMethodLegacy.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientServiceMethodLegacy {
    fn default() -> &'a CMsgClientServiceMethodLegacy {
        <CMsgClientServiceMethodLegacy as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientServiceMethodLegacy {
    pub fn new() -> CMsgClientServiceMethodLegacy {
        ::std::default::Default::default()
    }

    // optional string method_name = 1;

    pub fn method_name(&self) -> &str {
        match self.method_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_method_name(&mut self) {
        self.method_name = ::std::option::Option::None;
    }

    pub fn has_method_name(&self) -> bool {
        self.method_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_method_name(&mut self, v: ::std::string::String) {
        self.method_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_method_name(&mut self) -> &mut ::std::string::String {
        if self.method_name.is_none() {
            self.method_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.method_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_method_name(&mut self) -> ::std::string::String {
        self.method_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes serialized_method = 2;

    pub fn serialized_method(&self) -> &[u8] {
        match self.serialized_method.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_serialized_method(&mut self) {
        self.serialized_method = ::std::option::Option::None;
    }

    pub fn has_serialized_method(&self) -> bool {
        self.serialized_method.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serialized_method(&mut self, v: ::std::vec::Vec<u8>) {
        self.serialized_method = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serialized_method(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.serialized_method.is_none() {
            self.serialized_method = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.serialized_method.as_mut().unwrap()
    }

    // Take field
    pub fn take_serialized_method(&mut self) -> ::std::vec::Vec<u8> {
        self.serialized_method.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool is_notification = 3;

    pub fn is_notification(&self) -> bool {
        self.is_notification.unwrap_or(false)
    }

    pub fn clear_is_notification(&mut self) {
        self.is_notification = ::std::option::Option::None;
    }

    pub fn has_is_notification(&self) -> bool {
        self.is_notification.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_notification(&mut self, v: bool) {
        self.is_notification = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientServiceMethodLegacy {
    const NAME: &'static str = "CMsgClientServiceMethodLegacy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.method_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.serialized_method = ::std::option::Option::Some(is.read_bytes()?);
                },
                24 => {
                    self.is_notification = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.method_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.serialized_method.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.is_notification {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.method_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.serialized_method.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.is_notification {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientServiceMethodLegacy {
        CMsgClientServiceMethodLegacy::new()
    }

    fn clear(&mut self) {
        self.method_name = ::std::option::Option::None;
        self.serialized_method = ::std::option::Option::None;
        self.is_notification = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientServiceMethodLegacy {
        static instance: CMsgClientServiceMethodLegacy = CMsgClientServiceMethodLegacy {
            method_name: ::std::option::Option::None,
            serialized_method: ::std::option::Option::None,
            is_notification: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientServiceMethodLegacyResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientServiceMethodLegacyResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientServiceMethodLegacyResponse.method_name)
    pub method_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientServiceMethodLegacyResponse.serialized_method_response)
    pub serialized_method_response: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientServiceMethodLegacyResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientServiceMethodLegacyResponse {
    fn default() -> &'a CMsgClientServiceMethodLegacyResponse {
        <CMsgClientServiceMethodLegacyResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientServiceMethodLegacyResponse {
    pub fn new() -> CMsgClientServiceMethodLegacyResponse {
        ::std::default::Default::default()
    }

    // optional string method_name = 1;

    pub fn method_name(&self) -> &str {
        match self.method_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_method_name(&mut self) {
        self.method_name = ::std::option::Option::None;
    }

    pub fn has_method_name(&self) -> bool {
        self.method_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_method_name(&mut self, v: ::std::string::String) {
        self.method_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_method_name(&mut self) -> &mut ::std::string::String {
        if self.method_name.is_none() {
            self.method_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.method_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_method_name(&mut self) -> ::std::string::String {
        self.method_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes serialized_method_response = 2;

    pub fn serialized_method_response(&self) -> &[u8] {
        match self.serialized_method_response.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_serialized_method_response(&mut self) {
        self.serialized_method_response = ::std::option::Option::None;
    }

    pub fn has_serialized_method_response(&self) -> bool {
        self.serialized_method_response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serialized_method_response(&mut self, v: ::std::vec::Vec<u8>) {
        self.serialized_method_response = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serialized_method_response(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.serialized_method_response.is_none() {
            self.serialized_method_response = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.serialized_method_response.as_mut().unwrap()
    }

    // Take field
    pub fn take_serialized_method_response(&mut self) -> ::std::vec::Vec<u8> {
        self.serialized_method_response.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientServiceMethodLegacyResponse {
    const NAME: &'static str = "CMsgClientServiceMethodLegacyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.method_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.serialized_method_response = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.method_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.serialized_method_response.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.method_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.serialized_method_response.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientServiceMethodLegacyResponse {
        CMsgClientServiceMethodLegacyResponse::new()
    }

    fn clear(&mut self) {
        self.method_name = ::std::option::Option::None;
        self.serialized_method_response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientServiceMethodLegacyResponse {
        static instance: CMsgClientServiceMethodLegacyResponse = CMsgClientServiceMethodLegacyResponse {
            method_name: ::std::option::Option::None,
            serialized_method_response: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientUIMode)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUIMode {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUIMode.uimode)
    pub uimode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUIMode.chat_mode)
    pub chat_mode: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUIMode.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUIMode {
    fn default() -> &'a CMsgClientUIMode {
        <CMsgClientUIMode as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUIMode {
    pub fn new() -> CMsgClientUIMode {
        ::std::default::Default::default()
    }

    // optional uint32 uimode = 1;

    pub fn uimode(&self) -> u32 {
        self.uimode.unwrap_or(0)
    }

    pub fn clear_uimode(&mut self) {
        self.uimode = ::std::option::Option::None;
    }

    pub fn has_uimode(&self) -> bool {
        self.uimode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uimode(&mut self, v: u32) {
        self.uimode = ::std::option::Option::Some(v);
    }

    // optional uint32 chat_mode = 2;

    pub fn chat_mode(&self) -> u32 {
        self.chat_mode.unwrap_or(0)
    }

    pub fn clear_chat_mode(&mut self) {
        self.chat_mode = ::std::option::Option::None;
    }

    pub fn has_chat_mode(&self) -> bool {
        self.chat_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_mode(&mut self, v: u32) {
        self.chat_mode = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUIMode {
    const NAME: &'static str = "CMsgClientUIMode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.uimode = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.chat_mode = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.uimode {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.chat_mode {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.uimode {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.chat_mode {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUIMode {
        CMsgClientUIMode::new()
    }

    fn clear(&mut self) {
        self.uimode = ::std::option::Option::None;
        self.chat_mode = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUIMode {
        static instance: CMsgClientUIMode = CMsgClientUIMode {
            uimode: ::std::option::Option::None,
            chat_mode: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientVanityURLChangedNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientVanityURLChangedNotification {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientVanityURLChangedNotification.vanity_url)
    pub vanity_url: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientVanityURLChangedNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientVanityURLChangedNotification {
    fn default() -> &'a CMsgClientVanityURLChangedNotification {
        <CMsgClientVanityURLChangedNotification as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientVanityURLChangedNotification {
    pub fn new() -> CMsgClientVanityURLChangedNotification {
        ::std::default::Default::default()
    }

    // optional string vanity_url = 1;

    pub fn vanity_url(&self) -> &str {
        match self.vanity_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_vanity_url(&mut self) {
        self.vanity_url = ::std::option::Option::None;
    }

    pub fn has_vanity_url(&self) -> bool {
        self.vanity_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vanity_url(&mut self, v: ::std::string::String) {
        self.vanity_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vanity_url(&mut self) -> &mut ::std::string::String {
        if self.vanity_url.is_none() {
            self.vanity_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.vanity_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_vanity_url(&mut self) -> ::std::string::String {
        self.vanity_url.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientVanityURLChangedNotification {
    const NAME: &'static str = "CMsgClientVanityURLChangedNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.vanity_url = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.vanity_url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.vanity_url.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientVanityURLChangedNotification {
        CMsgClientVanityURLChangedNotification::new()
    }

    fn clear(&mut self) {
        self.vanity_url = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientVanityURLChangedNotification {
        static instance: CMsgClientVanityURLChangedNotification = CMsgClientVanityURLChangedNotification {
            vanity_url: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientAuthorizeLocalDeviceRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientAuthorizeLocalDeviceRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientAuthorizeLocalDeviceRequest.device_description)
    pub device_description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientAuthorizeLocalDeviceRequest.owner_account_id)
    pub owner_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientAuthorizeLocalDeviceRequest.local_device_token)
    pub local_device_token: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientAuthorizeLocalDeviceRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientAuthorizeLocalDeviceRequest {
    fn default() -> &'a CMsgClientAuthorizeLocalDeviceRequest {
        <CMsgClientAuthorizeLocalDeviceRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAuthorizeLocalDeviceRequest {
    pub fn new() -> CMsgClientAuthorizeLocalDeviceRequest {
        ::std::default::Default::default()
    }

    // optional string device_description = 1;

    pub fn device_description(&self) -> &str {
        match self.device_description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_device_description(&mut self) {
        self.device_description = ::std::option::Option::None;
    }

    pub fn has_device_description(&self) -> bool {
        self.device_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_description(&mut self, v: ::std::string::String) {
        self.device_description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_description(&mut self) -> &mut ::std::string::String {
        if self.device_description.is_none() {
            self.device_description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.device_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_description(&mut self) -> ::std::string::String {
        self.device_description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 owner_account_id = 2;

    pub fn owner_account_id(&self) -> u32 {
        self.owner_account_id.unwrap_or(0)
    }

    pub fn clear_owner_account_id(&mut self) {
        self.owner_account_id = ::std::option::Option::None;
    }

    pub fn has_owner_account_id(&self) -> bool {
        self.owner_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_account_id(&mut self, v: u32) {
        self.owner_account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 local_device_token = 3;

    pub fn local_device_token(&self) -> u64 {
        self.local_device_token.unwrap_or(0)
    }

    pub fn clear_local_device_token(&mut self) {
        self.local_device_token = ::std::option::Option::None;
    }

    pub fn has_local_device_token(&self) -> bool {
        self.local_device_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local_device_token(&mut self, v: u64) {
        self.local_device_token = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientAuthorizeLocalDeviceRequest {
    const NAME: &'static str = "CMsgClientAuthorizeLocalDeviceRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.device_description = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.owner_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.local_device_token = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.device_description.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.owner_account_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.local_device_token {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.device_description.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.owner_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.local_device_token {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientAuthorizeLocalDeviceRequest {
        CMsgClientAuthorizeLocalDeviceRequest::new()
    }

    fn clear(&mut self) {
        self.device_description = ::std::option::Option::None;
        self.owner_account_id = ::std::option::Option::None;
        self.local_device_token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientAuthorizeLocalDeviceRequest {
        static instance: CMsgClientAuthorizeLocalDeviceRequest = CMsgClientAuthorizeLocalDeviceRequest {
            device_description: ::std::option::Option::None,
            owner_account_id: ::std::option::Option::None,
            local_device_token: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientAuthorizeLocalDevice)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientAuthorizeLocalDevice {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientAuthorizeLocalDevice.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientAuthorizeLocalDevice.owner_account_id)
    pub owner_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientAuthorizeLocalDevice.authed_device_token)
    pub authed_device_token: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientAuthorizeLocalDevice.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientAuthorizeLocalDevice {
    fn default() -> &'a CMsgClientAuthorizeLocalDevice {
        <CMsgClientAuthorizeLocalDevice as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAuthorizeLocalDevice {
    pub fn new() -> CMsgClientAuthorizeLocalDevice {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 owner_account_id = 2;

    pub fn owner_account_id(&self) -> u32 {
        self.owner_account_id.unwrap_or(0)
    }

    pub fn clear_owner_account_id(&mut self) {
        self.owner_account_id = ::std::option::Option::None;
    }

    pub fn has_owner_account_id(&self) -> bool {
        self.owner_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_account_id(&mut self, v: u32) {
        self.owner_account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 authed_device_token = 3;

    pub fn authed_device_token(&self) -> u64 {
        self.authed_device_token.unwrap_or(0)
    }

    pub fn clear_authed_device_token(&mut self) {
        self.authed_device_token = ::std::option::Option::None;
    }

    pub fn has_authed_device_token(&self) -> bool {
        self.authed_device_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authed_device_token(&mut self, v: u64) {
        self.authed_device_token = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientAuthorizeLocalDevice {
    const NAME: &'static str = "CMsgClientAuthorizeLocalDevice";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.owner_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.authed_device_token = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.owner_account_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.authed_device_token {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.owner_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.authed_device_token {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientAuthorizeLocalDevice {
        CMsgClientAuthorizeLocalDevice::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.owner_account_id = ::std::option::Option::None;
        self.authed_device_token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientAuthorizeLocalDevice {
        static instance: CMsgClientAuthorizeLocalDevice = CMsgClientAuthorizeLocalDevice {
            eresult: ::std::option::Option::None,
            owner_account_id: ::std::option::Option::None,
            authed_device_token: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientAuthorizeLocalDeviceNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientAuthorizeLocalDeviceNotification {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientAuthorizeLocalDeviceNotification.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientAuthorizeLocalDeviceNotification.owner_account_id)
    pub owner_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientAuthorizeLocalDeviceNotification.local_device_token)
    pub local_device_token: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientAuthorizeLocalDeviceNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientAuthorizeLocalDeviceNotification {
    fn default() -> &'a CMsgClientAuthorizeLocalDeviceNotification {
        <CMsgClientAuthorizeLocalDeviceNotification as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAuthorizeLocalDeviceNotification {
    pub fn new() -> CMsgClientAuthorizeLocalDeviceNotification {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 owner_account_id = 2;

    pub fn owner_account_id(&self) -> u32 {
        self.owner_account_id.unwrap_or(0)
    }

    pub fn clear_owner_account_id(&mut self) {
        self.owner_account_id = ::std::option::Option::None;
    }

    pub fn has_owner_account_id(&self) -> bool {
        self.owner_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_account_id(&mut self, v: u32) {
        self.owner_account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 local_device_token = 3;

    pub fn local_device_token(&self) -> u64 {
        self.local_device_token.unwrap_or(0)
    }

    pub fn clear_local_device_token(&mut self) {
        self.local_device_token = ::std::option::Option::None;
    }

    pub fn has_local_device_token(&self) -> bool {
        self.local_device_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local_device_token(&mut self, v: u64) {
        self.local_device_token = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientAuthorizeLocalDeviceNotification {
    const NAME: &'static str = "CMsgClientAuthorizeLocalDeviceNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.owner_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.local_device_token = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.owner_account_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.local_device_token {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.owner_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.local_device_token {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientAuthorizeLocalDeviceNotification {
        CMsgClientAuthorizeLocalDeviceNotification::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.owner_account_id = ::std::option::Option::None;
        self.local_device_token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientAuthorizeLocalDeviceNotification {
        static instance: CMsgClientAuthorizeLocalDeviceNotification = CMsgClientAuthorizeLocalDeviceNotification {
            eresult: ::std::option::Option::None,
            owner_account_id: ::std::option::Option::None,
            local_device_token: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientDeauthorizeDeviceRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientDeauthorizeDeviceRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientDeauthorizeDeviceRequest.deauthorization_account_id)
    pub deauthorization_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientDeauthorizeDeviceRequest.deauthorization_device_token)
    pub deauthorization_device_token: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientDeauthorizeDeviceRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientDeauthorizeDeviceRequest {
    fn default() -> &'a CMsgClientDeauthorizeDeviceRequest {
        <CMsgClientDeauthorizeDeviceRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientDeauthorizeDeviceRequest {
    pub fn new() -> CMsgClientDeauthorizeDeviceRequest {
        ::std::default::Default::default()
    }

    // optional uint32 deauthorization_account_id = 1;

    pub fn deauthorization_account_id(&self) -> u32 {
        self.deauthorization_account_id.unwrap_or(0)
    }

    pub fn clear_deauthorization_account_id(&mut self) {
        self.deauthorization_account_id = ::std::option::Option::None;
    }

    pub fn has_deauthorization_account_id(&self) -> bool {
        self.deauthorization_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deauthorization_account_id(&mut self, v: u32) {
        self.deauthorization_account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 deauthorization_device_token = 2;

    pub fn deauthorization_device_token(&self) -> u64 {
        self.deauthorization_device_token.unwrap_or(0)
    }

    pub fn clear_deauthorization_device_token(&mut self) {
        self.deauthorization_device_token = ::std::option::Option::None;
    }

    pub fn has_deauthorization_device_token(&self) -> bool {
        self.deauthorization_device_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deauthorization_device_token(&mut self, v: u64) {
        self.deauthorization_device_token = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientDeauthorizeDeviceRequest {
    const NAME: &'static str = "CMsgClientDeauthorizeDeviceRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.deauthorization_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.deauthorization_device_token = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.deauthorization_account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.deauthorization_device_token {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.deauthorization_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.deauthorization_device_token {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientDeauthorizeDeviceRequest {
        CMsgClientDeauthorizeDeviceRequest::new()
    }

    fn clear(&mut self) {
        self.deauthorization_account_id = ::std::option::Option::None;
        self.deauthorization_device_token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientDeauthorizeDeviceRequest {
        static instance: CMsgClientDeauthorizeDeviceRequest = CMsgClientDeauthorizeDeviceRequest {
            deauthorization_account_id: ::std::option::Option::None,
            deauthorization_device_token: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientDeauthorizeDevice)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientDeauthorizeDevice {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientDeauthorizeDevice.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientDeauthorizeDevice.deauthorization_account_id)
    pub deauthorization_account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientDeauthorizeDevice.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientDeauthorizeDevice {
    fn default() -> &'a CMsgClientDeauthorizeDevice {
        <CMsgClientDeauthorizeDevice as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientDeauthorizeDevice {
    pub fn new() -> CMsgClientDeauthorizeDevice {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 deauthorization_account_id = 2;

    pub fn deauthorization_account_id(&self) -> u32 {
        self.deauthorization_account_id.unwrap_or(0)
    }

    pub fn clear_deauthorization_account_id(&mut self) {
        self.deauthorization_account_id = ::std::option::Option::None;
    }

    pub fn has_deauthorization_account_id(&self) -> bool {
        self.deauthorization_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deauthorization_account_id(&mut self, v: u32) {
        self.deauthorization_account_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientDeauthorizeDevice {
    const NAME: &'static str = "CMsgClientDeauthorizeDevice";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.deauthorization_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.deauthorization_account_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.deauthorization_account_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientDeauthorizeDevice {
        CMsgClientDeauthorizeDevice::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.deauthorization_account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientDeauthorizeDevice {
        static instance: CMsgClientDeauthorizeDevice = CMsgClientDeauthorizeDevice {
            eresult: ::std::option::Option::None,
            deauthorization_account_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientUseLocalDeviceAuthorizations)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUseLocalDeviceAuthorizations {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUseLocalDeviceAuthorizations.authorization_account_id)
    pub authorization_account_id: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgClientUseLocalDeviceAuthorizations.device_tokens)
    pub device_tokens: ::std::vec::Vec<cmsg_client_use_local_device_authorizations::DeviceToken>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUseLocalDeviceAuthorizations.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUseLocalDeviceAuthorizations {
    fn default() -> &'a CMsgClientUseLocalDeviceAuthorizations {
        <CMsgClientUseLocalDeviceAuthorizations as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUseLocalDeviceAuthorizations {
    pub fn new() -> CMsgClientUseLocalDeviceAuthorizations {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientUseLocalDeviceAuthorizations {
    const NAME: &'static str = "CMsgClientUseLocalDeviceAuthorizations";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.authorization_account_id)?;
                },
                8 => {
                    self.authorization_account_id.push(is.read_uint32()?);
                },
                18 => {
                    self.device_tokens.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.authorization_account_id {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        for value in &self.device_tokens {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.authorization_account_id {
            os.write_uint32(1, *v)?;
        };
        for v in &self.device_tokens {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUseLocalDeviceAuthorizations {
        CMsgClientUseLocalDeviceAuthorizations::new()
    }

    fn clear(&mut self) {
        self.authorization_account_id.clear();
        self.device_tokens.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUseLocalDeviceAuthorizations {
        static instance: CMsgClientUseLocalDeviceAuthorizations = CMsgClientUseLocalDeviceAuthorizations {
            authorization_account_id: ::std::vec::Vec::new(),
            device_tokens: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientUseLocalDeviceAuthorizations`
pub mod cmsg_client_use_local_device_authorizations {
    // @@protoc_insertion_point(message:CMsgClientUseLocalDeviceAuthorizations.DeviceToken)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DeviceToken {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientUseLocalDeviceAuthorizations.DeviceToken.owner_account_id)
        pub owner_account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientUseLocalDeviceAuthorizations.DeviceToken.token_id)
        pub token_id: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientUseLocalDeviceAuthorizations.DeviceToken.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DeviceToken {
        fn default() -> &'a DeviceToken {
            <DeviceToken as ::protobuf::Message>::default_instance()
        }
    }

    impl DeviceToken {
        pub fn new() -> DeviceToken {
            ::std::default::Default::default()
        }

        // optional uint32 owner_account_id = 1;

        pub fn owner_account_id(&self) -> u32 {
            self.owner_account_id.unwrap_or(0)
        }

        pub fn clear_owner_account_id(&mut self) {
            self.owner_account_id = ::std::option::Option::None;
        }

        pub fn has_owner_account_id(&self) -> bool {
            self.owner_account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_owner_account_id(&mut self, v: u32) {
            self.owner_account_id = ::std::option::Option::Some(v);
        }

        // optional uint64 token_id = 2;

        pub fn token_id(&self) -> u64 {
            self.token_id.unwrap_or(0)
        }

        pub fn clear_token_id(&mut self) {
            self.token_id = ::std::option::Option::None;
        }

        pub fn has_token_id(&self) -> bool {
            self.token_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_token_id(&mut self, v: u64) {
            self.token_id = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for DeviceToken {
        const NAME: &'static str = "DeviceToken";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.owner_account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.token_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.owner_account_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.token_id {
                my_size += ::protobuf::rt::uint64_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.owner_account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.token_id {
                os.write_uint64(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DeviceToken {
            DeviceToken::new()
        }

        fn clear(&mut self) {
            self.owner_account_id = ::std::option::Option::None;
            self.token_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DeviceToken {
            static instance: DeviceToken = DeviceToken {
                owner_account_id: ::std::option::Option::None,
                token_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientGetAuthorizedDevices)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGetAuthorizedDevices {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetAuthorizedDevices.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetAuthorizedDevices {
    fn default() -> &'a CMsgClientGetAuthorizedDevices {
        <CMsgClientGetAuthorizedDevices as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetAuthorizedDevices {
    pub fn new() -> CMsgClientGetAuthorizedDevices {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientGetAuthorizedDevices {
    const NAME: &'static str = "CMsgClientGetAuthorizedDevices";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetAuthorizedDevices {
        CMsgClientGetAuthorizedDevices::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetAuthorizedDevices {
        static instance: CMsgClientGetAuthorizedDevices = CMsgClientGetAuthorizedDevices {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientGetAuthorizedDevicesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGetAuthorizedDevicesResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGetAuthorizedDevicesResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientGetAuthorizedDevicesResponse.authorized_device)
    pub authorized_device: ::std::vec::Vec<cmsg_client_get_authorized_devices_response::AuthorizedDevice>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetAuthorizedDevicesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetAuthorizedDevicesResponse {
    fn default() -> &'a CMsgClientGetAuthorizedDevicesResponse {
        <CMsgClientGetAuthorizedDevicesResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetAuthorizedDevicesResponse {
    pub fn new() -> CMsgClientGetAuthorizedDevicesResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientGetAuthorizedDevicesResponse {
    const NAME: &'static str = "CMsgClientGetAuthorizedDevicesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.authorized_device.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        for value in &self.authorized_device {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        for v in &self.authorized_device {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetAuthorizedDevicesResponse {
        CMsgClientGetAuthorizedDevicesResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.authorized_device.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetAuthorizedDevicesResponse {
        static instance: CMsgClientGetAuthorizedDevicesResponse = CMsgClientGetAuthorizedDevicesResponse {
            eresult: ::std::option::Option::None,
            authorized_device: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientGetAuthorizedDevicesResponse`
pub mod cmsg_client_get_authorized_devices_response {
    // @@protoc_insertion_point(message:CMsgClientGetAuthorizedDevicesResponse.AuthorizedDevice)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AuthorizedDevice {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientGetAuthorizedDevicesResponse.AuthorizedDevice.auth_device_token)
        pub auth_device_token: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientGetAuthorizedDevicesResponse.AuthorizedDevice.device_name)
        pub device_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientGetAuthorizedDevicesResponse.AuthorizedDevice.last_access_time)
        pub last_access_time: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGetAuthorizedDevicesResponse.AuthorizedDevice.borrower_id)
        pub borrower_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGetAuthorizedDevicesResponse.AuthorizedDevice.is_pending)
        pub is_pending: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgClientGetAuthorizedDevicesResponse.AuthorizedDevice.app_played)
        pub app_played: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientGetAuthorizedDevicesResponse.AuthorizedDevice.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AuthorizedDevice {
        fn default() -> &'a AuthorizedDevice {
            <AuthorizedDevice as ::protobuf::Message>::default_instance()
        }
    }

    impl AuthorizedDevice {
        pub fn new() -> AuthorizedDevice {
            ::std::default::Default::default()
        }

        // optional uint64 auth_device_token = 1;

        pub fn auth_device_token(&self) -> u64 {
            self.auth_device_token.unwrap_or(0)
        }

        pub fn clear_auth_device_token(&mut self) {
            self.auth_device_token = ::std::option::Option::None;
        }

        pub fn has_auth_device_token(&self) -> bool {
            self.auth_device_token.is_some()
        }

        // Param is passed by value, moved
        pub fn set_auth_device_token(&mut self, v: u64) {
            self.auth_device_token = ::std::option::Option::Some(v);
        }

        // optional string device_name = 2;

        pub fn device_name(&self) -> &str {
            match self.device_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_device_name(&mut self) {
            self.device_name = ::std::option::Option::None;
        }

        pub fn has_device_name(&self) -> bool {
            self.device_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_device_name(&mut self, v: ::std::string::String) {
            self.device_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_device_name(&mut self) -> &mut ::std::string::String {
            if self.device_name.is_none() {
                self.device_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.device_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_device_name(&mut self) -> ::std::string::String {
            self.device_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 last_access_time = 3;

        pub fn last_access_time(&self) -> u32 {
            self.last_access_time.unwrap_or(0)
        }

        pub fn clear_last_access_time(&mut self) {
            self.last_access_time = ::std::option::Option::None;
        }

        pub fn has_last_access_time(&self) -> bool {
            self.last_access_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_last_access_time(&mut self, v: u32) {
            self.last_access_time = ::std::option::Option::Some(v);
        }

        // optional uint32 borrower_id = 4;

        pub fn borrower_id(&self) -> u32 {
            self.borrower_id.unwrap_or(0)
        }

        pub fn clear_borrower_id(&mut self) {
            self.borrower_id = ::std::option::Option::None;
        }

        pub fn has_borrower_id(&self) -> bool {
            self.borrower_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_borrower_id(&mut self, v: u32) {
            self.borrower_id = ::std::option::Option::Some(v);
        }

        // optional bool is_pending = 5;

        pub fn is_pending(&self) -> bool {
            self.is_pending.unwrap_or(false)
        }

        pub fn clear_is_pending(&mut self) {
            self.is_pending = ::std::option::Option::None;
        }

        pub fn has_is_pending(&self) -> bool {
            self.is_pending.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_pending(&mut self, v: bool) {
            self.is_pending = ::std::option::Option::Some(v);
        }

        // optional uint32 app_played = 6;

        pub fn app_played(&self) -> u32 {
            self.app_played.unwrap_or(0)
        }

        pub fn clear_app_played(&mut self) {
            self.app_played = ::std::option::Option::None;
        }

        pub fn has_app_played(&self) -> bool {
            self.app_played.is_some()
        }

        // Param is passed by value, moved
        pub fn set_app_played(&mut self, v: u32) {
            self.app_played = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for AuthorizedDevice {
        const NAME: &'static str = "AuthorizedDevice";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.auth_device_token = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    18 => {
                        self.device_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.last_access_time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.borrower_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.is_pending = ::std::option::Option::Some(is.read_bool()?);
                    },
                    48 => {
                        self.app_played = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.auth_device_token {
                my_size += ::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.device_name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.last_access_time {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.borrower_id {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.is_pending {
                my_size += 1 + 1;
            }
            if let Some(v) = self.app_played {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.auth_device_token {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.device_name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.last_access_time {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.borrower_id {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.is_pending {
                os.write_bool(5, v)?;
            }
            if let Some(v) = self.app_played {
                os.write_uint32(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AuthorizedDevice {
            AuthorizedDevice::new()
        }

        fn clear(&mut self) {
            self.auth_device_token = ::std::option::Option::None;
            self.device_name = ::std::option::Option::None;
            self.last_access_time = ::std::option::Option::None;
            self.borrower_id = ::std::option::Option::None;
            self.is_pending = ::std::option::Option::None;
            self.app_played = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AuthorizedDevice {
            static instance: AuthorizedDevice = AuthorizedDevice {
                auth_device_token: ::std::option::Option::None,
                device_name: ::std::option::Option::None,
                last_access_time: ::std::option::Option::None,
                borrower_id: ::std::option::Option::None,
                is_pending: ::std::option::Option::None,
                app_played: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientSharedLibraryLockStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientSharedLibraryLockStatus {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientSharedLibraryLockStatus.locked_library)
    pub locked_library: ::std::vec::Vec<cmsg_client_shared_library_lock_status::LockedLibrary>,
    // @@protoc_insertion_point(field:CMsgClientSharedLibraryLockStatus.own_library_locked_by)
    pub own_library_locked_by: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientSharedLibraryLockStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientSharedLibraryLockStatus {
    fn default() -> &'a CMsgClientSharedLibraryLockStatus {
        <CMsgClientSharedLibraryLockStatus as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientSharedLibraryLockStatus {
    pub fn new() -> CMsgClientSharedLibraryLockStatus {
        ::std::default::Default::default()
    }

    // optional uint32 own_library_locked_by = 2;

    pub fn own_library_locked_by(&self) -> u32 {
        self.own_library_locked_by.unwrap_or(0)
    }

    pub fn clear_own_library_locked_by(&mut self) {
        self.own_library_locked_by = ::std::option::Option::None;
    }

    pub fn has_own_library_locked_by(&self) -> bool {
        self.own_library_locked_by.is_some()
    }

    // Param is passed by value, moved
    pub fn set_own_library_locked_by(&mut self, v: u32) {
        self.own_library_locked_by = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientSharedLibraryLockStatus {
    const NAME: &'static str = "CMsgClientSharedLibraryLockStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.locked_library.push(is.read_message()?);
                },
                16 => {
                    self.own_library_locked_by = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.locked_library {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.own_library_locked_by {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.locked_library {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.own_library_locked_by {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientSharedLibraryLockStatus {
        CMsgClientSharedLibraryLockStatus::new()
    }

    fn clear(&mut self) {
        self.locked_library.clear();
        self.own_library_locked_by = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientSharedLibraryLockStatus {
        static instance: CMsgClientSharedLibraryLockStatus = CMsgClientSharedLibraryLockStatus {
            locked_library: ::std::vec::Vec::new(),
            own_library_locked_by: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientSharedLibraryLockStatus`
pub mod cmsg_client_shared_library_lock_status {
    // @@protoc_insertion_point(message:CMsgClientSharedLibraryLockStatus.LockedLibrary)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LockedLibrary {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientSharedLibraryLockStatus.LockedLibrary.owner_id)
        pub owner_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientSharedLibraryLockStatus.LockedLibrary.locked_by)
        pub locked_by: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientSharedLibraryLockStatus.LockedLibrary.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LockedLibrary {
        fn default() -> &'a LockedLibrary {
            <LockedLibrary as ::protobuf::Message>::default_instance()
        }
    }

    impl LockedLibrary {
        pub fn new() -> LockedLibrary {
            ::std::default::Default::default()
        }

        // optional uint32 owner_id = 1;

        pub fn owner_id(&self) -> u32 {
            self.owner_id.unwrap_or(0)
        }

        pub fn clear_owner_id(&mut self) {
            self.owner_id = ::std::option::Option::None;
        }

        pub fn has_owner_id(&self) -> bool {
            self.owner_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_owner_id(&mut self, v: u32) {
            self.owner_id = ::std::option::Option::Some(v);
        }

        // optional uint32 locked_by = 2;

        pub fn locked_by(&self) -> u32 {
            self.locked_by.unwrap_or(0)
        }

        pub fn clear_locked_by(&mut self) {
            self.locked_by = ::std::option::Option::None;
        }

        pub fn has_locked_by(&self) -> bool {
            self.locked_by.is_some()
        }

        // Param is passed by value, moved
        pub fn set_locked_by(&mut self, v: u32) {
            self.locked_by = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for LockedLibrary {
        const NAME: &'static str = "LockedLibrary";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.owner_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.locked_by = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.owner_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.locked_by {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.owner_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.locked_by {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LockedLibrary {
            LockedLibrary::new()
        }

        fn clear(&mut self) {
            self.owner_id = ::std::option::Option::None;
            self.locked_by = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LockedLibrary {
            static instance: LockedLibrary = LockedLibrary {
                owner_id: ::std::option::Option::None,
                locked_by: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientSharedLibraryStopPlaying)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientSharedLibraryStopPlaying {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientSharedLibraryStopPlaying.seconds_left)
    pub seconds_left: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientSharedLibraryStopPlaying.stop_apps)
    pub stop_apps: ::std::vec::Vec<cmsg_client_shared_library_stop_playing::StopApp>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientSharedLibraryStopPlaying.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientSharedLibraryStopPlaying {
    fn default() -> &'a CMsgClientSharedLibraryStopPlaying {
        <CMsgClientSharedLibraryStopPlaying as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientSharedLibraryStopPlaying {
    pub fn new() -> CMsgClientSharedLibraryStopPlaying {
        ::std::default::Default::default()
    }

    // optional int32 seconds_left = 1;

    pub fn seconds_left(&self) -> i32 {
        self.seconds_left.unwrap_or(0)
    }

    pub fn clear_seconds_left(&mut self) {
        self.seconds_left = ::std::option::Option::None;
    }

    pub fn has_seconds_left(&self) -> bool {
        self.seconds_left.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_left(&mut self, v: i32) {
        self.seconds_left = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientSharedLibraryStopPlaying {
    const NAME: &'static str = "CMsgClientSharedLibraryStopPlaying";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.seconds_left = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.stop_apps.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.seconds_left {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        for value in &self.stop_apps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.seconds_left {
            os.write_int32(1, v)?;
        }
        for v in &self.stop_apps {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientSharedLibraryStopPlaying {
        CMsgClientSharedLibraryStopPlaying::new()
    }

    fn clear(&mut self) {
        self.seconds_left = ::std::option::Option::None;
        self.stop_apps.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientSharedLibraryStopPlaying {
        static instance: CMsgClientSharedLibraryStopPlaying = CMsgClientSharedLibraryStopPlaying {
            seconds_left: ::std::option::Option::None,
            stop_apps: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientSharedLibraryStopPlaying`
pub mod cmsg_client_shared_library_stop_playing {
    // @@protoc_insertion_point(message:CMsgClientSharedLibraryStopPlaying.StopApp)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct StopApp {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientSharedLibraryStopPlaying.StopApp.app_id)
        pub app_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientSharedLibraryStopPlaying.StopApp.owner_id)
        pub owner_id: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientSharedLibraryStopPlaying.StopApp.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a StopApp {
        fn default() -> &'a StopApp {
            <StopApp as ::protobuf::Message>::default_instance()
        }
    }

    impl StopApp {
        pub fn new() -> StopApp {
            ::std::default::Default::default()
        }

        // optional uint32 app_id = 1;

        pub fn app_id(&self) -> u32 {
            self.app_id.unwrap_or(0)
        }

        pub fn clear_app_id(&mut self) {
            self.app_id = ::std::option::Option::None;
        }

        pub fn has_app_id(&self) -> bool {
            self.app_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_app_id(&mut self, v: u32) {
            self.app_id = ::std::option::Option::Some(v);
        }

        // optional uint32 owner_id = 2;

        pub fn owner_id(&self) -> u32 {
            self.owner_id.unwrap_or(0)
        }

        pub fn clear_owner_id(&mut self) {
            self.owner_id = ::std::option::Option::None;
        }

        pub fn has_owner_id(&self) -> bool {
            self.owner_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_owner_id(&mut self, v: u32) {
            self.owner_id = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for StopApp {
        const NAME: &'static str = "StopApp";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.owner_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.app_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.owner_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.app_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.owner_id {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> StopApp {
            StopApp::new()
        }

        fn clear(&mut self) {
            self.app_id = ::std::option::Option::None;
            self.owner_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static StopApp {
            static instance: StopApp = StopApp {
                app_id: ::std::option::Option::None,
                owner_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientServiceCall)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientServiceCall {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientServiceCall.sysid_routing)
    pub sysid_routing: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientServiceCall.call_handle)
    pub call_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientServiceCall.module_crc)
    pub module_crc: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientServiceCall.module_hash)
    pub module_hash: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientServiceCall.function_id)
    pub function_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientServiceCall.cub_output_max)
    pub cub_output_max: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientServiceCall.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientServiceCall.callparameter)
    pub callparameter: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientServiceCall.ping_only)
    pub ping_only: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientServiceCall.max_outstanding_calls)
    pub max_outstanding_calls: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientServiceCall.app_id)
    pub app_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientServiceCall.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientServiceCall {
    fn default() -> &'a CMsgClientServiceCall {
        <CMsgClientServiceCall as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientServiceCall {
    pub fn new() -> CMsgClientServiceCall {
        ::std::default::Default::default()
    }

    // optional bytes sysid_routing = 1;

    pub fn sysid_routing(&self) -> &[u8] {
        match self.sysid_routing.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_sysid_routing(&mut self) {
        self.sysid_routing = ::std::option::Option::None;
    }

    pub fn has_sysid_routing(&self) -> bool {
        self.sysid_routing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sysid_routing(&mut self, v: ::std::vec::Vec<u8>) {
        self.sysid_routing = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sysid_routing(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sysid_routing.is_none() {
            self.sysid_routing = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.sysid_routing.as_mut().unwrap()
    }

    // Take field
    pub fn take_sysid_routing(&mut self) -> ::std::vec::Vec<u8> {
        self.sysid_routing.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 call_handle = 2;

    pub fn call_handle(&self) -> u32 {
        self.call_handle.unwrap_or(0)
    }

    pub fn clear_call_handle(&mut self) {
        self.call_handle = ::std::option::Option::None;
    }

    pub fn has_call_handle(&self) -> bool {
        self.call_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_call_handle(&mut self, v: u32) {
        self.call_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 module_crc = 3;

    pub fn module_crc(&self) -> u32 {
        self.module_crc.unwrap_or(0)
    }

    pub fn clear_module_crc(&mut self) {
        self.module_crc = ::std::option::Option::None;
    }

    pub fn has_module_crc(&self) -> bool {
        self.module_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_crc(&mut self, v: u32) {
        self.module_crc = ::std::option::Option::Some(v);
    }

    // optional bytes module_hash = 4;

    pub fn module_hash(&self) -> &[u8] {
        match self.module_hash.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_module_hash(&mut self) {
        self.module_hash = ::std::option::Option::None;
    }

    pub fn has_module_hash(&self) -> bool {
        self.module_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.module_hash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.module_hash.is_none() {
            self.module_hash = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.module_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_module_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.module_hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 function_id = 5;

    pub fn function_id(&self) -> u32 {
        self.function_id.unwrap_or(0)
    }

    pub fn clear_function_id(&mut self) {
        self.function_id = ::std::option::Option::None;
    }

    pub fn has_function_id(&self) -> bool {
        self.function_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_function_id(&mut self, v: u32) {
        self.function_id = ::std::option::Option::Some(v);
    }

    // optional uint32 cub_output_max = 6;

    pub fn cub_output_max(&self) -> u32 {
        self.cub_output_max.unwrap_or(0)
    }

    pub fn clear_cub_output_max(&mut self) {
        self.cub_output_max = ::std::option::Option::None;
    }

    pub fn has_cub_output_max(&self) -> bool {
        self.cub_output_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cub_output_max(&mut self, v: u32) {
        self.cub_output_max = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 7;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional bytes callparameter = 8;

    pub fn callparameter(&self) -> &[u8] {
        match self.callparameter.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_callparameter(&mut self) {
        self.callparameter = ::std::option::Option::None;
    }

    pub fn has_callparameter(&self) -> bool {
        self.callparameter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_callparameter(&mut self, v: ::std::vec::Vec<u8>) {
        self.callparameter = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_callparameter(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.callparameter.is_none() {
            self.callparameter = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.callparameter.as_mut().unwrap()
    }

    // Take field
    pub fn take_callparameter(&mut self) -> ::std::vec::Vec<u8> {
        self.callparameter.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool ping_only = 9;

    pub fn ping_only(&self) -> bool {
        self.ping_only.unwrap_or(false)
    }

    pub fn clear_ping_only(&mut self) {
        self.ping_only = ::std::option::Option::None;
    }

    pub fn has_ping_only(&self) -> bool {
        self.ping_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_only(&mut self, v: bool) {
        self.ping_only = ::std::option::Option::Some(v);
    }

    // optional uint32 max_outstanding_calls = 10;

    pub fn max_outstanding_calls(&self) -> u32 {
        self.max_outstanding_calls.unwrap_or(0)
    }

    pub fn clear_max_outstanding_calls(&mut self) {
        self.max_outstanding_calls = ::std::option::Option::None;
    }

    pub fn has_max_outstanding_calls(&self) -> bool {
        self.max_outstanding_calls.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_outstanding_calls(&mut self, v: u32) {
        self.max_outstanding_calls = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 11;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientServiceCall {
    const NAME: &'static str = "CMsgClientServiceCall";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.sysid_routing = ::std::option::Option::Some(is.read_bytes()?);
                },
                16 => {
                    self.call_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.module_crc = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.module_hash = ::std::option::Option::Some(is.read_bytes()?);
                },
                40 => {
                    self.function_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.cub_output_max = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.callparameter = ::std::option::Option::Some(is.read_bytes()?);
                },
                72 => {
                    self.ping_only = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.max_outstanding_calls = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.sysid_routing.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.call_handle {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.module_crc {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.module_hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.function_id {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.cub_output_max {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.callparameter.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.ping_only {
            my_size += 1 + 1;
        }
        if let Some(v) = self.max_outstanding_calls {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.sysid_routing.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.call_handle {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.module_crc {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.module_hash.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.function_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.cub_output_max {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.callparameter.as_ref() {
            os.write_bytes(8, v)?;
        }
        if let Some(v) = self.ping_only {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.max_outstanding_calls {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientServiceCall {
        CMsgClientServiceCall::new()
    }

    fn clear(&mut self) {
        self.sysid_routing = ::std::option::Option::None;
        self.call_handle = ::std::option::Option::None;
        self.module_crc = ::std::option::Option::None;
        self.module_hash = ::std::option::Option::None;
        self.function_id = ::std::option::Option::None;
        self.cub_output_max = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.callparameter = ::std::option::Option::None;
        self.ping_only = ::std::option::Option::None;
        self.max_outstanding_calls = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientServiceCall {
        static instance: CMsgClientServiceCall = CMsgClientServiceCall {
            sysid_routing: ::std::option::Option::None,
            call_handle: ::std::option::Option::None,
            module_crc: ::std::option::Option::None,
            module_hash: ::std::option::Option::None,
            function_id: ::std::option::Option::None,
            cub_output_max: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            callparameter: ::std::option::Option::None,
            ping_only: ::std::option::Option::None,
            max_outstanding_calls: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientServiceModule)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientServiceModule {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientServiceModule.module_crc)
    pub module_crc: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientServiceModule.module_hash)
    pub module_hash: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientServiceModule.module_content)
    pub module_content: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientServiceModule.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientServiceModule {
    fn default() -> &'a CMsgClientServiceModule {
        <CMsgClientServiceModule as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientServiceModule {
    pub fn new() -> CMsgClientServiceModule {
        ::std::default::Default::default()
    }

    // optional uint32 module_crc = 1;

    pub fn module_crc(&self) -> u32 {
        self.module_crc.unwrap_or(0)
    }

    pub fn clear_module_crc(&mut self) {
        self.module_crc = ::std::option::Option::None;
    }

    pub fn has_module_crc(&self) -> bool {
        self.module_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_crc(&mut self, v: u32) {
        self.module_crc = ::std::option::Option::Some(v);
    }

    // optional bytes module_hash = 2;

    pub fn module_hash(&self) -> &[u8] {
        match self.module_hash.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_module_hash(&mut self) {
        self.module_hash = ::std::option::Option::None;
    }

    pub fn has_module_hash(&self) -> bool {
        self.module_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.module_hash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.module_hash.is_none() {
            self.module_hash = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.module_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_module_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.module_hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes module_content = 3;

    pub fn module_content(&self) -> &[u8] {
        match self.module_content.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_module_content(&mut self) {
        self.module_content = ::std::option::Option::None;
    }

    pub fn has_module_content(&self) -> bool {
        self.module_content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_content(&mut self, v: ::std::vec::Vec<u8>) {
        self.module_content = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module_content(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.module_content.is_none() {
            self.module_content = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.module_content.as_mut().unwrap()
    }

    // Take field
    pub fn take_module_content(&mut self) -> ::std::vec::Vec<u8> {
        self.module_content.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientServiceModule {
    const NAME: &'static str = "CMsgClientServiceModule";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.module_crc = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.module_hash = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    self.module_content = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.module_crc {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.module_hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.module_content.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.module_crc {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.module_hash.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.module_content.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientServiceModule {
        CMsgClientServiceModule::new()
    }

    fn clear(&mut self) {
        self.module_crc = ::std::option::Option::None;
        self.module_hash = ::std::option::Option::None;
        self.module_content = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientServiceModule {
        static instance: CMsgClientServiceModule = CMsgClientServiceModule {
            module_crc: ::std::option::Option::None,
            module_hash: ::std::option::Option::None,
            module_content: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientServiceCallResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientServiceCallResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.sysid_routing)
    pub sysid_routing: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.call_handle)
    pub call_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.module_crc)
    pub module_crc: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.module_hash)
    pub module_hash: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.ecallresult)
    pub ecallresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.result_content)
    pub result_content: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.os_version_info)
    pub os_version_info: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.system_info)
    pub system_info: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.load_address)
    pub load_address: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.exception_record)
    pub exception_record: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.portable_os_version_info)
    pub portable_os_version_info: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.portable_system_info)
    pub portable_system_info: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.was_converted)
    pub was_converted: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.internal_result)
    pub internal_result: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.current_count)
    pub current_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.last_call_handle)
    pub last_call_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.last_call_module_crc)
    pub last_call_module_crc: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.last_call_sysid_routing)
    pub last_call_sysid_routing: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.last_ecallresult)
    pub last_ecallresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.last_callissue_delta)
    pub last_callissue_delta: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.last_callcomplete_delta)
    pub last_callcomplete_delta: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientServiceCallResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientServiceCallResponse {
    fn default() -> &'a CMsgClientServiceCallResponse {
        <CMsgClientServiceCallResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientServiceCallResponse {
    pub fn new() -> CMsgClientServiceCallResponse {
        ::std::default::Default::default()
    }

    // optional bytes sysid_routing = 1;

    pub fn sysid_routing(&self) -> &[u8] {
        match self.sysid_routing.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_sysid_routing(&mut self) {
        self.sysid_routing = ::std::option::Option::None;
    }

    pub fn has_sysid_routing(&self) -> bool {
        self.sysid_routing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sysid_routing(&mut self, v: ::std::vec::Vec<u8>) {
        self.sysid_routing = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sysid_routing(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sysid_routing.is_none() {
            self.sysid_routing = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.sysid_routing.as_mut().unwrap()
    }

    // Take field
    pub fn take_sysid_routing(&mut self) -> ::std::vec::Vec<u8> {
        self.sysid_routing.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 call_handle = 2;

    pub fn call_handle(&self) -> u32 {
        self.call_handle.unwrap_or(0)
    }

    pub fn clear_call_handle(&mut self) {
        self.call_handle = ::std::option::Option::None;
    }

    pub fn has_call_handle(&self) -> bool {
        self.call_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_call_handle(&mut self, v: u32) {
        self.call_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 module_crc = 3;

    pub fn module_crc(&self) -> u32 {
        self.module_crc.unwrap_or(0)
    }

    pub fn clear_module_crc(&mut self) {
        self.module_crc = ::std::option::Option::None;
    }

    pub fn has_module_crc(&self) -> bool {
        self.module_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_crc(&mut self, v: u32) {
        self.module_crc = ::std::option::Option::Some(v);
    }

    // optional bytes module_hash = 4;

    pub fn module_hash(&self) -> &[u8] {
        match self.module_hash.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_module_hash(&mut self) {
        self.module_hash = ::std::option::Option::None;
    }

    pub fn has_module_hash(&self) -> bool {
        self.module_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.module_hash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.module_hash.is_none() {
            self.module_hash = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.module_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_module_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.module_hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 ecallresult = 5;

    pub fn ecallresult(&self) -> u32 {
        self.ecallresult.unwrap_or(0)
    }

    pub fn clear_ecallresult(&mut self) {
        self.ecallresult = ::std::option::Option::None;
    }

    pub fn has_ecallresult(&self) -> bool {
        self.ecallresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ecallresult(&mut self, v: u32) {
        self.ecallresult = ::std::option::Option::Some(v);
    }

    // optional bytes result_content = 6;

    pub fn result_content(&self) -> &[u8] {
        match self.result_content.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_result_content(&mut self) {
        self.result_content = ::std::option::Option::None;
    }

    pub fn has_result_content(&self) -> bool {
        self.result_content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result_content(&mut self, v: ::std::vec::Vec<u8>) {
        self.result_content = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result_content(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.result_content.is_none() {
            self.result_content = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.result_content.as_mut().unwrap()
    }

    // Take field
    pub fn take_result_content(&mut self) -> ::std::vec::Vec<u8> {
        self.result_content.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes os_version_info = 7;

    pub fn os_version_info(&self) -> &[u8] {
        match self.os_version_info.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_os_version_info(&mut self) {
        self.os_version_info = ::std::option::Option::None;
    }

    pub fn has_os_version_info(&self) -> bool {
        self.os_version_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os_version_info(&mut self, v: ::std::vec::Vec<u8>) {
        self.os_version_info = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_os_version_info(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.os_version_info.is_none() {
            self.os_version_info = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.os_version_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_os_version_info(&mut self) -> ::std::vec::Vec<u8> {
        self.os_version_info.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes system_info = 8;

    pub fn system_info(&self) -> &[u8] {
        match self.system_info.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_system_info(&mut self) {
        self.system_info = ::std::option::Option::None;
    }

    pub fn has_system_info(&self) -> bool {
        self.system_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_system_info(&mut self, v: ::std::vec::Vec<u8>) {
        self.system_info = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_system_info(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.system_info.is_none() {
            self.system_info = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.system_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_system_info(&mut self) -> ::std::vec::Vec<u8> {
        self.system_info.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed64 load_address = 9;

    pub fn load_address(&self) -> u64 {
        self.load_address.unwrap_or(0)
    }

    pub fn clear_load_address(&mut self) {
        self.load_address = ::std::option::Option::None;
    }

    pub fn has_load_address(&self) -> bool {
        self.load_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_load_address(&mut self, v: u64) {
        self.load_address = ::std::option::Option::Some(v);
    }

    // optional bytes exception_record = 10;

    pub fn exception_record(&self) -> &[u8] {
        match self.exception_record.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_exception_record(&mut self) {
        self.exception_record = ::std::option::Option::None;
    }

    pub fn has_exception_record(&self) -> bool {
        self.exception_record.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exception_record(&mut self, v: ::std::vec::Vec<u8>) {
        self.exception_record = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exception_record(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.exception_record.is_none() {
            self.exception_record = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.exception_record.as_mut().unwrap()
    }

    // Take field
    pub fn take_exception_record(&mut self) -> ::std::vec::Vec<u8> {
        self.exception_record.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes portable_os_version_info = 11;

    pub fn portable_os_version_info(&self) -> &[u8] {
        match self.portable_os_version_info.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_portable_os_version_info(&mut self) {
        self.portable_os_version_info = ::std::option::Option::None;
    }

    pub fn has_portable_os_version_info(&self) -> bool {
        self.portable_os_version_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_portable_os_version_info(&mut self, v: ::std::vec::Vec<u8>) {
        self.portable_os_version_info = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_portable_os_version_info(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.portable_os_version_info.is_none() {
            self.portable_os_version_info = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.portable_os_version_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_portable_os_version_info(&mut self) -> ::std::vec::Vec<u8> {
        self.portable_os_version_info.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes portable_system_info = 12;

    pub fn portable_system_info(&self) -> &[u8] {
        match self.portable_system_info.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_portable_system_info(&mut self) {
        self.portable_system_info = ::std::option::Option::None;
    }

    pub fn has_portable_system_info(&self) -> bool {
        self.portable_system_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_portable_system_info(&mut self, v: ::std::vec::Vec<u8>) {
        self.portable_system_info = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_portable_system_info(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.portable_system_info.is_none() {
            self.portable_system_info = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.portable_system_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_portable_system_info(&mut self) -> ::std::vec::Vec<u8> {
        self.portable_system_info.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool was_converted = 13;

    pub fn was_converted(&self) -> bool {
        self.was_converted.unwrap_or(false)
    }

    pub fn clear_was_converted(&mut self) {
        self.was_converted = ::std::option::Option::None;
    }

    pub fn has_was_converted(&self) -> bool {
        self.was_converted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_was_converted(&mut self, v: bool) {
        self.was_converted = ::std::option::Option::Some(v);
    }

    // optional uint32 internal_result = 14;

    pub fn internal_result(&self) -> u32 {
        self.internal_result.unwrap_or(0)
    }

    pub fn clear_internal_result(&mut self) {
        self.internal_result = ::std::option::Option::None;
    }

    pub fn has_internal_result(&self) -> bool {
        self.internal_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_internal_result(&mut self, v: u32) {
        self.internal_result = ::std::option::Option::Some(v);
    }

    // optional uint32 current_count = 15;

    pub fn current_count(&self) -> u32 {
        self.current_count.unwrap_or(0)
    }

    pub fn clear_current_count(&mut self) {
        self.current_count = ::std::option::Option::None;
    }

    pub fn has_current_count(&self) -> bool {
        self.current_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_count(&mut self, v: u32) {
        self.current_count = ::std::option::Option::Some(v);
    }

    // optional uint32 last_call_handle = 16;

    pub fn last_call_handle(&self) -> u32 {
        self.last_call_handle.unwrap_or(0)
    }

    pub fn clear_last_call_handle(&mut self) {
        self.last_call_handle = ::std::option::Option::None;
    }

    pub fn has_last_call_handle(&self) -> bool {
        self.last_call_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_call_handle(&mut self, v: u32) {
        self.last_call_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 last_call_module_crc = 17;

    pub fn last_call_module_crc(&self) -> u32 {
        self.last_call_module_crc.unwrap_or(0)
    }

    pub fn clear_last_call_module_crc(&mut self) {
        self.last_call_module_crc = ::std::option::Option::None;
    }

    pub fn has_last_call_module_crc(&self) -> bool {
        self.last_call_module_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_call_module_crc(&mut self, v: u32) {
        self.last_call_module_crc = ::std::option::Option::Some(v);
    }

    // optional bytes last_call_sysid_routing = 18;

    pub fn last_call_sysid_routing(&self) -> &[u8] {
        match self.last_call_sysid_routing.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_last_call_sysid_routing(&mut self) {
        self.last_call_sysid_routing = ::std::option::Option::None;
    }

    pub fn has_last_call_sysid_routing(&self) -> bool {
        self.last_call_sysid_routing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_call_sysid_routing(&mut self, v: ::std::vec::Vec<u8>) {
        self.last_call_sysid_routing = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_call_sysid_routing(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.last_call_sysid_routing.is_none() {
            self.last_call_sysid_routing = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.last_call_sysid_routing.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_call_sysid_routing(&mut self) -> ::std::vec::Vec<u8> {
        self.last_call_sysid_routing.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 last_ecallresult = 19;

    pub fn last_ecallresult(&self) -> u32 {
        self.last_ecallresult.unwrap_or(0)
    }

    pub fn clear_last_ecallresult(&mut self) {
        self.last_ecallresult = ::std::option::Option::None;
    }

    pub fn has_last_ecallresult(&self) -> bool {
        self.last_ecallresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_ecallresult(&mut self, v: u32) {
        self.last_ecallresult = ::std::option::Option::Some(v);
    }

    // optional uint32 last_callissue_delta = 20;

    pub fn last_callissue_delta(&self) -> u32 {
        self.last_callissue_delta.unwrap_or(0)
    }

    pub fn clear_last_callissue_delta(&mut self) {
        self.last_callissue_delta = ::std::option::Option::None;
    }

    pub fn has_last_callissue_delta(&self) -> bool {
        self.last_callissue_delta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_callissue_delta(&mut self, v: u32) {
        self.last_callissue_delta = ::std::option::Option::Some(v);
    }

    // optional uint32 last_callcomplete_delta = 21;

    pub fn last_callcomplete_delta(&self) -> u32 {
        self.last_callcomplete_delta.unwrap_or(0)
    }

    pub fn clear_last_callcomplete_delta(&mut self) {
        self.last_callcomplete_delta = ::std::option::Option::None;
    }

    pub fn has_last_callcomplete_delta(&self) -> bool {
        self.last_callcomplete_delta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_callcomplete_delta(&mut self, v: u32) {
        self.last_callcomplete_delta = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientServiceCallResponse {
    const NAME: &'static str = "CMsgClientServiceCallResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.sysid_routing = ::std::option::Option::Some(is.read_bytes()?);
                },
                16 => {
                    self.call_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.module_crc = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.module_hash = ::std::option::Option::Some(is.read_bytes()?);
                },
                40 => {
                    self.ecallresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    self.result_content = ::std::option::Option::Some(is.read_bytes()?);
                },
                58 => {
                    self.os_version_info = ::std::option::Option::Some(is.read_bytes()?);
                },
                66 => {
                    self.system_info = ::std::option::Option::Some(is.read_bytes()?);
                },
                73 => {
                    self.load_address = ::std::option::Option::Some(is.read_fixed64()?);
                },
                82 => {
                    self.exception_record = ::std::option::Option::Some(is.read_bytes()?);
                },
                90 => {
                    self.portable_os_version_info = ::std::option::Option::Some(is.read_bytes()?);
                },
                98 => {
                    self.portable_system_info = ::std::option::Option::Some(is.read_bytes()?);
                },
                104 => {
                    self.was_converted = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.internal_result = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.current_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.last_call_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.last_call_module_crc = ::std::option::Option::Some(is.read_uint32()?);
                },
                146 => {
                    self.last_call_sysid_routing = ::std::option::Option::Some(is.read_bytes()?);
                },
                152 => {
                    self.last_ecallresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.last_callissue_delta = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.last_callcomplete_delta = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.sysid_routing.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.call_handle {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.module_crc {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.module_hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.ecallresult {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.result_content.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.os_version_info.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.system_info.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.load_address {
            my_size += 1 + 8;
        }
        if let Some(v) = self.exception_record.as_ref() {
            my_size += ::protobuf::rt::bytes_size(10, &v);
        }
        if let Some(v) = self.portable_os_version_info.as_ref() {
            my_size += ::protobuf::rt::bytes_size(11, &v);
        }
        if let Some(v) = self.portable_system_info.as_ref() {
            my_size += ::protobuf::rt::bytes_size(12, &v);
        }
        if let Some(v) = self.was_converted {
            my_size += 1 + 1;
        }
        if let Some(v) = self.internal_result {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.current_count {
            my_size += ::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.last_call_handle {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.last_call_module_crc {
            my_size += ::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.last_call_sysid_routing.as_ref() {
            my_size += ::protobuf::rt::bytes_size(18, &v);
        }
        if let Some(v) = self.last_ecallresult {
            my_size += ::protobuf::rt::uint32_size(19, v);
        }
        if let Some(v) = self.last_callissue_delta {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.last_callcomplete_delta {
            my_size += ::protobuf::rt::uint32_size(21, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.sysid_routing.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.call_handle {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.module_crc {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.module_hash.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.ecallresult {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.result_content.as_ref() {
            os.write_bytes(6, v)?;
        }
        if let Some(v) = self.os_version_info.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.system_info.as_ref() {
            os.write_bytes(8, v)?;
        }
        if let Some(v) = self.load_address {
            os.write_fixed64(9, v)?;
        }
        if let Some(v) = self.exception_record.as_ref() {
            os.write_bytes(10, v)?;
        }
        if let Some(v) = self.portable_os_version_info.as_ref() {
            os.write_bytes(11, v)?;
        }
        if let Some(v) = self.portable_system_info.as_ref() {
            os.write_bytes(12, v)?;
        }
        if let Some(v) = self.was_converted {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.internal_result {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.current_count {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.last_call_handle {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.last_call_module_crc {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.last_call_sysid_routing.as_ref() {
            os.write_bytes(18, v)?;
        }
        if let Some(v) = self.last_ecallresult {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.last_callissue_delta {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.last_callcomplete_delta {
            os.write_uint32(21, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientServiceCallResponse {
        CMsgClientServiceCallResponse::new()
    }

    fn clear(&mut self) {
        self.sysid_routing = ::std::option::Option::None;
        self.call_handle = ::std::option::Option::None;
        self.module_crc = ::std::option::Option::None;
        self.module_hash = ::std::option::Option::None;
        self.ecallresult = ::std::option::Option::None;
        self.result_content = ::std::option::Option::None;
        self.os_version_info = ::std::option::Option::None;
        self.system_info = ::std::option::Option::None;
        self.load_address = ::std::option::Option::None;
        self.exception_record = ::std::option::Option::None;
        self.portable_os_version_info = ::std::option::Option::None;
        self.portable_system_info = ::std::option::Option::None;
        self.was_converted = ::std::option::Option::None;
        self.internal_result = ::std::option::Option::None;
        self.current_count = ::std::option::Option::None;
        self.last_call_handle = ::std::option::Option::None;
        self.last_call_module_crc = ::std::option::Option::None;
        self.last_call_sysid_routing = ::std::option::Option::None;
        self.last_ecallresult = ::std::option::Option::None;
        self.last_callissue_delta = ::std::option::Option::None;
        self.last_callcomplete_delta = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientServiceCallResponse {
        static instance: CMsgClientServiceCallResponse = CMsgClientServiceCallResponse {
            sysid_routing: ::std::option::Option::None,
            call_handle: ::std::option::Option::None,
            module_crc: ::std::option::Option::None,
            module_hash: ::std::option::Option::None,
            ecallresult: ::std::option::Option::None,
            result_content: ::std::option::Option::None,
            os_version_info: ::std::option::Option::None,
            system_info: ::std::option::Option::None,
            load_address: ::std::option::Option::None,
            exception_record: ::std::option::Option::None,
            portable_os_version_info: ::std::option::Option::None,
            portable_system_info: ::std::option::Option::None,
            was_converted: ::std::option::Option::None,
            internal_result: ::std::option::Option::None,
            current_count: ::std::option::Option::None,
            last_call_handle: ::std::option::Option::None,
            last_call_module_crc: ::std::option::Option::None,
            last_call_sysid_routing: ::std::option::Option::None,
            last_ecallresult: ::std::option::Option::None,
            last_callissue_delta: ::std::option::Option::None,
            last_callcomplete_delta: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgAMUnlockH264)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAMUnlockH264 {
    // message fields
    // @@protoc_insertion_point(field:CMsgAMUnlockH264.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgAMUnlockH264.platform)
    pub platform: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgAMUnlockH264.reason)
    pub reason: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAMUnlockH264.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAMUnlockH264 {
    fn default() -> &'a CMsgAMUnlockH264 {
        <CMsgAMUnlockH264 as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAMUnlockH264 {
    pub fn new() -> CMsgAMUnlockH264 {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional int32 platform = 2;

    pub fn platform(&self) -> i32 {
        self.platform.unwrap_or(0)
    }

    pub fn clear_platform(&mut self) {
        self.platform = ::std::option::Option::None;
    }

    pub fn has_platform(&self) -> bool {
        self.platform.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platform(&mut self, v: i32) {
        self.platform = ::std::option::Option::Some(v);
    }

    // optional int32 reason = 3;

    pub fn reason(&self) -> i32 {
        self.reason.unwrap_or(0)
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: i32) {
        self.reason = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgAMUnlockH264 {
    const NAME: &'static str = "CMsgAMUnlockH264";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.platform = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.reason = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.platform {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.platform {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.reason {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAMUnlockH264 {
        CMsgAMUnlockH264::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.platform = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAMUnlockH264 {
        static instance: CMsgAMUnlockH264 = CMsgAMUnlockH264 {
            appid: ::std::option::Option::None,
            platform: ::std::option::Option::None,
            reason: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgAMUnlockH264Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAMUnlockH264Response {
    // message fields
    // @@protoc_insertion_point(field:CMsgAMUnlockH264Response.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgAMUnlockH264Response.encryption_key)
    pub encryption_key: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAMUnlockH264Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAMUnlockH264Response {
    fn default() -> &'a CMsgAMUnlockH264Response {
        <CMsgAMUnlockH264Response as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAMUnlockH264Response {
    pub fn new() -> CMsgAMUnlockH264Response {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional bytes encryption_key = 2;

    pub fn encryption_key(&self) -> &[u8] {
        match self.encryption_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_encryption_key(&mut self) {
        self.encryption_key = ::std::option::Option::None;
    }

    pub fn has_encryption_key(&self) -> bool {
        self.encryption_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encryption_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.encryption_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encryption_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.encryption_key.is_none() {
            self.encryption_key = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.encryption_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_encryption_key(&mut self) -> ::std::vec::Vec<u8> {
        self.encryption_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgAMUnlockH264Response {
    const NAME: &'static str = "CMsgAMUnlockH264Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.encryption_key = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.encryption_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.encryption_key.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAMUnlockH264Response {
        CMsgAMUnlockH264Response::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.encryption_key = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAMUnlockH264Response {
        static instance: CMsgAMUnlockH264Response = CMsgAMUnlockH264Response {
            eresult: ::std::option::Option::None,
            encryption_key: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientPlayingSessionState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientPlayingSessionState {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientPlayingSessionState.playing_blocked)
    pub playing_blocked: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientPlayingSessionState.playing_app)
    pub playing_app: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientPlayingSessionState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientPlayingSessionState {
    fn default() -> &'a CMsgClientPlayingSessionState {
        <CMsgClientPlayingSessionState as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPlayingSessionState {
    pub fn new() -> CMsgClientPlayingSessionState {
        ::std::default::Default::default()
    }

    // optional bool playing_blocked = 2;

    pub fn playing_blocked(&self) -> bool {
        self.playing_blocked.unwrap_or(false)
    }

    pub fn clear_playing_blocked(&mut self) {
        self.playing_blocked = ::std::option::Option::None;
    }

    pub fn has_playing_blocked(&self) -> bool {
        self.playing_blocked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playing_blocked(&mut self, v: bool) {
        self.playing_blocked = ::std::option::Option::Some(v);
    }

    // optional uint32 playing_app = 3;

    pub fn playing_app(&self) -> u32 {
        self.playing_app.unwrap_or(0)
    }

    pub fn clear_playing_app(&mut self) {
        self.playing_app = ::std::option::Option::None;
    }

    pub fn has_playing_app(&self) -> bool {
        self.playing_app.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playing_app(&mut self, v: u32) {
        self.playing_app = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientPlayingSessionState {
    const NAME: &'static str = "CMsgClientPlayingSessionState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.playing_blocked = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.playing_app = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.playing_blocked {
            my_size += 1 + 1;
        }
        if let Some(v) = self.playing_app {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.playing_blocked {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.playing_app {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientPlayingSessionState {
        CMsgClientPlayingSessionState::new()
    }

    fn clear(&mut self) {
        self.playing_blocked = ::std::option::Option::None;
        self.playing_app = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientPlayingSessionState {
        static instance: CMsgClientPlayingSessionState = CMsgClientPlayingSessionState {
            playing_blocked: ::std::option::Option::None,
            playing_app: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientKickPlayingSession)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientKickPlayingSession {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientKickPlayingSession.only_stop_game)
    pub only_stop_game: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientKickPlayingSession.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientKickPlayingSession {
    fn default() -> &'a CMsgClientKickPlayingSession {
        <CMsgClientKickPlayingSession as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientKickPlayingSession {
    pub fn new() -> CMsgClientKickPlayingSession {
        ::std::default::Default::default()
    }

    // optional bool only_stop_game = 1;

    pub fn only_stop_game(&self) -> bool {
        self.only_stop_game.unwrap_or(false)
    }

    pub fn clear_only_stop_game(&mut self) {
        self.only_stop_game = ::std::option::Option::None;
    }

    pub fn has_only_stop_game(&self) -> bool {
        self.only_stop_game.is_some()
    }

    // Param is passed by value, moved
    pub fn set_only_stop_game(&mut self, v: bool) {
        self.only_stop_game = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientKickPlayingSession {
    const NAME: &'static str = "CMsgClientKickPlayingSession";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.only_stop_game = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.only_stop_game {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.only_stop_game {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientKickPlayingSession {
        CMsgClientKickPlayingSession::new()
    }

    fn clear(&mut self) {
        self.only_stop_game = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientKickPlayingSession {
        static instance: CMsgClientKickPlayingSession = CMsgClientKickPlayingSession {
            only_stop_game: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientVoiceCallPreAuthorize)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientVoiceCallPreAuthorize {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientVoiceCallPreAuthorize.caller_steamid)
    pub caller_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientVoiceCallPreAuthorize.receiver_steamid)
    pub receiver_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientVoiceCallPreAuthorize.caller_id)
    pub caller_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientVoiceCallPreAuthorize.hangup)
    pub hangup: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientVoiceCallPreAuthorize.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientVoiceCallPreAuthorize {
    fn default() -> &'a CMsgClientVoiceCallPreAuthorize {
        <CMsgClientVoiceCallPreAuthorize as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientVoiceCallPreAuthorize {
    pub fn new() -> CMsgClientVoiceCallPreAuthorize {
        ::std::default::Default::default()
    }

    // optional fixed64 caller_steamid = 1;

    pub fn caller_steamid(&self) -> u64 {
        self.caller_steamid.unwrap_or(0)
    }

    pub fn clear_caller_steamid(&mut self) {
        self.caller_steamid = ::std::option::Option::None;
    }

    pub fn has_caller_steamid(&self) -> bool {
        self.caller_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caller_steamid(&mut self, v: u64) {
        self.caller_steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 receiver_steamid = 2;

    pub fn receiver_steamid(&self) -> u64 {
        self.receiver_steamid.unwrap_or(0)
    }

    pub fn clear_receiver_steamid(&mut self) {
        self.receiver_steamid = ::std::option::Option::None;
    }

    pub fn has_receiver_steamid(&self) -> bool {
        self.receiver_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receiver_steamid(&mut self, v: u64) {
        self.receiver_steamid = ::std::option::Option::Some(v);
    }

    // optional int32 caller_id = 3;

    pub fn caller_id(&self) -> i32 {
        self.caller_id.unwrap_or(0)
    }

    pub fn clear_caller_id(&mut self) {
        self.caller_id = ::std::option::Option::None;
    }

    pub fn has_caller_id(&self) -> bool {
        self.caller_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caller_id(&mut self, v: i32) {
        self.caller_id = ::std::option::Option::Some(v);
    }

    // optional bool hangup = 4;

    pub fn hangup(&self) -> bool {
        self.hangup.unwrap_or(false)
    }

    pub fn clear_hangup(&mut self) {
        self.hangup = ::std::option::Option::None;
    }

    pub fn has_hangup(&self) -> bool {
        self.hangup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hangup(&mut self, v: bool) {
        self.hangup = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientVoiceCallPreAuthorize {
    const NAME: &'static str = "CMsgClientVoiceCallPreAuthorize";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.caller_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.receiver_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.caller_id = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.hangup = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.caller_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.receiver_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.caller_id {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.hangup {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.caller_steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.receiver_steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.caller_id {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.hangup {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientVoiceCallPreAuthorize {
        CMsgClientVoiceCallPreAuthorize::new()
    }

    fn clear(&mut self) {
        self.caller_steamid = ::std::option::Option::None;
        self.receiver_steamid = ::std::option::Option::None;
        self.caller_id = ::std::option::Option::None;
        self.hangup = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientVoiceCallPreAuthorize {
        static instance: CMsgClientVoiceCallPreAuthorize = CMsgClientVoiceCallPreAuthorize {
            caller_steamid: ::std::option::Option::None,
            receiver_steamid: ::std::option::Option::None,
            caller_id: ::std::option::Option::None,
            hangup: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientVoiceCallPreAuthorizeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientVoiceCallPreAuthorizeResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientVoiceCallPreAuthorizeResponse.caller_steamid)
    pub caller_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientVoiceCallPreAuthorizeResponse.receiver_steamid)
    pub receiver_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientVoiceCallPreAuthorizeResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientVoiceCallPreAuthorizeResponse.caller_id)
    pub caller_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientVoiceCallPreAuthorizeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientVoiceCallPreAuthorizeResponse {
    fn default() -> &'a CMsgClientVoiceCallPreAuthorizeResponse {
        <CMsgClientVoiceCallPreAuthorizeResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientVoiceCallPreAuthorizeResponse {
    pub fn new() -> CMsgClientVoiceCallPreAuthorizeResponse {
        ::std::default::Default::default()
    }

    // optional fixed64 caller_steamid = 1;

    pub fn caller_steamid(&self) -> u64 {
        self.caller_steamid.unwrap_or(0)
    }

    pub fn clear_caller_steamid(&mut self) {
        self.caller_steamid = ::std::option::Option::None;
    }

    pub fn has_caller_steamid(&self) -> bool {
        self.caller_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caller_steamid(&mut self, v: u64) {
        self.caller_steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 receiver_steamid = 2;

    pub fn receiver_steamid(&self) -> u64 {
        self.receiver_steamid.unwrap_or(0)
    }

    pub fn clear_receiver_steamid(&mut self) {
        self.receiver_steamid = ::std::option::Option::None;
    }

    pub fn has_receiver_steamid(&self) -> bool {
        self.receiver_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receiver_steamid(&mut self, v: u64) {
        self.receiver_steamid = ::std::option::Option::Some(v);
    }

    // optional int32 eresult = 3;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional int32 caller_id = 4;

    pub fn caller_id(&self) -> i32 {
        self.caller_id.unwrap_or(0)
    }

    pub fn clear_caller_id(&mut self) {
        self.caller_id = ::std::option::Option::None;
    }

    pub fn has_caller_id(&self) -> bool {
        self.caller_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caller_id(&mut self, v: i32) {
        self.caller_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientVoiceCallPreAuthorizeResponse {
    const NAME: &'static str = "CMsgClientVoiceCallPreAuthorizeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.caller_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.receiver_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.caller_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.caller_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.receiver_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.caller_id {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.caller_steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.receiver_steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.caller_id {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientVoiceCallPreAuthorizeResponse {
        CMsgClientVoiceCallPreAuthorizeResponse::new()
    }

    fn clear(&mut self) {
        self.caller_steamid = ::std::option::Option::None;
        self.receiver_steamid = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.caller_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientVoiceCallPreAuthorizeResponse {
        static instance: CMsgClientVoiceCallPreAuthorizeResponse = CMsgClientVoiceCallPreAuthorizeResponse {
            caller_steamid: ::std::option::Option::None,
            receiver_steamid: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            caller_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgBadgeCraftedNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBadgeCraftedNotification {
    // message fields
    // @@protoc_insertion_point(field:CMsgBadgeCraftedNotification.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBadgeCraftedNotification.badge_level)
    pub badge_level: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBadgeCraftedNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBadgeCraftedNotification {
    fn default() -> &'a CMsgBadgeCraftedNotification {
        <CMsgBadgeCraftedNotification as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBadgeCraftedNotification {
    pub fn new() -> CMsgBadgeCraftedNotification {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 badge_level = 2;

    pub fn badge_level(&self) -> u32 {
        self.badge_level.unwrap_or(0)
    }

    pub fn clear_badge_level(&mut self) {
        self.badge_level = ::std::option::Option::None;
    }

    pub fn has_badge_level(&self) -> bool {
        self.badge_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_badge_level(&mut self, v: u32) {
        self.badge_level = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgBadgeCraftedNotification {
    const NAME: &'static str = "CMsgBadgeCraftedNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.badge_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.badge_level {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.badge_level {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBadgeCraftedNotification {
        CMsgBadgeCraftedNotification::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.badge_level = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBadgeCraftedNotification {
        static instance: CMsgBadgeCraftedNotification = CMsgBadgeCraftedNotification {
            appid: ::std::option::Option::None,
            badge_level: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientStartPeerContentServer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientStartPeerContentServer {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientStartPeerContentServer.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientStartPeerContentServer.client_remote_id)
    pub client_remote_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientStartPeerContentServer.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientStartPeerContentServer.current_build_id)
    pub current_build_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientStartPeerContentServer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientStartPeerContentServer {
    fn default() -> &'a CMsgClientStartPeerContentServer {
        <CMsgClientStartPeerContentServer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientStartPeerContentServer {
    pub fn new() -> CMsgClientStartPeerContentServer {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 client_remote_id = 2;

    pub fn client_remote_id(&self) -> u64 {
        self.client_remote_id.unwrap_or(0)
    }

    pub fn clear_client_remote_id(&mut self) {
        self.client_remote_id = ::std::option::Option::None;
    }

    pub fn has_client_remote_id(&self) -> bool {
        self.client_remote_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_remote_id(&mut self, v: u64) {
        self.client_remote_id = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 3;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 current_build_id = 4;

    pub fn current_build_id(&self) -> u32 {
        self.current_build_id.unwrap_or(0)
    }

    pub fn clear_current_build_id(&mut self) {
        self.current_build_id = ::std::option::Option::None;
    }

    pub fn has_current_build_id(&self) -> bool {
        self.current_build_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_build_id(&mut self, v: u32) {
        self.current_build_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientStartPeerContentServer {
    const NAME: &'static str = "CMsgClientStartPeerContentServer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.client_remote_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.current_build_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.client_remote_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.current_build_id {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.client_remote_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.current_build_id {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientStartPeerContentServer {
        CMsgClientStartPeerContentServer::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.client_remote_id = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.current_build_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientStartPeerContentServer {
        static instance: CMsgClientStartPeerContentServer = CMsgClientStartPeerContentServer {
            steamid: ::std::option::Option::None,
            client_remote_id: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            current_build_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientStartPeerContentServerResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientStartPeerContentServerResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientStartPeerContentServerResponse.result)
    pub result: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientStartPeerContentServerResponse.server_port)
    pub server_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientStartPeerContentServerResponse.installed_depots)
    pub installed_depots: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientStartPeerContentServerResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientStartPeerContentServerResponse {
    fn default() -> &'a CMsgClientStartPeerContentServerResponse {
        <CMsgClientStartPeerContentServerResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientStartPeerContentServerResponse {
    pub fn new() -> CMsgClientStartPeerContentServerResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional uint32 server_port = 2;

    pub fn server_port(&self) -> u32 {
        self.server_port.unwrap_or(0)
    }

    pub fn clear_server_port(&mut self) {
        self.server_port = ::std::option::Option::None;
    }

    pub fn has_server_port(&self) -> bool {
        self.server_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_port(&mut self, v: u32) {
        self.server_port = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientStartPeerContentServerResponse {
    const NAME: &'static str = "CMsgClientStartPeerContentServerResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.server_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.installed_depots)?;
                },
                24 => {
                    self.installed_depots.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.server_port {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.installed_depots {
            my_size += ::protobuf::rt::uint32_size(3, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.server_port {
            os.write_uint32(2, v)?;
        }
        for v in &self.installed_depots {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientStartPeerContentServerResponse {
        CMsgClientStartPeerContentServerResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.server_port = ::std::option::Option::None;
        self.installed_depots.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientStartPeerContentServerResponse {
        static instance: CMsgClientStartPeerContentServerResponse = CMsgClientStartPeerContentServerResponse {
            result: ::std::option::Option::None,
            server_port: ::std::option::Option::None,
            installed_depots: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientGetPeerContentInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGetPeerContentInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGetPeerContentInfo.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientGetPeerContentInfo.client_remote_id)
    pub client_remote_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientGetPeerContentInfo.owned_games_visible)
    pub owned_games_visible: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetPeerContentInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetPeerContentInfo {
    fn default() -> &'a CMsgClientGetPeerContentInfo {
        <CMsgClientGetPeerContentInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetPeerContentInfo {
    pub fn new() -> CMsgClientGetPeerContentInfo {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 client_remote_id = 2;

    pub fn client_remote_id(&self) -> u64 {
        self.client_remote_id.unwrap_or(0)
    }

    pub fn clear_client_remote_id(&mut self) {
        self.client_remote_id = ::std::option::Option::None;
    }

    pub fn has_client_remote_id(&self) -> bool {
        self.client_remote_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_remote_id(&mut self, v: u64) {
        self.client_remote_id = ::std::option::Option::Some(v);
    }

    // optional bool owned_games_visible = 3;

    pub fn owned_games_visible(&self) -> bool {
        self.owned_games_visible.unwrap_or(false)
    }

    pub fn clear_owned_games_visible(&mut self) {
        self.owned_games_visible = ::std::option::Option::None;
    }

    pub fn has_owned_games_visible(&self) -> bool {
        self.owned_games_visible.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owned_games_visible(&mut self, v: bool) {
        self.owned_games_visible = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientGetPeerContentInfo {
    const NAME: &'static str = "CMsgClientGetPeerContentInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.client_remote_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.owned_games_visible = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.client_remote_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.owned_games_visible {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.client_remote_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.owned_games_visible {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetPeerContentInfo {
        CMsgClientGetPeerContentInfo::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.client_remote_id = ::std::option::Option::None;
        self.owned_games_visible = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetPeerContentInfo {
        static instance: CMsgClientGetPeerContentInfo = CMsgClientGetPeerContentInfo {
            steamid: ::std::option::Option::None,
            client_remote_id: ::std::option::Option::None,
            owned_games_visible: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientGetPeerContentInfoResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGetPeerContentInfoResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGetPeerContentInfoResponse.result)
    pub result: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientGetPeerContentInfoResponse.apps)
    pub apps: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetPeerContentInfoResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetPeerContentInfoResponse {
    fn default() -> &'a CMsgClientGetPeerContentInfoResponse {
        <CMsgClientGetPeerContentInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetPeerContentInfoResponse {
    pub fn new() -> CMsgClientGetPeerContentInfoResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientGetPeerContentInfoResponse {
    const NAME: &'static str = "CMsgClientGetPeerContentInfoResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.apps)?;
                },
                16 => {
                    self.apps.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.apps {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        for v in &self.apps {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetPeerContentInfoResponse {
        CMsgClientGetPeerContentInfoResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.apps.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetPeerContentInfoResponse {
        static instance: CMsgClientGetPeerContentInfoResponse = CMsgClientGetPeerContentInfoResponse {
            result: ::std::option::Option::None,
            apps: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientFeatureGroupInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientFeatureGroupInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientFeatureGroupInfo.groupid)
    pub groupid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientFeatureGroupInfo.members)
    pub members: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientFeatureGroupInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientFeatureGroupInfo {
    fn default() -> &'a CMsgClientFeatureGroupInfo {
        <CMsgClientFeatureGroupInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientFeatureGroupInfo {
    pub fn new() -> CMsgClientFeatureGroupInfo {
        ::std::default::Default::default()
    }

    // optional uint64 groupid = 1;

    pub fn groupid(&self) -> u64 {
        self.groupid.unwrap_or(0)
    }

    pub fn clear_groupid(&mut self) {
        self.groupid = ::std::option::Option::None;
    }

    pub fn has_groupid(&self) -> bool {
        self.groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupid(&mut self, v: u64) {
        self.groupid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientFeatureGroupInfo {
    const NAME: &'static str = "CMsgClientFeatureGroupInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.groupid = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.members)?;
                },
                16 => {
                    self.members.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.groupid {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        for value in &self.members {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.groupid {
            os.write_uint64(1, v)?;
        }
        for v in &self.members {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientFeatureGroupInfo {
        CMsgClientFeatureGroupInfo::new()
    }

    fn clear(&mut self) {
        self.groupid = ::std::option::Option::None;
        self.members.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientFeatureGroupInfo {
        static instance: CMsgClientFeatureGroupInfo = CMsgClientFeatureGroupInfo {
            groupid: ::std::option::Option::None,
            members: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}
#[allow(unused_imports)]
use crate::steammessages_base::*;
impl crate::RpcMessage for CMsgClientUpdateUserGameInfo {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientUpdateUserGameInfo {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientUpdateUserGameInfo;
}
impl crate::RpcMessage for CMsgClientRichPresenceUpload {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientRichPresenceUpload {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientRichPresenceUpload;
}
impl crate::RpcMessage for CMsgClientRichPresenceRequest {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientRichPresenceRequest {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientRichPresenceRequest;
}
impl crate::RpcMessage for CMsgClientRichPresenceInfo {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientRichPresenceInfo {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientRichPresenceInfo;
}
impl crate::RpcMessage for CMsgClientCheckFileSignature {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgClientCheckFileSignatureResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgClientReadMachineAuth {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientReadMachineAuth {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientReadMachineAuth;
}
impl crate::RpcMessage for CMsgClientReadMachineAuthResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientReadMachineAuthResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientReadMachineAuthResponse;
}
impl crate::RpcMessage for CMsgClientUpdateMachineAuth {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientUpdateMachineAuth {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientUpdateMachineAuth;
}
impl crate::RpcMessage for CMsgClientUpdateMachineAuthResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientUpdateMachineAuthResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientUpdateMachineAuthResponse;
}
impl crate::RpcMessage for CMsgClientRequestMachineAuth {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientRequestMachineAuth {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientRequestMachineAuth;
}
impl crate::RpcMessage for CMsgClientRequestMachineAuthResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientRequestMachineAuthResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientRequestMachineAuthResponse;
}
impl crate::RpcMessage for CMsgClientRegisterKey {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientRegisterKey {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientRegisterKey;
}
impl crate::RpcMessage for CMsgClientPurchaseResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientPurchaseResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientPurchaseResponse;
}
impl crate::RpcMessage for CMsgClientActivateOEMLicense {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgClientRegisterOEMMachine {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgClientRegisterOEMMachineResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgClientPurchaseWithMachineID {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientPurchaseWithMachineID {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientPurchaseWithMachineID;
}
impl crate::RpcMessage for CMsgTrading_InitiateTradeRequest {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgTrading_InitiateTradeResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgTrading_CancelTradeRequest {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgTrading_StartSession {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgClientGetCDNAuthToken {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientGetCDNAuthToken {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientGetCDNAuthToken;
}
impl crate::RpcMessage for CMsgClientGetDepotDecryptionKey {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientGetDepotDecryptionKey {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientGetDepotDecryptionKey;
}
impl crate::RpcMessage for CMsgClientGetDepotDecryptionKeyResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientGetDepotDecryptionKeyResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientGetDepotDecryptionKeyResponse;
}
impl crate::RpcMessage for CMsgClientCheckAppBetaPassword {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientCheckAppBetaPassword {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientCheckAppBetaPassword;
}
impl crate::RpcMessage for CMsgClientCheckAppBetaPasswordResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientCheckAppBetaPasswordResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientCheckAppBetaPasswordResponse;
}
impl crate::RpcMessage for CMsgClientGetCDNAuthTokenResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientGetCDNAuthTokenResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientGetCDNAuthTokenResponse;
}
impl crate::RpcMessage for CMsgDownloadRateStatistics {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgClientRequestAccountData {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientRequestAccountData {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientRequestAccountData;
}
impl crate::RpcMessage for CMsgClientRequestAccountDataResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientRequestAccountDataResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientRequestAccountDataResponse;
}
impl crate::RpcMessage for CMsgClientUGSGetGlobalStats {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientUGSGetGlobalStats {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientUGSGetGlobalStats;
}
impl crate::RpcMessage for CMsgClientUGSGetGlobalStatsResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientUGSGetGlobalStatsResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientUGSGetGlobalStatsResponse;
}
impl crate::RpcMessage for CMsgClientRedeemGuestPass {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientRedeemGuestPass {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientRedeemGuestPass;
}
impl crate::RpcMessage for CMsgClientRedeemGuestPassResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientRedeemGuestPassResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientRedeemGuestPassResponse;
}
impl crate::RpcMessage for CMsgClientGetClanActivityCounts {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientGetClanActivityCounts {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientGetClanActivityCounts;
}
impl crate::RpcMessage for CMsgClientGetClanActivityCountsResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientGetClanActivityCountsResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientGetClanActivityCountsResponse;
}
impl crate::RpcMessage for CMsgClientOGSReportString {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientOGSReportString {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientOGSReportString;
}
impl crate::RpcMessage for CMsgClientOGSReportBug {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientOGSReportBug {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientOGSReportBug;
}
impl crate::RpcMessage for CMsgClientSentLogs {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientSentLogs {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientSentLogs;
}
impl crate::RpcMessage for CMsgGCClient {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgClientRequestFreeLicense {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientRequestFreeLicense {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientRequestFreeLicense;
}
impl crate::RpcMessage for CMsgClientRequestFreeLicenseResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientRequestFreeLicenseResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientRequestFreeLicenseResponse;
}
impl crate::RpcMessage for CMsgDRMDownloadRequestWithCrashData {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgDRMDownloadResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgDRMFinalResult {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgClientDPCheckSpecialSurvey {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientDPCheckSpecialSurvey {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientDPCheckSpecialSurvey;
}
impl crate::RpcMessage for CMsgClientDPCheckSpecialSurveyResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientDPCheckSpecialSurveyResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientDPCheckSpecialSurveyResponse;
}
impl crate::RpcMessage for CMsgClientDPSendSpecialSurveyResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientDPSendSpecialSurveyResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientDPSendSpecialSurveyResponse;
}
impl crate::RpcMessage for CMsgClientDPSendSpecialSurveyResponseReply {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientDPSendSpecialSurveyResponseReply {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientDPSendSpecialSurveyResponseReply;
}
impl crate::RpcMessage for CMsgClientRequestForgottenPasswordEmail {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientRequestForgottenPasswordEmail {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientRequestForgottenPasswordEmail;
}
impl crate::RpcMessage for CMsgClientRequestForgottenPasswordEmailResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientRequestForgottenPasswordEmailResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientRequestForgottenPasswordEmailResponse;
}
impl crate::RpcMessage for CMsgClientItemAnnouncements {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientItemAnnouncements {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientItemAnnouncements;
}
impl crate::RpcMessage for CMsgClientRequestItemAnnouncements {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientRequestItemAnnouncements {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientRequestItemAnnouncements;
}
impl crate::RpcMessage for CMsgClientUserNotifications {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientUserNotifications {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientUserNotifications;
}
impl crate::RpcMessage for CMsgClientCommentNotifications {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientCommentNotifications {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientCommentNotifications;
}
impl crate::RpcMessage for CMsgClientRequestCommentNotifications {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientRequestCommentNotifications {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientRequestCommentNotifications;
}
impl crate::RpcMessage for CMsgClientOfflineMessageNotification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgClientRequestOfflineMessageCount {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgClientChatGetFriendMessageHistory {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientChatGetFriendMessageHistory {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientChatGetFriendMessageHistory;
}
impl crate::RpcMessage for CMsgClientChatGetFriendMessageHistoryResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientChatGetFriendMessageHistoryResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientChatGetFriendMessageHistoryResponse;
}
impl crate::RpcMessage for CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind
for CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientChatGetFriendMessageHistoryForOfflineMessages;
}
impl crate::RpcMessage for CMsgClientFSGetFriendsSteamLevels {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientFSGetFriendsSteamLevels {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientFSGetFriendsSteamLevels;
}
impl crate::RpcMessage for CMsgClientFSGetFriendsSteamLevelsResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientFSGetFriendsSteamLevelsResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientFSGetFriendsSteamLevelsResponse;
}
impl crate::RpcMessage for CMsgClientEmailAddrInfo {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientEmailAddrInfo {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientEmailAddrInfo;
}
impl crate::RpcMessage for CMsgCREItemVoteSummary {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgCREItemVoteSummary {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgCREItemVoteSummary;
}
impl crate::RpcMessage for CMsgCREItemVoteSummaryResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgCREItemVoteSummaryResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgCREItemVoteSummaryResponse;
}
impl crate::RpcMessage for CMsgCREUpdateUserPublishedItemVote {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgCREUpdateUserPublishedItemVote {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgCREUpdateUserPublishedItemVote;
}
impl crate::RpcMessage for CMsgCREUpdateUserPublishedItemVoteResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgCREUpdateUserPublishedItemVoteResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgCREUpdateUserPublishedItemVoteResponse;
}
impl crate::RpcMessage for CMsgCREGetUserPublishedItemVoteDetails {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgCREGetUserPublishedItemVoteDetails {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgCREGetUserPublishedItemVoteDetails;
}
impl crate::RpcMessage for CMsgCREGetUserPublishedItemVoteDetailsResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgCREGetUserPublishedItemVoteDetailsResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgCREGetUserPublishedItemVoteDetailsResponse;
}
impl crate::RpcMessage for CMsgFSGetFollowerCount {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgFSGetFollowerCountResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgFSGetIsFollowing {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgFSGetIsFollowingResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgFSEnumerateFollowingList {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgFSEnumerateFollowingListResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgDPGetNumberOfCurrentPlayers {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgDPGetNumberOfCurrentPlayersResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgClientFriendUserStatusPublished {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientFriendUserStatusPublished {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientFriendUserStatusPublished;
}
impl crate::RpcMessage for CMsgClientServiceMethodLegacy {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientServiceMethodLegacy {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientServiceMethodLegacy;
}
impl crate::RpcMessage for CMsgClientServiceMethodLegacyResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientServiceMethodLegacyResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientServiceMethodLegacyResponse;
}
impl crate::RpcMessage for CMsgClientUIMode {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgClientVanityURLChangedNotification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientVanityURLChangedNotification {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientVanityURLChangedNotification;
}
impl crate::RpcMessage for CMsgClientAuthorizeLocalDeviceRequest {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientAuthorizeLocalDeviceRequest {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientAuthorizeLocalDeviceRequest;
}
impl crate::RpcMessage for CMsgClientAuthorizeLocalDevice {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgClientAuthorizeLocalDeviceNotification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientAuthorizeLocalDeviceNotification {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientAuthorizeLocalDeviceNotification;
}
impl crate::RpcMessage for CMsgClientDeauthorizeDeviceRequest {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientDeauthorizeDeviceRequest {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientDeauthorizeDeviceRequest;
}
impl crate::RpcMessage for CMsgClientDeauthorizeDevice {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientDeauthorizeDevice {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientDeauthorizeDevice;
}
impl crate::RpcMessage for CMsgClientUseLocalDeviceAuthorizations {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientUseLocalDeviceAuthorizations {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientUseLocalDeviceAuthorizations;
}
impl crate::RpcMessage for CMsgClientGetAuthorizedDevices {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientGetAuthorizedDevices {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientGetAuthorizedDevices;
}
impl crate::RpcMessage for CMsgClientGetAuthorizedDevicesResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientGetAuthorizedDevicesResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientGetAuthorizedDevicesResponse;
}
impl crate::RpcMessage for CMsgClientSharedLibraryLockStatus {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientSharedLibraryLockStatus {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientSharedLibraryLockStatus;
}
impl crate::RpcMessage for CMsgClientSharedLibraryStopPlaying {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientSharedLibraryStopPlaying {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientSharedLibraryStopPlaying;
}
impl crate::RpcMessage for CMsgClientServiceCall {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientServiceCall {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientServiceCall;
}
impl crate::RpcMessage for CMsgClientServiceModule {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientServiceModule {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientServiceModule;
}
impl crate::RpcMessage for CMsgClientServiceCallResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientServiceCallResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientServiceCallResponse;
}
impl crate::RpcMessage for CMsgAMUnlockH264 {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgAMUnlockH264Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgClientPlayingSessionState {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientPlayingSessionState {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientPlayingSessionState;
}
impl crate::RpcMessage for CMsgClientKickPlayingSession {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientKickPlayingSession {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientKickPlayingSession;
}
impl crate::RpcMessage for CMsgClientVoiceCallPreAuthorize {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientVoiceCallPreAuthorize {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientVoiceCallPreAuthorize;
}
impl crate::RpcMessage for CMsgClientVoiceCallPreAuthorizeResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientVoiceCallPreAuthorizeResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientVoiceCallPreAuthorizeResponse;
}
impl crate::RpcMessage for CMsgBadgeCraftedNotification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgBadgeCraftedNotification {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgBadgeCraftedNotification;
}
impl crate::RpcMessage for CMsgClientStartPeerContentServer {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientStartPeerContentServer {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientStartPeerContentServer;
}
impl crate::RpcMessage for CMsgClientStartPeerContentServerResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientStartPeerContentServerResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientStartPeerContentServerResponse;
}
impl crate::RpcMessage for CMsgClientGetPeerContentInfo {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientGetPeerContentInfo {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientGetPeerContentInfo;
}
impl crate::RpcMessage for CMsgClientGetPeerContentInfoResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientGetPeerContentInfoResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientGetPeerContentInfoResponse;
}
impl crate::RpcMessage for CMsgClientFeatureGroupInfo {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientFeatureGroupInfo {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientFeatureGroupInfo;
}
