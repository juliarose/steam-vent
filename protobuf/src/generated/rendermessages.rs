// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `renderer/rendermessages.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:CMsgBeginFrame)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBeginFrame {
    // message fields
    // @@protoc_insertion_point(field:CMsgBeginFrame.frame_paint_time)
    pub frame_paint_time: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgBeginFrame.surface_width)
    pub surface_width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBeginFrame.surface_height)
    pub surface_height: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBeginFrame.render_target)
    pub render_target: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBeginFrame.ui_scale_factor)
    pub ui_scale_factor: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgBeginFrame.empty_frame)
    pub empty_frame: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgBeginFrame.clear_gpu_resources_before_frame)
    pub clear_gpu_resources_before_frame: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBeginFrame.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBeginFrame {
    fn default() -> &'a CMsgBeginFrame {
        <CMsgBeginFrame as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBeginFrame {
    pub fn new() -> CMsgBeginFrame {
        ::std::default::Default::default()
    }

    // optional double frame_paint_time = 1;

    pub fn frame_paint_time(&self) -> f64 {
        self.frame_paint_time.unwrap_or(0.)
    }

    pub fn clear_frame_paint_time(&mut self) {
        self.frame_paint_time = ::std::option::Option::None;
    }

    pub fn has_frame_paint_time(&self) -> bool {
        self.frame_paint_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frame_paint_time(&mut self, v: f64) {
        self.frame_paint_time = ::std::option::Option::Some(v);
    }

    // optional uint32 surface_width = 2;

    pub fn surface_width(&self) -> u32 {
        self.surface_width.unwrap_or(0)
    }

    pub fn clear_surface_width(&mut self) {
        self.surface_width = ::std::option::Option::None;
    }

    pub fn has_surface_width(&self) -> bool {
        self.surface_width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_surface_width(&mut self, v: u32) {
        self.surface_width = ::std::option::Option::Some(v);
    }

    // optional uint32 surface_height = 3;

    pub fn surface_height(&self) -> u32 {
        self.surface_height.unwrap_or(0)
    }

    pub fn clear_surface_height(&mut self) {
        self.surface_height = ::std::option::Option::None;
    }

    pub fn has_surface_height(&self) -> bool {
        self.surface_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_surface_height(&mut self, v: u32) {
        self.surface_height = ::std::option::Option::Some(v);
    }

    // optional uint32 render_target = 4;

    pub fn render_target(&self) -> u32 {
        self.render_target.unwrap_or(0)
    }

    pub fn clear_render_target(&mut self) {
        self.render_target = ::std::option::Option::None;
    }

    pub fn has_render_target(&self) -> bool {
        self.render_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_render_target(&mut self, v: u32) {
        self.render_target = ::std::option::Option::Some(v);
    }

    // optional double ui_scale_factor = 5;

    pub fn ui_scale_factor(&self) -> f64 {
        self.ui_scale_factor.unwrap_or(0.)
    }

    pub fn clear_ui_scale_factor(&mut self) {
        self.ui_scale_factor = ::std::option::Option::None;
    }

    pub fn has_ui_scale_factor(&self) -> bool {
        self.ui_scale_factor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ui_scale_factor(&mut self, v: f64) {
        self.ui_scale_factor = ::std::option::Option::Some(v);
    }

    // optional bool empty_frame = 6;

    pub fn empty_frame(&self) -> bool {
        self.empty_frame.unwrap_or(false)
    }

    pub fn clear_empty_frame(&mut self) {
        self.empty_frame = ::std::option::Option::None;
    }

    pub fn has_empty_frame(&self) -> bool {
        self.empty_frame.is_some()
    }

    // Param is passed by value, moved
    pub fn set_empty_frame(&mut self, v: bool) {
        self.empty_frame = ::std::option::Option::Some(v);
    }

    // optional bool clear_gpu_resources_before_frame = 7;

    pub fn clear_gpu_resources_before_frame(&self) -> bool {
        self.clear_gpu_resources_before_frame.unwrap_or(false)
    }

    pub fn clear_clear_gpu_resources_before_frame(&mut self) {
        self.clear_gpu_resources_before_frame = ::std::option::Option::None;
    }

    pub fn has_clear_gpu_resources_before_frame(&self) -> bool {
        self.clear_gpu_resources_before_frame.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clear_gpu_resources_before_frame(&mut self, v: bool) {
        self.clear_gpu_resources_before_frame = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgBeginFrame {
    const NAME: &'static str = "CMsgBeginFrame";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.frame_paint_time = ::std::option::Option::Some(is.read_double()?);
                },
                16 => {
                    self.surface_width = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.surface_height = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.render_target = ::std::option::Option::Some(is.read_uint32()?);
                },
                41 => {
                    self.ui_scale_factor = ::std::option::Option::Some(is.read_double()?);
                },
                48 => {
                    self.empty_frame = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.clear_gpu_resources_before_frame = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.frame_paint_time {
            my_size += 1 + 8;
        }
        if let Some(v) = self.surface_width {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.surface_height {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.render_target {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.ui_scale_factor {
            my_size += 1 + 8;
        }
        if let Some(v) = self.empty_frame {
            my_size += 1 + 1;
        }
        if let Some(v) = self.clear_gpu_resources_before_frame {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.frame_paint_time {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.surface_width {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.surface_height {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.render_target {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.ui_scale_factor {
            os.write_double(5, v)?;
        }
        if let Some(v) = self.empty_frame {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.clear_gpu_resources_before_frame {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBeginFrame {
        CMsgBeginFrame::new()
    }

    fn clear(&mut self) {
        self.frame_paint_time = ::std::option::Option::None;
        self.surface_width = ::std::option::Option::None;
        self.surface_height = ::std::option::Option::None;
        self.render_target = ::std::option::Option::None;
        self.ui_scale_factor = ::std::option::Option::None;
        self.empty_frame = ::std::option::Option::None;
        self.clear_gpu_resources_before_frame = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBeginFrame {
        static instance: CMsgBeginFrame = CMsgBeginFrame {
            frame_paint_time: ::std::option::Option::None,
            surface_width: ::std::option::Option::None,
            surface_height: ::std::option::Option::None,
            render_target: ::std::option::Option::None,
            ui_scale_factor: ::std::option::Option::None,
            empty_frame: ::std::option::Option::None,
            clear_gpu_resources_before_frame: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgEndFrame)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgEndFrame {
    // message fields
    // @@protoc_insertion_point(field:CMsgEndFrame.mouse_cursor_texture_id)
    pub mouse_cursor_texture_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgEndFrame.mouse_cursor_hotspot_x)
    pub mouse_cursor_hotspot_x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgEndFrame.mouse_cursor_hotspot_y)
    pub mouse_cursor_hotspot_y: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgEndFrame.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgEndFrame {
    fn default() -> &'a CMsgEndFrame {
        <CMsgEndFrame as ::protobuf::Message>::default_instance()
    }
}

impl CMsgEndFrame {
    pub fn new() -> CMsgEndFrame {
        ::std::default::Default::default()
    }

    // optional uint32 mouse_cursor_texture_id = 1;

    pub fn mouse_cursor_texture_id(&self) -> u32 {
        self.mouse_cursor_texture_id.unwrap_or(0)
    }

    pub fn clear_mouse_cursor_texture_id(&mut self) {
        self.mouse_cursor_texture_id = ::std::option::Option::None;
    }

    pub fn has_mouse_cursor_texture_id(&self) -> bool {
        self.mouse_cursor_texture_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mouse_cursor_texture_id(&mut self, v: u32) {
        self.mouse_cursor_texture_id = ::std::option::Option::Some(v);
    }

    // optional float mouse_cursor_hotspot_x = 2;

    pub fn mouse_cursor_hotspot_x(&self) -> f32 {
        self.mouse_cursor_hotspot_x.unwrap_or(0.)
    }

    pub fn clear_mouse_cursor_hotspot_x(&mut self) {
        self.mouse_cursor_hotspot_x = ::std::option::Option::None;
    }

    pub fn has_mouse_cursor_hotspot_x(&self) -> bool {
        self.mouse_cursor_hotspot_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mouse_cursor_hotspot_x(&mut self, v: f32) {
        self.mouse_cursor_hotspot_x = ::std::option::Option::Some(v);
    }

    // optional float mouse_cursor_hotspot_y = 3;

    pub fn mouse_cursor_hotspot_y(&self) -> f32 {
        self.mouse_cursor_hotspot_y.unwrap_or(0.)
    }

    pub fn clear_mouse_cursor_hotspot_y(&mut self) {
        self.mouse_cursor_hotspot_y = ::std::option::Option::None;
    }

    pub fn has_mouse_cursor_hotspot_y(&self) -> bool {
        self.mouse_cursor_hotspot_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mouse_cursor_hotspot_y(&mut self, v: f32) {
        self.mouse_cursor_hotspot_y = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgEndFrame {
    const NAME: &'static str = "CMsgEndFrame";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.mouse_cursor_texture_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.mouse_cursor_hotspot_x = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.mouse_cursor_hotspot_y = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mouse_cursor_texture_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.mouse_cursor_hotspot_x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.mouse_cursor_hotspot_y {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.mouse_cursor_texture_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.mouse_cursor_hotspot_x {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.mouse_cursor_hotspot_y {
            os.write_float(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgEndFrame {
        CMsgEndFrame::new()
    }

    fn clear(&mut self) {
        self.mouse_cursor_texture_id = ::std::option::Option::None;
        self.mouse_cursor_hotspot_x = ::std::option::Option::None;
        self.mouse_cursor_hotspot_y = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgEndFrame {
        static instance: CMsgEndFrame = CMsgEndFrame {
            mouse_cursor_texture_id: ::std::option::Option::None,
            mouse_cursor_hotspot_x: ::std::option::Option::None,
            mouse_cursor_hotspot_y: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClearBackbuffer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClearBackbuffer {
    // message fields
    // @@protoc_insertion_point(field:CMsgClearBackbuffer.clear_color_rgba)
    pub clear_color_rgba: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClearBackbuffer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClearBackbuffer {
    fn default() -> &'a CMsgClearBackbuffer {
        <CMsgClearBackbuffer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClearBackbuffer {
    pub fn new() -> CMsgClearBackbuffer {
        ::std::default::Default::default()
    }

    // optional uint32 clear_color_rgba = 1;

    pub fn clear_color_rgba(&self) -> u32 {
        self.clear_color_rgba.unwrap_or(0)
    }

    pub fn clear_clear_color_rgba(&mut self) {
        self.clear_color_rgba = ::std::option::Option::None;
    }

    pub fn has_clear_color_rgba(&self) -> bool {
        self.clear_color_rgba.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clear_color_rgba(&mut self, v: u32) {
        self.clear_color_rgba = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClearBackbuffer {
    const NAME: &'static str = "CMsgClearBackbuffer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.clear_color_rgba = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.clear_color_rgba {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.clear_color_rgba {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClearBackbuffer {
        CMsgClearBackbuffer::new()
    }

    fn clear(&mut self) {
        self.clear_color_rgba = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClearBackbuffer {
        static instance: CMsgClearBackbuffer = CMsgClearBackbuffer {
            clear_color_rgba: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDeleteTexture)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDeleteTexture {
    // message fields
    // @@protoc_insertion_point(field:CMsgDeleteTexture.texture_pointer)
    pub texture_pointer: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDeleteTexture.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDeleteTexture {
    fn default() -> &'a CMsgDeleteTexture {
        <CMsgDeleteTexture as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDeleteTexture {
    pub fn new() -> CMsgDeleteTexture {
        ::std::default::Default::default()
    }

    // optional uint64 texture_pointer = 1;

    pub fn texture_pointer(&self) -> u64 {
        self.texture_pointer.unwrap_or(0)
    }

    pub fn clear_texture_pointer(&mut self) {
        self.texture_pointer = ::std::option::Option::None;
    }

    pub fn has_texture_pointer(&self) -> bool {
        self.texture_pointer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_texture_pointer(&mut self, v: u64) {
        self.texture_pointer = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgDeleteTexture {
    const NAME: &'static str = "CMsgDeleteTexture";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.texture_pointer = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.texture_pointer {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.texture_pointer {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDeleteTexture {
        CMsgDeleteTexture::new()
    }

    fn clear(&mut self) {
        self.texture_pointer = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDeleteTexture {
        static instance: CMsgDeleteTexture = CMsgDeleteTexture {
            texture_pointer: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDeletePanel)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDeletePanel {
    // message fields
    // @@protoc_insertion_point(field:CMsgDeletePanel.context_id)
    pub context_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDeletePanel.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDeletePanel {
    fn default() -> &'a CMsgDeletePanel {
        <CMsgDeletePanel as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDeletePanel {
    pub fn new() -> CMsgDeletePanel {
        ::std::default::Default::default()
    }

    // optional uint64 context_id = 1;

    pub fn context_id(&self) -> u64 {
        self.context_id.unwrap_or(0)
    }

    pub fn clear_context_id(&mut self) {
        self.context_id = ::std::option::Option::None;
    }

    pub fn has_context_id(&self) -> bool {
        self.context_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context_id(&mut self, v: u64) {
        self.context_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgDeletePanel {
    const NAME: &'static str = "CMsgDeletePanel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.context_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.context_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.context_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDeletePanel {
        CMsgDeletePanel::new()
    }

    fn clear(&mut self) {
        self.context_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDeletePanel {
        static instance: CMsgDeletePanel = CMsgDeletePanel {
            context_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDeleteParticleSystem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDeleteParticleSystem {
    // message fields
    // @@protoc_insertion_point(field:CMsgDeleteParticleSystem.panel_handle)
    pub panel_handle: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgDeleteParticleSystem.brush_index)
    pub brush_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDeleteParticleSystem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDeleteParticleSystem {
    fn default() -> &'a CMsgDeleteParticleSystem {
        <CMsgDeleteParticleSystem as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDeleteParticleSystem {
    pub fn new() -> CMsgDeleteParticleSystem {
        ::std::default::Default::default()
    }

    // optional uint64 panel_handle = 1;

    pub fn panel_handle(&self) -> u64 {
        self.panel_handle.unwrap_or(0)
    }

    pub fn clear_panel_handle(&mut self) {
        self.panel_handle = ::std::option::Option::None;
    }

    pub fn has_panel_handle(&self) -> bool {
        self.panel_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_panel_handle(&mut self, v: u64) {
        self.panel_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 brush_index = 2;

    pub fn brush_index(&self) -> u32 {
        self.brush_index.unwrap_or(0)
    }

    pub fn clear_brush_index(&mut self) {
        self.brush_index = ::std::option::Option::None;
    }

    pub fn has_brush_index(&self) -> bool {
        self.brush_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_brush_index(&mut self, v: u32) {
        self.brush_index = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgDeleteParticleSystem {
    const NAME: &'static str = "CMsgDeleteParticleSystem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.panel_handle = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.brush_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.panel_handle {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.brush_index {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.panel_handle {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.brush_index {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDeleteParticleSystem {
        CMsgDeleteParticleSystem::new()
    }

    fn clear(&mut self) {
        self.panel_handle = ::std::option::Option::None;
        self.brush_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDeleteParticleSystem {
        static instance: CMsgDeleteParticleSystem = CMsgDeleteParticleSystem {
            panel_handle: ::std::option::Option::None,
            brush_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPoint)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPoint {
    // message fields
    // @@protoc_insertion_point(field:CMsgPoint.x)
    pub x: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPoint.y)
    pub y: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPoint.z)
    pub z: ::std::option::Option<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPoint.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPoint {
    fn default() -> &'a CMsgPoint {
        <CMsgPoint as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPoint {
    pub fn new() -> CMsgPoint {
        ::std::default::Default::default()
    }

    // optional double x = 1;

    pub fn x(&self) -> f64 {
        self.x.unwrap_or(0.)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f64) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional double y = 2;

    pub fn y(&self) -> f64 {
        self.y.unwrap_or(0.)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f64) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional double z = 3;

    pub fn z(&self) -> f64 {
        self.z.unwrap_or(0.)
    }

    pub fn clear_z(&mut self) {
        self.z = ::std::option::Option::None;
    }

    pub fn has_z(&self) -> bool {
        self.z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_z(&mut self, v: f64) {
        self.z = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgPoint {
    const NAME: &'static str = "CMsgPoint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.x = ::std::option::Option::Some(is.read_double()?);
                },
                17 => {
                    self.y = ::std::option::Option::Some(is.read_double()?);
                },
                25 => {
                    self.z = ::std::option::Option::Some(is.read_double()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.x {
            my_size += 1 + 8;
        }
        if let Some(v) = self.y {
            my_size += 1 + 8;
        }
        if let Some(v) = self.z {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.x {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.y {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.z {
            os.write_double(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPoint {
        CMsgPoint::new()
    }

    fn clear(&mut self) {
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.z = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPoint {
        static instance: CMsgPoint = CMsgPoint {
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            z: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgMatrix4x4)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMatrix4x4 {
    // message fields
    // @@protoc_insertion_point(field:CMsgMatrix4x4.m00)
    pub m00: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgMatrix4x4.m01)
    pub m01: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgMatrix4x4.m02)
    pub m02: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgMatrix4x4.m03)
    pub m03: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgMatrix4x4.m10)
    pub m10: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgMatrix4x4.m11)
    pub m11: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgMatrix4x4.m12)
    pub m12: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgMatrix4x4.m13)
    pub m13: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgMatrix4x4.m20)
    pub m20: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgMatrix4x4.m21)
    pub m21: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgMatrix4x4.m22)
    pub m22: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgMatrix4x4.m23)
    pub m23: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgMatrix4x4.m30)
    pub m30: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgMatrix4x4.m31)
    pub m31: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgMatrix4x4.m32)
    pub m32: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgMatrix4x4.m33)
    pub m33: ::std::option::Option<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMatrix4x4.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMatrix4x4 {
    fn default() -> &'a CMsgMatrix4x4 {
        <CMsgMatrix4x4 as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMatrix4x4 {
    pub fn new() -> CMsgMatrix4x4 {
        ::std::default::Default::default()
    }

    // optional double m00 = 1;

    pub fn m00(&self) -> f64 {
        self.m00.unwrap_or(0.)
    }

    pub fn clear_m00(&mut self) {
        self.m00 = ::std::option::Option::None;
    }

    pub fn has_m00(&self) -> bool {
        self.m00.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m00(&mut self, v: f64) {
        self.m00 = ::std::option::Option::Some(v);
    }

    // optional double m01 = 2;

    pub fn m01(&self) -> f64 {
        self.m01.unwrap_or(0.)
    }

    pub fn clear_m01(&mut self) {
        self.m01 = ::std::option::Option::None;
    }

    pub fn has_m01(&self) -> bool {
        self.m01.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m01(&mut self, v: f64) {
        self.m01 = ::std::option::Option::Some(v);
    }

    // optional double m02 = 3;

    pub fn m02(&self) -> f64 {
        self.m02.unwrap_or(0.)
    }

    pub fn clear_m02(&mut self) {
        self.m02 = ::std::option::Option::None;
    }

    pub fn has_m02(&self) -> bool {
        self.m02.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m02(&mut self, v: f64) {
        self.m02 = ::std::option::Option::Some(v);
    }

    // optional double m03 = 4;

    pub fn m03(&self) -> f64 {
        self.m03.unwrap_or(0.)
    }

    pub fn clear_m03(&mut self) {
        self.m03 = ::std::option::Option::None;
    }

    pub fn has_m03(&self) -> bool {
        self.m03.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m03(&mut self, v: f64) {
        self.m03 = ::std::option::Option::Some(v);
    }

    // optional double m10 = 5;

    pub fn m10(&self) -> f64 {
        self.m10.unwrap_or(0.)
    }

    pub fn clear_m10(&mut self) {
        self.m10 = ::std::option::Option::None;
    }

    pub fn has_m10(&self) -> bool {
        self.m10.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m10(&mut self, v: f64) {
        self.m10 = ::std::option::Option::Some(v);
    }

    // optional double m11 = 6;

    pub fn m11(&self) -> f64 {
        self.m11.unwrap_or(0.)
    }

    pub fn clear_m11(&mut self) {
        self.m11 = ::std::option::Option::None;
    }

    pub fn has_m11(&self) -> bool {
        self.m11.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m11(&mut self, v: f64) {
        self.m11 = ::std::option::Option::Some(v);
    }

    // optional double m12 = 7;

    pub fn m12(&self) -> f64 {
        self.m12.unwrap_or(0.)
    }

    pub fn clear_m12(&mut self) {
        self.m12 = ::std::option::Option::None;
    }

    pub fn has_m12(&self) -> bool {
        self.m12.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m12(&mut self, v: f64) {
        self.m12 = ::std::option::Option::Some(v);
    }

    // optional double m13 = 8;

    pub fn m13(&self) -> f64 {
        self.m13.unwrap_or(0.)
    }

    pub fn clear_m13(&mut self) {
        self.m13 = ::std::option::Option::None;
    }

    pub fn has_m13(&self) -> bool {
        self.m13.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m13(&mut self, v: f64) {
        self.m13 = ::std::option::Option::Some(v);
    }

    // optional double m20 = 9;

    pub fn m20(&self) -> f64 {
        self.m20.unwrap_or(0.)
    }

    pub fn clear_m20(&mut self) {
        self.m20 = ::std::option::Option::None;
    }

    pub fn has_m20(&self) -> bool {
        self.m20.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m20(&mut self, v: f64) {
        self.m20 = ::std::option::Option::Some(v);
    }

    // optional double m21 = 10;

    pub fn m21(&self) -> f64 {
        self.m21.unwrap_or(0.)
    }

    pub fn clear_m21(&mut self) {
        self.m21 = ::std::option::Option::None;
    }

    pub fn has_m21(&self) -> bool {
        self.m21.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m21(&mut self, v: f64) {
        self.m21 = ::std::option::Option::Some(v);
    }

    // optional double m22 = 11;

    pub fn m22(&self) -> f64 {
        self.m22.unwrap_or(0.)
    }

    pub fn clear_m22(&mut self) {
        self.m22 = ::std::option::Option::None;
    }

    pub fn has_m22(&self) -> bool {
        self.m22.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m22(&mut self, v: f64) {
        self.m22 = ::std::option::Option::Some(v);
    }

    // optional double m23 = 12;

    pub fn m23(&self) -> f64 {
        self.m23.unwrap_or(0.)
    }

    pub fn clear_m23(&mut self) {
        self.m23 = ::std::option::Option::None;
    }

    pub fn has_m23(&self) -> bool {
        self.m23.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m23(&mut self, v: f64) {
        self.m23 = ::std::option::Option::Some(v);
    }

    // optional double m30 = 13;

    pub fn m30(&self) -> f64 {
        self.m30.unwrap_or(0.)
    }

    pub fn clear_m30(&mut self) {
        self.m30 = ::std::option::Option::None;
    }

    pub fn has_m30(&self) -> bool {
        self.m30.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m30(&mut self, v: f64) {
        self.m30 = ::std::option::Option::Some(v);
    }

    // optional double m31 = 14;

    pub fn m31(&self) -> f64 {
        self.m31.unwrap_or(0.)
    }

    pub fn clear_m31(&mut self) {
        self.m31 = ::std::option::Option::None;
    }

    pub fn has_m31(&self) -> bool {
        self.m31.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m31(&mut self, v: f64) {
        self.m31 = ::std::option::Option::Some(v);
    }

    // optional double m32 = 15;

    pub fn m32(&self) -> f64 {
        self.m32.unwrap_or(0.)
    }

    pub fn clear_m32(&mut self) {
        self.m32 = ::std::option::Option::None;
    }

    pub fn has_m32(&self) -> bool {
        self.m32.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m32(&mut self, v: f64) {
        self.m32 = ::std::option::Option::Some(v);
    }

    // optional double m33 = 16;

    pub fn m33(&self) -> f64 {
        self.m33.unwrap_or(0.)
    }

    pub fn clear_m33(&mut self) {
        self.m33 = ::std::option::Option::None;
    }

    pub fn has_m33(&self) -> bool {
        self.m33.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m33(&mut self, v: f64) {
        self.m33 = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgMatrix4x4 {
    const NAME: &'static str = "CMsgMatrix4x4";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.m00 = ::std::option::Option::Some(is.read_double()?);
                },
                17 => {
                    self.m01 = ::std::option::Option::Some(is.read_double()?);
                },
                25 => {
                    self.m02 = ::std::option::Option::Some(is.read_double()?);
                },
                33 => {
                    self.m03 = ::std::option::Option::Some(is.read_double()?);
                },
                41 => {
                    self.m10 = ::std::option::Option::Some(is.read_double()?);
                },
                49 => {
                    self.m11 = ::std::option::Option::Some(is.read_double()?);
                },
                57 => {
                    self.m12 = ::std::option::Option::Some(is.read_double()?);
                },
                65 => {
                    self.m13 = ::std::option::Option::Some(is.read_double()?);
                },
                73 => {
                    self.m20 = ::std::option::Option::Some(is.read_double()?);
                },
                81 => {
                    self.m21 = ::std::option::Option::Some(is.read_double()?);
                },
                89 => {
                    self.m22 = ::std::option::Option::Some(is.read_double()?);
                },
                97 => {
                    self.m23 = ::std::option::Option::Some(is.read_double()?);
                },
                105 => {
                    self.m30 = ::std::option::Option::Some(is.read_double()?);
                },
                113 => {
                    self.m31 = ::std::option::Option::Some(is.read_double()?);
                },
                121 => {
                    self.m32 = ::std::option::Option::Some(is.read_double()?);
                },
                129 => {
                    self.m33 = ::std::option::Option::Some(is.read_double()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.m00 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.m01 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.m02 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.m03 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.m10 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.m11 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.m12 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.m13 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.m20 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.m21 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.m22 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.m23 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.m30 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.m31 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.m32 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.m33 {
            my_size += 2 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.m00 {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.m01 {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.m02 {
            os.write_double(3, v)?;
        }
        if let Some(v) = self.m03 {
            os.write_double(4, v)?;
        }
        if let Some(v) = self.m10 {
            os.write_double(5, v)?;
        }
        if let Some(v) = self.m11 {
            os.write_double(6, v)?;
        }
        if let Some(v) = self.m12 {
            os.write_double(7, v)?;
        }
        if let Some(v) = self.m13 {
            os.write_double(8, v)?;
        }
        if let Some(v) = self.m20 {
            os.write_double(9, v)?;
        }
        if let Some(v) = self.m21 {
            os.write_double(10, v)?;
        }
        if let Some(v) = self.m22 {
            os.write_double(11, v)?;
        }
        if let Some(v) = self.m23 {
            os.write_double(12, v)?;
        }
        if let Some(v) = self.m30 {
            os.write_double(13, v)?;
        }
        if let Some(v) = self.m31 {
            os.write_double(14, v)?;
        }
        if let Some(v) = self.m32 {
            os.write_double(15, v)?;
        }
        if let Some(v) = self.m33 {
            os.write_double(16, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMatrix4x4 {
        CMsgMatrix4x4::new()
    }

    fn clear(&mut self) {
        self.m00 = ::std::option::Option::None;
        self.m01 = ::std::option::Option::None;
        self.m02 = ::std::option::Option::None;
        self.m03 = ::std::option::Option::None;
        self.m10 = ::std::option::Option::None;
        self.m11 = ::std::option::Option::None;
        self.m12 = ::std::option::Option::None;
        self.m13 = ::std::option::Option::None;
        self.m20 = ::std::option::Option::None;
        self.m21 = ::std::option::Option::None;
        self.m22 = ::std::option::Option::None;
        self.m23 = ::std::option::Option::None;
        self.m30 = ::std::option::Option::None;
        self.m31 = ::std::option::Option::None;
        self.m32 = ::std::option::Option::None;
        self.m33 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMatrix4x4 {
        static instance: CMsgMatrix4x4 = CMsgMatrix4x4 {
            m00: ::std::option::Option::None,
            m01: ::std::option::Option::None,
            m02: ::std::option::Option::None,
            m03: ::std::option::Option::None,
            m10: ::std::option::Option::None,
            m11: ::std::option::Option::None,
            m12: ::std::option::Option::None,
            m13: ::std::option::Option::None,
            m20: ::std::option::Option::None,
            m21: ::std::option::Option::None,
            m22: ::std::option::Option::None,
            m23: ::std::option::Option::None,
            m30: ::std::option::Option::None,
            m31: ::std::option::Option::None,
            m32: ::std::option::Option::None,
            m33: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CRadiusData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CRadiusData {
    // message fields
    // @@protoc_insertion_point(field:CRadiusData.top_left)
    pub top_left: ::protobuf::MessageField<cradius_data::CCornerRadius>,
    // @@protoc_insertion_point(field:CRadiusData.top_right)
    pub top_right: ::protobuf::MessageField<cradius_data::CCornerRadius>,
    // @@protoc_insertion_point(field:CRadiusData.bottom_right)
    pub bottom_right: ::protobuf::MessageField<cradius_data::CCornerRadius>,
    // @@protoc_insertion_point(field:CRadiusData.bottom_left)
    pub bottom_left: ::protobuf::MessageField<cradius_data::CCornerRadius>,
    // special fields
    // @@protoc_insertion_point(special_field:CRadiusData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CRadiusData {
    fn default() -> &'a CRadiusData {
        <CRadiusData as ::protobuf::Message>::default_instance()
    }
}

impl CRadiusData {
    pub fn new() -> CRadiusData {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CRadiusData {
    const NAME: &'static str = "CRadiusData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.top_left)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.top_right)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.bottom_right)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.bottom_left)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.top_left.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.top_right.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.bottom_right.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.bottom_left.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.top_left.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.top_right.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.bottom_right.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.bottom_left.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CRadiusData {
        CRadiusData::new()
    }

    fn clear(&mut self) {
        self.top_left.clear();
        self.top_right.clear();
        self.bottom_right.clear();
        self.bottom_left.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CRadiusData {
        static instance: CRadiusData = CRadiusData {
            top_left: ::protobuf::MessageField::none(),
            top_right: ::protobuf::MessageField::none(),
            bottom_right: ::protobuf::MessageField::none(),
            bottom_left: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CRadiusData`
pub mod cradius_data {
    // @@protoc_insertion_point(message:CRadiusData.CCornerRadius)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CCornerRadius {
        // message fields
        // @@protoc_insertion_point(field:CRadiusData.CCornerRadius.horizontal)
        pub horizontal: ::std::option::Option<f64>,
        // @@protoc_insertion_point(field:CRadiusData.CCornerRadius.vertical)
        pub vertical: ::std::option::Option<f64>,
        // special fields
        // @@protoc_insertion_point(special_field:CRadiusData.CCornerRadius.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CCornerRadius {
        fn default() -> &'a CCornerRadius {
            <CCornerRadius as ::protobuf::Message>::default_instance()
        }
    }

    impl CCornerRadius {
        pub fn new() -> CCornerRadius {
            ::std::default::Default::default()
        }

        // optional double horizontal = 1;

        pub fn horizontal(&self) -> f64 {
            self.horizontal.unwrap_or(0.)
        }

        pub fn clear_horizontal(&mut self) {
            self.horizontal = ::std::option::Option::None;
        }

        pub fn has_horizontal(&self) -> bool {
            self.horizontal.is_some()
        }

        // Param is passed by value, moved
        pub fn set_horizontal(&mut self, v: f64) {
            self.horizontal = ::std::option::Option::Some(v);
        }

        // optional double vertical = 2;

        pub fn vertical(&self) -> f64 {
            self.vertical.unwrap_or(0.)
        }

        pub fn clear_vertical(&mut self) {
            self.vertical = ::std::option::Option::None;
        }

        pub fn has_vertical(&self) -> bool {
            self.vertical.is_some()
        }

        // Param is passed by value, moved
        pub fn set_vertical(&mut self, v: f64) {
            self.vertical = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for CCornerRadius {
        const NAME: &'static str = "CCornerRadius";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.horizontal = ::std::option::Option::Some(is.read_double()?);
                    },
                    17 => {
                        self.vertical = ::std::option::Option::Some(is.read_double()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.horizontal {
                my_size += 1 + 8;
            }
            if let Some(v) = self.vertical {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.horizontal {
                os.write_double(1, v)?;
            }
            if let Some(v) = self.vertical {
                os.write_double(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CCornerRadius {
            CCornerRadius::new()
        }

        fn clear(&mut self) {
            self.horizontal = ::std::option::Option::None;
            self.vertical = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CCornerRadius {
            static instance: CCornerRadius = CCornerRadius {
                horizontal: ::std::option::Option::None,
                vertical: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CBorderData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBorderData {
    // message fields
    // @@protoc_insertion_point(field:CBorderData.top)
    pub top: ::protobuf::MessageField<cborder_data::CBorderSide>,
    // @@protoc_insertion_point(field:CBorderData.right)
    pub right: ::protobuf::MessageField<cborder_data::CBorderSide>,
    // @@protoc_insertion_point(field:CBorderData.bottom)
    pub bottom: ::protobuf::MessageField<cborder_data::CBorderSide>,
    // @@protoc_insertion_point(field:CBorderData.left)
    pub left: ::protobuf::MessageField<cborder_data::CBorderSide>,
    // special fields
    // @@protoc_insertion_point(special_field:CBorderData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBorderData {
    fn default() -> &'a CBorderData {
        <CBorderData as ::protobuf::Message>::default_instance()
    }
}

impl CBorderData {
    pub fn new() -> CBorderData {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CBorderData {
    const NAME: &'static str = "CBorderData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.top)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.right)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.bottom)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.left)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.top.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.right.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.bottom.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.left.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.top.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.right.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.bottom.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.left.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBorderData {
        CBorderData::new()
    }

    fn clear(&mut self) {
        self.top.clear();
        self.right.clear();
        self.bottom.clear();
        self.left.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBorderData {
        static instance: CBorderData = CBorderData {
            top: ::protobuf::MessageField::none(),
            right: ::protobuf::MessageField::none(),
            bottom: ::protobuf::MessageField::none(),
            left: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CBorderData`
pub mod cborder_data {
    // @@protoc_insertion_point(message:CBorderData.CBorderSide)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CBorderSide {
        // message fields
        // @@protoc_insertion_point(field:CBorderData.CBorderSide.style)
        pub style: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CBorderData.CBorderSide.width)
        pub width: ::std::option::Option<f64>,
        // @@protoc_insertion_point(field:CBorderData.CBorderSide.color)
        pub color: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CBorderData.CBorderSide.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CBorderSide {
        fn default() -> &'a CBorderSide {
            <CBorderSide as ::protobuf::Message>::default_instance()
        }
    }

    impl CBorderSide {
        pub fn new() -> CBorderSide {
            ::std::default::Default::default()
        }

        // optional uint32 style = 1;

        pub fn style(&self) -> u32 {
            self.style.unwrap_or(0)
        }

        pub fn clear_style(&mut self) {
            self.style = ::std::option::Option::None;
        }

        pub fn has_style(&self) -> bool {
            self.style.is_some()
        }

        // Param is passed by value, moved
        pub fn set_style(&mut self, v: u32) {
            self.style = ::std::option::Option::Some(v);
        }

        // optional double width = 2;

        pub fn width(&self) -> f64 {
            self.width.unwrap_or(0.)
        }

        pub fn clear_width(&mut self) {
            self.width = ::std::option::Option::None;
        }

        pub fn has_width(&self) -> bool {
            self.width.is_some()
        }

        // Param is passed by value, moved
        pub fn set_width(&mut self, v: f64) {
            self.width = ::std::option::Option::Some(v);
        }

        // optional uint32 color = 3;

        pub fn color(&self) -> u32 {
            self.color.unwrap_or(0)
        }

        pub fn clear_color(&mut self) {
            self.color = ::std::option::Option::None;
        }

        pub fn has_color(&self) -> bool {
            self.color.is_some()
        }

        // Param is passed by value, moved
        pub fn set_color(&mut self, v: u32) {
            self.color = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for CBorderSide {
        const NAME: &'static str = "CBorderSide";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.style = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    17 => {
                        self.width = ::std::option::Option::Some(is.read_double()?);
                    },
                    24 => {
                        self.color = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.style {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.width {
                my_size += 1 + 8;
            }
            if let Some(v) = self.color {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.style {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.width {
                os.write_double(2, v)?;
            }
            if let Some(v) = self.color {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CBorderSide {
            CBorderSide::new()
        }

        fn clear(&mut self) {
            self.style = ::std::option::Option::None;
            self.width = ::std::option::Option::None;
            self.color = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CBorderSide {
            static instance: CBorderSide = CBorderSide {
                style: ::std::option::Option::None,
                width: ::std::option::Option::None,
                color: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CBoxShadowData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBoxShadowData {
    // message fields
    // @@protoc_insertion_point(field:CBoxShadowData.inset)
    pub inset: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CBoxShadowData.horizontal_offset)
    pub horizontal_offset: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CBoxShadowData.vertical_offset)
    pub vertical_offset: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CBoxShadowData.blur_radius)
    pub blur_radius: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CBoxShadowData.spread_distance)
    pub spread_distance: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CBoxShadowData.color)
    pub color: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CBoxShadowData.fill)
    pub fill: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CBoxShadowData.animating)
    pub animating: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CBoxShadowData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBoxShadowData {
    fn default() -> &'a CBoxShadowData {
        <CBoxShadowData as ::protobuf::Message>::default_instance()
    }
}

impl CBoxShadowData {
    pub fn new() -> CBoxShadowData {
        ::std::default::Default::default()
    }

    // optional bool inset = 1;

    pub fn inset(&self) -> bool {
        self.inset.unwrap_or(false)
    }

    pub fn clear_inset(&mut self) {
        self.inset = ::std::option::Option::None;
    }

    pub fn has_inset(&self) -> bool {
        self.inset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inset(&mut self, v: bool) {
        self.inset = ::std::option::Option::Some(v);
    }

    // optional double horizontal_offset = 2;

    pub fn horizontal_offset(&self) -> f64 {
        self.horizontal_offset.unwrap_or(0.)
    }

    pub fn clear_horizontal_offset(&mut self) {
        self.horizontal_offset = ::std::option::Option::None;
    }

    pub fn has_horizontal_offset(&self) -> bool {
        self.horizontal_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_horizontal_offset(&mut self, v: f64) {
        self.horizontal_offset = ::std::option::Option::Some(v);
    }

    // optional double vertical_offset = 3;

    pub fn vertical_offset(&self) -> f64 {
        self.vertical_offset.unwrap_or(0.)
    }

    pub fn clear_vertical_offset(&mut self) {
        self.vertical_offset = ::std::option::Option::None;
    }

    pub fn has_vertical_offset(&self) -> bool {
        self.vertical_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vertical_offset(&mut self, v: f64) {
        self.vertical_offset = ::std::option::Option::Some(v);
    }

    // optional double blur_radius = 4;

    pub fn blur_radius(&self) -> f64 {
        self.blur_radius.unwrap_or(0.)
    }

    pub fn clear_blur_radius(&mut self) {
        self.blur_radius = ::std::option::Option::None;
    }

    pub fn has_blur_radius(&self) -> bool {
        self.blur_radius.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blur_radius(&mut self, v: f64) {
        self.blur_radius = ::std::option::Option::Some(v);
    }

    // optional double spread_distance = 5;

    pub fn spread_distance(&self) -> f64 {
        self.spread_distance.unwrap_or(0.)
    }

    pub fn clear_spread_distance(&mut self) {
        self.spread_distance = ::std::option::Option::None;
    }

    pub fn has_spread_distance(&self) -> bool {
        self.spread_distance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spread_distance(&mut self, v: f64) {
        self.spread_distance = ::std::option::Option::Some(v);
    }

    // optional uint32 color = 6;

    pub fn color(&self) -> u32 {
        self.color.unwrap_or(0)
    }

    pub fn clear_color(&mut self) {
        self.color = ::std::option::Option::None;
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: u32) {
        self.color = ::std::option::Option::Some(v);
    }

    // optional bool fill = 7;

    pub fn fill(&self) -> bool {
        self.fill.unwrap_or(false)
    }

    pub fn clear_fill(&mut self) {
        self.fill = ::std::option::Option::None;
    }

    pub fn has_fill(&self) -> bool {
        self.fill.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fill(&mut self, v: bool) {
        self.fill = ::std::option::Option::Some(v);
    }

    // optional bool animating = 8;

    pub fn animating(&self) -> bool {
        self.animating.unwrap_or(false)
    }

    pub fn clear_animating(&mut self) {
        self.animating = ::std::option::Option::None;
    }

    pub fn has_animating(&self) -> bool {
        self.animating.is_some()
    }

    // Param is passed by value, moved
    pub fn set_animating(&mut self, v: bool) {
        self.animating = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBoxShadowData {
    const NAME: &'static str = "CBoxShadowData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.inset = ::std::option::Option::Some(is.read_bool()?);
                },
                17 => {
                    self.horizontal_offset = ::std::option::Option::Some(is.read_double()?);
                },
                25 => {
                    self.vertical_offset = ::std::option::Option::Some(is.read_double()?);
                },
                33 => {
                    self.blur_radius = ::std::option::Option::Some(is.read_double()?);
                },
                41 => {
                    self.spread_distance = ::std::option::Option::Some(is.read_double()?);
                },
                48 => {
                    self.color = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.fill = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.animating = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.inset {
            my_size += 1 + 1;
        }
        if let Some(v) = self.horizontal_offset {
            my_size += 1 + 8;
        }
        if let Some(v) = self.vertical_offset {
            my_size += 1 + 8;
        }
        if let Some(v) = self.blur_radius {
            my_size += 1 + 8;
        }
        if let Some(v) = self.spread_distance {
            my_size += 1 + 8;
        }
        if let Some(v) = self.color {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.fill {
            my_size += 1 + 1;
        }
        if let Some(v) = self.animating {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.inset {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.horizontal_offset {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.vertical_offset {
            os.write_double(3, v)?;
        }
        if let Some(v) = self.blur_radius {
            os.write_double(4, v)?;
        }
        if let Some(v) = self.spread_distance {
            os.write_double(5, v)?;
        }
        if let Some(v) = self.color {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.fill {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.animating {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBoxShadowData {
        CBoxShadowData::new()
    }

    fn clear(&mut self) {
        self.inset = ::std::option::Option::None;
        self.horizontal_offset = ::std::option::Option::None;
        self.vertical_offset = ::std::option::Option::None;
        self.blur_radius = ::std::option::Option::None;
        self.spread_distance = ::std::option::Option::None;
        self.color = ::std::option::Option::None;
        self.fill = ::std::option::Option::None;
        self.animating = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBoxShadowData {
        static instance: CBoxShadowData = CBoxShadowData {
            inset: ::std::option::Option::None,
            horizontal_offset: ::std::option::Option::None,
            vertical_offset: ::std::option::Option::None,
            blur_radius: ::std::option::Option::None,
            spread_distance: ::std::option::Option::None,
            color: ::std::option::Option::None,
            fill: ::std::option::Option::None,
            animating: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CTextShadowData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CTextShadowData {
    // message fields
    // @@protoc_insertion_point(field:CTextShadowData.horizontal_offset)
    pub horizontal_offset: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CTextShadowData.vertical_offset)
    pub vertical_offset: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CTextShadowData.blur_radius)
    pub blur_radius: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CTextShadowData.color)
    pub color: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CTextShadowData.animating)
    pub animating: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CTextShadowData.strength)
    pub strength: ::std::option::Option<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:CTextShadowData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CTextShadowData {
    fn default() -> &'a CTextShadowData {
        <CTextShadowData as ::protobuf::Message>::default_instance()
    }
}

impl CTextShadowData {
    pub fn new() -> CTextShadowData {
        ::std::default::Default::default()
    }

    // optional double horizontal_offset = 2;

    pub fn horizontal_offset(&self) -> f64 {
        self.horizontal_offset.unwrap_or(0.)
    }

    pub fn clear_horizontal_offset(&mut self) {
        self.horizontal_offset = ::std::option::Option::None;
    }

    pub fn has_horizontal_offset(&self) -> bool {
        self.horizontal_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_horizontal_offset(&mut self, v: f64) {
        self.horizontal_offset = ::std::option::Option::Some(v);
    }

    // optional double vertical_offset = 3;

    pub fn vertical_offset(&self) -> f64 {
        self.vertical_offset.unwrap_or(0.)
    }

    pub fn clear_vertical_offset(&mut self) {
        self.vertical_offset = ::std::option::Option::None;
    }

    pub fn has_vertical_offset(&self) -> bool {
        self.vertical_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vertical_offset(&mut self, v: f64) {
        self.vertical_offset = ::std::option::Option::Some(v);
    }

    // optional double blur_radius = 4;

    pub fn blur_radius(&self) -> f64 {
        self.blur_radius.unwrap_or(0.)
    }

    pub fn clear_blur_radius(&mut self) {
        self.blur_radius = ::std::option::Option::None;
    }

    pub fn has_blur_radius(&self) -> bool {
        self.blur_radius.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blur_radius(&mut self, v: f64) {
        self.blur_radius = ::std::option::Option::Some(v);
    }

    // optional uint32 color = 6;

    pub fn color(&self) -> u32 {
        self.color.unwrap_or(0)
    }

    pub fn clear_color(&mut self) {
        self.color = ::std::option::Option::None;
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: u32) {
        self.color = ::std::option::Option::Some(v);
    }

    // optional bool animating = 8;

    pub fn animating(&self) -> bool {
        self.animating.unwrap_or(false)
    }

    pub fn clear_animating(&mut self) {
        self.animating = ::std::option::Option::None;
    }

    pub fn has_animating(&self) -> bool {
        self.animating.is_some()
    }

    // Param is passed by value, moved
    pub fn set_animating(&mut self, v: bool) {
        self.animating = ::std::option::Option::Some(v);
    }

    // optional double strength = 9;

    pub fn strength(&self) -> f64 {
        self.strength.unwrap_or(0.)
    }

    pub fn clear_strength(&mut self) {
        self.strength = ::std::option::Option::None;
    }

    pub fn has_strength(&self) -> bool {
        self.strength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strength(&mut self, v: f64) {
        self.strength = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CTextShadowData {
    const NAME: &'static str = "CTextShadowData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                17 => {
                    self.horizontal_offset = ::std::option::Option::Some(is.read_double()?);
                },
                25 => {
                    self.vertical_offset = ::std::option::Option::Some(is.read_double()?);
                },
                33 => {
                    self.blur_radius = ::std::option::Option::Some(is.read_double()?);
                },
                48 => {
                    self.color = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.animating = ::std::option::Option::Some(is.read_bool()?);
                },
                73 => {
                    self.strength = ::std::option::Option::Some(is.read_double()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.horizontal_offset {
            my_size += 1 + 8;
        }
        if let Some(v) = self.vertical_offset {
            my_size += 1 + 8;
        }
        if let Some(v) = self.blur_radius {
            my_size += 1 + 8;
        }
        if let Some(v) = self.color {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.animating {
            my_size += 1 + 1;
        }
        if let Some(v) = self.strength {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.horizontal_offset {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.vertical_offset {
            os.write_double(3, v)?;
        }
        if let Some(v) = self.blur_radius {
            os.write_double(4, v)?;
        }
        if let Some(v) = self.color {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.animating {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.strength {
            os.write_double(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CTextShadowData {
        CTextShadowData::new()
    }

    fn clear(&mut self) {
        self.horizontal_offset = ::std::option::Option::None;
        self.vertical_offset = ::std::option::Option::None;
        self.blur_radius = ::std::option::Option::None;
        self.color = ::std::option::Option::None;
        self.animating = ::std::option::Option::None;
        self.strength = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CTextShadowData {
        static instance: CTextShadowData = CTextShadowData {
            horizontal_offset: ::std::option::Option::None,
            vertical_offset: ::std::option::Option::None,
            blur_radius: ::std::option::Option::None,
            color: ::std::option::Option::None,
            animating: ::std::option::Option::None,
            strength: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CRadialClipData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CRadialClipData {
    // message fields
    // @@protoc_insertion_point(field:CRadialClipData.center_x)
    pub center_x: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CRadialClipData.center_y)
    pub center_y: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CRadialClipData.start_angle)
    pub start_angle: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CRadialClipData.sector_angle)
    pub sector_angle: ::std::option::Option<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:CRadialClipData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CRadialClipData {
    fn default() -> &'a CRadialClipData {
        <CRadialClipData as ::protobuf::Message>::default_instance()
    }
}

impl CRadialClipData {
    pub fn new() -> CRadialClipData {
        ::std::default::Default::default()
    }

    // optional double center_x = 1;

    pub fn center_x(&self) -> f64 {
        self.center_x.unwrap_or(0.)
    }

    pub fn clear_center_x(&mut self) {
        self.center_x = ::std::option::Option::None;
    }

    pub fn has_center_x(&self) -> bool {
        self.center_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_center_x(&mut self, v: f64) {
        self.center_x = ::std::option::Option::Some(v);
    }

    // optional double center_y = 2;

    pub fn center_y(&self) -> f64 {
        self.center_y.unwrap_or(0.)
    }

    pub fn clear_center_y(&mut self) {
        self.center_y = ::std::option::Option::None;
    }

    pub fn has_center_y(&self) -> bool {
        self.center_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_center_y(&mut self, v: f64) {
        self.center_y = ::std::option::Option::Some(v);
    }

    // optional double start_angle = 3;

    pub fn start_angle(&self) -> f64 {
        self.start_angle.unwrap_or(0.)
    }

    pub fn clear_start_angle(&mut self) {
        self.start_angle = ::std::option::Option::None;
    }

    pub fn has_start_angle(&self) -> bool {
        self.start_angle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_angle(&mut self, v: f64) {
        self.start_angle = ::std::option::Option::Some(v);
    }

    // optional double sector_angle = 4;

    pub fn sector_angle(&self) -> f64 {
        self.sector_angle.unwrap_or(0.)
    }

    pub fn clear_sector_angle(&mut self) {
        self.sector_angle = ::std::option::Option::None;
    }

    pub fn has_sector_angle(&self) -> bool {
        self.sector_angle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sector_angle(&mut self, v: f64) {
        self.sector_angle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CRadialClipData {
    const NAME: &'static str = "CRadialClipData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.center_x = ::std::option::Option::Some(is.read_double()?);
                },
                17 => {
                    self.center_y = ::std::option::Option::Some(is.read_double()?);
                },
                25 => {
                    self.start_angle = ::std::option::Option::Some(is.read_double()?);
                },
                33 => {
                    self.sector_angle = ::std::option::Option::Some(is.read_double()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.center_x {
            my_size += 1 + 8;
        }
        if let Some(v) = self.center_y {
            my_size += 1 + 8;
        }
        if let Some(v) = self.start_angle {
            my_size += 1 + 8;
        }
        if let Some(v) = self.sector_angle {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.center_x {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.center_y {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.start_angle {
            os.write_double(3, v)?;
        }
        if let Some(v) = self.sector_angle {
            os.write_double(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CRadialClipData {
        CRadialClipData::new()
    }

    fn clear(&mut self) {
        self.center_x = ::std::option::Option::None;
        self.center_y = ::std::option::Option::None;
        self.start_angle = ::std::option::Option::None;
        self.sector_angle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CRadialClipData {
        static instance: CRadialClipData = CRadialClipData {
            center_x: ::std::option::Option::None,
            center_y: ::std::option::Option::None,
            start_angle: ::std::option::Option::None,
            sector_angle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClipData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClipData {
    // message fields
    // @@protoc_insertion_point(field:CMsgClipData.rect_clip)
    pub rect_clip: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClipData.left)
    pub left: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgClipData.top)
    pub top: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgClipData.right)
    pub right: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgClipData.bottom)
    pub bottom: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgClipData.radial_clip)
    pub radial_clip: ::protobuf::MessageField<CRadialClipData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClipData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClipData {
    fn default() -> &'a CMsgClipData {
        <CMsgClipData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClipData {
    pub fn new() -> CMsgClipData {
        ::std::default::Default::default()
    }

    // optional bool rect_clip = 1;

    pub fn rect_clip(&self) -> bool {
        self.rect_clip.unwrap_or(false)
    }

    pub fn clear_rect_clip(&mut self) {
        self.rect_clip = ::std::option::Option::None;
    }

    pub fn has_rect_clip(&self) -> bool {
        self.rect_clip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rect_clip(&mut self, v: bool) {
        self.rect_clip = ::std::option::Option::Some(v);
    }

    // optional double left = 2;

    pub fn left(&self) -> f64 {
        self.left.unwrap_or(0.)
    }

    pub fn clear_left(&mut self) {
        self.left = ::std::option::Option::None;
    }

    pub fn has_left(&self) -> bool {
        self.left.is_some()
    }

    // Param is passed by value, moved
    pub fn set_left(&mut self, v: f64) {
        self.left = ::std::option::Option::Some(v);
    }

    // optional double top = 3;

    pub fn top(&self) -> f64 {
        self.top.unwrap_or(0.)
    }

    pub fn clear_top(&mut self) {
        self.top = ::std::option::Option::None;
    }

    pub fn has_top(&self) -> bool {
        self.top.is_some()
    }

    // Param is passed by value, moved
    pub fn set_top(&mut self, v: f64) {
        self.top = ::std::option::Option::Some(v);
    }

    // optional double right = 4;

    pub fn right(&self) -> f64 {
        self.right.unwrap_or(0.)
    }

    pub fn clear_right(&mut self) {
        self.right = ::std::option::Option::None;
    }

    pub fn has_right(&self) -> bool {
        self.right.is_some()
    }

    // Param is passed by value, moved
    pub fn set_right(&mut self, v: f64) {
        self.right = ::std::option::Option::Some(v);
    }

    // optional double bottom = 5;

    pub fn bottom(&self) -> f64 {
        self.bottom.unwrap_or(0.)
    }

    pub fn clear_bottom(&mut self) {
        self.bottom = ::std::option::Option::None;
    }

    pub fn has_bottom(&self) -> bool {
        self.bottom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bottom(&mut self, v: f64) {
        self.bottom = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClipData {
    const NAME: &'static str = "CMsgClipData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.rect_clip = ::std::option::Option::Some(is.read_bool()?);
                },
                17 => {
                    self.left = ::std::option::Option::Some(is.read_double()?);
                },
                25 => {
                    self.top = ::std::option::Option::Some(is.read_double()?);
                },
                33 => {
                    self.right = ::std::option::Option::Some(is.read_double()?);
                },
                41 => {
                    self.bottom = ::std::option::Option::Some(is.read_double()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.radial_clip)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rect_clip {
            my_size += 1 + 1;
        }
        if let Some(v) = self.left {
            my_size += 1 + 8;
        }
        if let Some(v) = self.top {
            my_size += 1 + 8;
        }
        if let Some(v) = self.right {
            my_size += 1 + 8;
        }
        if let Some(v) = self.bottom {
            my_size += 1 + 8;
        }
        if let Some(v) = self.radial_clip.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.rect_clip {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.left {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.top {
            os.write_double(3, v)?;
        }
        if let Some(v) = self.right {
            os.write_double(4, v)?;
        }
        if let Some(v) = self.bottom {
            os.write_double(5, v)?;
        }
        if let Some(v) = self.radial_clip.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClipData {
        CMsgClipData::new()
    }

    fn clear(&mut self) {
        self.rect_clip = ::std::option::Option::None;
        self.left = ::std::option::Option::None;
        self.top = ::std::option::Option::None;
        self.right = ::std::option::Option::None;
        self.bottom = ::std::option::Option::None;
        self.radial_clip.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClipData {
        static instance: CMsgClipData = CMsgClipData {
            rect_clip: ::std::option::Option::None,
            left: ::std::option::Option::None,
            top: ::std::option::Option::None,
            right: ::std::option::Option::None,
            bottom: ::std::option::Option::None,
            radial_clip: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPushCompositingLayer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPushCompositingLayer {
    // message fields
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.layer_id)
    pub layer_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.width)
    pub width: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.height)
    pub height: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.layer_quad_top_left_x)
    pub layer_quad_top_left_x: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.layer_quad_top_left_y)
    pub layer_quad_top_left_y: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.layer_quad_top_left_z)
    pub layer_quad_top_left_z: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.layer_quad_top_right_x)
    pub layer_quad_top_right_x: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.layer_quad_top_right_y)
    pub layer_quad_top_right_y: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.layer_quad_top_right_z)
    pub layer_quad_top_right_z: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.layer_quad_bottom_left_x)
    pub layer_quad_bottom_left_x: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.layer_quad_bottom_left_y)
    pub layer_quad_bottom_left_y: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.layer_quad_bottom_left_z)
    pub layer_quad_bottom_left_z: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.layer_quad_bottom_right_x)
    pub layer_quad_bottom_right_x: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.layer_quad_bottom_right_y)
    pub layer_quad_bottom_right_y: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.layer_quad_bottom_right_z)
    pub layer_quad_bottom_right_z: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.transform_m00)
    pub transform_m00: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.transform_m01)
    pub transform_m01: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.transform_m02)
    pub transform_m02: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.transform_m03)
    pub transform_m03: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.transform_m10)
    pub transform_m10: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.transform_m11)
    pub transform_m11: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.transform_m12)
    pub transform_m12: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.transform_m13)
    pub transform_m13: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.transform_m20)
    pub transform_m20: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.transform_m21)
    pub transform_m21: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.transform_m22)
    pub transform_m22: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.transform_m23)
    pub transform_m23: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.transform_m30)
    pub transform_m30: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.transform_m31)
    pub transform_m31: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.transform_m32)
    pub transform_m32: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.transform_m33)
    pub transform_m33: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.perspective_depth)
    pub perspective_depth: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.opacity)
    pub opacity: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.composition_color)
    pub composition_color: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.saturation)
    pub saturation: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.hue_shift)
    pub hue_shift: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.brightness)
    pub brightness: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.contrast)
    pub contrast: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.opacity_mask_texture_id)
    pub opacity_mask_texture_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.opacity_mask_opacity)
    pub opacity_mask_opacity: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.border)
    pub border: ::protobuf::MessageField<CBorderData>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.border_radius)
    pub border_radius: ::protobuf::MessageField<CRadiusData>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.box_shadow)
    pub box_shadow: ::protobuf::MessageField<CBoxShadowData>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.gaussianblur_passes)
    pub gaussianblur_passes: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.gaussianblur_stddevhor)
    pub gaussianblur_stddevhor: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.gaussianblur_stddevver)
    pub gaussianblur_stddevver: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.scale_2d_factors_x)
    pub scale_2d_factors_x: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.scale_2d_factors_y)
    pub scale_2d_factors_y: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.rotate_2d)
    pub rotate_2d: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.needs_clear)
    pub needs_clear: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.needs_depth)
    pub needs_depth: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.needs_intermediate_texture)
    pub needs_intermediate_texture: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.needs_redraw_every_frame)
    pub needs_redraw_every_frame: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.text_shadow)
    pub text_shadow: ::protobuf::MessageField<CTextShadowData>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.mix_blend_mode)
    pub mix_blend_mode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.occluded_left_edge)
    pub occluded_left_edge: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.occluded_top_edge)
    pub occluded_top_edge: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.occluded_right_edge)
    pub occluded_right_edge: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.occluded_bottom_edge)
    pub occluded_bottom_edge: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.radial_clip)
    pub radial_clip: ::protobuf::MessageField<CRadialClipData>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.motionblur_velocity)
    pub motionblur_velocity: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.motionblur_dirx)
    pub motionblur_dirx: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.motionblur_diry)
    pub motionblur_diry: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.composition_layer_texture_name)
    pub composition_layer_texture_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPushCompositingLayer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPushCompositingLayer {
    fn default() -> &'a CMsgPushCompositingLayer {
        <CMsgPushCompositingLayer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPushCompositingLayer {
    pub fn new() -> CMsgPushCompositingLayer {
        ::std::default::Default::default()
    }

    // optional uint64 layer_id = 1;

    pub fn layer_id(&self) -> u64 {
        self.layer_id.unwrap_or(0)
    }

    pub fn clear_layer_id(&mut self) {
        self.layer_id = ::std::option::Option::None;
    }

    pub fn has_layer_id(&self) -> bool {
        self.layer_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layer_id(&mut self, v: u64) {
        self.layer_id = ::std::option::Option::Some(v);
    }

    // optional double width = 2;

    pub fn width(&self) -> f64 {
        self.width.unwrap_or(0.)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: f64) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional double height = 3;

    pub fn height(&self) -> f64 {
        self.height.unwrap_or(0.)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: f64) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional double layer_quad_top_left_x = 4;

    pub fn layer_quad_top_left_x(&self) -> f64 {
        self.layer_quad_top_left_x.unwrap_or(0.)
    }

    pub fn clear_layer_quad_top_left_x(&mut self) {
        self.layer_quad_top_left_x = ::std::option::Option::None;
    }

    pub fn has_layer_quad_top_left_x(&self) -> bool {
        self.layer_quad_top_left_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layer_quad_top_left_x(&mut self, v: f64) {
        self.layer_quad_top_left_x = ::std::option::Option::Some(v);
    }

    // optional double layer_quad_top_left_y = 5;

    pub fn layer_quad_top_left_y(&self) -> f64 {
        self.layer_quad_top_left_y.unwrap_or(0.)
    }

    pub fn clear_layer_quad_top_left_y(&mut self) {
        self.layer_quad_top_left_y = ::std::option::Option::None;
    }

    pub fn has_layer_quad_top_left_y(&self) -> bool {
        self.layer_quad_top_left_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layer_quad_top_left_y(&mut self, v: f64) {
        self.layer_quad_top_left_y = ::std::option::Option::Some(v);
    }

    // optional double layer_quad_top_left_z = 6;

    pub fn layer_quad_top_left_z(&self) -> f64 {
        self.layer_quad_top_left_z.unwrap_or(0.)
    }

    pub fn clear_layer_quad_top_left_z(&mut self) {
        self.layer_quad_top_left_z = ::std::option::Option::None;
    }

    pub fn has_layer_quad_top_left_z(&self) -> bool {
        self.layer_quad_top_left_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layer_quad_top_left_z(&mut self, v: f64) {
        self.layer_quad_top_left_z = ::std::option::Option::Some(v);
    }

    // optional double layer_quad_top_right_x = 7;

    pub fn layer_quad_top_right_x(&self) -> f64 {
        self.layer_quad_top_right_x.unwrap_or(0.)
    }

    pub fn clear_layer_quad_top_right_x(&mut self) {
        self.layer_quad_top_right_x = ::std::option::Option::None;
    }

    pub fn has_layer_quad_top_right_x(&self) -> bool {
        self.layer_quad_top_right_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layer_quad_top_right_x(&mut self, v: f64) {
        self.layer_quad_top_right_x = ::std::option::Option::Some(v);
    }

    // optional double layer_quad_top_right_y = 8;

    pub fn layer_quad_top_right_y(&self) -> f64 {
        self.layer_quad_top_right_y.unwrap_or(0.)
    }

    pub fn clear_layer_quad_top_right_y(&mut self) {
        self.layer_quad_top_right_y = ::std::option::Option::None;
    }

    pub fn has_layer_quad_top_right_y(&self) -> bool {
        self.layer_quad_top_right_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layer_quad_top_right_y(&mut self, v: f64) {
        self.layer_quad_top_right_y = ::std::option::Option::Some(v);
    }

    // optional double layer_quad_top_right_z = 9;

    pub fn layer_quad_top_right_z(&self) -> f64 {
        self.layer_quad_top_right_z.unwrap_or(0.)
    }

    pub fn clear_layer_quad_top_right_z(&mut self) {
        self.layer_quad_top_right_z = ::std::option::Option::None;
    }

    pub fn has_layer_quad_top_right_z(&self) -> bool {
        self.layer_quad_top_right_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layer_quad_top_right_z(&mut self, v: f64) {
        self.layer_quad_top_right_z = ::std::option::Option::Some(v);
    }

    // optional double layer_quad_bottom_left_x = 10;

    pub fn layer_quad_bottom_left_x(&self) -> f64 {
        self.layer_quad_bottom_left_x.unwrap_or(0.)
    }

    pub fn clear_layer_quad_bottom_left_x(&mut self) {
        self.layer_quad_bottom_left_x = ::std::option::Option::None;
    }

    pub fn has_layer_quad_bottom_left_x(&self) -> bool {
        self.layer_quad_bottom_left_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layer_quad_bottom_left_x(&mut self, v: f64) {
        self.layer_quad_bottom_left_x = ::std::option::Option::Some(v);
    }

    // optional double layer_quad_bottom_left_y = 11;

    pub fn layer_quad_bottom_left_y(&self) -> f64 {
        self.layer_quad_bottom_left_y.unwrap_or(0.)
    }

    pub fn clear_layer_quad_bottom_left_y(&mut self) {
        self.layer_quad_bottom_left_y = ::std::option::Option::None;
    }

    pub fn has_layer_quad_bottom_left_y(&self) -> bool {
        self.layer_quad_bottom_left_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layer_quad_bottom_left_y(&mut self, v: f64) {
        self.layer_quad_bottom_left_y = ::std::option::Option::Some(v);
    }

    // optional double layer_quad_bottom_left_z = 12;

    pub fn layer_quad_bottom_left_z(&self) -> f64 {
        self.layer_quad_bottom_left_z.unwrap_or(0.)
    }

    pub fn clear_layer_quad_bottom_left_z(&mut self) {
        self.layer_quad_bottom_left_z = ::std::option::Option::None;
    }

    pub fn has_layer_quad_bottom_left_z(&self) -> bool {
        self.layer_quad_bottom_left_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layer_quad_bottom_left_z(&mut self, v: f64) {
        self.layer_quad_bottom_left_z = ::std::option::Option::Some(v);
    }

    // optional double layer_quad_bottom_right_x = 13;

    pub fn layer_quad_bottom_right_x(&self) -> f64 {
        self.layer_quad_bottom_right_x.unwrap_or(0.)
    }

    pub fn clear_layer_quad_bottom_right_x(&mut self) {
        self.layer_quad_bottom_right_x = ::std::option::Option::None;
    }

    pub fn has_layer_quad_bottom_right_x(&self) -> bool {
        self.layer_quad_bottom_right_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layer_quad_bottom_right_x(&mut self, v: f64) {
        self.layer_quad_bottom_right_x = ::std::option::Option::Some(v);
    }

    // optional double layer_quad_bottom_right_y = 14;

    pub fn layer_quad_bottom_right_y(&self) -> f64 {
        self.layer_quad_bottom_right_y.unwrap_or(0.)
    }

    pub fn clear_layer_quad_bottom_right_y(&mut self) {
        self.layer_quad_bottom_right_y = ::std::option::Option::None;
    }

    pub fn has_layer_quad_bottom_right_y(&self) -> bool {
        self.layer_quad_bottom_right_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layer_quad_bottom_right_y(&mut self, v: f64) {
        self.layer_quad_bottom_right_y = ::std::option::Option::Some(v);
    }

    // optional double layer_quad_bottom_right_z = 15;

    pub fn layer_quad_bottom_right_z(&self) -> f64 {
        self.layer_quad_bottom_right_z.unwrap_or(0.)
    }

    pub fn clear_layer_quad_bottom_right_z(&mut self) {
        self.layer_quad_bottom_right_z = ::std::option::Option::None;
    }

    pub fn has_layer_quad_bottom_right_z(&self) -> bool {
        self.layer_quad_bottom_right_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layer_quad_bottom_right_z(&mut self, v: f64) {
        self.layer_quad_bottom_right_z = ::std::option::Option::Some(v);
    }

    // optional double transform_m00 = 16;

    pub fn transform_m00(&self) -> f64 {
        self.transform_m00.unwrap_or(0.)
    }

    pub fn clear_transform_m00(&mut self) {
        self.transform_m00 = ::std::option::Option::None;
    }

    pub fn has_transform_m00(&self) -> bool {
        self.transform_m00.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m00(&mut self, v: f64) {
        self.transform_m00 = ::std::option::Option::Some(v);
    }

    // optional double transform_m01 = 17;

    pub fn transform_m01(&self) -> f64 {
        self.transform_m01.unwrap_or(0.)
    }

    pub fn clear_transform_m01(&mut self) {
        self.transform_m01 = ::std::option::Option::None;
    }

    pub fn has_transform_m01(&self) -> bool {
        self.transform_m01.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m01(&mut self, v: f64) {
        self.transform_m01 = ::std::option::Option::Some(v);
    }

    // optional double transform_m02 = 18;

    pub fn transform_m02(&self) -> f64 {
        self.transform_m02.unwrap_or(0.)
    }

    pub fn clear_transform_m02(&mut self) {
        self.transform_m02 = ::std::option::Option::None;
    }

    pub fn has_transform_m02(&self) -> bool {
        self.transform_m02.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m02(&mut self, v: f64) {
        self.transform_m02 = ::std::option::Option::Some(v);
    }

    // optional double transform_m03 = 19;

    pub fn transform_m03(&self) -> f64 {
        self.transform_m03.unwrap_or(0.)
    }

    pub fn clear_transform_m03(&mut self) {
        self.transform_m03 = ::std::option::Option::None;
    }

    pub fn has_transform_m03(&self) -> bool {
        self.transform_m03.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m03(&mut self, v: f64) {
        self.transform_m03 = ::std::option::Option::Some(v);
    }

    // optional double transform_m10 = 20;

    pub fn transform_m10(&self) -> f64 {
        self.transform_m10.unwrap_or(0.)
    }

    pub fn clear_transform_m10(&mut self) {
        self.transform_m10 = ::std::option::Option::None;
    }

    pub fn has_transform_m10(&self) -> bool {
        self.transform_m10.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m10(&mut self, v: f64) {
        self.transform_m10 = ::std::option::Option::Some(v);
    }

    // optional double transform_m11 = 21;

    pub fn transform_m11(&self) -> f64 {
        self.transform_m11.unwrap_or(0.)
    }

    pub fn clear_transform_m11(&mut self) {
        self.transform_m11 = ::std::option::Option::None;
    }

    pub fn has_transform_m11(&self) -> bool {
        self.transform_m11.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m11(&mut self, v: f64) {
        self.transform_m11 = ::std::option::Option::Some(v);
    }

    // optional double transform_m12 = 22;

    pub fn transform_m12(&self) -> f64 {
        self.transform_m12.unwrap_or(0.)
    }

    pub fn clear_transform_m12(&mut self) {
        self.transform_m12 = ::std::option::Option::None;
    }

    pub fn has_transform_m12(&self) -> bool {
        self.transform_m12.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m12(&mut self, v: f64) {
        self.transform_m12 = ::std::option::Option::Some(v);
    }

    // optional double transform_m13 = 23;

    pub fn transform_m13(&self) -> f64 {
        self.transform_m13.unwrap_or(0.)
    }

    pub fn clear_transform_m13(&mut self) {
        self.transform_m13 = ::std::option::Option::None;
    }

    pub fn has_transform_m13(&self) -> bool {
        self.transform_m13.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m13(&mut self, v: f64) {
        self.transform_m13 = ::std::option::Option::Some(v);
    }

    // optional double transform_m20 = 24;

    pub fn transform_m20(&self) -> f64 {
        self.transform_m20.unwrap_or(0.)
    }

    pub fn clear_transform_m20(&mut self) {
        self.transform_m20 = ::std::option::Option::None;
    }

    pub fn has_transform_m20(&self) -> bool {
        self.transform_m20.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m20(&mut self, v: f64) {
        self.transform_m20 = ::std::option::Option::Some(v);
    }

    // optional double transform_m21 = 25;

    pub fn transform_m21(&self) -> f64 {
        self.transform_m21.unwrap_or(0.)
    }

    pub fn clear_transform_m21(&mut self) {
        self.transform_m21 = ::std::option::Option::None;
    }

    pub fn has_transform_m21(&self) -> bool {
        self.transform_m21.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m21(&mut self, v: f64) {
        self.transform_m21 = ::std::option::Option::Some(v);
    }

    // optional double transform_m22 = 26;

    pub fn transform_m22(&self) -> f64 {
        self.transform_m22.unwrap_or(0.)
    }

    pub fn clear_transform_m22(&mut self) {
        self.transform_m22 = ::std::option::Option::None;
    }

    pub fn has_transform_m22(&self) -> bool {
        self.transform_m22.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m22(&mut self, v: f64) {
        self.transform_m22 = ::std::option::Option::Some(v);
    }

    // optional double transform_m23 = 27;

    pub fn transform_m23(&self) -> f64 {
        self.transform_m23.unwrap_or(0.)
    }

    pub fn clear_transform_m23(&mut self) {
        self.transform_m23 = ::std::option::Option::None;
    }

    pub fn has_transform_m23(&self) -> bool {
        self.transform_m23.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m23(&mut self, v: f64) {
        self.transform_m23 = ::std::option::Option::Some(v);
    }

    // optional double transform_m30 = 28;

    pub fn transform_m30(&self) -> f64 {
        self.transform_m30.unwrap_or(0.)
    }

    pub fn clear_transform_m30(&mut self) {
        self.transform_m30 = ::std::option::Option::None;
    }

    pub fn has_transform_m30(&self) -> bool {
        self.transform_m30.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m30(&mut self, v: f64) {
        self.transform_m30 = ::std::option::Option::Some(v);
    }

    // optional double transform_m31 = 29;

    pub fn transform_m31(&self) -> f64 {
        self.transform_m31.unwrap_or(0.)
    }

    pub fn clear_transform_m31(&mut self) {
        self.transform_m31 = ::std::option::Option::None;
    }

    pub fn has_transform_m31(&self) -> bool {
        self.transform_m31.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m31(&mut self, v: f64) {
        self.transform_m31 = ::std::option::Option::Some(v);
    }

    // optional double transform_m32 = 30;

    pub fn transform_m32(&self) -> f64 {
        self.transform_m32.unwrap_or(0.)
    }

    pub fn clear_transform_m32(&mut self) {
        self.transform_m32 = ::std::option::Option::None;
    }

    pub fn has_transform_m32(&self) -> bool {
        self.transform_m32.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m32(&mut self, v: f64) {
        self.transform_m32 = ::std::option::Option::Some(v);
    }

    // optional double transform_m33 = 31;

    pub fn transform_m33(&self) -> f64 {
        self.transform_m33.unwrap_or(0.)
    }

    pub fn clear_transform_m33(&mut self) {
        self.transform_m33 = ::std::option::Option::None;
    }

    pub fn has_transform_m33(&self) -> bool {
        self.transform_m33.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m33(&mut self, v: f64) {
        self.transform_m33 = ::std::option::Option::Some(v);
    }

    // optional double perspective_depth = 32;

    pub fn perspective_depth(&self) -> f64 {
        self.perspective_depth.unwrap_or(0.)
    }

    pub fn clear_perspective_depth(&mut self) {
        self.perspective_depth = ::std::option::Option::None;
    }

    pub fn has_perspective_depth(&self) -> bool {
        self.perspective_depth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_perspective_depth(&mut self, v: f64) {
        self.perspective_depth = ::std::option::Option::Some(v);
    }

    // optional double opacity = 33;

    pub fn opacity(&self) -> f64 {
        self.opacity.unwrap_or(0.)
    }

    pub fn clear_opacity(&mut self) {
        self.opacity = ::std::option::Option::None;
    }

    pub fn has_opacity(&self) -> bool {
        self.opacity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_opacity(&mut self, v: f64) {
        self.opacity = ::std::option::Option::Some(v);
    }

    // optional uint32 composition_color = 34;

    pub fn composition_color(&self) -> u32 {
        self.composition_color.unwrap_or(0)
    }

    pub fn clear_composition_color(&mut self) {
        self.composition_color = ::std::option::Option::None;
    }

    pub fn has_composition_color(&self) -> bool {
        self.composition_color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_composition_color(&mut self, v: u32) {
        self.composition_color = ::std::option::Option::Some(v);
    }

    // optional double saturation = 35;

    pub fn saturation(&self) -> f64 {
        self.saturation.unwrap_or(0.)
    }

    pub fn clear_saturation(&mut self) {
        self.saturation = ::std::option::Option::None;
    }

    pub fn has_saturation(&self) -> bool {
        self.saturation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_saturation(&mut self, v: f64) {
        self.saturation = ::std::option::Option::Some(v);
    }

    // optional double hue_shift = 36;

    pub fn hue_shift(&self) -> f64 {
        self.hue_shift.unwrap_or(0.)
    }

    pub fn clear_hue_shift(&mut self) {
        self.hue_shift = ::std::option::Option::None;
    }

    pub fn has_hue_shift(&self) -> bool {
        self.hue_shift.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hue_shift(&mut self, v: f64) {
        self.hue_shift = ::std::option::Option::Some(v);
    }

    // optional double brightness = 37;

    pub fn brightness(&self) -> f64 {
        self.brightness.unwrap_or(0.)
    }

    pub fn clear_brightness(&mut self) {
        self.brightness = ::std::option::Option::None;
    }

    pub fn has_brightness(&self) -> bool {
        self.brightness.is_some()
    }

    // Param is passed by value, moved
    pub fn set_brightness(&mut self, v: f64) {
        self.brightness = ::std::option::Option::Some(v);
    }

    // optional double contrast = 38;

    pub fn contrast(&self) -> f64 {
        self.contrast.unwrap_or(0.)
    }

    pub fn clear_contrast(&mut self) {
        self.contrast = ::std::option::Option::None;
    }

    pub fn has_contrast(&self) -> bool {
        self.contrast.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contrast(&mut self, v: f64) {
        self.contrast = ::std::option::Option::Some(v);
    }

    // optional uint32 opacity_mask_texture_id = 39;

    pub fn opacity_mask_texture_id(&self) -> u32 {
        self.opacity_mask_texture_id.unwrap_or(0)
    }

    pub fn clear_opacity_mask_texture_id(&mut self) {
        self.opacity_mask_texture_id = ::std::option::Option::None;
    }

    pub fn has_opacity_mask_texture_id(&self) -> bool {
        self.opacity_mask_texture_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_opacity_mask_texture_id(&mut self, v: u32) {
        self.opacity_mask_texture_id = ::std::option::Option::Some(v);
    }

    // optional double opacity_mask_opacity = 40;

    pub fn opacity_mask_opacity(&self) -> f64 {
        self.opacity_mask_opacity.unwrap_or(0.)
    }

    pub fn clear_opacity_mask_opacity(&mut self) {
        self.opacity_mask_opacity = ::std::option::Option::None;
    }

    pub fn has_opacity_mask_opacity(&self) -> bool {
        self.opacity_mask_opacity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_opacity_mask_opacity(&mut self, v: f64) {
        self.opacity_mask_opacity = ::std::option::Option::Some(v);
    }

    // optional double gaussianblur_passes = 44;

    pub fn gaussianblur_passes(&self) -> f64 {
        self.gaussianblur_passes.unwrap_or(0.)
    }

    pub fn clear_gaussianblur_passes(&mut self) {
        self.gaussianblur_passes = ::std::option::Option::None;
    }

    pub fn has_gaussianblur_passes(&self) -> bool {
        self.gaussianblur_passes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gaussianblur_passes(&mut self, v: f64) {
        self.gaussianblur_passes = ::std::option::Option::Some(v);
    }

    // optional double gaussianblur_stddevhor = 45;

    pub fn gaussianblur_stddevhor(&self) -> f64 {
        self.gaussianblur_stddevhor.unwrap_or(0.)
    }

    pub fn clear_gaussianblur_stddevhor(&mut self) {
        self.gaussianblur_stddevhor = ::std::option::Option::None;
    }

    pub fn has_gaussianblur_stddevhor(&self) -> bool {
        self.gaussianblur_stddevhor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gaussianblur_stddevhor(&mut self, v: f64) {
        self.gaussianblur_stddevhor = ::std::option::Option::Some(v);
    }

    // optional double gaussianblur_stddevver = 46;

    pub fn gaussianblur_stddevver(&self) -> f64 {
        self.gaussianblur_stddevver.unwrap_or(0.)
    }

    pub fn clear_gaussianblur_stddevver(&mut self) {
        self.gaussianblur_stddevver = ::std::option::Option::None;
    }

    pub fn has_gaussianblur_stddevver(&self) -> bool {
        self.gaussianblur_stddevver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gaussianblur_stddevver(&mut self, v: f64) {
        self.gaussianblur_stddevver = ::std::option::Option::Some(v);
    }

    // optional double scale_2d_factors_x = 47;

    pub fn scale_2d_factors_x(&self) -> f64 {
        self.scale_2d_factors_x.unwrap_or(0.)
    }

    pub fn clear_scale_2d_factors_x(&mut self) {
        self.scale_2d_factors_x = ::std::option::Option::None;
    }

    pub fn has_scale_2d_factors_x(&self) -> bool {
        self.scale_2d_factors_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scale_2d_factors_x(&mut self, v: f64) {
        self.scale_2d_factors_x = ::std::option::Option::Some(v);
    }

    // optional double scale_2d_factors_y = 48;

    pub fn scale_2d_factors_y(&self) -> f64 {
        self.scale_2d_factors_y.unwrap_or(0.)
    }

    pub fn clear_scale_2d_factors_y(&mut self) {
        self.scale_2d_factors_y = ::std::option::Option::None;
    }

    pub fn has_scale_2d_factors_y(&self) -> bool {
        self.scale_2d_factors_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scale_2d_factors_y(&mut self, v: f64) {
        self.scale_2d_factors_y = ::std::option::Option::Some(v);
    }

    // optional double rotate_2d = 49;

    pub fn rotate_2d(&self) -> f64 {
        self.rotate_2d.unwrap_or(0.)
    }

    pub fn clear_rotate_2d(&mut self) {
        self.rotate_2d = ::std::option::Option::None;
    }

    pub fn has_rotate_2d(&self) -> bool {
        self.rotate_2d.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rotate_2d(&mut self, v: f64) {
        self.rotate_2d = ::std::option::Option::Some(v);
    }

    // optional bool needs_clear = 50;

    pub fn needs_clear(&self) -> bool {
        self.needs_clear.unwrap_or(false)
    }

    pub fn clear_needs_clear(&mut self) {
        self.needs_clear = ::std::option::Option::None;
    }

    pub fn has_needs_clear(&self) -> bool {
        self.needs_clear.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needs_clear(&mut self, v: bool) {
        self.needs_clear = ::std::option::Option::Some(v);
    }

    // optional bool needs_depth = 51;

    pub fn needs_depth(&self) -> bool {
        self.needs_depth.unwrap_or(false)
    }

    pub fn clear_needs_depth(&mut self) {
        self.needs_depth = ::std::option::Option::None;
    }

    pub fn has_needs_depth(&self) -> bool {
        self.needs_depth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needs_depth(&mut self, v: bool) {
        self.needs_depth = ::std::option::Option::Some(v);
    }

    // optional bool needs_intermediate_texture = 52;

    pub fn needs_intermediate_texture(&self) -> bool {
        self.needs_intermediate_texture.unwrap_or(false)
    }

    pub fn clear_needs_intermediate_texture(&mut self) {
        self.needs_intermediate_texture = ::std::option::Option::None;
    }

    pub fn has_needs_intermediate_texture(&self) -> bool {
        self.needs_intermediate_texture.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needs_intermediate_texture(&mut self, v: bool) {
        self.needs_intermediate_texture = ::std::option::Option::Some(v);
    }

    // optional bool needs_redraw_every_frame = 53;

    pub fn needs_redraw_every_frame(&self) -> bool {
        self.needs_redraw_every_frame.unwrap_or(false)
    }

    pub fn clear_needs_redraw_every_frame(&mut self) {
        self.needs_redraw_every_frame = ::std::option::Option::None;
    }

    pub fn has_needs_redraw_every_frame(&self) -> bool {
        self.needs_redraw_every_frame.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needs_redraw_every_frame(&mut self, v: bool) {
        self.needs_redraw_every_frame = ::std::option::Option::Some(v);
    }

    // optional uint32 mix_blend_mode = 55;

    pub fn mix_blend_mode(&self) -> u32 {
        self.mix_blend_mode.unwrap_or(0)
    }

    pub fn clear_mix_blend_mode(&mut self) {
        self.mix_blend_mode = ::std::option::Option::None;
    }

    pub fn has_mix_blend_mode(&self) -> bool {
        self.mix_blend_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mix_blend_mode(&mut self, v: u32) {
        self.mix_blend_mode = ::std::option::Option::Some(v);
    }

    // optional double occluded_left_edge = 56;

    pub fn occluded_left_edge(&self) -> f64 {
        self.occluded_left_edge.unwrap_or(0.)
    }

    pub fn clear_occluded_left_edge(&mut self) {
        self.occluded_left_edge = ::std::option::Option::None;
    }

    pub fn has_occluded_left_edge(&self) -> bool {
        self.occluded_left_edge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_occluded_left_edge(&mut self, v: f64) {
        self.occluded_left_edge = ::std::option::Option::Some(v);
    }

    // optional double occluded_top_edge = 57;

    pub fn occluded_top_edge(&self) -> f64 {
        self.occluded_top_edge.unwrap_or(0.)
    }

    pub fn clear_occluded_top_edge(&mut self) {
        self.occluded_top_edge = ::std::option::Option::None;
    }

    pub fn has_occluded_top_edge(&self) -> bool {
        self.occluded_top_edge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_occluded_top_edge(&mut self, v: f64) {
        self.occluded_top_edge = ::std::option::Option::Some(v);
    }

    // optional double occluded_right_edge = 58;

    pub fn occluded_right_edge(&self) -> f64 {
        self.occluded_right_edge.unwrap_or(0.)
    }

    pub fn clear_occluded_right_edge(&mut self) {
        self.occluded_right_edge = ::std::option::Option::None;
    }

    pub fn has_occluded_right_edge(&self) -> bool {
        self.occluded_right_edge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_occluded_right_edge(&mut self, v: f64) {
        self.occluded_right_edge = ::std::option::Option::Some(v);
    }

    // optional double occluded_bottom_edge = 59;

    pub fn occluded_bottom_edge(&self) -> f64 {
        self.occluded_bottom_edge.unwrap_or(0.)
    }

    pub fn clear_occluded_bottom_edge(&mut self) {
        self.occluded_bottom_edge = ::std::option::Option::None;
    }

    pub fn has_occluded_bottom_edge(&self) -> bool {
        self.occluded_bottom_edge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_occluded_bottom_edge(&mut self, v: f64) {
        self.occluded_bottom_edge = ::std::option::Option::Some(v);
    }

    // optional double motionblur_velocity = 61;

    pub fn motionblur_velocity(&self) -> f64 {
        self.motionblur_velocity.unwrap_or(0.)
    }

    pub fn clear_motionblur_velocity(&mut self) {
        self.motionblur_velocity = ::std::option::Option::None;
    }

    pub fn has_motionblur_velocity(&self) -> bool {
        self.motionblur_velocity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_motionblur_velocity(&mut self, v: f64) {
        self.motionblur_velocity = ::std::option::Option::Some(v);
    }

    // optional double motionblur_dirx = 62;

    pub fn motionblur_dirx(&self) -> f64 {
        self.motionblur_dirx.unwrap_or(0.)
    }

    pub fn clear_motionblur_dirx(&mut self) {
        self.motionblur_dirx = ::std::option::Option::None;
    }

    pub fn has_motionblur_dirx(&self) -> bool {
        self.motionblur_dirx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_motionblur_dirx(&mut self, v: f64) {
        self.motionblur_dirx = ::std::option::Option::Some(v);
    }

    // optional double motionblur_diry = 63;

    pub fn motionblur_diry(&self) -> f64 {
        self.motionblur_diry.unwrap_or(0.)
    }

    pub fn clear_motionblur_diry(&mut self) {
        self.motionblur_diry = ::std::option::Option::None;
    }

    pub fn has_motionblur_diry(&self) -> bool {
        self.motionblur_diry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_motionblur_diry(&mut self, v: f64) {
        self.motionblur_diry = ::std::option::Option::Some(v);
    }

    // optional string composition_layer_texture_name = 64;

    pub fn composition_layer_texture_name(&self) -> &str {
        match self.composition_layer_texture_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_composition_layer_texture_name(&mut self) {
        self.composition_layer_texture_name = ::std::option::Option::None;
    }

    pub fn has_composition_layer_texture_name(&self) -> bool {
        self.composition_layer_texture_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_composition_layer_texture_name(&mut self, v: ::std::string::String) {
        self.composition_layer_texture_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_composition_layer_texture_name(&mut self) -> &mut ::std::string::String {
        if self.composition_layer_texture_name.is_none() {
            self.composition_layer_texture_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.composition_layer_texture_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_composition_layer_texture_name(&mut self) -> ::std::string::String {
        self.composition_layer_texture_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgPushCompositingLayer {
    const NAME: &'static str = "CMsgPushCompositingLayer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.layer_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                17 => {
                    self.width = ::std::option::Option::Some(is.read_double()?);
                },
                25 => {
                    self.height = ::std::option::Option::Some(is.read_double()?);
                },
                33 => {
                    self.layer_quad_top_left_x = ::std::option::Option::Some(is.read_double()?);
                },
                41 => {
                    self.layer_quad_top_left_y = ::std::option::Option::Some(is.read_double()?);
                },
                49 => {
                    self.layer_quad_top_left_z = ::std::option::Option::Some(is.read_double()?);
                },
                57 => {
                    self.layer_quad_top_right_x = ::std::option::Option::Some(is.read_double()?);
                },
                65 => {
                    self.layer_quad_top_right_y = ::std::option::Option::Some(is.read_double()?);
                },
                73 => {
                    self.layer_quad_top_right_z = ::std::option::Option::Some(is.read_double()?);
                },
                81 => {
                    self.layer_quad_bottom_left_x = ::std::option::Option::Some(is.read_double()?);
                },
                89 => {
                    self.layer_quad_bottom_left_y = ::std::option::Option::Some(is.read_double()?);
                },
                97 => {
                    self.layer_quad_bottom_left_z = ::std::option::Option::Some(is.read_double()?);
                },
                105 => {
                    self.layer_quad_bottom_right_x = ::std::option::Option::Some(is.read_double()?);
                },
                113 => {
                    self.layer_quad_bottom_right_y = ::std::option::Option::Some(is.read_double()?);
                },
                121 => {
                    self.layer_quad_bottom_right_z = ::std::option::Option::Some(is.read_double()?);
                },
                129 => {
                    self.transform_m00 = ::std::option::Option::Some(is.read_double()?);
                },
                137 => {
                    self.transform_m01 = ::std::option::Option::Some(is.read_double()?);
                },
                145 => {
                    self.transform_m02 = ::std::option::Option::Some(is.read_double()?);
                },
                153 => {
                    self.transform_m03 = ::std::option::Option::Some(is.read_double()?);
                },
                161 => {
                    self.transform_m10 = ::std::option::Option::Some(is.read_double()?);
                },
                169 => {
                    self.transform_m11 = ::std::option::Option::Some(is.read_double()?);
                },
                177 => {
                    self.transform_m12 = ::std::option::Option::Some(is.read_double()?);
                },
                185 => {
                    self.transform_m13 = ::std::option::Option::Some(is.read_double()?);
                },
                193 => {
                    self.transform_m20 = ::std::option::Option::Some(is.read_double()?);
                },
                201 => {
                    self.transform_m21 = ::std::option::Option::Some(is.read_double()?);
                },
                209 => {
                    self.transform_m22 = ::std::option::Option::Some(is.read_double()?);
                },
                217 => {
                    self.transform_m23 = ::std::option::Option::Some(is.read_double()?);
                },
                225 => {
                    self.transform_m30 = ::std::option::Option::Some(is.read_double()?);
                },
                233 => {
                    self.transform_m31 = ::std::option::Option::Some(is.read_double()?);
                },
                241 => {
                    self.transform_m32 = ::std::option::Option::Some(is.read_double()?);
                },
                249 => {
                    self.transform_m33 = ::std::option::Option::Some(is.read_double()?);
                },
                257 => {
                    self.perspective_depth = ::std::option::Option::Some(is.read_double()?);
                },
                265 => {
                    self.opacity = ::std::option::Option::Some(is.read_double()?);
                },
                272 => {
                    self.composition_color = ::std::option::Option::Some(is.read_uint32()?);
                },
                281 => {
                    self.saturation = ::std::option::Option::Some(is.read_double()?);
                },
                289 => {
                    self.hue_shift = ::std::option::Option::Some(is.read_double()?);
                },
                297 => {
                    self.brightness = ::std::option::Option::Some(is.read_double()?);
                },
                305 => {
                    self.contrast = ::std::option::Option::Some(is.read_double()?);
                },
                312 => {
                    self.opacity_mask_texture_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                321 => {
                    self.opacity_mask_opacity = ::std::option::Option::Some(is.read_double()?);
                },
                330 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.border)?;
                },
                338 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.border_radius)?;
                },
                346 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.box_shadow)?;
                },
                353 => {
                    self.gaussianblur_passes = ::std::option::Option::Some(is.read_double()?);
                },
                361 => {
                    self.gaussianblur_stddevhor = ::std::option::Option::Some(is.read_double()?);
                },
                369 => {
                    self.gaussianblur_stddevver = ::std::option::Option::Some(is.read_double()?);
                },
                377 => {
                    self.scale_2d_factors_x = ::std::option::Option::Some(is.read_double()?);
                },
                385 => {
                    self.scale_2d_factors_y = ::std::option::Option::Some(is.read_double()?);
                },
                393 => {
                    self.rotate_2d = ::std::option::Option::Some(is.read_double()?);
                },
                400 => {
                    self.needs_clear = ::std::option::Option::Some(is.read_bool()?);
                },
                408 => {
                    self.needs_depth = ::std::option::Option::Some(is.read_bool()?);
                },
                416 => {
                    self.needs_intermediate_texture = ::std::option::Option::Some(is.read_bool()?);
                },
                424 => {
                    self.needs_redraw_every_frame = ::std::option::Option::Some(is.read_bool()?);
                },
                434 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.text_shadow)?;
                },
                440 => {
                    self.mix_blend_mode = ::std::option::Option::Some(is.read_uint32()?);
                },
                449 => {
                    self.occluded_left_edge = ::std::option::Option::Some(is.read_double()?);
                },
                457 => {
                    self.occluded_top_edge = ::std::option::Option::Some(is.read_double()?);
                },
                465 => {
                    self.occluded_right_edge = ::std::option::Option::Some(is.read_double()?);
                },
                473 => {
                    self.occluded_bottom_edge = ::std::option::Option::Some(is.read_double()?);
                },
                482 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.radial_clip)?;
                },
                489 => {
                    self.motionblur_velocity = ::std::option::Option::Some(is.read_double()?);
                },
                497 => {
                    self.motionblur_dirx = ::std::option::Option::Some(is.read_double()?);
                },
                505 => {
                    self.motionblur_diry = ::std::option::Option::Some(is.read_double()?);
                },
                514 => {
                    self.composition_layer_texture_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.layer_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.width {
            my_size += 1 + 8;
        }
        if let Some(v) = self.height {
            my_size += 1 + 8;
        }
        if let Some(v) = self.layer_quad_top_left_x {
            my_size += 1 + 8;
        }
        if let Some(v) = self.layer_quad_top_left_y {
            my_size += 1 + 8;
        }
        if let Some(v) = self.layer_quad_top_left_z {
            my_size += 1 + 8;
        }
        if let Some(v) = self.layer_quad_top_right_x {
            my_size += 1 + 8;
        }
        if let Some(v) = self.layer_quad_top_right_y {
            my_size += 1 + 8;
        }
        if let Some(v) = self.layer_quad_top_right_z {
            my_size += 1 + 8;
        }
        if let Some(v) = self.layer_quad_bottom_left_x {
            my_size += 1 + 8;
        }
        if let Some(v) = self.layer_quad_bottom_left_y {
            my_size += 1 + 8;
        }
        if let Some(v) = self.layer_quad_bottom_left_z {
            my_size += 1 + 8;
        }
        if let Some(v) = self.layer_quad_bottom_right_x {
            my_size += 1 + 8;
        }
        if let Some(v) = self.layer_quad_bottom_right_y {
            my_size += 1 + 8;
        }
        if let Some(v) = self.layer_quad_bottom_right_z {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transform_m00 {
            my_size += 2 + 8;
        }
        if let Some(v) = self.transform_m01 {
            my_size += 2 + 8;
        }
        if let Some(v) = self.transform_m02 {
            my_size += 2 + 8;
        }
        if let Some(v) = self.transform_m03 {
            my_size += 2 + 8;
        }
        if let Some(v) = self.transform_m10 {
            my_size += 2 + 8;
        }
        if let Some(v) = self.transform_m11 {
            my_size += 2 + 8;
        }
        if let Some(v) = self.transform_m12 {
            my_size += 2 + 8;
        }
        if let Some(v) = self.transform_m13 {
            my_size += 2 + 8;
        }
        if let Some(v) = self.transform_m20 {
            my_size += 2 + 8;
        }
        if let Some(v) = self.transform_m21 {
            my_size += 2 + 8;
        }
        if let Some(v) = self.transform_m22 {
            my_size += 2 + 8;
        }
        if let Some(v) = self.transform_m23 {
            my_size += 2 + 8;
        }
        if let Some(v) = self.transform_m30 {
            my_size += 2 + 8;
        }
        if let Some(v) = self.transform_m31 {
            my_size += 2 + 8;
        }
        if let Some(v) = self.transform_m32 {
            my_size += 2 + 8;
        }
        if let Some(v) = self.transform_m33 {
            my_size += 2 + 8;
        }
        if let Some(v) = self.perspective_depth {
            my_size += 2 + 8;
        }
        if let Some(v) = self.opacity {
            my_size += 2 + 8;
        }
        if let Some(v) = self.composition_color {
            my_size += ::protobuf::rt::uint32_size(34, v);
        }
        if let Some(v) = self.saturation {
            my_size += 2 + 8;
        }
        if let Some(v) = self.hue_shift {
            my_size += 2 + 8;
        }
        if let Some(v) = self.brightness {
            my_size += 2 + 8;
        }
        if let Some(v) = self.contrast {
            my_size += 2 + 8;
        }
        if let Some(v) = self.opacity_mask_texture_id {
            my_size += ::protobuf::rt::uint32_size(39, v);
        }
        if let Some(v) = self.opacity_mask_opacity {
            my_size += 2 + 8;
        }
        if let Some(v) = self.border.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.border_radius.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.box_shadow.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.gaussianblur_passes {
            my_size += 2 + 8;
        }
        if let Some(v) = self.gaussianblur_stddevhor {
            my_size += 2 + 8;
        }
        if let Some(v) = self.gaussianblur_stddevver {
            my_size += 2 + 8;
        }
        if let Some(v) = self.scale_2d_factors_x {
            my_size += 2 + 8;
        }
        if let Some(v) = self.scale_2d_factors_y {
            my_size += 2 + 8;
        }
        if let Some(v) = self.rotate_2d {
            my_size += 2 + 8;
        }
        if let Some(v) = self.needs_clear {
            my_size += 2 + 1;
        }
        if let Some(v) = self.needs_depth {
            my_size += 2 + 1;
        }
        if let Some(v) = self.needs_intermediate_texture {
            my_size += 2 + 1;
        }
        if let Some(v) = self.needs_redraw_every_frame {
            my_size += 2 + 1;
        }
        if let Some(v) = self.text_shadow.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.mix_blend_mode {
            my_size += ::protobuf::rt::uint32_size(55, v);
        }
        if let Some(v) = self.occluded_left_edge {
            my_size += 2 + 8;
        }
        if let Some(v) = self.occluded_top_edge {
            my_size += 2 + 8;
        }
        if let Some(v) = self.occluded_right_edge {
            my_size += 2 + 8;
        }
        if let Some(v) = self.occluded_bottom_edge {
            my_size += 2 + 8;
        }
        if let Some(v) = self.radial_clip.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.motionblur_velocity {
            my_size += 2 + 8;
        }
        if let Some(v) = self.motionblur_dirx {
            my_size += 2 + 8;
        }
        if let Some(v) = self.motionblur_diry {
            my_size += 2 + 8;
        }
        if let Some(v) = self.composition_layer_texture_name.as_ref() {
            my_size += ::protobuf::rt::string_size(64, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.layer_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.width {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.height {
            os.write_double(3, v)?;
        }
        if let Some(v) = self.layer_quad_top_left_x {
            os.write_double(4, v)?;
        }
        if let Some(v) = self.layer_quad_top_left_y {
            os.write_double(5, v)?;
        }
        if let Some(v) = self.layer_quad_top_left_z {
            os.write_double(6, v)?;
        }
        if let Some(v) = self.layer_quad_top_right_x {
            os.write_double(7, v)?;
        }
        if let Some(v) = self.layer_quad_top_right_y {
            os.write_double(8, v)?;
        }
        if let Some(v) = self.layer_quad_top_right_z {
            os.write_double(9, v)?;
        }
        if let Some(v) = self.layer_quad_bottom_left_x {
            os.write_double(10, v)?;
        }
        if let Some(v) = self.layer_quad_bottom_left_y {
            os.write_double(11, v)?;
        }
        if let Some(v) = self.layer_quad_bottom_left_z {
            os.write_double(12, v)?;
        }
        if let Some(v) = self.layer_quad_bottom_right_x {
            os.write_double(13, v)?;
        }
        if let Some(v) = self.layer_quad_bottom_right_y {
            os.write_double(14, v)?;
        }
        if let Some(v) = self.layer_quad_bottom_right_z {
            os.write_double(15, v)?;
        }
        if let Some(v) = self.transform_m00 {
            os.write_double(16, v)?;
        }
        if let Some(v) = self.transform_m01 {
            os.write_double(17, v)?;
        }
        if let Some(v) = self.transform_m02 {
            os.write_double(18, v)?;
        }
        if let Some(v) = self.transform_m03 {
            os.write_double(19, v)?;
        }
        if let Some(v) = self.transform_m10 {
            os.write_double(20, v)?;
        }
        if let Some(v) = self.transform_m11 {
            os.write_double(21, v)?;
        }
        if let Some(v) = self.transform_m12 {
            os.write_double(22, v)?;
        }
        if let Some(v) = self.transform_m13 {
            os.write_double(23, v)?;
        }
        if let Some(v) = self.transform_m20 {
            os.write_double(24, v)?;
        }
        if let Some(v) = self.transform_m21 {
            os.write_double(25, v)?;
        }
        if let Some(v) = self.transform_m22 {
            os.write_double(26, v)?;
        }
        if let Some(v) = self.transform_m23 {
            os.write_double(27, v)?;
        }
        if let Some(v) = self.transform_m30 {
            os.write_double(28, v)?;
        }
        if let Some(v) = self.transform_m31 {
            os.write_double(29, v)?;
        }
        if let Some(v) = self.transform_m32 {
            os.write_double(30, v)?;
        }
        if let Some(v) = self.transform_m33 {
            os.write_double(31, v)?;
        }
        if let Some(v) = self.perspective_depth {
            os.write_double(32, v)?;
        }
        if let Some(v) = self.opacity {
            os.write_double(33, v)?;
        }
        if let Some(v) = self.composition_color {
            os.write_uint32(34, v)?;
        }
        if let Some(v) = self.saturation {
            os.write_double(35, v)?;
        }
        if let Some(v) = self.hue_shift {
            os.write_double(36, v)?;
        }
        if let Some(v) = self.brightness {
            os.write_double(37, v)?;
        }
        if let Some(v) = self.contrast {
            os.write_double(38, v)?;
        }
        if let Some(v) = self.opacity_mask_texture_id {
            os.write_uint32(39, v)?;
        }
        if let Some(v) = self.opacity_mask_opacity {
            os.write_double(40, v)?;
        }
        if let Some(v) = self.border.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(41, v, os)?;
        }
        if let Some(v) = self.border_radius.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(42, v, os)?;
        }
        if let Some(v) = self.box_shadow.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(43, v, os)?;
        }
        if let Some(v) = self.gaussianblur_passes {
            os.write_double(44, v)?;
        }
        if let Some(v) = self.gaussianblur_stddevhor {
            os.write_double(45, v)?;
        }
        if let Some(v) = self.gaussianblur_stddevver {
            os.write_double(46, v)?;
        }
        if let Some(v) = self.scale_2d_factors_x {
            os.write_double(47, v)?;
        }
        if let Some(v) = self.scale_2d_factors_y {
            os.write_double(48, v)?;
        }
        if let Some(v) = self.rotate_2d {
            os.write_double(49, v)?;
        }
        if let Some(v) = self.needs_clear {
            os.write_bool(50, v)?;
        }
        if let Some(v) = self.needs_depth {
            os.write_bool(51, v)?;
        }
        if let Some(v) = self.needs_intermediate_texture {
            os.write_bool(52, v)?;
        }
        if let Some(v) = self.needs_redraw_every_frame {
            os.write_bool(53, v)?;
        }
        if let Some(v) = self.text_shadow.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(54, v, os)?;
        }
        if let Some(v) = self.mix_blend_mode {
            os.write_uint32(55, v)?;
        }
        if let Some(v) = self.occluded_left_edge {
            os.write_double(56, v)?;
        }
        if let Some(v) = self.occluded_top_edge {
            os.write_double(57, v)?;
        }
        if let Some(v) = self.occluded_right_edge {
            os.write_double(58, v)?;
        }
        if let Some(v) = self.occluded_bottom_edge {
            os.write_double(59, v)?;
        }
        if let Some(v) = self.radial_clip.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(60, v, os)?;
        }
        if let Some(v) = self.motionblur_velocity {
            os.write_double(61, v)?;
        }
        if let Some(v) = self.motionblur_dirx {
            os.write_double(62, v)?;
        }
        if let Some(v) = self.motionblur_diry {
            os.write_double(63, v)?;
        }
        if let Some(v) = self.composition_layer_texture_name.as_ref() {
            os.write_string(64, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPushCompositingLayer {
        CMsgPushCompositingLayer::new()
    }

    fn clear(&mut self) {
        self.layer_id = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.layer_quad_top_left_x = ::std::option::Option::None;
        self.layer_quad_top_left_y = ::std::option::Option::None;
        self.layer_quad_top_left_z = ::std::option::Option::None;
        self.layer_quad_top_right_x = ::std::option::Option::None;
        self.layer_quad_top_right_y = ::std::option::Option::None;
        self.layer_quad_top_right_z = ::std::option::Option::None;
        self.layer_quad_bottom_left_x = ::std::option::Option::None;
        self.layer_quad_bottom_left_y = ::std::option::Option::None;
        self.layer_quad_bottom_left_z = ::std::option::Option::None;
        self.layer_quad_bottom_right_x = ::std::option::Option::None;
        self.layer_quad_bottom_right_y = ::std::option::Option::None;
        self.layer_quad_bottom_right_z = ::std::option::Option::None;
        self.transform_m00 = ::std::option::Option::None;
        self.transform_m01 = ::std::option::Option::None;
        self.transform_m02 = ::std::option::Option::None;
        self.transform_m03 = ::std::option::Option::None;
        self.transform_m10 = ::std::option::Option::None;
        self.transform_m11 = ::std::option::Option::None;
        self.transform_m12 = ::std::option::Option::None;
        self.transform_m13 = ::std::option::Option::None;
        self.transform_m20 = ::std::option::Option::None;
        self.transform_m21 = ::std::option::Option::None;
        self.transform_m22 = ::std::option::Option::None;
        self.transform_m23 = ::std::option::Option::None;
        self.transform_m30 = ::std::option::Option::None;
        self.transform_m31 = ::std::option::Option::None;
        self.transform_m32 = ::std::option::Option::None;
        self.transform_m33 = ::std::option::Option::None;
        self.perspective_depth = ::std::option::Option::None;
        self.opacity = ::std::option::Option::None;
        self.composition_color = ::std::option::Option::None;
        self.saturation = ::std::option::Option::None;
        self.hue_shift = ::std::option::Option::None;
        self.brightness = ::std::option::Option::None;
        self.contrast = ::std::option::Option::None;
        self.opacity_mask_texture_id = ::std::option::Option::None;
        self.opacity_mask_opacity = ::std::option::Option::None;
        self.border.clear();
        self.border_radius.clear();
        self.box_shadow.clear();
        self.gaussianblur_passes = ::std::option::Option::None;
        self.gaussianblur_stddevhor = ::std::option::Option::None;
        self.gaussianblur_stddevver = ::std::option::Option::None;
        self.scale_2d_factors_x = ::std::option::Option::None;
        self.scale_2d_factors_y = ::std::option::Option::None;
        self.rotate_2d = ::std::option::Option::None;
        self.needs_clear = ::std::option::Option::None;
        self.needs_depth = ::std::option::Option::None;
        self.needs_intermediate_texture = ::std::option::Option::None;
        self.needs_redraw_every_frame = ::std::option::Option::None;
        self.text_shadow.clear();
        self.mix_blend_mode = ::std::option::Option::None;
        self.occluded_left_edge = ::std::option::Option::None;
        self.occluded_top_edge = ::std::option::Option::None;
        self.occluded_right_edge = ::std::option::Option::None;
        self.occluded_bottom_edge = ::std::option::Option::None;
        self.radial_clip.clear();
        self.motionblur_velocity = ::std::option::Option::None;
        self.motionblur_dirx = ::std::option::Option::None;
        self.motionblur_diry = ::std::option::Option::None;
        self.composition_layer_texture_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPushCompositingLayer {
        static instance: CMsgPushCompositingLayer = CMsgPushCompositingLayer {
            layer_id: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            layer_quad_top_left_x: ::std::option::Option::None,
            layer_quad_top_left_y: ::std::option::Option::None,
            layer_quad_top_left_z: ::std::option::Option::None,
            layer_quad_top_right_x: ::std::option::Option::None,
            layer_quad_top_right_y: ::std::option::Option::None,
            layer_quad_top_right_z: ::std::option::Option::None,
            layer_quad_bottom_left_x: ::std::option::Option::None,
            layer_quad_bottom_left_y: ::std::option::Option::None,
            layer_quad_bottom_left_z: ::std::option::Option::None,
            layer_quad_bottom_right_x: ::std::option::Option::None,
            layer_quad_bottom_right_y: ::std::option::Option::None,
            layer_quad_bottom_right_z: ::std::option::Option::None,
            transform_m00: ::std::option::Option::None,
            transform_m01: ::std::option::Option::None,
            transform_m02: ::std::option::Option::None,
            transform_m03: ::std::option::Option::None,
            transform_m10: ::std::option::Option::None,
            transform_m11: ::std::option::Option::None,
            transform_m12: ::std::option::Option::None,
            transform_m13: ::std::option::Option::None,
            transform_m20: ::std::option::Option::None,
            transform_m21: ::std::option::Option::None,
            transform_m22: ::std::option::Option::None,
            transform_m23: ::std::option::Option::None,
            transform_m30: ::std::option::Option::None,
            transform_m31: ::std::option::Option::None,
            transform_m32: ::std::option::Option::None,
            transform_m33: ::std::option::Option::None,
            perspective_depth: ::std::option::Option::None,
            opacity: ::std::option::Option::None,
            composition_color: ::std::option::Option::None,
            saturation: ::std::option::Option::None,
            hue_shift: ::std::option::Option::None,
            brightness: ::std::option::Option::None,
            contrast: ::std::option::Option::None,
            opacity_mask_texture_id: ::std::option::Option::None,
            opacity_mask_opacity: ::std::option::Option::None,
            border: ::protobuf::MessageField::none(),
            border_radius: ::protobuf::MessageField::none(),
            box_shadow: ::protobuf::MessageField::none(),
            gaussianblur_passes: ::std::option::Option::None,
            gaussianblur_stddevhor: ::std::option::Option::None,
            gaussianblur_stddevver: ::std::option::Option::None,
            scale_2d_factors_x: ::std::option::Option::None,
            scale_2d_factors_y: ::std::option::Option::None,
            rotate_2d: ::std::option::Option::None,
            needs_clear: ::std::option::Option::None,
            needs_depth: ::std::option::Option::None,
            needs_intermediate_texture: ::std::option::Option::None,
            needs_redraw_every_frame: ::std::option::Option::None,
            text_shadow: ::protobuf::MessageField::none(),
            mix_blend_mode: ::std::option::Option::None,
            occluded_left_edge: ::std::option::Option::None,
            occluded_top_edge: ::std::option::Option::None,
            occluded_right_edge: ::std::option::Option::None,
            occluded_bottom_edge: ::std::option::Option::None,
            radial_clip: ::protobuf::MessageField::none(),
            motionblur_velocity: ::std::option::Option::None,
            motionblur_dirx: ::std::option::Option::None,
            motionblur_diry: ::std::option::Option::None,
            composition_layer_texture_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPopCompositingLayer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPopCompositingLayer {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPopCompositingLayer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPopCompositingLayer {
    fn default() -> &'a CMsgPopCompositingLayer {
        <CMsgPopCompositingLayer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPopCompositingLayer {
    pub fn new() -> CMsgPopCompositingLayer {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgPopCompositingLayer {
    const NAME: &'static str = "CMsgPopCompositingLayer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPopCompositingLayer {
        CMsgPopCompositingLayer::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPopCompositingLayer {
        static instance: CMsgPopCompositingLayer = CMsgPopCompositingLayer {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgFreeCompositingLayer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFreeCompositingLayer {
    // message fields
    // @@protoc_insertion_point(field:CMsgFreeCompositingLayer.layer_id)
    pub layer_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFreeCompositingLayer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFreeCompositingLayer {
    fn default() -> &'a CMsgFreeCompositingLayer {
        <CMsgFreeCompositingLayer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFreeCompositingLayer {
    pub fn new() -> CMsgFreeCompositingLayer {
        ::std::default::Default::default()
    }

    // optional uint64 layer_id = 1;

    pub fn layer_id(&self) -> u64 {
        self.layer_id.unwrap_or(0)
    }

    pub fn clear_layer_id(&mut self) {
        self.layer_id = ::std::option::Option::None;
    }

    pub fn has_layer_id(&self) -> bool {
        self.layer_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layer_id(&mut self, v: u64) {
        self.layer_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgFreeCompositingLayer {
    const NAME: &'static str = "CMsgFreeCompositingLayer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.layer_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.layer_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.layer_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFreeCompositingLayer {
        CMsgFreeCompositingLayer::new()
    }

    fn clear(&mut self) {
        self.layer_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFreeCompositingLayer {
        static instance: CMsgFreeCompositingLayer = CMsgFreeCompositingLayer {
            layer_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTransitionData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTransitionData {
    // message fields
    // @@protoc_insertion_point(field:CMsgTransitionData.start_time)
    pub start_time: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgTransitionData.delay_seconds)
    pub delay_seconds: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgTransitionData.duration_seconds)
    pub duration_seconds: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgTransitionData.timing_func)
    pub timing_func: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTransitionData.cubic_bezier_0)
    pub cubic_bezier_0: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgTransitionData.cubic_bezier_1)
    pub cubic_bezier_1: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgTransitionData.cubic_bezier_2)
    pub cubic_bezier_2: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgTransitionData.cubic_bezier_3)
    pub cubic_bezier_3: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTransitionData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTransitionData {
    fn default() -> &'a CMsgTransitionData {
        <CMsgTransitionData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTransitionData {
    pub fn new() -> CMsgTransitionData {
        ::std::default::Default::default()
    }

    // optional double start_time = 1;

    pub fn start_time(&self) -> f64 {
        self.start_time.unwrap_or(0.)
    }

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: f64) {
        self.start_time = ::std::option::Option::Some(v);
    }

    // optional double delay_seconds = 2;

    pub fn delay_seconds(&self) -> f64 {
        self.delay_seconds.unwrap_or(0.)
    }

    pub fn clear_delay_seconds(&mut self) {
        self.delay_seconds = ::std::option::Option::None;
    }

    pub fn has_delay_seconds(&self) -> bool {
        self.delay_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delay_seconds(&mut self, v: f64) {
        self.delay_seconds = ::std::option::Option::Some(v);
    }

    // optional double duration_seconds = 3;

    pub fn duration_seconds(&self) -> f64 {
        self.duration_seconds.unwrap_or(0.)
    }

    pub fn clear_duration_seconds(&mut self) {
        self.duration_seconds = ::std::option::Option::None;
    }

    pub fn has_duration_seconds(&self) -> bool {
        self.duration_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration_seconds(&mut self, v: f64) {
        self.duration_seconds = ::std::option::Option::Some(v);
    }

    // optional uint32 timing_func = 4;

    pub fn timing_func(&self) -> u32 {
        self.timing_func.unwrap_or(0u32)
    }

    pub fn clear_timing_func(&mut self) {
        self.timing_func = ::std::option::Option::None;
    }

    pub fn has_timing_func(&self) -> bool {
        self.timing_func.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timing_func(&mut self, v: u32) {
        self.timing_func = ::std::option::Option::Some(v);
    }

    // optional float cubic_bezier_0 = 5;

    pub fn cubic_bezier_0(&self) -> f32 {
        self.cubic_bezier_0.unwrap_or(0.)
    }

    pub fn clear_cubic_bezier_0(&mut self) {
        self.cubic_bezier_0 = ::std::option::Option::None;
    }

    pub fn has_cubic_bezier_0(&self) -> bool {
        self.cubic_bezier_0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cubic_bezier_0(&mut self, v: f32) {
        self.cubic_bezier_0 = ::std::option::Option::Some(v);
    }

    // optional float cubic_bezier_1 = 6;

    pub fn cubic_bezier_1(&self) -> f32 {
        self.cubic_bezier_1.unwrap_or(0.)
    }

    pub fn clear_cubic_bezier_1(&mut self) {
        self.cubic_bezier_1 = ::std::option::Option::None;
    }

    pub fn has_cubic_bezier_1(&self) -> bool {
        self.cubic_bezier_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cubic_bezier_1(&mut self, v: f32) {
        self.cubic_bezier_1 = ::std::option::Option::Some(v);
    }

    // optional float cubic_bezier_2 = 7;

    pub fn cubic_bezier_2(&self) -> f32 {
        self.cubic_bezier_2.unwrap_or(0.)
    }

    pub fn clear_cubic_bezier_2(&mut self) {
        self.cubic_bezier_2 = ::std::option::Option::None;
    }

    pub fn has_cubic_bezier_2(&self) -> bool {
        self.cubic_bezier_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cubic_bezier_2(&mut self, v: f32) {
        self.cubic_bezier_2 = ::std::option::Option::Some(v);
    }

    // optional float cubic_bezier_3 = 8;

    pub fn cubic_bezier_3(&self) -> f32 {
        self.cubic_bezier_3.unwrap_or(0.)
    }

    pub fn clear_cubic_bezier_3(&mut self) {
        self.cubic_bezier_3 = ::std::option::Option::None;
    }

    pub fn has_cubic_bezier_3(&self) -> bool {
        self.cubic_bezier_3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cubic_bezier_3(&mut self, v: f32) {
        self.cubic_bezier_3 = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgTransitionData {
    const NAME: &'static str = "CMsgTransitionData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.start_time = ::std::option::Option::Some(is.read_double()?);
                },
                17 => {
                    self.delay_seconds = ::std::option::Option::Some(is.read_double()?);
                },
                25 => {
                    self.duration_seconds = ::std::option::Option::Some(is.read_double()?);
                },
                32 => {
                    self.timing_func = ::std::option::Option::Some(is.read_uint32()?);
                },
                45 => {
                    self.cubic_bezier_0 = ::std::option::Option::Some(is.read_float()?);
                },
                53 => {
                    self.cubic_bezier_1 = ::std::option::Option::Some(is.read_float()?);
                },
                61 => {
                    self.cubic_bezier_2 = ::std::option::Option::Some(is.read_float()?);
                },
                69 => {
                    self.cubic_bezier_3 = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.start_time {
            my_size += 1 + 8;
        }
        if let Some(v) = self.delay_seconds {
            my_size += 1 + 8;
        }
        if let Some(v) = self.duration_seconds {
            my_size += 1 + 8;
        }
        if let Some(v) = self.timing_func {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.cubic_bezier_0 {
            my_size += 1 + 4;
        }
        if let Some(v) = self.cubic_bezier_1 {
            my_size += 1 + 4;
        }
        if let Some(v) = self.cubic_bezier_2 {
            my_size += 1 + 4;
        }
        if let Some(v) = self.cubic_bezier_3 {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.start_time {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.delay_seconds {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.duration_seconds {
            os.write_double(3, v)?;
        }
        if let Some(v) = self.timing_func {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.cubic_bezier_0 {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.cubic_bezier_1 {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.cubic_bezier_2 {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.cubic_bezier_3 {
            os.write_float(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTransitionData {
        CMsgTransitionData::new()
    }

    fn clear(&mut self) {
        self.start_time = ::std::option::Option::None;
        self.delay_seconds = ::std::option::Option::None;
        self.duration_seconds = ::std::option::Option::None;
        self.timing_func = ::std::option::Option::None;
        self.cubic_bezier_0 = ::std::option::Option::None;
        self.cubic_bezier_1 = ::std::option::Option::None;
        self.cubic_bezier_2 = ::std::option::Option::None;
        self.cubic_bezier_3 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTransitionData {
        static instance: CMsgTransitionData = CMsgTransitionData {
            start_time: ::std::option::Option::None,
            delay_seconds: ::std::option::Option::None,
            duration_seconds: ::std::option::Option::None,
            timing_func: ::std::option::Option::None,
            cubic_bezier_0: ::std::option::Option::None,
            cubic_bezier_1: ::std::option::Option::None,
            cubic_bezier_2: ::std::option::Option::None,
            cubic_bezier_3: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgAnimationData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAnimationData {
    // message fields
    // @@protoc_insertion_point(field:CMsgAnimationData.start_time)
    pub start_time: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgAnimationData.delay_seconds)
    pub delay_seconds: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgAnimationData.duration_seconds)
    pub duration_seconds: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgAnimationData.timing_func)
    pub timing_func: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgAnimationData.cubic_bezier_0)
    pub cubic_bezier_0: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgAnimationData.cubic_bezier_1)
    pub cubic_bezier_1: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgAnimationData.cubic_bezier_2)
    pub cubic_bezier_2: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgAnimationData.cubic_bezier_3)
    pub cubic_bezier_3: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgAnimationData.direction)
    pub direction: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgAnimationData.iteration)
    pub iteration: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgAnimationData.frames)
    pub frames: ::std::vec::Vec<CMsgAnimationFrameData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAnimationData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAnimationData {
    fn default() -> &'a CMsgAnimationData {
        <CMsgAnimationData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAnimationData {
    pub fn new() -> CMsgAnimationData {
        ::std::default::Default::default()
    }

    // optional double start_time = 1;

    pub fn start_time(&self) -> f64 {
        self.start_time.unwrap_or(0.)
    }

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: f64) {
        self.start_time = ::std::option::Option::Some(v);
    }

    // optional double delay_seconds = 2;

    pub fn delay_seconds(&self) -> f64 {
        self.delay_seconds.unwrap_or(0.)
    }

    pub fn clear_delay_seconds(&mut self) {
        self.delay_seconds = ::std::option::Option::None;
    }

    pub fn has_delay_seconds(&self) -> bool {
        self.delay_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delay_seconds(&mut self, v: f64) {
        self.delay_seconds = ::std::option::Option::Some(v);
    }

    // optional double duration_seconds = 3;

    pub fn duration_seconds(&self) -> f64 {
        self.duration_seconds.unwrap_or(0.)
    }

    pub fn clear_duration_seconds(&mut self) {
        self.duration_seconds = ::std::option::Option::None;
    }

    pub fn has_duration_seconds(&self) -> bool {
        self.duration_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration_seconds(&mut self, v: f64) {
        self.duration_seconds = ::std::option::Option::Some(v);
    }

    // optional uint32 timing_func = 4;

    pub fn timing_func(&self) -> u32 {
        self.timing_func.unwrap_or(0)
    }

    pub fn clear_timing_func(&mut self) {
        self.timing_func = ::std::option::Option::None;
    }

    pub fn has_timing_func(&self) -> bool {
        self.timing_func.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timing_func(&mut self, v: u32) {
        self.timing_func = ::std::option::Option::Some(v);
    }

    // optional float cubic_bezier_0 = 5;

    pub fn cubic_bezier_0(&self) -> f32 {
        self.cubic_bezier_0.unwrap_or(0.)
    }

    pub fn clear_cubic_bezier_0(&mut self) {
        self.cubic_bezier_0 = ::std::option::Option::None;
    }

    pub fn has_cubic_bezier_0(&self) -> bool {
        self.cubic_bezier_0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cubic_bezier_0(&mut self, v: f32) {
        self.cubic_bezier_0 = ::std::option::Option::Some(v);
    }

    // optional float cubic_bezier_1 = 6;

    pub fn cubic_bezier_1(&self) -> f32 {
        self.cubic_bezier_1.unwrap_or(0.)
    }

    pub fn clear_cubic_bezier_1(&mut self) {
        self.cubic_bezier_1 = ::std::option::Option::None;
    }

    pub fn has_cubic_bezier_1(&self) -> bool {
        self.cubic_bezier_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cubic_bezier_1(&mut self, v: f32) {
        self.cubic_bezier_1 = ::std::option::Option::Some(v);
    }

    // optional float cubic_bezier_2 = 7;

    pub fn cubic_bezier_2(&self) -> f32 {
        self.cubic_bezier_2.unwrap_or(0.)
    }

    pub fn clear_cubic_bezier_2(&mut self) {
        self.cubic_bezier_2 = ::std::option::Option::None;
    }

    pub fn has_cubic_bezier_2(&self) -> bool {
        self.cubic_bezier_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cubic_bezier_2(&mut self, v: f32) {
        self.cubic_bezier_2 = ::std::option::Option::Some(v);
    }

    // optional float cubic_bezier_3 = 8;

    pub fn cubic_bezier_3(&self) -> f32 {
        self.cubic_bezier_3.unwrap_or(0.)
    }

    pub fn clear_cubic_bezier_3(&mut self) {
        self.cubic_bezier_3 = ::std::option::Option::None;
    }

    pub fn has_cubic_bezier_3(&self) -> bool {
        self.cubic_bezier_3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cubic_bezier_3(&mut self, v: f32) {
        self.cubic_bezier_3 = ::std::option::Option::Some(v);
    }

    // optional uint32 direction = 9;

    pub fn direction(&self) -> u32 {
        self.direction.unwrap_or(0)
    }

    pub fn clear_direction(&mut self) {
        self.direction = ::std::option::Option::None;
    }

    pub fn has_direction(&self) -> bool {
        self.direction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: u32) {
        self.direction = ::std::option::Option::Some(v);
    }

    // optional float iteration = 10;

    pub fn iteration(&self) -> f32 {
        self.iteration.unwrap_or(0.)
    }

    pub fn clear_iteration(&mut self) {
        self.iteration = ::std::option::Option::None;
    }

    pub fn has_iteration(&self) -> bool {
        self.iteration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_iteration(&mut self, v: f32) {
        self.iteration = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgAnimationData {
    const NAME: &'static str = "CMsgAnimationData";

    fn is_initialized(&self) -> bool {
        for v in &self.frames {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.start_time = ::std::option::Option::Some(is.read_double()?);
                },
                17 => {
                    self.delay_seconds = ::std::option::Option::Some(is.read_double()?);
                },
                25 => {
                    self.duration_seconds = ::std::option::Option::Some(is.read_double()?);
                },
                32 => {
                    self.timing_func = ::std::option::Option::Some(is.read_uint32()?);
                },
                45 => {
                    self.cubic_bezier_0 = ::std::option::Option::Some(is.read_float()?);
                },
                53 => {
                    self.cubic_bezier_1 = ::std::option::Option::Some(is.read_float()?);
                },
                61 => {
                    self.cubic_bezier_2 = ::std::option::Option::Some(is.read_float()?);
                },
                69 => {
                    self.cubic_bezier_3 = ::std::option::Option::Some(is.read_float()?);
                },
                72 => {
                    self.direction = ::std::option::Option::Some(is.read_uint32()?);
                },
                85 => {
                    self.iteration = ::std::option::Option::Some(is.read_float()?);
                },
                90 => {
                    self.frames.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.start_time {
            my_size += 1 + 8;
        }
        if let Some(v) = self.delay_seconds {
            my_size += 1 + 8;
        }
        if let Some(v) = self.duration_seconds {
            my_size += 1 + 8;
        }
        if let Some(v) = self.timing_func {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.cubic_bezier_0 {
            my_size += 1 + 4;
        }
        if let Some(v) = self.cubic_bezier_1 {
            my_size += 1 + 4;
        }
        if let Some(v) = self.cubic_bezier_2 {
            my_size += 1 + 4;
        }
        if let Some(v) = self.cubic_bezier_3 {
            my_size += 1 + 4;
        }
        if let Some(v) = self.direction {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.iteration {
            my_size += 1 + 4;
        }
        for value in &self.frames {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.start_time {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.delay_seconds {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.duration_seconds {
            os.write_double(3, v)?;
        }
        if let Some(v) = self.timing_func {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.cubic_bezier_0 {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.cubic_bezier_1 {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.cubic_bezier_2 {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.cubic_bezier_3 {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.direction {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.iteration {
            os.write_float(10, v)?;
        }
        for v in &self.frames {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAnimationData {
        CMsgAnimationData::new()
    }

    fn clear(&mut self) {
        self.start_time = ::std::option::Option::None;
        self.delay_seconds = ::std::option::Option::None;
        self.duration_seconds = ::std::option::Option::None;
        self.timing_func = ::std::option::Option::None;
        self.cubic_bezier_0 = ::std::option::Option::None;
        self.cubic_bezier_1 = ::std::option::Option::None;
        self.cubic_bezier_2 = ::std::option::Option::None;
        self.cubic_bezier_3 = ::std::option::Option::None;
        self.direction = ::std::option::Option::None;
        self.iteration = ::std::option::Option::None;
        self.frames.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAnimationData {
        static instance: CMsgAnimationData = CMsgAnimationData {
            start_time: ::std::option::Option::None,
            delay_seconds: ::std::option::Option::None,
            duration_seconds: ::std::option::Option::None,
            timing_func: ::std::option::Option::None,
            cubic_bezier_0: ::std::option::Option::None,
            cubic_bezier_1: ::std::option::Option::None,
            cubic_bezier_2: ::std::option::Option::None,
            cubic_bezier_3: ::std::option::Option::None,
            direction: ::std::option::Option::None,
            iteration: ::std::option::Option::None,
            frames: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgAnimationFrameData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAnimationFrameData {
    // message fields
    // @@protoc_insertion_point(field:CMsgAnimationFrameData.percent)
    pub percent: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgAnimationFrameData.timing_func)
    pub timing_func: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgAnimationFrameData.cubic_bezier_0)
    pub cubic_bezier_0: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgAnimationFrameData.cubic_bezier_1)
    pub cubic_bezier_1: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgAnimationFrameData.cubic_bezier_2)
    pub cubic_bezier_2: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgAnimationFrameData.cubic_bezier_3)
    pub cubic_bezier_3: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAnimationFrameData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAnimationFrameData {
    fn default() -> &'a CMsgAnimationFrameData {
        <CMsgAnimationFrameData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAnimationFrameData {
    pub fn new() -> CMsgAnimationFrameData {
        ::std::default::Default::default()
    }

    // optional float percent = 1;

    pub fn percent(&self) -> f32 {
        self.percent.unwrap_or(0.)
    }

    pub fn clear_percent(&mut self) {
        self.percent = ::std::option::Option::None;
    }

    pub fn has_percent(&self) -> bool {
        self.percent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_percent(&mut self, v: f32) {
        self.percent = ::std::option::Option::Some(v);
    }

    // optional uint32 timing_func = 2;

    pub fn timing_func(&self) -> u32 {
        self.timing_func.unwrap_or(0u32)
    }

    pub fn clear_timing_func(&mut self) {
        self.timing_func = ::std::option::Option::None;
    }

    pub fn has_timing_func(&self) -> bool {
        self.timing_func.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timing_func(&mut self, v: u32) {
        self.timing_func = ::std::option::Option::Some(v);
    }

    // optional float cubic_bezier_0 = 3;

    pub fn cubic_bezier_0(&self) -> f32 {
        self.cubic_bezier_0.unwrap_or(0.)
    }

    pub fn clear_cubic_bezier_0(&mut self) {
        self.cubic_bezier_0 = ::std::option::Option::None;
    }

    pub fn has_cubic_bezier_0(&self) -> bool {
        self.cubic_bezier_0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cubic_bezier_0(&mut self, v: f32) {
        self.cubic_bezier_0 = ::std::option::Option::Some(v);
    }

    // optional float cubic_bezier_1 = 4;

    pub fn cubic_bezier_1(&self) -> f32 {
        self.cubic_bezier_1.unwrap_or(0.)
    }

    pub fn clear_cubic_bezier_1(&mut self) {
        self.cubic_bezier_1 = ::std::option::Option::None;
    }

    pub fn has_cubic_bezier_1(&self) -> bool {
        self.cubic_bezier_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cubic_bezier_1(&mut self, v: f32) {
        self.cubic_bezier_1 = ::std::option::Option::Some(v);
    }

    // optional float cubic_bezier_2 = 5;

    pub fn cubic_bezier_2(&self) -> f32 {
        self.cubic_bezier_2.unwrap_or(0.)
    }

    pub fn clear_cubic_bezier_2(&mut self) {
        self.cubic_bezier_2 = ::std::option::Option::None;
    }

    pub fn has_cubic_bezier_2(&self) -> bool {
        self.cubic_bezier_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cubic_bezier_2(&mut self, v: f32) {
        self.cubic_bezier_2 = ::std::option::Option::Some(v);
    }

    // optional float cubic_bezier_3 = 6;

    pub fn cubic_bezier_3(&self) -> f32 {
        self.cubic_bezier_3.unwrap_or(0.)
    }

    pub fn clear_cubic_bezier_3(&mut self) {
        self.cubic_bezier_3 = ::std::option::Option::None;
    }

    pub fn has_cubic_bezier_3(&self) -> bool {
        self.cubic_bezier_3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cubic_bezier_3(&mut self, v: f32) {
        self.cubic_bezier_3 = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgAnimationFrameData {
    const NAME: &'static str = "CMsgAnimationFrameData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.percent = ::std::option::Option::Some(is.read_float()?);
                },
                16 => {
                    self.timing_func = ::std::option::Option::Some(is.read_uint32()?);
                },
                29 => {
                    self.cubic_bezier_0 = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.cubic_bezier_1 = ::std::option::Option::Some(is.read_float()?);
                },
                45 => {
                    self.cubic_bezier_2 = ::std::option::Option::Some(is.read_float()?);
                },
                53 => {
                    self.cubic_bezier_3 = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.percent {
            my_size += 1 + 4;
        }
        if let Some(v) = self.timing_func {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.cubic_bezier_0 {
            my_size += 1 + 4;
        }
        if let Some(v) = self.cubic_bezier_1 {
            my_size += 1 + 4;
        }
        if let Some(v) = self.cubic_bezier_2 {
            my_size += 1 + 4;
        }
        if let Some(v) = self.cubic_bezier_3 {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.percent {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.timing_func {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.cubic_bezier_0 {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.cubic_bezier_1 {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.cubic_bezier_2 {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.cubic_bezier_3 {
            os.write_float(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAnimationFrameData {
        CMsgAnimationFrameData::new()
    }

    fn clear(&mut self) {
        self.percent = ::std::option::Option::None;
        self.timing_func = ::std::option::Option::None;
        self.cubic_bezier_0 = ::std::option::Option::None;
        self.cubic_bezier_1 = ::std::option::Option::None;
        self.cubic_bezier_2 = ::std::option::Option::None;
        self.cubic_bezier_3 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAnimationFrameData {
        static instance: CMsgAnimationFrameData = CMsgAnimationFrameData {
            percent: ::std::option::Option::None,
            timing_func: ::std::option::Option::None,
            cubic_bezier_0: ::std::option::Option::None,
            cubic_bezier_1: ::std::option::Option::None,
            cubic_bezier_2: ::std::option::Option::None,
            cubic_bezier_3: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPointWithTransition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPointWithTransition {
    // message fields
    // @@protoc_insertion_point(field:CMsgPointWithTransition.base)
    pub base: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgPointWithTransition.transition)
    pub transition: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgPointWithTransition.transition_data)
    pub transition_data: ::protobuf::MessageField<CMsgTransitionData>,
    // @@protoc_insertion_point(field:CMsgPointWithTransition.style_symbol)
    pub style_symbol: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPointWithTransition.animations)
    pub animations: ::std::vec::Vec<CMsgAnimationData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPointWithTransition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPointWithTransition {
    fn default() -> &'a CMsgPointWithTransition {
        <CMsgPointWithTransition as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPointWithTransition {
    pub fn new() -> CMsgPointWithTransition {
        ::std::default::Default::default()
    }

    // optional uint32 style_symbol = 4;

    pub fn style_symbol(&self) -> u32 {
        self.style_symbol.unwrap_or(0)
    }

    pub fn clear_style_symbol(&mut self) {
        self.style_symbol = ::std::option::Option::None;
    }

    pub fn has_style_symbol(&self) -> bool {
        self.style_symbol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_symbol(&mut self, v: u32) {
        self.style_symbol = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgPointWithTransition {
    const NAME: &'static str = "CMsgPointWithTransition";

    fn is_initialized(&self) -> bool {
        for v in &self.base {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.animations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.base)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition_data)?;
                },
                32 => {
                    self.style_symbol = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.animations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.style_symbol {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.animations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.transition.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.transition_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.style_symbol {
            os.write_uint32(4, v)?;
        }
        for v in &self.animations {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPointWithTransition {
        CMsgPointWithTransition::new()
    }

    fn clear(&mut self) {
        self.base.clear();
        self.transition.clear();
        self.transition_data.clear();
        self.style_symbol = ::std::option::Option::None;
        self.animations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPointWithTransition {
        static instance: CMsgPointWithTransition = CMsgPointWithTransition {
            base: ::protobuf::MessageField::none(),
            transition: ::protobuf::MessageField::none(),
            transition_data: ::protobuf::MessageField::none(),
            style_symbol: ::std::option::Option::None,
            animations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgPointWithTransition`
pub mod cmsg_point_with_transition {
    // @@protoc_insertion_point(message:CMsgPointWithTransition.AnimationFrameData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AnimationFrameData {
        // message fields
        // @@protoc_insertion_point(field:CMsgPointWithTransition.AnimationFrameData.data)
        pub data: ::protobuf::MessageField<super::CMsgPoint>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgPointWithTransition.AnimationFrameData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AnimationFrameData {
        fn default() -> &'a AnimationFrameData {
            <AnimationFrameData as ::protobuf::Message>::default_instance()
        }
    }

    impl AnimationFrameData {
        pub fn new() -> AnimationFrameData {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for AnimationFrameData {
        const NAME: &'static str = "AnimationFrameData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AnimationFrameData {
            AnimationFrameData::new()
        }

        fn clear(&mut self) {
            self.data.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AnimationFrameData {
            static instance: AnimationFrameData = AnimationFrameData {
                data: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgColor)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgColor {
    // message fields
    // @@protoc_insertion_point(field:CMsgColor.base)
    pub base: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgColor.transition)
    pub transition: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgColor.transition_data)
    pub transition_data: ::protobuf::MessageField<CMsgTransitionData>,
    // @@protoc_insertion_point(field:CMsgColor.style_symbol)
    pub style_symbol: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgColor.animations)
    pub animations: ::std::vec::Vec<CMsgAnimationData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgColor.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgColor {
    fn default() -> &'a CMsgColor {
        <CMsgColor as ::protobuf::Message>::default_instance()
    }
}

impl CMsgColor {
    pub fn new() -> CMsgColor {
        ::std::default::Default::default()
    }

    // optional uint32 base = 1;

    pub fn base(&self) -> u32 {
        self.base.unwrap_or(0)
    }

    pub fn clear_base(&mut self) {
        self.base = ::std::option::Option::None;
    }

    pub fn has_base(&self) -> bool {
        self.base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base(&mut self, v: u32) {
        self.base = ::std::option::Option::Some(v);
    }

    // optional uint32 transition = 2;

    pub fn transition(&self) -> u32 {
        self.transition.unwrap_or(0)
    }

    pub fn clear_transition(&mut self) {
        self.transition = ::std::option::Option::None;
    }

    pub fn has_transition(&self) -> bool {
        self.transition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transition(&mut self, v: u32) {
        self.transition = ::std::option::Option::Some(v);
    }

    // optional uint32 style_symbol = 4;

    pub fn style_symbol(&self) -> u32 {
        self.style_symbol.unwrap_or(0)
    }

    pub fn clear_style_symbol(&mut self) {
        self.style_symbol = ::std::option::Option::None;
    }

    pub fn has_style_symbol(&self) -> bool {
        self.style_symbol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_symbol(&mut self, v: u32) {
        self.style_symbol = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgColor {
    const NAME: &'static str = "CMsgColor";

    fn is_initialized(&self) -> bool {
        for v in &self.transition_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.animations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.base = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.transition = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition_data)?;
                },
                32 => {
                    self.style_symbol = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.animations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.transition {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.transition_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.style_symbol {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.animations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.transition {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.transition_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.style_symbol {
            os.write_uint32(4, v)?;
        }
        for v in &self.animations {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgColor {
        CMsgColor::new()
    }

    fn clear(&mut self) {
        self.base = ::std::option::Option::None;
        self.transition = ::std::option::Option::None;
        self.transition_data.clear();
        self.style_symbol = ::std::option::Option::None;
        self.animations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgColor {
        static instance: CMsgColor = CMsgColor {
            base: ::std::option::Option::None,
            transition: ::std::option::Option::None,
            transition_data: ::protobuf::MessageField::none(),
            style_symbol: ::std::option::Option::None,
            animations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgColor`
pub mod cmsg_color {
    // @@protoc_insertion_point(message:CMsgColor.AnimationFrameData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AnimationFrameData {
        // message fields
        // @@protoc_insertion_point(field:CMsgColor.AnimationFrameData.data)
        pub data: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgColor.AnimationFrameData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AnimationFrameData {
        fn default() -> &'a AnimationFrameData {
            <AnimationFrameData as ::protobuf::Message>::default_instance()
        }
    }

    impl AnimationFrameData {
        pub fn new() -> AnimationFrameData {
            ::std::default::Default::default()
        }

        // optional uint32 data = 1;

        pub fn data(&self) -> u32 {
            self.data.unwrap_or(0)
        }

        pub fn clear_data(&mut self) {
            self.data = ::std::option::Option::None;
        }

        pub fn has_data(&self) -> bool {
            self.data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data(&mut self, v: u32) {
            self.data = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for AnimationFrameData {
        const NAME: &'static str = "AnimationFrameData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.data = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data {
                os.write_uint32(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AnimationFrameData {
            AnimationFrameData::new()
        }

        fn clear(&mut self) {
            self.data = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AnimationFrameData {
            static instance: AnimationFrameData = AnimationFrameData {
                data: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgColorStop)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgColorStop {
    // message fields
    // @@protoc_insertion_point(field:CMsgColorStop.position)
    pub position: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgColorStop.color_rgba)
    pub color_rgba: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgColorStop.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgColorStop {
    fn default() -> &'a CMsgColorStop {
        <CMsgColorStop as ::protobuf::Message>::default_instance()
    }
}

impl CMsgColorStop {
    pub fn new() -> CMsgColorStop {
        ::std::default::Default::default()
    }

    // optional double position = 1;

    pub fn position(&self) -> f64 {
        self.position.unwrap_or(0.)
    }

    pub fn clear_position(&mut self) {
        self.position = ::std::option::Option::None;
    }

    pub fn has_position(&self) -> bool {
        self.position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position(&mut self, v: f64) {
        self.position = ::std::option::Option::Some(v);
    }

    // optional uint32 color_rgba = 2;

    pub fn color_rgba(&self) -> u32 {
        self.color_rgba.unwrap_or(0)
    }

    pub fn clear_color_rgba(&mut self) {
        self.color_rgba = ::std::option::Option::None;
    }

    pub fn has_color_rgba(&self) -> bool {
        self.color_rgba.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color_rgba(&mut self, v: u32) {
        self.color_rgba = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgColorStop {
    const NAME: &'static str = "CMsgColorStop";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.position = ::std::option::Option::Some(is.read_double()?);
                },
                16 => {
                    self.color_rgba = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.position {
            my_size += 1 + 8;
        }
        if let Some(v) = self.color_rgba {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.position {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.color_rgba {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgColorStop {
        CMsgColorStop::new()
    }

    fn clear(&mut self) {
        self.position = ::std::option::Option::None;
        self.color_rgba = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgColorStop {
        static instance: CMsgColorStop = CMsgColorStop {
            position: ::std::option::Option::None,
            color_rgba: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgLinearGradient)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLinearGradient {
    // message fields
    // @@protoc_insertion_point(field:CMsgLinearGradient.start_position)
    pub start_position: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgLinearGradient.end_position)
    pub end_position: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgLinearGradient.color_stop)
    pub color_stop: ::std::vec::Vec<CMsgColorStop>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLinearGradient.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLinearGradient {
    fn default() -> &'a CMsgLinearGradient {
        <CMsgLinearGradient as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLinearGradient {
    pub fn new() -> CMsgLinearGradient {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgLinearGradient {
    const NAME: &'static str = "CMsgLinearGradient";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.start_position)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.end_position)?;
                },
                26 => {
                    self.color_stop.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.start_position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.end_position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.color_stop {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.start_position.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.end_position.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.color_stop {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLinearGradient {
        CMsgLinearGradient::new()
    }

    fn clear(&mut self) {
        self.start_position.clear();
        self.end_position.clear();
        self.color_stop.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLinearGradient {
        static instance: CMsgLinearGradient = CMsgLinearGradient {
            start_position: ::protobuf::MessageField::none(),
            end_position: ::protobuf::MessageField::none(),
            color_stop: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgRadialGradient)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRadialGradient {
    // message fields
    // @@protoc_insertion_point(field:CMsgRadialGradient.center_position)
    pub center_position: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgRadialGradient.offset_distance)
    pub offset_distance: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgRadialGradient.radii)
    pub radii: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgRadialGradient.color_stop)
    pub color_stop: ::std::vec::Vec<CMsgColorStop>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRadialGradient.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRadialGradient {
    fn default() -> &'a CMsgRadialGradient {
        <CMsgRadialGradient as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRadialGradient {
    pub fn new() -> CMsgRadialGradient {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgRadialGradient {
    const NAME: &'static str = "CMsgRadialGradient";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.center_position)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.offset_distance)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.radii)?;
                },
                34 => {
                    self.color_stop.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.center_position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.offset_distance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.radii.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.color_stop {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.center_position.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.offset_distance.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.radii.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.color_stop {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRadialGradient {
        CMsgRadialGradient::new()
    }

    fn clear(&mut self) {
        self.center_position.clear();
        self.offset_distance.clear();
        self.radii.clear();
        self.color_stop.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRadialGradient {
        static instance: CMsgRadialGradient = CMsgRadialGradient {
            center_position: ::protobuf::MessageField::none(),
            offset_distance: ::protobuf::MessageField::none(),
            radii: ::protobuf::MessageField::none(),
            color_stop: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgParticle)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgParticle {
    // message fields
    // @@protoc_insertion_point(field:CMsgParticle.particle_position)
    pub particle_position: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgParticle.particle_size)
    pub particle_size: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgParticle.particle_sharpness)
    pub particle_sharpness: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgParticle.color_rgba)
    pub color_rgba: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgParticle.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgParticle {
    fn default() -> &'a CMsgParticle {
        <CMsgParticle as ::protobuf::Message>::default_instance()
    }
}

impl CMsgParticle {
    pub fn new() -> CMsgParticle {
        ::std::default::Default::default()
    }

    // optional float particle_size = 2;

    pub fn particle_size(&self) -> f32 {
        self.particle_size.unwrap_or(0.)
    }

    pub fn clear_particle_size(&mut self) {
        self.particle_size = ::std::option::Option::None;
    }

    pub fn has_particle_size(&self) -> bool {
        self.particle_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_particle_size(&mut self, v: f32) {
        self.particle_size = ::std::option::Option::Some(v);
    }

    // optional float particle_sharpness = 3;

    pub fn particle_sharpness(&self) -> f32 {
        self.particle_sharpness.unwrap_or(0.)
    }

    pub fn clear_particle_sharpness(&mut self) {
        self.particle_sharpness = ::std::option::Option::None;
    }

    pub fn has_particle_sharpness(&self) -> bool {
        self.particle_sharpness.is_some()
    }

    // Param is passed by value, moved
    pub fn set_particle_sharpness(&mut self, v: f32) {
        self.particle_sharpness = ::std::option::Option::Some(v);
    }

    // optional uint32 color_rgba = 4;

    pub fn color_rgba(&self) -> u32 {
        self.color_rgba.unwrap_or(0)
    }

    pub fn clear_color_rgba(&mut self) {
        self.color_rgba = ::std::option::Option::None;
    }

    pub fn has_color_rgba(&self) -> bool {
        self.color_rgba.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color_rgba(&mut self, v: u32) {
        self.color_rgba = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgParticle {
    const NAME: &'static str = "CMsgParticle";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.particle_position)?;
                },
                21 => {
                    self.particle_size = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.particle_sharpness = ::std::option::Option::Some(is.read_float()?);
                },
                32 => {
                    self.color_rgba = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.particle_position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.particle_size {
            my_size += 1 + 4;
        }
        if let Some(v) = self.particle_sharpness {
            my_size += 1 + 4;
        }
        if let Some(v) = self.color_rgba {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.particle_position.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.particle_size {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.particle_sharpness {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.color_rgba {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgParticle {
        CMsgParticle::new()
    }

    fn clear(&mut self) {
        self.particle_position.clear();
        self.particle_size = ::std::option::Option::None;
        self.particle_sharpness = ::std::option::Option::None;
        self.color_rgba = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgParticle {
        static instance: CMsgParticle = CMsgParticle {
            particle_position: ::protobuf::MessageField::none(),
            particle_size: ::std::option::Option::None,
            particle_sharpness: ::std::option::Option::None,
            color_rgba: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgParticleSystem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgParticleSystem {
    // message fields
    // @@protoc_insertion_point(field:CMsgParticleSystem.base_position)
    pub base_position: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgParticleSystem.base_position_variance)
    pub base_position_variance: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgParticleSystem.particle_size)
    pub particle_size: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgParticleSystem.particle_size_variance)
    pub particle_size_variance: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgParticleSystem.particles_per_second)
    pub particles_per_second: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgParticleSystem.particles_per_second_variance)
    pub particles_per_second_variance: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgParticleSystem.particle_lifespan_seconds)
    pub particle_lifespan_seconds: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgParticleSystem.particle_lifespan_seconds_variance)
    pub particle_lifespan_seconds_variance: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgParticleSystem.particle_initial_velocity)
    pub particle_initial_velocity: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgParticleSystem.particle_initial_velocity_variance)
    pub particle_initial_velocity_variance: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgParticleSystem.gravity_acceleration)
    pub gravity_acceleration: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgParticleSystem.gravity_acceleration_particle_variance)
    pub gravity_acceleration_particle_variance: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgParticleSystem.color_start_rgba)
    pub color_start_rgba: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgParticleSystem.color_start_rgba_variance)
    pub color_start_rgba_variance: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgParticleSystem.color_end_rgba)
    pub color_end_rgba: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgParticleSystem.color_end_rgba_variance)
    pub color_end_rgba_variance: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgParticleSystem.parent_panel_handle)
    pub parent_panel_handle: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgParticleSystem.parent_brush_index)
    pub parent_brush_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgParticleSystem.particle_sharpness)
    pub particle_sharpness: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgParticleSystem.particle_sharpness_variance)
    pub particle_sharpness_variance: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgParticleSystem.particle_flicker)
    pub particle_flicker: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgParticleSystem.particle_flicker_variance)
    pub particle_flicker_variance: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgParticleSystem.particle_velocity_min)
    pub particle_velocity_min: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgParticleSystem.particle_velocity_max)
    pub particle_velocity_max: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgParticleSystem.particles)
    pub particles: ::std::vec::Vec<CMsgParticle>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgParticleSystem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgParticleSystem {
    fn default() -> &'a CMsgParticleSystem {
        <CMsgParticleSystem as ::protobuf::Message>::default_instance()
    }
}

impl CMsgParticleSystem {
    pub fn new() -> CMsgParticleSystem {
        ::std::default::Default::default()
    }

    // optional double particle_size = 3;

    pub fn particle_size(&self) -> f64 {
        self.particle_size.unwrap_or(0.)
    }

    pub fn clear_particle_size(&mut self) {
        self.particle_size = ::std::option::Option::None;
    }

    pub fn has_particle_size(&self) -> bool {
        self.particle_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_particle_size(&mut self, v: f64) {
        self.particle_size = ::std::option::Option::Some(v);
    }

    // optional double particle_size_variance = 4;

    pub fn particle_size_variance(&self) -> f64 {
        self.particle_size_variance.unwrap_or(0.)
    }

    pub fn clear_particle_size_variance(&mut self) {
        self.particle_size_variance = ::std::option::Option::None;
    }

    pub fn has_particle_size_variance(&self) -> bool {
        self.particle_size_variance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_particle_size_variance(&mut self, v: f64) {
        self.particle_size_variance = ::std::option::Option::Some(v);
    }

    // optional double particles_per_second = 5;

    pub fn particles_per_second(&self) -> f64 {
        self.particles_per_second.unwrap_or(0.)
    }

    pub fn clear_particles_per_second(&mut self) {
        self.particles_per_second = ::std::option::Option::None;
    }

    pub fn has_particles_per_second(&self) -> bool {
        self.particles_per_second.is_some()
    }

    // Param is passed by value, moved
    pub fn set_particles_per_second(&mut self, v: f64) {
        self.particles_per_second = ::std::option::Option::Some(v);
    }

    // optional double particles_per_second_variance = 6;

    pub fn particles_per_second_variance(&self) -> f64 {
        self.particles_per_second_variance.unwrap_or(0.)
    }

    pub fn clear_particles_per_second_variance(&mut self) {
        self.particles_per_second_variance = ::std::option::Option::None;
    }

    pub fn has_particles_per_second_variance(&self) -> bool {
        self.particles_per_second_variance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_particles_per_second_variance(&mut self, v: f64) {
        self.particles_per_second_variance = ::std::option::Option::Some(v);
    }

    // optional double particle_lifespan_seconds = 7;

    pub fn particle_lifespan_seconds(&self) -> f64 {
        self.particle_lifespan_seconds.unwrap_or(0.)
    }

    pub fn clear_particle_lifespan_seconds(&mut self) {
        self.particle_lifespan_seconds = ::std::option::Option::None;
    }

    pub fn has_particle_lifespan_seconds(&self) -> bool {
        self.particle_lifespan_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_particle_lifespan_seconds(&mut self, v: f64) {
        self.particle_lifespan_seconds = ::std::option::Option::Some(v);
    }

    // optional double particle_lifespan_seconds_variance = 8;

    pub fn particle_lifespan_seconds_variance(&self) -> f64 {
        self.particle_lifespan_seconds_variance.unwrap_or(0.)
    }

    pub fn clear_particle_lifespan_seconds_variance(&mut self) {
        self.particle_lifespan_seconds_variance = ::std::option::Option::None;
    }

    pub fn has_particle_lifespan_seconds_variance(&self) -> bool {
        self.particle_lifespan_seconds_variance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_particle_lifespan_seconds_variance(&mut self, v: f64) {
        self.particle_lifespan_seconds_variance = ::std::option::Option::Some(v);
    }

    // optional uint32 color_start_rgba = 13;

    pub fn color_start_rgba(&self) -> u32 {
        self.color_start_rgba.unwrap_or(0)
    }

    pub fn clear_color_start_rgba(&mut self) {
        self.color_start_rgba = ::std::option::Option::None;
    }

    pub fn has_color_start_rgba(&self) -> bool {
        self.color_start_rgba.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color_start_rgba(&mut self, v: u32) {
        self.color_start_rgba = ::std::option::Option::Some(v);
    }

    // optional uint32 color_start_rgba_variance = 14;

    pub fn color_start_rgba_variance(&self) -> u32 {
        self.color_start_rgba_variance.unwrap_or(0)
    }

    pub fn clear_color_start_rgba_variance(&mut self) {
        self.color_start_rgba_variance = ::std::option::Option::None;
    }

    pub fn has_color_start_rgba_variance(&self) -> bool {
        self.color_start_rgba_variance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color_start_rgba_variance(&mut self, v: u32) {
        self.color_start_rgba_variance = ::std::option::Option::Some(v);
    }

    // optional uint32 color_end_rgba = 15;

    pub fn color_end_rgba(&self) -> u32 {
        self.color_end_rgba.unwrap_or(0)
    }

    pub fn clear_color_end_rgba(&mut self) {
        self.color_end_rgba = ::std::option::Option::None;
    }

    pub fn has_color_end_rgba(&self) -> bool {
        self.color_end_rgba.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color_end_rgba(&mut self, v: u32) {
        self.color_end_rgba = ::std::option::Option::Some(v);
    }

    // optional uint32 color_end_rgba_variance = 16;

    pub fn color_end_rgba_variance(&self) -> u32 {
        self.color_end_rgba_variance.unwrap_or(0)
    }

    pub fn clear_color_end_rgba_variance(&mut self) {
        self.color_end_rgba_variance = ::std::option::Option::None;
    }

    pub fn has_color_end_rgba_variance(&self) -> bool {
        self.color_end_rgba_variance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color_end_rgba_variance(&mut self, v: u32) {
        self.color_end_rgba_variance = ::std::option::Option::Some(v);
    }

    // optional uint64 parent_panel_handle = 17;

    pub fn parent_panel_handle(&self) -> u64 {
        self.parent_panel_handle.unwrap_or(0)
    }

    pub fn clear_parent_panel_handle(&mut self) {
        self.parent_panel_handle = ::std::option::Option::None;
    }

    pub fn has_parent_panel_handle(&self) -> bool {
        self.parent_panel_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent_panel_handle(&mut self, v: u64) {
        self.parent_panel_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 parent_brush_index = 18;

    pub fn parent_brush_index(&self) -> u32 {
        self.parent_brush_index.unwrap_or(0)
    }

    pub fn clear_parent_brush_index(&mut self) {
        self.parent_brush_index = ::std::option::Option::None;
    }

    pub fn has_parent_brush_index(&self) -> bool {
        self.parent_brush_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent_brush_index(&mut self, v: u32) {
        self.parent_brush_index = ::std::option::Option::Some(v);
    }

    // optional float particle_sharpness = 19;

    pub fn particle_sharpness(&self) -> f32 {
        self.particle_sharpness.unwrap_or(0.)
    }

    pub fn clear_particle_sharpness(&mut self) {
        self.particle_sharpness = ::std::option::Option::None;
    }

    pub fn has_particle_sharpness(&self) -> bool {
        self.particle_sharpness.is_some()
    }

    // Param is passed by value, moved
    pub fn set_particle_sharpness(&mut self, v: f32) {
        self.particle_sharpness = ::std::option::Option::Some(v);
    }

    // optional float particle_sharpness_variance = 20;

    pub fn particle_sharpness_variance(&self) -> f32 {
        self.particle_sharpness_variance.unwrap_or(0.)
    }

    pub fn clear_particle_sharpness_variance(&mut self) {
        self.particle_sharpness_variance = ::std::option::Option::None;
    }

    pub fn has_particle_sharpness_variance(&self) -> bool {
        self.particle_sharpness_variance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_particle_sharpness_variance(&mut self, v: f32) {
        self.particle_sharpness_variance = ::std::option::Option::Some(v);
    }

    // optional float particle_flicker = 21;

    pub fn particle_flicker(&self) -> f32 {
        self.particle_flicker.unwrap_or(0.)
    }

    pub fn clear_particle_flicker(&mut self) {
        self.particle_flicker = ::std::option::Option::None;
    }

    pub fn has_particle_flicker(&self) -> bool {
        self.particle_flicker.is_some()
    }

    // Param is passed by value, moved
    pub fn set_particle_flicker(&mut self, v: f32) {
        self.particle_flicker = ::std::option::Option::Some(v);
    }

    // optional float particle_flicker_variance = 22;

    pub fn particle_flicker_variance(&self) -> f32 {
        self.particle_flicker_variance.unwrap_or(0.)
    }

    pub fn clear_particle_flicker_variance(&mut self) {
        self.particle_flicker_variance = ::std::option::Option::None;
    }

    pub fn has_particle_flicker_variance(&self) -> bool {
        self.particle_flicker_variance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_particle_flicker_variance(&mut self, v: f32) {
        self.particle_flicker_variance = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgParticleSystem {
    const NAME: &'static str = "CMsgParticleSystem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.base_position)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.base_position_variance)?;
                },
                25 => {
                    self.particle_size = ::std::option::Option::Some(is.read_double()?);
                },
                33 => {
                    self.particle_size_variance = ::std::option::Option::Some(is.read_double()?);
                },
                41 => {
                    self.particles_per_second = ::std::option::Option::Some(is.read_double()?);
                },
                49 => {
                    self.particles_per_second_variance = ::std::option::Option::Some(is.read_double()?);
                },
                57 => {
                    self.particle_lifespan_seconds = ::std::option::Option::Some(is.read_double()?);
                },
                65 => {
                    self.particle_lifespan_seconds_variance = ::std::option::Option::Some(is.read_double()?);
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.particle_initial_velocity)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.particle_initial_velocity_variance)?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.gravity_acceleration)?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.gravity_acceleration_particle_variance)?;
                },
                104 => {
                    self.color_start_rgba = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.color_start_rgba_variance = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.color_end_rgba = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.color_end_rgba_variance = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.parent_panel_handle = ::std::option::Option::Some(is.read_uint64()?);
                },
                144 => {
                    self.parent_brush_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                157 => {
                    self.particle_sharpness = ::std::option::Option::Some(is.read_float()?);
                },
                165 => {
                    self.particle_sharpness_variance = ::std::option::Option::Some(is.read_float()?);
                },
                173 => {
                    self.particle_flicker = ::std::option::Option::Some(is.read_float()?);
                },
                181 => {
                    self.particle_flicker_variance = ::std::option::Option::Some(is.read_float()?);
                },
                186 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.particle_velocity_min)?;
                },
                194 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.particle_velocity_max)?;
                },
                402 => {
                    self.particles.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base_position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.base_position_variance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.particle_size {
            my_size += 1 + 8;
        }
        if let Some(v) = self.particle_size_variance {
            my_size += 1 + 8;
        }
        if let Some(v) = self.particles_per_second {
            my_size += 1 + 8;
        }
        if let Some(v) = self.particles_per_second_variance {
            my_size += 1 + 8;
        }
        if let Some(v) = self.particle_lifespan_seconds {
            my_size += 1 + 8;
        }
        if let Some(v) = self.particle_lifespan_seconds_variance {
            my_size += 1 + 8;
        }
        if let Some(v) = self.particle_initial_velocity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.particle_initial_velocity_variance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.gravity_acceleration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.gravity_acceleration_particle_variance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.color_start_rgba {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.color_start_rgba_variance {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.color_end_rgba {
            my_size += ::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.color_end_rgba_variance {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.parent_panel_handle {
            my_size += ::protobuf::rt::uint64_size(17, v);
        }
        if let Some(v) = self.parent_brush_index {
            my_size += ::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.particle_sharpness {
            my_size += 2 + 4;
        }
        if let Some(v) = self.particle_sharpness_variance {
            my_size += 2 + 4;
        }
        if let Some(v) = self.particle_flicker {
            my_size += 2 + 4;
        }
        if let Some(v) = self.particle_flicker_variance {
            my_size += 2 + 4;
        }
        if let Some(v) = self.particle_velocity_min.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.particle_velocity_max.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.particles {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base_position.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.base_position_variance.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.particle_size {
            os.write_double(3, v)?;
        }
        if let Some(v) = self.particle_size_variance {
            os.write_double(4, v)?;
        }
        if let Some(v) = self.particles_per_second {
            os.write_double(5, v)?;
        }
        if let Some(v) = self.particles_per_second_variance {
            os.write_double(6, v)?;
        }
        if let Some(v) = self.particle_lifespan_seconds {
            os.write_double(7, v)?;
        }
        if let Some(v) = self.particle_lifespan_seconds_variance {
            os.write_double(8, v)?;
        }
        if let Some(v) = self.particle_initial_velocity.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.particle_initial_velocity_variance.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.gravity_acceleration.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.gravity_acceleration_particle_variance.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.color_start_rgba {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.color_start_rgba_variance {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.color_end_rgba {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.color_end_rgba_variance {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.parent_panel_handle {
            os.write_uint64(17, v)?;
        }
        if let Some(v) = self.parent_brush_index {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.particle_sharpness {
            os.write_float(19, v)?;
        }
        if let Some(v) = self.particle_sharpness_variance {
            os.write_float(20, v)?;
        }
        if let Some(v) = self.particle_flicker {
            os.write_float(21, v)?;
        }
        if let Some(v) = self.particle_flicker_variance {
            os.write_float(22, v)?;
        }
        if let Some(v) = self.particle_velocity_min.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
        }
        if let Some(v) = self.particle_velocity_max.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        }
        for v in &self.particles {
            ::protobuf::rt::write_message_field_with_cached_size(50, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgParticleSystem {
        CMsgParticleSystem::new()
    }

    fn clear(&mut self) {
        self.base_position.clear();
        self.base_position_variance.clear();
        self.particle_size = ::std::option::Option::None;
        self.particle_size_variance = ::std::option::Option::None;
        self.particles_per_second = ::std::option::Option::None;
        self.particles_per_second_variance = ::std::option::Option::None;
        self.particle_lifespan_seconds = ::std::option::Option::None;
        self.particle_lifespan_seconds_variance = ::std::option::Option::None;
        self.particle_initial_velocity.clear();
        self.particle_initial_velocity_variance.clear();
        self.gravity_acceleration.clear();
        self.gravity_acceleration_particle_variance.clear();
        self.color_start_rgba = ::std::option::Option::None;
        self.color_start_rgba_variance = ::std::option::Option::None;
        self.color_end_rgba = ::std::option::Option::None;
        self.color_end_rgba_variance = ::std::option::Option::None;
        self.parent_panel_handle = ::std::option::Option::None;
        self.parent_brush_index = ::std::option::Option::None;
        self.particle_sharpness = ::std::option::Option::None;
        self.particle_sharpness_variance = ::std::option::Option::None;
        self.particle_flicker = ::std::option::Option::None;
        self.particle_flicker_variance = ::std::option::Option::None;
        self.particle_velocity_min.clear();
        self.particle_velocity_max.clear();
        self.particles.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgParticleSystem {
        static instance: CMsgParticleSystem = CMsgParticleSystem {
            base_position: ::protobuf::MessageField::none(),
            base_position_variance: ::protobuf::MessageField::none(),
            particle_size: ::std::option::Option::None,
            particle_size_variance: ::std::option::Option::None,
            particles_per_second: ::std::option::Option::None,
            particles_per_second_variance: ::std::option::Option::None,
            particle_lifespan_seconds: ::std::option::Option::None,
            particle_lifespan_seconds_variance: ::std::option::Option::None,
            particle_initial_velocity: ::protobuf::MessageField::none(),
            particle_initial_velocity_variance: ::protobuf::MessageField::none(),
            gravity_acceleration: ::protobuf::MessageField::none(),
            gravity_acceleration_particle_variance: ::protobuf::MessageField::none(),
            color_start_rgba: ::std::option::Option::None,
            color_start_rgba_variance: ::std::option::Option::None,
            color_end_rgba: ::std::option::Option::None,
            color_end_rgba_variance: ::std::option::Option::None,
            parent_panel_handle: ::std::option::Option::None,
            parent_brush_index: ::std::option::Option::None,
            particle_sharpness: ::std::option::Option::None,
            particle_sharpness_variance: ::std::option::Option::None,
            particle_flicker: ::std::option::Option::None,
            particle_flicker_variance: ::std::option::Option::None,
            particle_velocity_min: ::protobuf::MessageField::none(),
            particle_velocity_max: ::protobuf::MessageField::none(),
            particles: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgFillBrush)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFillBrush {
    // message fields
    // @@protoc_insertion_point(field:CMsgFillBrush.opacity)
    pub opacity: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgFillBrush.color_rgba)
    pub color_rgba: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgFillBrush.linear_gradient)
    pub linear_gradient: ::protobuf::MessageField<CMsgLinearGradient>,
    // @@protoc_insertion_point(field:CMsgFillBrush.radial_gradient)
    pub radial_gradient: ::protobuf::MessageField<CMsgRadialGradient>,
    // @@protoc_insertion_point(field:CMsgFillBrush.particle_system)
    pub particle_system: ::protobuf::MessageField<CMsgParticleSystem>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFillBrush.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFillBrush {
    fn default() -> &'a CMsgFillBrush {
        <CMsgFillBrush as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFillBrush {
    pub fn new() -> CMsgFillBrush {
        ::std::default::Default::default()
    }

    // optional double opacity = 1;

    pub fn opacity(&self) -> f64 {
        self.opacity.unwrap_or(0.)
    }

    pub fn clear_opacity(&mut self) {
        self.opacity = ::std::option::Option::None;
    }

    pub fn has_opacity(&self) -> bool {
        self.opacity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_opacity(&mut self, v: f64) {
        self.opacity = ::std::option::Option::Some(v);
    }

    // optional uint32 color_rgba = 2;

    pub fn color_rgba(&self) -> u32 {
        self.color_rgba.unwrap_or(0)
    }

    pub fn clear_color_rgba(&mut self) {
        self.color_rgba = ::std::option::Option::None;
    }

    pub fn has_color_rgba(&self) -> bool {
        self.color_rgba.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color_rgba(&mut self, v: u32) {
        self.color_rgba = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgFillBrush {
    const NAME: &'static str = "CMsgFillBrush";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.opacity = ::std::option::Option::Some(is.read_double()?);
                },
                16 => {
                    self.color_rgba = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.linear_gradient)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.radial_gradient)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.particle_system)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.opacity {
            my_size += 1 + 8;
        }
        if let Some(v) = self.color_rgba {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.linear_gradient.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.radial_gradient.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.particle_system.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.opacity {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.color_rgba {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.linear_gradient.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.radial_gradient.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.particle_system.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFillBrush {
        CMsgFillBrush::new()
    }

    fn clear(&mut self) {
        self.opacity = ::std::option::Option::None;
        self.color_rgba = ::std::option::Option::None;
        self.linear_gradient.clear();
        self.radial_gradient.clear();
        self.particle_system.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFillBrush {
        static instance: CMsgFillBrush = CMsgFillBrush {
            opacity: ::std::option::Option::None,
            color_rgba: ::std::option::Option::None,
            linear_gradient: ::protobuf::MessageField::none(),
            radial_gradient: ::protobuf::MessageField::none(),
            particle_system: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgFillBrushCollection)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFillBrushCollection {
    // message fields
    // @@protoc_insertion_point(field:CMsgFillBrushCollection.base)
    pub base: ::std::vec::Vec<CMsgFillBrush>,
    // @@protoc_insertion_point(field:CMsgFillBrushCollection.transition)
    pub transition: ::std::vec::Vec<CMsgFillBrush>,
    // @@protoc_insertion_point(field:CMsgFillBrushCollection.transition_data)
    pub transition_data: ::protobuf::MessageField<CMsgTransitionData>,
    // @@protoc_insertion_point(field:CMsgFillBrushCollection.style_symbol)
    pub style_symbol: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgFillBrushCollection.animations)
    pub animations: ::std::vec::Vec<CMsgAnimationData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFillBrushCollection.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFillBrushCollection {
    fn default() -> &'a CMsgFillBrushCollection {
        <CMsgFillBrushCollection as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFillBrushCollection {
    pub fn new() -> CMsgFillBrushCollection {
        ::std::default::Default::default()
    }

    // optional uint32 style_symbol = 4;

    pub fn style_symbol(&self) -> u32 {
        self.style_symbol.unwrap_or(0)
    }

    pub fn clear_style_symbol(&mut self) {
        self.style_symbol = ::std::option::Option::None;
    }

    pub fn has_style_symbol(&self) -> bool {
        self.style_symbol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_symbol(&mut self, v: u32) {
        self.style_symbol = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgFillBrushCollection {
    const NAME: &'static str = "CMsgFillBrushCollection";

    fn is_initialized(&self) -> bool {
        for v in &self.base {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.animations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.base.push(is.read_message()?);
                },
                18 => {
                    self.transition.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition_data)?;
                },
                32 => {
                    self.style_symbol = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.animations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.base {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.transition {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.transition_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.style_symbol {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.animations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.base {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.transition {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.transition_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.style_symbol {
            os.write_uint32(4, v)?;
        }
        for v in &self.animations {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFillBrushCollection {
        CMsgFillBrushCollection::new()
    }

    fn clear(&mut self) {
        self.base.clear();
        self.transition.clear();
        self.transition_data.clear();
        self.style_symbol = ::std::option::Option::None;
        self.animations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFillBrushCollection {
        static instance: CMsgFillBrushCollection = CMsgFillBrushCollection {
            base: ::std::vec::Vec::new(),
            transition: ::std::vec::Vec::new(),
            transition_data: ::protobuf::MessageField::none(),
            style_symbol: ::std::option::Option::None,
            animations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgFillBrushCollection`
pub mod cmsg_fill_brush_collection {
    // @@protoc_insertion_point(message:CMsgFillBrushCollection.AnimationFrameData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AnimationFrameData {
        // message fields
        // @@protoc_insertion_point(field:CMsgFillBrushCollection.AnimationFrameData.data)
        pub data: ::std::vec::Vec<super::CMsgFillBrush>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgFillBrushCollection.AnimationFrameData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AnimationFrameData {
        fn default() -> &'a AnimationFrameData {
            <AnimationFrameData as ::protobuf::Message>::default_instance()
        }
    }

    impl AnimationFrameData {
        pub fn new() -> AnimationFrameData {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for AnimationFrameData {
        const NAME: &'static str = "AnimationFrameData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.data.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.data {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.data {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AnimationFrameData {
            AnimationFrameData::new()
        }

        fn clear(&mut self) {
            self.data.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AnimationFrameData {
            static instance: AnimationFrameData = AnimationFrameData {
                data: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgRenderFillBrushCollection)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRenderFillBrushCollection {
    // message fields
    // @@protoc_insertion_point(field:CMsgRenderFillBrushCollection.fill_brush)
    pub fill_brush: ::std::vec::Vec<CMsgFillBrush>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRenderFillBrushCollection.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRenderFillBrushCollection {
    fn default() -> &'a CMsgRenderFillBrushCollection {
        <CMsgRenderFillBrushCollection as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRenderFillBrushCollection {
    pub fn new() -> CMsgRenderFillBrushCollection {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgRenderFillBrushCollection {
    const NAME: &'static str = "CMsgRenderFillBrushCollection";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.fill_brush.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.fill_brush {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.fill_brush {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRenderFillBrushCollection {
        CMsgRenderFillBrushCollection::new()
    }

    fn clear(&mut self) {
        self.fill_brush.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRenderFillBrushCollection {
        static instance: CMsgRenderFillBrushCollection = CMsgRenderFillBrushCollection {
            fill_brush: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPanelPosition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPanelPosition {
    // message fields
    // @@protoc_insertion_point(field:CMsgPanelPosition.base)
    pub base: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgPanelPosition.transition)
    pub transition: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgPanelPosition.transition_data)
    pub transition_data: ::protobuf::MessageField<CMsgTransitionData>,
    // @@protoc_insertion_point(field:CMsgPanelPosition.style_symbol)
    pub style_symbol: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPanelPosition.animations)
    pub animations: ::std::vec::Vec<CMsgAnimationData>,
    // @@protoc_insertion_point(field:CMsgPanelPosition.scroll_offset)
    pub scroll_offset: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgPanelPosition.scroll_offset_target)
    pub scroll_offset_target: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgPanelPosition.scroll_transition_x)
    pub scroll_transition_x: ::protobuf::MessageField<CMsgTransitionData>,
    // @@protoc_insertion_point(field:CMsgPanelPosition.scroll_transition_y)
    pub scroll_transition_y: ::protobuf::MessageField<CMsgTransitionData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPanelPosition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPanelPosition {
    fn default() -> &'a CMsgPanelPosition {
        <CMsgPanelPosition as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPanelPosition {
    pub fn new() -> CMsgPanelPosition {
        ::std::default::Default::default()
    }

    // optional uint32 style_symbol = 4;

    pub fn style_symbol(&self) -> u32 {
        self.style_symbol.unwrap_or(0)
    }

    pub fn clear_style_symbol(&mut self) {
        self.style_symbol = ::std::option::Option::None;
    }

    pub fn has_style_symbol(&self) -> bool {
        self.style_symbol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_symbol(&mut self, v: u32) {
        self.style_symbol = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgPanelPosition {
    const NAME: &'static str = "CMsgPanelPosition";

    fn is_initialized(&self) -> bool {
        for v in &self.base {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.animations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.scroll_offset {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.scroll_offset_target {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.scroll_transition_x {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.scroll_transition_y {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.base)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition_data)?;
                },
                32 => {
                    self.style_symbol = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.animations.push(is.read_message()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.scroll_offset)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.scroll_offset_target)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.scroll_transition_x)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.scroll_transition_y)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.style_symbol {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.animations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.scroll_offset.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.scroll_offset_target.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.scroll_transition_x.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.scroll_transition_y.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.transition.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.transition_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.style_symbol {
            os.write_uint32(4, v)?;
        }
        for v in &self.animations {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.scroll_offset.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.scroll_offset_target.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.scroll_transition_x.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.scroll_transition_y.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPanelPosition {
        CMsgPanelPosition::new()
    }

    fn clear(&mut self) {
        self.base.clear();
        self.transition.clear();
        self.transition_data.clear();
        self.style_symbol = ::std::option::Option::None;
        self.animations.clear();
        self.scroll_offset.clear();
        self.scroll_offset_target.clear();
        self.scroll_transition_x.clear();
        self.scroll_transition_y.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPanelPosition {
        static instance: CMsgPanelPosition = CMsgPanelPosition {
            base: ::protobuf::MessageField::none(),
            transition: ::protobuf::MessageField::none(),
            transition_data: ::protobuf::MessageField::none(),
            style_symbol: ::std::option::Option::None,
            animations: ::std::vec::Vec::new(),
            scroll_offset: ::protobuf::MessageField::none(),
            scroll_offset_target: ::protobuf::MessageField::none(),
            scroll_transition_x: ::protobuf::MessageField::none(),
            scroll_transition_y: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgPanelPosition`
pub mod cmsg_panel_position {
    // @@protoc_insertion_point(message:CMsgPanelPosition.AnimationFrameData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AnimationFrameData {
        // message fields
        // @@protoc_insertion_point(field:CMsgPanelPosition.AnimationFrameData.data)
        pub data: ::protobuf::MessageField<super::CMsgPoint>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgPanelPosition.AnimationFrameData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AnimationFrameData {
        fn default() -> &'a AnimationFrameData {
            <AnimationFrameData as ::protobuf::Message>::default_instance()
        }
    }

    impl AnimationFrameData {
        pub fn new() -> AnimationFrameData {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for AnimationFrameData {
        const NAME: &'static str = "AnimationFrameData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AnimationFrameData {
            AnimationFrameData::new()
        }

        fn clear(&mut self) {
            self.data.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AnimationFrameData {
            static instance: AnimationFrameData = AnimationFrameData {
                data: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgOpacity)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgOpacity {
    // message fields
    // @@protoc_insertion_point(field:CMsgOpacity.base)
    pub base: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgOpacity.transition)
    pub transition: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgOpacity.transition_data)
    pub transition_data: ::protobuf::MessageField<CMsgTransitionData>,
    // @@protoc_insertion_point(field:CMsgOpacity.style_symbol)
    pub style_symbol: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgOpacity.animations)
    pub animations: ::std::vec::Vec<CMsgAnimationData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgOpacity.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgOpacity {
    fn default() -> &'a CMsgOpacity {
        <CMsgOpacity as ::protobuf::Message>::default_instance()
    }
}

impl CMsgOpacity {
    pub fn new() -> CMsgOpacity {
        ::std::default::Default::default()
    }

    // optional double base = 1;

    pub fn base(&self) -> f64 {
        self.base.unwrap_or(0.)
    }

    pub fn clear_base(&mut self) {
        self.base = ::std::option::Option::None;
    }

    pub fn has_base(&self) -> bool {
        self.base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base(&mut self, v: f64) {
        self.base = ::std::option::Option::Some(v);
    }

    // optional double transition = 2;

    pub fn transition(&self) -> f64 {
        self.transition.unwrap_or(0.)
    }

    pub fn clear_transition(&mut self) {
        self.transition = ::std::option::Option::None;
    }

    pub fn has_transition(&self) -> bool {
        self.transition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transition(&mut self, v: f64) {
        self.transition = ::std::option::Option::Some(v);
    }

    // optional uint32 style_symbol = 4;

    pub fn style_symbol(&self) -> u32 {
        self.style_symbol.unwrap_or(0)
    }

    pub fn clear_style_symbol(&mut self) {
        self.style_symbol = ::std::option::Option::None;
    }

    pub fn has_style_symbol(&self) -> bool {
        self.style_symbol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_symbol(&mut self, v: u32) {
        self.style_symbol = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgOpacity {
    const NAME: &'static str = "CMsgOpacity";

    fn is_initialized(&self) -> bool {
        for v in &self.transition_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.animations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.base = ::std::option::Option::Some(is.read_double()?);
                },
                17 => {
                    self.transition = ::std::option::Option::Some(is.read_double()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition_data)?;
                },
                32 => {
                    self.style_symbol = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.animations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transition {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transition_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.style_symbol {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.animations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.transition {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.transition_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.style_symbol {
            os.write_uint32(4, v)?;
        }
        for v in &self.animations {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgOpacity {
        CMsgOpacity::new()
    }

    fn clear(&mut self) {
        self.base = ::std::option::Option::None;
        self.transition = ::std::option::Option::None;
        self.transition_data.clear();
        self.style_symbol = ::std::option::Option::None;
        self.animations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgOpacity {
        static instance: CMsgOpacity = CMsgOpacity {
            base: ::std::option::Option::None,
            transition: ::std::option::Option::None,
            transition_data: ::protobuf::MessageField::none(),
            style_symbol: ::std::option::Option::None,
            animations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgOpacity`
pub mod cmsg_opacity {
    // @@protoc_insertion_point(message:CMsgOpacity.AnimationFrameData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AnimationFrameData {
        // message fields
        // @@protoc_insertion_point(field:CMsgOpacity.AnimationFrameData.data)
        pub data: ::std::option::Option<f64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgOpacity.AnimationFrameData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AnimationFrameData {
        fn default() -> &'a AnimationFrameData {
            <AnimationFrameData as ::protobuf::Message>::default_instance()
        }
    }

    impl AnimationFrameData {
        pub fn new() -> AnimationFrameData {
            ::std::default::Default::default()
        }

        // optional double data = 1;

        pub fn data(&self) -> f64 {
            self.data.unwrap_or(0.)
        }

        pub fn clear_data(&mut self) {
            self.data = ::std::option::Option::None;
        }

        pub fn has_data(&self) -> bool {
            self.data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data(&mut self, v: f64) {
            self.data = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for AnimationFrameData {
        const NAME: &'static str = "AnimationFrameData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.data = ::std::option::Option::Some(is.read_double()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data {
                os.write_double(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AnimationFrameData {
            AnimationFrameData::new()
        }

        fn clear(&mut self) {
            self.data = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AnimationFrameData {
            static instance: AnimationFrameData = AnimationFrameData {
                data: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgRotate2D)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRotate2D {
    // message fields
    // @@protoc_insertion_point(field:CMsgRotate2D.base)
    pub base: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgRotate2D.transition)
    pub transition: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgRotate2D.transition_data)
    pub transition_data: ::protobuf::MessageField<CMsgTransitionData>,
    // @@protoc_insertion_point(field:CMsgRotate2D.style_symbol)
    pub style_symbol: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRotate2D.animations)
    pub animations: ::std::vec::Vec<CMsgAnimationData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRotate2D.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRotate2D {
    fn default() -> &'a CMsgRotate2D {
        <CMsgRotate2D as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRotate2D {
    pub fn new() -> CMsgRotate2D {
        ::std::default::Default::default()
    }

    // optional double base = 1;

    pub fn base(&self) -> f64 {
        self.base.unwrap_or(0.)
    }

    pub fn clear_base(&mut self) {
        self.base = ::std::option::Option::None;
    }

    pub fn has_base(&self) -> bool {
        self.base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base(&mut self, v: f64) {
        self.base = ::std::option::Option::Some(v);
    }

    // optional double transition = 2;

    pub fn transition(&self) -> f64 {
        self.transition.unwrap_or(0.)
    }

    pub fn clear_transition(&mut self) {
        self.transition = ::std::option::Option::None;
    }

    pub fn has_transition(&self) -> bool {
        self.transition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transition(&mut self, v: f64) {
        self.transition = ::std::option::Option::Some(v);
    }

    // optional uint32 style_symbol = 4;

    pub fn style_symbol(&self) -> u32 {
        self.style_symbol.unwrap_or(0)
    }

    pub fn clear_style_symbol(&mut self) {
        self.style_symbol = ::std::option::Option::None;
    }

    pub fn has_style_symbol(&self) -> bool {
        self.style_symbol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_symbol(&mut self, v: u32) {
        self.style_symbol = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgRotate2D {
    const NAME: &'static str = "CMsgRotate2D";

    fn is_initialized(&self) -> bool {
        for v in &self.transition_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.animations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.base = ::std::option::Option::Some(is.read_double()?);
                },
                17 => {
                    self.transition = ::std::option::Option::Some(is.read_double()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition_data)?;
                },
                32 => {
                    self.style_symbol = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.animations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transition {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transition_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.style_symbol {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.animations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.transition {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.transition_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.style_symbol {
            os.write_uint32(4, v)?;
        }
        for v in &self.animations {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRotate2D {
        CMsgRotate2D::new()
    }

    fn clear(&mut self) {
        self.base = ::std::option::Option::None;
        self.transition = ::std::option::Option::None;
        self.transition_data.clear();
        self.style_symbol = ::std::option::Option::None;
        self.animations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRotate2D {
        static instance: CMsgRotate2D = CMsgRotate2D {
            base: ::std::option::Option::None,
            transition: ::std::option::Option::None,
            transition_data: ::protobuf::MessageField::none(),
            style_symbol: ::std::option::Option::None,
            animations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgRotate2D`
pub mod cmsg_rotate2d {
    // @@protoc_insertion_point(message:CMsgRotate2D.AnimationFrameData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AnimationFrameData {
        // message fields
        // @@protoc_insertion_point(field:CMsgRotate2D.AnimationFrameData.data)
        pub data: ::std::option::Option<f64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgRotate2D.AnimationFrameData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AnimationFrameData {
        fn default() -> &'a AnimationFrameData {
            <AnimationFrameData as ::protobuf::Message>::default_instance()
        }
    }

    impl AnimationFrameData {
        pub fn new() -> AnimationFrameData {
            ::std::default::Default::default()
        }

        // optional double data = 1;

        pub fn data(&self) -> f64 {
            self.data.unwrap_or(0.)
        }

        pub fn clear_data(&mut self) {
            self.data = ::std::option::Option::None;
        }

        pub fn has_data(&self) -> bool {
            self.data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data(&mut self, v: f64) {
            self.data = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for AnimationFrameData {
        const NAME: &'static str = "AnimationFrameData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.data = ::std::option::Option::Some(is.read_double()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data {
                os.write_double(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AnimationFrameData {
            AnimationFrameData::new()
        }

        fn clear(&mut self) {
            self.data = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AnimationFrameData {
            static instance: AnimationFrameData = AnimationFrameData {
                data: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgOpacityMaskData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgOpacityMaskData {
    // message fields
    // @@protoc_insertion_point(field:CMsgOpacityMaskData.opacity_mask_texture_id)
    pub opacity_mask_texture_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgOpacityMaskData.opacity_mask_opacity)
    pub opacity_mask_opacity: ::std::option::Option<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgOpacityMaskData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgOpacityMaskData {
    fn default() -> &'a CMsgOpacityMaskData {
        <CMsgOpacityMaskData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgOpacityMaskData {
    pub fn new() -> CMsgOpacityMaskData {
        ::std::default::Default::default()
    }

    // optional uint32 opacity_mask_texture_id = 1;

    pub fn opacity_mask_texture_id(&self) -> u32 {
        self.opacity_mask_texture_id.unwrap_or(0)
    }

    pub fn clear_opacity_mask_texture_id(&mut self) {
        self.opacity_mask_texture_id = ::std::option::Option::None;
    }

    pub fn has_opacity_mask_texture_id(&self) -> bool {
        self.opacity_mask_texture_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_opacity_mask_texture_id(&mut self, v: u32) {
        self.opacity_mask_texture_id = ::std::option::Option::Some(v);
    }

    // optional double opacity_mask_opacity = 2;

    pub fn opacity_mask_opacity(&self) -> f64 {
        self.opacity_mask_opacity.unwrap_or(0.)
    }

    pub fn clear_opacity_mask_opacity(&mut self) {
        self.opacity_mask_opacity = ::std::option::Option::None;
    }

    pub fn has_opacity_mask_opacity(&self) -> bool {
        self.opacity_mask_opacity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_opacity_mask_opacity(&mut self, v: f64) {
        self.opacity_mask_opacity = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgOpacityMaskData {
    const NAME: &'static str = "CMsgOpacityMaskData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.opacity_mask_texture_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.opacity_mask_opacity = ::std::option::Option::Some(is.read_double()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.opacity_mask_texture_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.opacity_mask_opacity {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.opacity_mask_texture_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.opacity_mask_opacity {
            os.write_double(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgOpacityMaskData {
        CMsgOpacityMaskData::new()
    }

    fn clear(&mut self) {
        self.opacity_mask_texture_id = ::std::option::Option::None;
        self.opacity_mask_opacity = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgOpacityMaskData {
        static instance: CMsgOpacityMaskData = CMsgOpacityMaskData {
            opacity_mask_texture_id: ::std::option::Option::None,
            opacity_mask_opacity: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgOpacityMask)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgOpacityMask {
    // message fields
    // @@protoc_insertion_point(field:CMsgOpacityMask.base)
    pub base: ::protobuf::MessageField<CMsgOpacityMaskData>,
    // @@protoc_insertion_point(field:CMsgOpacityMask.transition)
    pub transition: ::protobuf::MessageField<CMsgOpacityMaskData>,
    // @@protoc_insertion_point(field:CMsgOpacityMask.transition_data)
    pub transition_data: ::protobuf::MessageField<CMsgTransitionData>,
    // @@protoc_insertion_point(field:CMsgOpacityMask.style_symbol)
    pub style_symbol: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgOpacityMask.animations)
    pub animations: ::std::vec::Vec<CMsgAnimationData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgOpacityMask.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgOpacityMask {
    fn default() -> &'a CMsgOpacityMask {
        <CMsgOpacityMask as ::protobuf::Message>::default_instance()
    }
}

impl CMsgOpacityMask {
    pub fn new() -> CMsgOpacityMask {
        ::std::default::Default::default()
    }

    // optional uint32 style_symbol = 4;

    pub fn style_symbol(&self) -> u32 {
        self.style_symbol.unwrap_or(0)
    }

    pub fn clear_style_symbol(&mut self) {
        self.style_symbol = ::std::option::Option::None;
    }

    pub fn has_style_symbol(&self) -> bool {
        self.style_symbol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_symbol(&mut self, v: u32) {
        self.style_symbol = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgOpacityMask {
    const NAME: &'static str = "CMsgOpacityMask";

    fn is_initialized(&self) -> bool {
        for v in &self.base {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.animations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.base)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition_data)?;
                },
                32 => {
                    self.style_symbol = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.animations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.style_symbol {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.animations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.transition.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.transition_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.style_symbol {
            os.write_uint32(4, v)?;
        }
        for v in &self.animations {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgOpacityMask {
        CMsgOpacityMask::new()
    }

    fn clear(&mut self) {
        self.base.clear();
        self.transition.clear();
        self.transition_data.clear();
        self.style_symbol = ::std::option::Option::None;
        self.animations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgOpacityMask {
        static instance: CMsgOpacityMask = CMsgOpacityMask {
            base: ::protobuf::MessageField::none(),
            transition: ::protobuf::MessageField::none(),
            transition_data: ::protobuf::MessageField::none(),
            style_symbol: ::std::option::Option::None,
            animations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgOpacityMask`
pub mod cmsg_opacity_mask {
    // @@protoc_insertion_point(message:CMsgOpacityMask.AnimationFrameData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AnimationFrameData {
        // message fields
        // @@protoc_insertion_point(field:CMsgOpacityMask.AnimationFrameData.data)
        pub data: ::protobuf::MessageField<super::CMsgOpacityMaskData>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgOpacityMask.AnimationFrameData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AnimationFrameData {
        fn default() -> &'a AnimationFrameData {
            <AnimationFrameData as ::protobuf::Message>::default_instance()
        }
    }

    impl AnimationFrameData {
        pub fn new() -> AnimationFrameData {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for AnimationFrameData {
        const NAME: &'static str = "AnimationFrameData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AnimationFrameData {
            AnimationFrameData::new()
        }

        fn clear(&mut self) {
            self.data.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AnimationFrameData {
            static instance: AnimationFrameData = AnimationFrameData {
                data: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgHueShift)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgHueShift {
    // message fields
    // @@protoc_insertion_point(field:CMsgHueShift.base)
    pub base: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgHueShift.transition)
    pub transition: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgHueShift.transition_data)
    pub transition_data: ::protobuf::MessageField<CMsgTransitionData>,
    // @@protoc_insertion_point(field:CMsgHueShift.style_symbol)
    pub style_symbol: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHueShift.animations)
    pub animations: ::std::vec::Vec<CMsgAnimationData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgHueShift.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgHueShift {
    fn default() -> &'a CMsgHueShift {
        <CMsgHueShift as ::protobuf::Message>::default_instance()
    }
}

impl CMsgHueShift {
    pub fn new() -> CMsgHueShift {
        ::std::default::Default::default()
    }

    // optional double base = 1;

    pub fn base(&self) -> f64 {
        self.base.unwrap_or(0.)
    }

    pub fn clear_base(&mut self) {
        self.base = ::std::option::Option::None;
    }

    pub fn has_base(&self) -> bool {
        self.base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base(&mut self, v: f64) {
        self.base = ::std::option::Option::Some(v);
    }

    // optional double transition = 2;

    pub fn transition(&self) -> f64 {
        self.transition.unwrap_or(0.)
    }

    pub fn clear_transition(&mut self) {
        self.transition = ::std::option::Option::None;
    }

    pub fn has_transition(&self) -> bool {
        self.transition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transition(&mut self, v: f64) {
        self.transition = ::std::option::Option::Some(v);
    }

    // optional uint32 style_symbol = 4;

    pub fn style_symbol(&self) -> u32 {
        self.style_symbol.unwrap_or(0)
    }

    pub fn clear_style_symbol(&mut self) {
        self.style_symbol = ::std::option::Option::None;
    }

    pub fn has_style_symbol(&self) -> bool {
        self.style_symbol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_symbol(&mut self, v: u32) {
        self.style_symbol = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgHueShift {
    const NAME: &'static str = "CMsgHueShift";

    fn is_initialized(&self) -> bool {
        for v in &self.transition_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.animations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.base = ::std::option::Option::Some(is.read_double()?);
                },
                17 => {
                    self.transition = ::std::option::Option::Some(is.read_double()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition_data)?;
                },
                32 => {
                    self.style_symbol = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.animations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transition {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transition_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.style_symbol {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.animations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.transition {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.transition_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.style_symbol {
            os.write_uint32(4, v)?;
        }
        for v in &self.animations {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgHueShift {
        CMsgHueShift::new()
    }

    fn clear(&mut self) {
        self.base = ::std::option::Option::None;
        self.transition = ::std::option::Option::None;
        self.transition_data.clear();
        self.style_symbol = ::std::option::Option::None;
        self.animations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgHueShift {
        static instance: CMsgHueShift = CMsgHueShift {
            base: ::std::option::Option::None,
            transition: ::std::option::Option::None,
            transition_data: ::protobuf::MessageField::none(),
            style_symbol: ::std::option::Option::None,
            animations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgHueShift`
pub mod cmsg_hue_shift {
    // @@protoc_insertion_point(message:CMsgHueShift.AnimationFrameData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AnimationFrameData {
        // message fields
        // @@protoc_insertion_point(field:CMsgHueShift.AnimationFrameData.data)
        pub data: ::std::option::Option<f64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgHueShift.AnimationFrameData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AnimationFrameData {
        fn default() -> &'a AnimationFrameData {
            <AnimationFrameData as ::protobuf::Message>::default_instance()
        }
    }

    impl AnimationFrameData {
        pub fn new() -> AnimationFrameData {
            ::std::default::Default::default()
        }

        // optional double data = 1;

        pub fn data(&self) -> f64 {
            self.data.unwrap_or(0.)
        }

        pub fn clear_data(&mut self) {
            self.data = ::std::option::Option::None;
        }

        pub fn has_data(&self) -> bool {
            self.data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data(&mut self, v: f64) {
            self.data = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for AnimationFrameData {
        const NAME: &'static str = "AnimationFrameData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.data = ::std::option::Option::Some(is.read_double()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data {
                os.write_double(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AnimationFrameData {
            AnimationFrameData::new()
        }

        fn clear(&mut self) {
            self.data = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AnimationFrameData {
            static instance: AnimationFrameData = AnimationFrameData {
                data: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgSaturation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSaturation {
    // message fields
    // @@protoc_insertion_point(field:CMsgSaturation.base)
    pub base: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgSaturation.transition)
    pub transition: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgSaturation.transition_data)
    pub transition_data: ::protobuf::MessageField<CMsgTransitionData>,
    // @@protoc_insertion_point(field:CMsgSaturation.style_symbol)
    pub style_symbol: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSaturation.animations)
    pub animations: ::std::vec::Vec<CMsgAnimationData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSaturation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSaturation {
    fn default() -> &'a CMsgSaturation {
        <CMsgSaturation as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSaturation {
    pub fn new() -> CMsgSaturation {
        ::std::default::Default::default()
    }

    // optional double base = 1;

    pub fn base(&self) -> f64 {
        self.base.unwrap_or(0.)
    }

    pub fn clear_base(&mut self) {
        self.base = ::std::option::Option::None;
    }

    pub fn has_base(&self) -> bool {
        self.base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base(&mut self, v: f64) {
        self.base = ::std::option::Option::Some(v);
    }

    // optional double transition = 2;

    pub fn transition(&self) -> f64 {
        self.transition.unwrap_or(0.)
    }

    pub fn clear_transition(&mut self) {
        self.transition = ::std::option::Option::None;
    }

    pub fn has_transition(&self) -> bool {
        self.transition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transition(&mut self, v: f64) {
        self.transition = ::std::option::Option::Some(v);
    }

    // optional uint32 style_symbol = 4;

    pub fn style_symbol(&self) -> u32 {
        self.style_symbol.unwrap_or(0)
    }

    pub fn clear_style_symbol(&mut self) {
        self.style_symbol = ::std::option::Option::None;
    }

    pub fn has_style_symbol(&self) -> bool {
        self.style_symbol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_symbol(&mut self, v: u32) {
        self.style_symbol = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSaturation {
    const NAME: &'static str = "CMsgSaturation";

    fn is_initialized(&self) -> bool {
        for v in &self.transition_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.animations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.base = ::std::option::Option::Some(is.read_double()?);
                },
                17 => {
                    self.transition = ::std::option::Option::Some(is.read_double()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition_data)?;
                },
                32 => {
                    self.style_symbol = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.animations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transition {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transition_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.style_symbol {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.animations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.transition {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.transition_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.style_symbol {
            os.write_uint32(4, v)?;
        }
        for v in &self.animations {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSaturation {
        CMsgSaturation::new()
    }

    fn clear(&mut self) {
        self.base = ::std::option::Option::None;
        self.transition = ::std::option::Option::None;
        self.transition_data.clear();
        self.style_symbol = ::std::option::Option::None;
        self.animations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSaturation {
        static instance: CMsgSaturation = CMsgSaturation {
            base: ::std::option::Option::None,
            transition: ::std::option::Option::None,
            transition_data: ::protobuf::MessageField::none(),
            style_symbol: ::std::option::Option::None,
            animations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSaturation`
pub mod cmsg_saturation {
    // @@protoc_insertion_point(message:CMsgSaturation.AnimationFrameData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AnimationFrameData {
        // message fields
        // @@protoc_insertion_point(field:CMsgSaturation.AnimationFrameData.data)
        pub data: ::std::option::Option<f64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSaturation.AnimationFrameData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AnimationFrameData {
        fn default() -> &'a AnimationFrameData {
            <AnimationFrameData as ::protobuf::Message>::default_instance()
        }
    }

    impl AnimationFrameData {
        pub fn new() -> AnimationFrameData {
            ::std::default::Default::default()
        }

        // optional double data = 1;

        pub fn data(&self) -> f64 {
            self.data.unwrap_or(0.)
        }

        pub fn clear_data(&mut self) {
            self.data = ::std::option::Option::None;
        }

        pub fn has_data(&self) -> bool {
            self.data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data(&mut self, v: f64) {
            self.data = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for AnimationFrameData {
        const NAME: &'static str = "AnimationFrameData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.data = ::std::option::Option::Some(is.read_double()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data {
                os.write_double(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AnimationFrameData {
            AnimationFrameData::new()
        }

        fn clear(&mut self) {
            self.data = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AnimationFrameData {
            static instance: AnimationFrameData = AnimationFrameData {
                data: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgBrightness)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBrightness {
    // message fields
    // @@protoc_insertion_point(field:CMsgBrightness.base)
    pub base: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgBrightness.transition)
    pub transition: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgBrightness.transition_data)
    pub transition_data: ::protobuf::MessageField<CMsgTransitionData>,
    // @@protoc_insertion_point(field:CMsgBrightness.style_symbol)
    pub style_symbol: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBrightness.animations)
    pub animations: ::std::vec::Vec<CMsgAnimationData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBrightness.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBrightness {
    fn default() -> &'a CMsgBrightness {
        <CMsgBrightness as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBrightness {
    pub fn new() -> CMsgBrightness {
        ::std::default::Default::default()
    }

    // optional double base = 1;

    pub fn base(&self) -> f64 {
        self.base.unwrap_or(0.)
    }

    pub fn clear_base(&mut self) {
        self.base = ::std::option::Option::None;
    }

    pub fn has_base(&self) -> bool {
        self.base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base(&mut self, v: f64) {
        self.base = ::std::option::Option::Some(v);
    }

    // optional double transition = 2;

    pub fn transition(&self) -> f64 {
        self.transition.unwrap_or(0.)
    }

    pub fn clear_transition(&mut self) {
        self.transition = ::std::option::Option::None;
    }

    pub fn has_transition(&self) -> bool {
        self.transition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transition(&mut self, v: f64) {
        self.transition = ::std::option::Option::Some(v);
    }

    // optional uint32 style_symbol = 4;

    pub fn style_symbol(&self) -> u32 {
        self.style_symbol.unwrap_or(0)
    }

    pub fn clear_style_symbol(&mut self) {
        self.style_symbol = ::std::option::Option::None;
    }

    pub fn has_style_symbol(&self) -> bool {
        self.style_symbol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_symbol(&mut self, v: u32) {
        self.style_symbol = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgBrightness {
    const NAME: &'static str = "CMsgBrightness";

    fn is_initialized(&self) -> bool {
        for v in &self.transition_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.animations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.base = ::std::option::Option::Some(is.read_double()?);
                },
                17 => {
                    self.transition = ::std::option::Option::Some(is.read_double()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition_data)?;
                },
                32 => {
                    self.style_symbol = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.animations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transition {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transition_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.style_symbol {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.animations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.transition {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.transition_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.style_symbol {
            os.write_uint32(4, v)?;
        }
        for v in &self.animations {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBrightness {
        CMsgBrightness::new()
    }

    fn clear(&mut self) {
        self.base = ::std::option::Option::None;
        self.transition = ::std::option::Option::None;
        self.transition_data.clear();
        self.style_symbol = ::std::option::Option::None;
        self.animations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBrightness {
        static instance: CMsgBrightness = CMsgBrightness {
            base: ::std::option::Option::None,
            transition: ::std::option::Option::None,
            transition_data: ::protobuf::MessageField::none(),
            style_symbol: ::std::option::Option::None,
            animations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgBrightness`
pub mod cmsg_brightness {
    // @@protoc_insertion_point(message:CMsgBrightness.AnimationFrameData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AnimationFrameData {
        // message fields
        // @@protoc_insertion_point(field:CMsgBrightness.AnimationFrameData.data)
        pub data: ::std::option::Option<f64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgBrightness.AnimationFrameData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AnimationFrameData {
        fn default() -> &'a AnimationFrameData {
            <AnimationFrameData as ::protobuf::Message>::default_instance()
        }
    }

    impl AnimationFrameData {
        pub fn new() -> AnimationFrameData {
            ::std::default::Default::default()
        }

        // optional double data = 1;

        pub fn data(&self) -> f64 {
            self.data.unwrap_or(0.)
        }

        pub fn clear_data(&mut self) {
            self.data = ::std::option::Option::None;
        }

        pub fn has_data(&self) -> bool {
            self.data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data(&mut self, v: f64) {
            self.data = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for AnimationFrameData {
        const NAME: &'static str = "AnimationFrameData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.data = ::std::option::Option::Some(is.read_double()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data {
                os.write_double(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AnimationFrameData {
            AnimationFrameData::new()
        }

        fn clear(&mut self) {
            self.data = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AnimationFrameData {
            static instance: AnimationFrameData = AnimationFrameData {
                data: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgContrast)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgContrast {
    // message fields
    // @@protoc_insertion_point(field:CMsgContrast.base)
    pub base: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgContrast.transition)
    pub transition: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgContrast.transition_data)
    pub transition_data: ::protobuf::MessageField<CMsgTransitionData>,
    // @@protoc_insertion_point(field:CMsgContrast.style_symbol)
    pub style_symbol: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgContrast.animations)
    pub animations: ::std::vec::Vec<CMsgAnimationData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgContrast.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgContrast {
    fn default() -> &'a CMsgContrast {
        <CMsgContrast as ::protobuf::Message>::default_instance()
    }
}

impl CMsgContrast {
    pub fn new() -> CMsgContrast {
        ::std::default::Default::default()
    }

    // optional double base = 1;

    pub fn base(&self) -> f64 {
        self.base.unwrap_or(0.)
    }

    pub fn clear_base(&mut self) {
        self.base = ::std::option::Option::None;
    }

    pub fn has_base(&self) -> bool {
        self.base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base(&mut self, v: f64) {
        self.base = ::std::option::Option::Some(v);
    }

    // optional double transition = 2;

    pub fn transition(&self) -> f64 {
        self.transition.unwrap_or(0.)
    }

    pub fn clear_transition(&mut self) {
        self.transition = ::std::option::Option::None;
    }

    pub fn has_transition(&self) -> bool {
        self.transition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transition(&mut self, v: f64) {
        self.transition = ::std::option::Option::Some(v);
    }

    // optional uint32 style_symbol = 4;

    pub fn style_symbol(&self) -> u32 {
        self.style_symbol.unwrap_or(0)
    }

    pub fn clear_style_symbol(&mut self) {
        self.style_symbol = ::std::option::Option::None;
    }

    pub fn has_style_symbol(&self) -> bool {
        self.style_symbol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_symbol(&mut self, v: u32) {
        self.style_symbol = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgContrast {
    const NAME: &'static str = "CMsgContrast";

    fn is_initialized(&self) -> bool {
        for v in &self.transition_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.animations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.base = ::std::option::Option::Some(is.read_double()?);
                },
                17 => {
                    self.transition = ::std::option::Option::Some(is.read_double()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition_data)?;
                },
                32 => {
                    self.style_symbol = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.animations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transition {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transition_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.style_symbol {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.animations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.transition {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.transition_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.style_symbol {
            os.write_uint32(4, v)?;
        }
        for v in &self.animations {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgContrast {
        CMsgContrast::new()
    }

    fn clear(&mut self) {
        self.base = ::std::option::Option::None;
        self.transition = ::std::option::Option::None;
        self.transition_data.clear();
        self.style_symbol = ::std::option::Option::None;
        self.animations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgContrast {
        static instance: CMsgContrast = CMsgContrast {
            base: ::std::option::Option::None,
            transition: ::std::option::Option::None,
            transition_data: ::protobuf::MessageField::none(),
            style_symbol: ::std::option::Option::None,
            animations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgContrast`
pub mod cmsg_contrast {
    // @@protoc_insertion_point(message:CMsgContrast.AnimationFrameData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AnimationFrameData {
        // message fields
        // @@protoc_insertion_point(field:CMsgContrast.AnimationFrameData.data)
        pub data: ::std::option::Option<f64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgContrast.AnimationFrameData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AnimationFrameData {
        fn default() -> &'a AnimationFrameData {
            <AnimationFrameData as ::protobuf::Message>::default_instance()
        }
    }

    impl AnimationFrameData {
        pub fn new() -> AnimationFrameData {
            ::std::default::Default::default()
        }

        // optional double data = 1;

        pub fn data(&self) -> f64 {
            self.data.unwrap_or(0.)
        }

        pub fn clear_data(&mut self) {
            self.data = ::std::option::Option::None;
        }

        pub fn has_data(&self) -> bool {
            self.data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data(&mut self, v: f64) {
            self.data = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for AnimationFrameData {
        const NAME: &'static str = "AnimationFrameData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.data = ::std::option::Option::Some(is.read_double()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data {
                os.write_double(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AnimationFrameData {
            AnimationFrameData::new()
        }

        fn clear(&mut self) {
            self.data = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AnimationFrameData {
            static instance: AnimationFrameData = AnimationFrameData {
                data: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgGaussianValues)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGaussianValues {
    // message fields
    // @@protoc_insertion_point(field:CMsgGaussianValues.passes)
    pub passes: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgGaussianValues.stddev_hor)
    pub stddev_hor: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgGaussianValues.stddev_ver)
    pub stddev_ver: ::std::option::Option<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGaussianValues.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGaussianValues {
    fn default() -> &'a CMsgGaussianValues {
        <CMsgGaussianValues as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGaussianValues {
    pub fn new() -> CMsgGaussianValues {
        ::std::default::Default::default()
    }

    // optional double passes = 1;

    pub fn passes(&self) -> f64 {
        self.passes.unwrap_or(0.)
    }

    pub fn clear_passes(&mut self) {
        self.passes = ::std::option::Option::None;
    }

    pub fn has_passes(&self) -> bool {
        self.passes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_passes(&mut self, v: f64) {
        self.passes = ::std::option::Option::Some(v);
    }

    // optional double stddev_hor = 2;

    pub fn stddev_hor(&self) -> f64 {
        self.stddev_hor.unwrap_or(0.)
    }

    pub fn clear_stddev_hor(&mut self) {
        self.stddev_hor = ::std::option::Option::None;
    }

    pub fn has_stddev_hor(&self) -> bool {
        self.stddev_hor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stddev_hor(&mut self, v: f64) {
        self.stddev_hor = ::std::option::Option::Some(v);
    }

    // optional double stddev_ver = 3;

    pub fn stddev_ver(&self) -> f64 {
        self.stddev_ver.unwrap_or(0.)
    }

    pub fn clear_stddev_ver(&mut self) {
        self.stddev_ver = ::std::option::Option::None;
    }

    pub fn has_stddev_ver(&self) -> bool {
        self.stddev_ver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stddev_ver(&mut self, v: f64) {
        self.stddev_ver = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGaussianValues {
    const NAME: &'static str = "CMsgGaussianValues";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.passes = ::std::option::Option::Some(is.read_double()?);
                },
                17 => {
                    self.stddev_hor = ::std::option::Option::Some(is.read_double()?);
                },
                25 => {
                    self.stddev_ver = ::std::option::Option::Some(is.read_double()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.passes {
            my_size += 1 + 8;
        }
        if let Some(v) = self.stddev_hor {
            my_size += 1 + 8;
        }
        if let Some(v) = self.stddev_ver {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.passes {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.stddev_hor {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.stddev_ver {
            os.write_double(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGaussianValues {
        CMsgGaussianValues::new()
    }

    fn clear(&mut self) {
        self.passes = ::std::option::Option::None;
        self.stddev_hor = ::std::option::Option::None;
        self.stddev_ver = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGaussianValues {
        static instance: CMsgGaussianValues = CMsgGaussianValues {
            passes: ::std::option::Option::None,
            stddev_hor: ::std::option::Option::None,
            stddev_ver: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGaussianBlur)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGaussianBlur {
    // message fields
    // @@protoc_insertion_point(field:CMsgGaussianBlur.base)
    pub base: ::protobuf::MessageField<CMsgGaussianValues>,
    // @@protoc_insertion_point(field:CMsgGaussianBlur.transition)
    pub transition: ::protobuf::MessageField<CMsgGaussianValues>,
    // @@protoc_insertion_point(field:CMsgGaussianBlur.transition_data)
    pub transition_data: ::protobuf::MessageField<CMsgTransitionData>,
    // @@protoc_insertion_point(field:CMsgGaussianBlur.style_symbol)
    pub style_symbol: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGaussianBlur.animations)
    pub animations: ::std::vec::Vec<CMsgAnimationData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGaussianBlur.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGaussianBlur {
    fn default() -> &'a CMsgGaussianBlur {
        <CMsgGaussianBlur as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGaussianBlur {
    pub fn new() -> CMsgGaussianBlur {
        ::std::default::Default::default()
    }

    // optional uint32 style_symbol = 4;

    pub fn style_symbol(&self) -> u32 {
        self.style_symbol.unwrap_or(0)
    }

    pub fn clear_style_symbol(&mut self) {
        self.style_symbol = ::std::option::Option::None;
    }

    pub fn has_style_symbol(&self) -> bool {
        self.style_symbol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_symbol(&mut self, v: u32) {
        self.style_symbol = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGaussianBlur {
    const NAME: &'static str = "CMsgGaussianBlur";

    fn is_initialized(&self) -> bool {
        for v in &self.base {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.animations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.base)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition_data)?;
                },
                32 => {
                    self.style_symbol = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.animations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.style_symbol {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.animations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.transition.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.transition_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.style_symbol {
            os.write_uint32(4, v)?;
        }
        for v in &self.animations {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGaussianBlur {
        CMsgGaussianBlur::new()
    }

    fn clear(&mut self) {
        self.base.clear();
        self.transition.clear();
        self.transition_data.clear();
        self.style_symbol = ::std::option::Option::None;
        self.animations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGaussianBlur {
        static instance: CMsgGaussianBlur = CMsgGaussianBlur {
            base: ::protobuf::MessageField::none(),
            transition: ::protobuf::MessageField::none(),
            transition_data: ::protobuf::MessageField::none(),
            style_symbol: ::std::option::Option::None,
            animations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGaussianBlur`
pub mod cmsg_gaussian_blur {
    // @@protoc_insertion_point(message:CMsgGaussianBlur.AnimationFrameData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AnimationFrameData {
        // message fields
        // @@protoc_insertion_point(field:CMsgGaussianBlur.AnimationFrameData.data)
        pub data: ::protobuf::MessageField<super::CMsgGaussianValues>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGaussianBlur.AnimationFrameData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AnimationFrameData {
        fn default() -> &'a AnimationFrameData {
            <AnimationFrameData as ::protobuf::Message>::default_instance()
        }
    }

    impl AnimationFrameData {
        pub fn new() -> AnimationFrameData {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for AnimationFrameData {
        const NAME: &'static str = "AnimationFrameData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AnimationFrameData {
            AnimationFrameData::new()
        }

        fn clear(&mut self) {
            self.data.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AnimationFrameData {
            static instance: AnimationFrameData = AnimationFrameData {
                data: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgMotionBlurValues)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMotionBlurValues {
    // message fields
    // @@protoc_insertion_point(field:CMsgMotionBlurValues.velocity)
    pub velocity: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgMotionBlurValues.dirx)
    pub dirx: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgMotionBlurValues.diry)
    pub diry: ::std::option::Option<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMotionBlurValues.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMotionBlurValues {
    fn default() -> &'a CMsgMotionBlurValues {
        <CMsgMotionBlurValues as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMotionBlurValues {
    pub fn new() -> CMsgMotionBlurValues {
        ::std::default::Default::default()
    }

    // optional double velocity = 1;

    pub fn velocity(&self) -> f64 {
        self.velocity.unwrap_or(0.)
    }

    pub fn clear_velocity(&mut self) {
        self.velocity = ::std::option::Option::None;
    }

    pub fn has_velocity(&self) -> bool {
        self.velocity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_velocity(&mut self, v: f64) {
        self.velocity = ::std::option::Option::Some(v);
    }

    // optional double dirx = 2;

    pub fn dirx(&self) -> f64 {
        self.dirx.unwrap_or(0.)
    }

    pub fn clear_dirx(&mut self) {
        self.dirx = ::std::option::Option::None;
    }

    pub fn has_dirx(&self) -> bool {
        self.dirx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dirx(&mut self, v: f64) {
        self.dirx = ::std::option::Option::Some(v);
    }

    // optional double diry = 3;

    pub fn diry(&self) -> f64 {
        self.diry.unwrap_or(0.)
    }

    pub fn clear_diry(&mut self) {
        self.diry = ::std::option::Option::None;
    }

    pub fn has_diry(&self) -> bool {
        self.diry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_diry(&mut self, v: f64) {
        self.diry = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgMotionBlurValues {
    const NAME: &'static str = "CMsgMotionBlurValues";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.velocity = ::std::option::Option::Some(is.read_double()?);
                },
                17 => {
                    self.dirx = ::std::option::Option::Some(is.read_double()?);
                },
                25 => {
                    self.diry = ::std::option::Option::Some(is.read_double()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.velocity {
            my_size += 1 + 8;
        }
        if let Some(v) = self.dirx {
            my_size += 1 + 8;
        }
        if let Some(v) = self.diry {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.velocity {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.dirx {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.diry {
            os.write_double(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMotionBlurValues {
        CMsgMotionBlurValues::new()
    }

    fn clear(&mut self) {
        self.velocity = ::std::option::Option::None;
        self.dirx = ::std::option::Option::None;
        self.diry = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMotionBlurValues {
        static instance: CMsgMotionBlurValues = CMsgMotionBlurValues {
            velocity: ::std::option::Option::None,
            dirx: ::std::option::Option::None,
            diry: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgMotionBlur)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMotionBlur {
    // message fields
    // @@protoc_insertion_point(field:CMsgMotionBlur.base)
    pub base: ::protobuf::MessageField<CMsgMotionBlurValues>,
    // @@protoc_insertion_point(field:CMsgMotionBlur.transition)
    pub transition: ::protobuf::MessageField<CMsgMotionBlurValues>,
    // @@protoc_insertion_point(field:CMsgMotionBlur.transition_data)
    pub transition_data: ::protobuf::MessageField<CMsgTransitionData>,
    // @@protoc_insertion_point(field:CMsgMotionBlur.animations)
    pub animations: ::std::vec::Vec<CMsgAnimationData>,
    // @@protoc_insertion_point(field:CMsgMotionBlur.style_symbol)
    pub style_symbol: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMotionBlur.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMotionBlur {
    fn default() -> &'a CMsgMotionBlur {
        <CMsgMotionBlur as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMotionBlur {
    pub fn new() -> CMsgMotionBlur {
        ::std::default::Default::default()
    }

    // optional uint32 style_symbol = 5;

    pub fn style_symbol(&self) -> u32 {
        self.style_symbol.unwrap_or(0)
    }

    pub fn clear_style_symbol(&mut self) {
        self.style_symbol = ::std::option::Option::None;
    }

    pub fn has_style_symbol(&self) -> bool {
        self.style_symbol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_symbol(&mut self, v: u32) {
        self.style_symbol = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgMotionBlur {
    const NAME: &'static str = "CMsgMotionBlur";

    fn is_initialized(&self) -> bool {
        for v in &self.base {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.animations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.base)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition_data)?;
                },
                34 => {
                    self.animations.push(is.read_message()?);
                },
                40 => {
                    self.style_symbol = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.animations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.style_symbol {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.transition.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.transition_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.animations {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.style_symbol {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMotionBlur {
        CMsgMotionBlur::new()
    }

    fn clear(&mut self) {
        self.base.clear();
        self.transition.clear();
        self.transition_data.clear();
        self.animations.clear();
        self.style_symbol = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMotionBlur {
        static instance: CMsgMotionBlur = CMsgMotionBlur {
            base: ::protobuf::MessageField::none(),
            transition: ::protobuf::MessageField::none(),
            transition_data: ::protobuf::MessageField::none(),
            animations: ::std::vec::Vec::new(),
            style_symbol: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgMotionBlur`
pub mod cmsg_motion_blur {
    // @@protoc_insertion_point(message:CMsgMotionBlur.AnimationFrameData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AnimationFrameData {
        // message fields
        // @@protoc_insertion_point(field:CMsgMotionBlur.AnimationFrameData.data)
        pub data: ::protobuf::MessageField<super::CMsgMotionBlurValues>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgMotionBlur.AnimationFrameData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AnimationFrameData {
        fn default() -> &'a AnimationFrameData {
            <AnimationFrameData as ::protobuf::Message>::default_instance()
        }
    }

    impl AnimationFrameData {
        pub fn new() -> AnimationFrameData {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for AnimationFrameData {
        const NAME: &'static str = "AnimationFrameData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AnimationFrameData {
            AnimationFrameData::new()
        }

        fn clear(&mut self) {
            self.data.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AnimationFrameData {
            static instance: AnimationFrameData = AnimationFrameData {
                data: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsg3DTransformPerspective)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsg3DTransformPerspective {
    // message fields
    // @@protoc_insertion_point(field:CMsg3DTransformPerspective.base)
    pub base: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsg3DTransformPerspective.transition)
    pub transition: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsg3DTransformPerspective.transition_data)
    pub transition_data: ::protobuf::MessageField<CMsgTransitionData>,
    // @@protoc_insertion_point(field:CMsg3DTransformPerspective.style_symbol)
    pub style_symbol: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsg3DTransformPerspective.animations)
    pub animations: ::std::vec::Vec<CMsgAnimationData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsg3DTransformPerspective.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsg3DTransformPerspective {
    fn default() -> &'a CMsg3DTransformPerspective {
        <CMsg3DTransformPerspective as ::protobuf::Message>::default_instance()
    }
}

impl CMsg3DTransformPerspective {
    pub fn new() -> CMsg3DTransformPerspective {
        ::std::default::Default::default()
    }

    // optional double base = 1;

    pub fn base(&self) -> f64 {
        self.base.unwrap_or(0.)
    }

    pub fn clear_base(&mut self) {
        self.base = ::std::option::Option::None;
    }

    pub fn has_base(&self) -> bool {
        self.base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base(&mut self, v: f64) {
        self.base = ::std::option::Option::Some(v);
    }

    // optional double transition = 2;

    pub fn transition(&self) -> f64 {
        self.transition.unwrap_or(0.)
    }

    pub fn clear_transition(&mut self) {
        self.transition = ::std::option::Option::None;
    }

    pub fn has_transition(&self) -> bool {
        self.transition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transition(&mut self, v: f64) {
        self.transition = ::std::option::Option::Some(v);
    }

    // optional uint32 style_symbol = 4;

    pub fn style_symbol(&self) -> u32 {
        self.style_symbol.unwrap_or(0)
    }

    pub fn clear_style_symbol(&mut self) {
        self.style_symbol = ::std::option::Option::None;
    }

    pub fn has_style_symbol(&self) -> bool {
        self.style_symbol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_symbol(&mut self, v: u32) {
        self.style_symbol = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsg3DTransformPerspective {
    const NAME: &'static str = "CMsg3DTransformPerspective";

    fn is_initialized(&self) -> bool {
        for v in &self.transition_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.animations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.base = ::std::option::Option::Some(is.read_double()?);
                },
                17 => {
                    self.transition = ::std::option::Option::Some(is.read_double()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition_data)?;
                },
                32 => {
                    self.style_symbol = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.animations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transition {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transition_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.style_symbol {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.animations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.transition {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.transition_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.style_symbol {
            os.write_uint32(4, v)?;
        }
        for v in &self.animations {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsg3DTransformPerspective {
        CMsg3DTransformPerspective::new()
    }

    fn clear(&mut self) {
        self.base = ::std::option::Option::None;
        self.transition = ::std::option::Option::None;
        self.transition_data.clear();
        self.style_symbol = ::std::option::Option::None;
        self.animations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsg3DTransformPerspective {
        static instance: CMsg3DTransformPerspective = CMsg3DTransformPerspective {
            base: ::std::option::Option::None,
            transition: ::std::option::Option::None,
            transition_data: ::protobuf::MessageField::none(),
            style_symbol: ::std::option::Option::None,
            animations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsg3DTransformPerspective`
pub mod cmsg3dtransform_perspective {
    // @@protoc_insertion_point(message:CMsg3DTransformPerspective.AnimationFrameData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AnimationFrameData {
        // message fields
        // @@protoc_insertion_point(field:CMsg3DTransformPerspective.AnimationFrameData.data)
        pub data: ::std::option::Option<f64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsg3DTransformPerspective.AnimationFrameData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AnimationFrameData {
        fn default() -> &'a AnimationFrameData {
            <AnimationFrameData as ::protobuf::Message>::default_instance()
        }
    }

    impl AnimationFrameData {
        pub fn new() -> AnimationFrameData {
            ::std::default::Default::default()
        }

        // optional double data = 1;

        pub fn data(&self) -> f64 {
            self.data.unwrap_or(0.)
        }

        pub fn clear_data(&mut self) {
            self.data = ::std::option::Option::None;
        }

        pub fn has_data(&self) -> bool {
            self.data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data(&mut self, v: f64) {
            self.data = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for AnimationFrameData {
        const NAME: &'static str = "AnimationFrameData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.data = ::std::option::Option::Some(is.read_double()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data {
                os.write_double(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AnimationFrameData {
            AnimationFrameData::new()
        }

        fn clear(&mut self) {
            self.data = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AnimationFrameData {
            static instance: AnimationFrameData = AnimationFrameData {
                data: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsg3DTransformPerspectiveOrigin)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsg3DTransformPerspectiveOrigin {
    // message fields
    // @@protoc_insertion_point(field:CMsg3DTransformPerspectiveOrigin.base)
    pub base: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsg3DTransformPerspectiveOrigin.transition)
    pub transition: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsg3DTransformPerspectiveOrigin.transition_data)
    pub transition_data: ::protobuf::MessageField<CMsgTransitionData>,
    // @@protoc_insertion_point(field:CMsg3DTransformPerspectiveOrigin.style_symbol)
    pub style_symbol: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsg3DTransformPerspectiveOrigin.animations)
    pub animations: ::std::vec::Vec<CMsgAnimationData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsg3DTransformPerspectiveOrigin.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsg3DTransformPerspectiveOrigin {
    fn default() -> &'a CMsg3DTransformPerspectiveOrigin {
        <CMsg3DTransformPerspectiveOrigin as ::protobuf::Message>::default_instance()
    }
}

impl CMsg3DTransformPerspectiveOrigin {
    pub fn new() -> CMsg3DTransformPerspectiveOrigin {
        ::std::default::Default::default()
    }

    // optional uint32 style_symbol = 4;

    pub fn style_symbol(&self) -> u32 {
        self.style_symbol.unwrap_or(0)
    }

    pub fn clear_style_symbol(&mut self) {
        self.style_symbol = ::std::option::Option::None;
    }

    pub fn has_style_symbol(&self) -> bool {
        self.style_symbol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_symbol(&mut self, v: u32) {
        self.style_symbol = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsg3DTransformPerspectiveOrigin {
    const NAME: &'static str = "CMsg3DTransformPerspectiveOrigin";

    fn is_initialized(&self) -> bool {
        for v in &self.base {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.animations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.base)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition_data)?;
                },
                32 => {
                    self.style_symbol = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.animations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.style_symbol {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.animations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.transition.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.transition_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.style_symbol {
            os.write_uint32(4, v)?;
        }
        for v in &self.animations {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsg3DTransformPerspectiveOrigin {
        CMsg3DTransformPerspectiveOrigin::new()
    }

    fn clear(&mut self) {
        self.base.clear();
        self.transition.clear();
        self.transition_data.clear();
        self.style_symbol = ::std::option::Option::None;
        self.animations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsg3DTransformPerspectiveOrigin {
        static instance: CMsg3DTransformPerspectiveOrigin = CMsg3DTransformPerspectiveOrigin {
            base: ::protobuf::MessageField::none(),
            transition: ::protobuf::MessageField::none(),
            transition_data: ::protobuf::MessageField::none(),
            style_symbol: ::std::option::Option::None,
            animations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsg3DTransformPerspectiveOrigin`
pub mod cmsg3dtransform_perspective_origin {
    // @@protoc_insertion_point(message:CMsg3DTransformPerspectiveOrigin.AnimationFrameData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AnimationFrameData {
        // message fields
        // @@protoc_insertion_point(field:CMsg3DTransformPerspectiveOrigin.AnimationFrameData.data)
        pub data: ::protobuf::MessageField<super::CMsgPoint>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsg3DTransformPerspectiveOrigin.AnimationFrameData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AnimationFrameData {
        fn default() -> &'a AnimationFrameData {
            <AnimationFrameData as ::protobuf::Message>::default_instance()
        }
    }

    impl AnimationFrameData {
        pub fn new() -> AnimationFrameData {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for AnimationFrameData {
        const NAME: &'static str = "AnimationFrameData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AnimationFrameData {
            AnimationFrameData::new()
        }

        fn clear(&mut self) {
            self.data.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AnimationFrameData {
            static instance: AnimationFrameData = AnimationFrameData {
                data: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgTransformOriginData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTransformOriginData {
    // message fields
    // @@protoc_insertion_point(field:CMsgTransformOriginData.x)
    pub x: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgTransformOriginData.y)
    pub y: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgTransformOriginData.x_is_percent)
    pub x_is_percent: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgTransformOriginData.y_is_percent)
    pub y_is_percent: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgTransformOriginData.is_parent_relative)
    pub is_parent_relative: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTransformOriginData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTransformOriginData {
    fn default() -> &'a CMsgTransformOriginData {
        <CMsgTransformOriginData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTransformOriginData {
    pub fn new() -> CMsgTransformOriginData {
        ::std::default::Default::default()
    }

    // optional double x = 1;

    pub fn x(&self) -> f64 {
        self.x.unwrap_or(0.)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f64) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional double y = 2;

    pub fn y(&self) -> f64 {
        self.y.unwrap_or(0.)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f64) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional bool x_is_percent = 3;

    pub fn x_is_percent(&self) -> bool {
        self.x_is_percent.unwrap_or(false)
    }

    pub fn clear_x_is_percent(&mut self) {
        self.x_is_percent = ::std::option::Option::None;
    }

    pub fn has_x_is_percent(&self) -> bool {
        self.x_is_percent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x_is_percent(&mut self, v: bool) {
        self.x_is_percent = ::std::option::Option::Some(v);
    }

    // optional bool y_is_percent = 4;

    pub fn y_is_percent(&self) -> bool {
        self.y_is_percent.unwrap_or(false)
    }

    pub fn clear_y_is_percent(&mut self) {
        self.y_is_percent = ::std::option::Option::None;
    }

    pub fn has_y_is_percent(&self) -> bool {
        self.y_is_percent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y_is_percent(&mut self, v: bool) {
        self.y_is_percent = ::std::option::Option::Some(v);
    }

    // optional bool is_parent_relative = 5;

    pub fn is_parent_relative(&self) -> bool {
        self.is_parent_relative.unwrap_or(false)
    }

    pub fn clear_is_parent_relative(&mut self) {
        self.is_parent_relative = ::std::option::Option::None;
    }

    pub fn has_is_parent_relative(&self) -> bool {
        self.is_parent_relative.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_parent_relative(&mut self, v: bool) {
        self.is_parent_relative = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgTransformOriginData {
    const NAME: &'static str = "CMsgTransformOriginData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.x = ::std::option::Option::Some(is.read_double()?);
                },
                17 => {
                    self.y = ::std::option::Option::Some(is.read_double()?);
                },
                24 => {
                    self.x_is_percent = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.y_is_percent = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.is_parent_relative = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.x {
            my_size += 1 + 8;
        }
        if let Some(v) = self.y {
            my_size += 1 + 8;
        }
        if let Some(v) = self.x_is_percent {
            my_size += 1 + 1;
        }
        if let Some(v) = self.y_is_percent {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_parent_relative {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.x {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.y {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.x_is_percent {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.y_is_percent {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.is_parent_relative {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTransformOriginData {
        CMsgTransformOriginData::new()
    }

    fn clear(&mut self) {
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.x_is_percent = ::std::option::Option::None;
        self.y_is_percent = ::std::option::Option::None;
        self.is_parent_relative = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTransformOriginData {
        static instance: CMsgTransformOriginData = CMsgTransformOriginData {
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            x_is_percent: ::std::option::Option::None,
            y_is_percent: ::std::option::Option::None,
            is_parent_relative: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsg3DTransformOrigin)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsg3DTransformOrigin {
    // message fields
    // @@protoc_insertion_point(field:CMsg3DTransformOrigin.base)
    pub base: ::protobuf::MessageField<CMsgTransformOriginData>,
    // @@protoc_insertion_point(field:CMsg3DTransformOrigin.transition)
    pub transition: ::protobuf::MessageField<CMsgTransformOriginData>,
    // @@protoc_insertion_point(field:CMsg3DTransformOrigin.transition_data)
    pub transition_data: ::protobuf::MessageField<CMsgTransitionData>,
    // @@protoc_insertion_point(field:CMsg3DTransformOrigin.style_symbol)
    pub style_symbol: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsg3DTransformOrigin.animations)
    pub animations: ::std::vec::Vec<CMsgAnimationData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsg3DTransformOrigin.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsg3DTransformOrigin {
    fn default() -> &'a CMsg3DTransformOrigin {
        <CMsg3DTransformOrigin as ::protobuf::Message>::default_instance()
    }
}

impl CMsg3DTransformOrigin {
    pub fn new() -> CMsg3DTransformOrigin {
        ::std::default::Default::default()
    }

    // optional uint32 style_symbol = 4;

    pub fn style_symbol(&self) -> u32 {
        self.style_symbol.unwrap_or(0)
    }

    pub fn clear_style_symbol(&mut self) {
        self.style_symbol = ::std::option::Option::None;
    }

    pub fn has_style_symbol(&self) -> bool {
        self.style_symbol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_symbol(&mut self, v: u32) {
        self.style_symbol = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsg3DTransformOrigin {
    const NAME: &'static str = "CMsg3DTransformOrigin";

    fn is_initialized(&self) -> bool {
        for v in &self.base {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.animations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.base)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition_data)?;
                },
                32 => {
                    self.style_symbol = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.animations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.style_symbol {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.animations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.transition.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.transition_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.style_symbol {
            os.write_uint32(4, v)?;
        }
        for v in &self.animations {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsg3DTransformOrigin {
        CMsg3DTransformOrigin::new()
    }

    fn clear(&mut self) {
        self.base.clear();
        self.transition.clear();
        self.transition_data.clear();
        self.style_symbol = ::std::option::Option::None;
        self.animations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsg3DTransformOrigin {
        static instance: CMsg3DTransformOrigin = CMsg3DTransformOrigin {
            base: ::protobuf::MessageField::none(),
            transition: ::protobuf::MessageField::none(),
            transition_data: ::protobuf::MessageField::none(),
            style_symbol: ::std::option::Option::None,
            animations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsg3DTransformOrigin`
pub mod cmsg3dtransform_origin {
    // @@protoc_insertion_point(message:CMsg3DTransformOrigin.AnimationFrameData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AnimationFrameData {
        // message fields
        // @@protoc_insertion_point(field:CMsg3DTransformOrigin.AnimationFrameData.data)
        pub data: ::protobuf::MessageField<super::CMsgTransformOriginData>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsg3DTransformOrigin.AnimationFrameData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AnimationFrameData {
        fn default() -> &'a AnimationFrameData {
            <AnimationFrameData as ::protobuf::Message>::default_instance()
        }
    }

    impl AnimationFrameData {
        pub fn new() -> AnimationFrameData {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for AnimationFrameData {
        const NAME: &'static str = "AnimationFrameData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AnimationFrameData {
            AnimationFrameData::new()
        }

        fn clear(&mut self) {
            self.data.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AnimationFrameData {
            static instance: AnimationFrameData = AnimationFrameData {
                data: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsg3DTransformMatrix)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsg3DTransformMatrix {
    // message fields
    // @@protoc_insertion_point(field:CMsg3DTransformMatrix.base)
    pub base: ::protobuf::MessageField<CMsgMatrix4x4>,
    // @@protoc_insertion_point(field:CMsg3DTransformMatrix.transition_data)
    pub transition_data: ::protobuf::MessageField<CMsgTransitionData>,
    // @@protoc_insertion_point(field:CMsg3DTransformMatrix.transition)
    pub transition: ::protobuf::MessageField<CMsgMatrix4x4>,
    // @@protoc_insertion_point(field:CMsg3DTransformMatrix.style_symbol)
    pub style_symbol: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsg3DTransformMatrix.animations)
    pub animations: ::std::vec::Vec<CMsgAnimationData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsg3DTransformMatrix.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsg3DTransformMatrix {
    fn default() -> &'a CMsg3DTransformMatrix {
        <CMsg3DTransformMatrix as ::protobuf::Message>::default_instance()
    }
}

impl CMsg3DTransformMatrix {
    pub fn new() -> CMsg3DTransformMatrix {
        ::std::default::Default::default()
    }

    // optional uint32 style_symbol = 4;

    pub fn style_symbol(&self) -> u32 {
        self.style_symbol.unwrap_or(0)
    }

    pub fn clear_style_symbol(&mut self) {
        self.style_symbol = ::std::option::Option::None;
    }

    pub fn has_style_symbol(&self) -> bool {
        self.style_symbol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_symbol(&mut self, v: u32) {
        self.style_symbol = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsg3DTransformMatrix {
    const NAME: &'static str = "CMsg3DTransformMatrix";

    fn is_initialized(&self) -> bool {
        for v in &self.base {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.animations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.base)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition_data)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition)?;
                },
                32 => {
                    self.style_symbol = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.animations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.style_symbol {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.animations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.transition_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.transition.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.style_symbol {
            os.write_uint32(4, v)?;
        }
        for v in &self.animations {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsg3DTransformMatrix {
        CMsg3DTransformMatrix::new()
    }

    fn clear(&mut self) {
        self.base.clear();
        self.transition_data.clear();
        self.transition.clear();
        self.style_symbol = ::std::option::Option::None;
        self.animations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsg3DTransformMatrix {
        static instance: CMsg3DTransformMatrix = CMsg3DTransformMatrix {
            base: ::protobuf::MessageField::none(),
            transition_data: ::protobuf::MessageField::none(),
            transition: ::protobuf::MessageField::none(),
            style_symbol: ::std::option::Option::None,
            animations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsg3DTransformMatrix`
pub mod cmsg3dtransform_matrix {
    // @@protoc_insertion_point(message:CMsg3DTransformMatrix.AnimationFrameData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AnimationFrameData {
        // message fields
        // @@protoc_insertion_point(field:CMsg3DTransformMatrix.AnimationFrameData.data)
        pub data: ::protobuf::MessageField<super::CMsgMatrix4x4>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsg3DTransformMatrix.AnimationFrameData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AnimationFrameData {
        fn default() -> &'a AnimationFrameData {
            <AnimationFrameData as ::protobuf::Message>::default_instance()
        }
    }

    impl AnimationFrameData {
        pub fn new() -> AnimationFrameData {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for AnimationFrameData {
        const NAME: &'static str = "AnimationFrameData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AnimationFrameData {
            AnimationFrameData::new()
        }

        fn clear(&mut self) {
            self.data.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AnimationFrameData {
            static instance: AnimationFrameData = AnimationFrameData {
                data: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgBorderRadius)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBorderRadius {
    // message fields
    // @@protoc_insertion_point(field:CMsgBorderRadius.base)
    pub base: ::protobuf::MessageField<CRadiusData>,
    // @@protoc_insertion_point(field:CMsgBorderRadius.transition_data)
    pub transition_data: ::protobuf::MessageField<CMsgTransitionData>,
    // @@protoc_insertion_point(field:CMsgBorderRadius.transition)
    pub transition: ::protobuf::MessageField<CRadiusData>,
    // @@protoc_insertion_point(field:CMsgBorderRadius.style_symbol)
    pub style_symbol: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBorderRadius.animations)
    pub animations: ::std::vec::Vec<CMsgAnimationData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBorderRadius.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBorderRadius {
    fn default() -> &'a CMsgBorderRadius {
        <CMsgBorderRadius as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBorderRadius {
    pub fn new() -> CMsgBorderRadius {
        ::std::default::Default::default()
    }

    // optional uint32 style_symbol = 4;

    pub fn style_symbol(&self) -> u32 {
        self.style_symbol.unwrap_or(0)
    }

    pub fn clear_style_symbol(&mut self) {
        self.style_symbol = ::std::option::Option::None;
    }

    pub fn has_style_symbol(&self) -> bool {
        self.style_symbol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_symbol(&mut self, v: u32) {
        self.style_symbol = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgBorderRadius {
    const NAME: &'static str = "CMsgBorderRadius";

    fn is_initialized(&self) -> bool {
        for v in &self.base {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.animations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.base)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition_data)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition)?;
                },
                32 => {
                    self.style_symbol = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.animations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.style_symbol {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.animations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.transition_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.transition.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.style_symbol {
            os.write_uint32(4, v)?;
        }
        for v in &self.animations {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBorderRadius {
        CMsgBorderRadius::new()
    }

    fn clear(&mut self) {
        self.base.clear();
        self.transition_data.clear();
        self.transition.clear();
        self.style_symbol = ::std::option::Option::None;
        self.animations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBorderRadius {
        static instance: CMsgBorderRadius = CMsgBorderRadius {
            base: ::protobuf::MessageField::none(),
            transition_data: ::protobuf::MessageField::none(),
            transition: ::protobuf::MessageField::none(),
            style_symbol: ::std::option::Option::None,
            animations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgBorderRadius`
pub mod cmsg_border_radius {
    // @@protoc_insertion_point(message:CMsgBorderRadius.AnimationFrameData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AnimationFrameData {
        // message fields
        // @@protoc_insertion_point(field:CMsgBorderRadius.AnimationFrameData.data)
        pub data: ::protobuf::MessageField<super::CRadiusData>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgBorderRadius.AnimationFrameData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AnimationFrameData {
        fn default() -> &'a AnimationFrameData {
            <AnimationFrameData as ::protobuf::Message>::default_instance()
        }
    }

    impl AnimationFrameData {
        pub fn new() -> AnimationFrameData {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for AnimationFrameData {
        const NAME: &'static str = "AnimationFrameData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AnimationFrameData {
            AnimationFrameData::new()
        }

        fn clear(&mut self) {
            self.data.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AnimationFrameData {
            static instance: AnimationFrameData = AnimationFrameData {
                data: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgBorder)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBorder {
    // message fields
    // @@protoc_insertion_point(field:CMsgBorder.base)
    pub base: ::protobuf::MessageField<CBorderData>,
    // @@protoc_insertion_point(field:CMsgBorder.transition_data)
    pub transition_data: ::protobuf::MessageField<CMsgTransitionData>,
    // @@protoc_insertion_point(field:CMsgBorder.transition)
    pub transition: ::protobuf::MessageField<CBorderData>,
    // @@protoc_insertion_point(field:CMsgBorder.style_symbol)
    pub style_symbol: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBorder.animations)
    pub animations: ::std::vec::Vec<CMsgAnimationData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBorder.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBorder {
    fn default() -> &'a CMsgBorder {
        <CMsgBorder as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBorder {
    pub fn new() -> CMsgBorder {
        ::std::default::Default::default()
    }

    // optional uint32 style_symbol = 4;

    pub fn style_symbol(&self) -> u32 {
        self.style_symbol.unwrap_or(0)
    }

    pub fn clear_style_symbol(&mut self) {
        self.style_symbol = ::std::option::Option::None;
    }

    pub fn has_style_symbol(&self) -> bool {
        self.style_symbol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_symbol(&mut self, v: u32) {
        self.style_symbol = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgBorder {
    const NAME: &'static str = "CMsgBorder";

    fn is_initialized(&self) -> bool {
        for v in &self.base {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.animations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.base)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition_data)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition)?;
                },
                32 => {
                    self.style_symbol = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.animations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.style_symbol {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.animations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.transition_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.transition.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.style_symbol {
            os.write_uint32(4, v)?;
        }
        for v in &self.animations {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBorder {
        CMsgBorder::new()
    }

    fn clear(&mut self) {
        self.base.clear();
        self.transition_data.clear();
        self.transition.clear();
        self.style_symbol = ::std::option::Option::None;
        self.animations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBorder {
        static instance: CMsgBorder = CMsgBorder {
            base: ::protobuf::MessageField::none(),
            transition_data: ::protobuf::MessageField::none(),
            transition: ::protobuf::MessageField::none(),
            style_symbol: ::std::option::Option::None,
            animations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgBorder`
pub mod cmsg_border {
    // @@protoc_insertion_point(message:CMsgBorder.AnimationFrameData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AnimationFrameData {
        // message fields
        // @@protoc_insertion_point(field:CMsgBorder.AnimationFrameData.data)
        pub data: ::protobuf::MessageField<super::CBorderData>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgBorder.AnimationFrameData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AnimationFrameData {
        fn default() -> &'a AnimationFrameData {
            <AnimationFrameData as ::protobuf::Message>::default_instance()
        }
    }

    impl AnimationFrameData {
        pub fn new() -> AnimationFrameData {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for AnimationFrameData {
        const NAME: &'static str = "AnimationFrameData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AnimationFrameData {
            AnimationFrameData::new()
        }

        fn clear(&mut self) {
            self.data.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AnimationFrameData {
            static instance: AnimationFrameData = AnimationFrameData {
                data: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgBoxShadow)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBoxShadow {
    // message fields
    // @@protoc_insertion_point(field:CMsgBoxShadow.base)
    pub base: ::protobuf::MessageField<CBoxShadowData>,
    // @@protoc_insertion_point(field:CMsgBoxShadow.transition_data)
    pub transition_data: ::protobuf::MessageField<CMsgTransitionData>,
    // @@protoc_insertion_point(field:CMsgBoxShadow.transition)
    pub transition: ::protobuf::MessageField<CBoxShadowData>,
    // @@protoc_insertion_point(field:CMsgBoxShadow.style_symbol)
    pub style_symbol: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBoxShadow.animations)
    pub animations: ::std::vec::Vec<CMsgAnimationData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBoxShadow.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBoxShadow {
    fn default() -> &'a CMsgBoxShadow {
        <CMsgBoxShadow as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBoxShadow {
    pub fn new() -> CMsgBoxShadow {
        ::std::default::Default::default()
    }

    // optional uint32 style_symbol = 4;

    pub fn style_symbol(&self) -> u32 {
        self.style_symbol.unwrap_or(0)
    }

    pub fn clear_style_symbol(&mut self) {
        self.style_symbol = ::std::option::Option::None;
    }

    pub fn has_style_symbol(&self) -> bool {
        self.style_symbol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_symbol(&mut self, v: u32) {
        self.style_symbol = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgBoxShadow {
    const NAME: &'static str = "CMsgBoxShadow";

    fn is_initialized(&self) -> bool {
        for v in &self.base {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.animations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.base)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition_data)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition)?;
                },
                32 => {
                    self.style_symbol = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.animations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.style_symbol {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.animations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.transition_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.transition.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.style_symbol {
            os.write_uint32(4, v)?;
        }
        for v in &self.animations {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBoxShadow {
        CMsgBoxShadow::new()
    }

    fn clear(&mut self) {
        self.base.clear();
        self.transition_data.clear();
        self.transition.clear();
        self.style_symbol = ::std::option::Option::None;
        self.animations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBoxShadow {
        static instance: CMsgBoxShadow = CMsgBoxShadow {
            base: ::protobuf::MessageField::none(),
            transition_data: ::protobuf::MessageField::none(),
            transition: ::protobuf::MessageField::none(),
            style_symbol: ::std::option::Option::None,
            animations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgBoxShadow`
pub mod cmsg_box_shadow {
    // @@protoc_insertion_point(message:CMsgBoxShadow.AnimationFrameData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AnimationFrameData {
        // message fields
        // @@protoc_insertion_point(field:CMsgBoxShadow.AnimationFrameData.data)
        pub data: ::protobuf::MessageField<super::CBoxShadowData>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgBoxShadow.AnimationFrameData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AnimationFrameData {
        fn default() -> &'a AnimationFrameData {
            <AnimationFrameData as ::protobuf::Message>::default_instance()
        }
    }

    impl AnimationFrameData {
        pub fn new() -> AnimationFrameData {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for AnimationFrameData {
        const NAME: &'static str = "AnimationFrameData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AnimationFrameData {
            AnimationFrameData::new()
        }

        fn clear(&mut self) {
            self.data.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AnimationFrameData {
            static instance: AnimationFrameData = AnimationFrameData {
                data: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgTextShadow)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTextShadow {
    // message fields
    // @@protoc_insertion_point(field:CMsgTextShadow.base)
    pub base: ::protobuf::MessageField<CTextShadowData>,
    // @@protoc_insertion_point(field:CMsgTextShadow.transition_data)
    pub transition_data: ::protobuf::MessageField<CMsgTransitionData>,
    // @@protoc_insertion_point(field:CMsgTextShadow.transition)
    pub transition: ::protobuf::MessageField<CTextShadowData>,
    // @@protoc_insertion_point(field:CMsgTextShadow.style_symbol)
    pub style_symbol: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTextShadow.animations)
    pub animations: ::std::vec::Vec<CMsgAnimationData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTextShadow.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTextShadow {
    fn default() -> &'a CMsgTextShadow {
        <CMsgTextShadow as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTextShadow {
    pub fn new() -> CMsgTextShadow {
        ::std::default::Default::default()
    }

    // optional uint32 style_symbol = 4;

    pub fn style_symbol(&self) -> u32 {
        self.style_symbol.unwrap_or(0)
    }

    pub fn clear_style_symbol(&mut self) {
        self.style_symbol = ::std::option::Option::None;
    }

    pub fn has_style_symbol(&self) -> bool {
        self.style_symbol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_symbol(&mut self, v: u32) {
        self.style_symbol = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgTextShadow {
    const NAME: &'static str = "CMsgTextShadow";

    fn is_initialized(&self) -> bool {
        for v in &self.base {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.animations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.base)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition_data)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition)?;
                },
                32 => {
                    self.style_symbol = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.animations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.style_symbol {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.animations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.transition_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.transition.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.style_symbol {
            os.write_uint32(4, v)?;
        }
        for v in &self.animations {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTextShadow {
        CMsgTextShadow::new()
    }

    fn clear(&mut self) {
        self.base.clear();
        self.transition_data.clear();
        self.transition.clear();
        self.style_symbol = ::std::option::Option::None;
        self.animations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTextShadow {
        static instance: CMsgTextShadow = CMsgTextShadow {
            base: ::protobuf::MessageField::none(),
            transition_data: ::protobuf::MessageField::none(),
            transition: ::protobuf::MessageField::none(),
            style_symbol: ::std::option::Option::None,
            animations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgTextShadow`
pub mod cmsg_text_shadow {
    // @@protoc_insertion_point(message:CMsgTextShadow.AnimationFrameData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AnimationFrameData {
        // message fields
        // @@protoc_insertion_point(field:CMsgTextShadow.AnimationFrameData.data)
        pub data: ::protobuf::MessageField<super::CTextShadowData>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgTextShadow.AnimationFrameData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AnimationFrameData {
        fn default() -> &'a AnimationFrameData {
            <AnimationFrameData as ::protobuf::Message>::default_instance()
        }
    }

    impl AnimationFrameData {
        pub fn new() -> AnimationFrameData {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for AnimationFrameData {
        const NAME: &'static str = "AnimationFrameData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AnimationFrameData {
            AnimationFrameData::new()
        }

        fn clear(&mut self) {
            self.data.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AnimationFrameData {
            static instance: AnimationFrameData = AnimationFrameData {
                data: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgClip)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClip {
    // message fields
    // @@protoc_insertion_point(field:CMsgClip.base)
    pub base: ::protobuf::MessageField<CMsgClipData>,
    // @@protoc_insertion_point(field:CMsgClip.transition_data)
    pub transition_data: ::protobuf::MessageField<CMsgTransitionData>,
    // @@protoc_insertion_point(field:CMsgClip.transition)
    pub transition: ::protobuf::MessageField<CMsgClipData>,
    // @@protoc_insertion_point(field:CMsgClip.style_symbol)
    pub style_symbol: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClip.animations)
    pub animations: ::std::vec::Vec<CMsgAnimationData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClip.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClip {
    fn default() -> &'a CMsgClip {
        <CMsgClip as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClip {
    pub fn new() -> CMsgClip {
        ::std::default::Default::default()
    }

    // optional uint32 style_symbol = 4;

    pub fn style_symbol(&self) -> u32 {
        self.style_symbol.unwrap_or(0)
    }

    pub fn clear_style_symbol(&mut self) {
        self.style_symbol = ::std::option::Option::None;
    }

    pub fn has_style_symbol(&self) -> bool {
        self.style_symbol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_symbol(&mut self, v: u32) {
        self.style_symbol = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClip {
    const NAME: &'static str = "CMsgClip";

    fn is_initialized(&self) -> bool {
        for v in &self.base {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.animations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.base)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition_data)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition)?;
                },
                32 => {
                    self.style_symbol = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.animations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.style_symbol {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.animations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.transition_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.transition.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.style_symbol {
            os.write_uint32(4, v)?;
        }
        for v in &self.animations {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClip {
        CMsgClip::new()
    }

    fn clear(&mut self) {
        self.base.clear();
        self.transition_data.clear();
        self.transition.clear();
        self.style_symbol = ::std::option::Option::None;
        self.animations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClip {
        static instance: CMsgClip = CMsgClip {
            base: ::protobuf::MessageField::none(),
            transition_data: ::protobuf::MessageField::none(),
            transition: ::protobuf::MessageField::none(),
            style_symbol: ::std::option::Option::None,
            animations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClip`
pub mod cmsg_clip {
    // @@protoc_insertion_point(message:CMsgClip.AnimationFrameData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AnimationFrameData {
        // message fields
        // @@protoc_insertion_point(field:CMsgClip.AnimationFrameData.data)
        pub data: ::protobuf::MessageField<super::CMsgClipData>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClip.AnimationFrameData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AnimationFrameData {
        fn default() -> &'a AnimationFrameData {
            <AnimationFrameData as ::protobuf::Message>::default_instance()
        }
    }

    impl AnimationFrameData {
        pub fn new() -> AnimationFrameData {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for AnimationFrameData {
        const NAME: &'static str = "AnimationFrameData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AnimationFrameData {
            AnimationFrameData::new()
        }

        fn clear(&mut self) {
            self.data.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AnimationFrameData {
            static instance: AnimationFrameData = AnimationFrameData {
                data: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgPushClipLayer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPushClipLayer {
    // message fields
    // @@protoc_insertion_point(field:CMsgPushClipLayer.top_left)
    pub top_left: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgPushClipLayer.bottom_right)
    pub bottom_right: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgPushClipLayer.border_radius)
    pub border_radius: ::protobuf::MessageField<CRadiusData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPushClipLayer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPushClipLayer {
    fn default() -> &'a CMsgPushClipLayer {
        <CMsgPushClipLayer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPushClipLayer {
    pub fn new() -> CMsgPushClipLayer {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgPushClipLayer {
    const NAME: &'static str = "CMsgPushClipLayer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.top_left)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.bottom_right)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.border_radius)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.top_left.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.bottom_right.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.border_radius.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.top_left.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.bottom_right.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.border_radius.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPushClipLayer {
        CMsgPushClipLayer::new()
    }

    fn clear(&mut self) {
        self.top_left.clear();
        self.bottom_right.clear();
        self.border_radius.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPushClipLayer {
        static instance: CMsgPushClipLayer = CMsgPushClipLayer {
            top_left: ::protobuf::MessageField::none(),
            bottom_right: ::protobuf::MessageField::none(),
            border_radius: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPopClipLayer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPopClipLayer {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPopClipLayer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPopClipLayer {
    fn default() -> &'a CMsgPopClipLayer {
        <CMsgPopClipLayer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPopClipLayer {
    pub fn new() -> CMsgPopClipLayer {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgPopClipLayer {
    const NAME: &'static str = "CMsgPopClipLayer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPopClipLayer {
        CMsgPopClipLayer::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPopClipLayer {
        static instance: CMsgPopClipLayer = CMsgPopClipLayer {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPushPanelContextInLayer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPushPanelContextInLayer {
    // message fields
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.transform_m00)
    pub transform_m00: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.transform_m01)
    pub transform_m01: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.transform_m02)
    pub transform_m02: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.transform_m03)
    pub transform_m03: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.transform_m10)
    pub transform_m10: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.transform_m11)
    pub transform_m11: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.transform_m12)
    pub transform_m12: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.transform_m13)
    pub transform_m13: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.transform_m20)
    pub transform_m20: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.transform_m21)
    pub transform_m21: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.transform_m22)
    pub transform_m22: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.transform_m23)
    pub transform_m23: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.transform_m30)
    pub transform_m30: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.transform_m31)
    pub transform_m31: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.transform_m32)
    pub transform_m32: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.transform_m33)
    pub transform_m33: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.box_shadow)
    pub box_shadow: ::protobuf::MessageField<CBoxShadowData>,
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.width)
    pub width: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.height)
    pub height: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.position_x)
    pub position_x: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.position_y)
    pub position_y: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.position_z)
    pub position_z: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.border)
    pub border: ::protobuf::MessageField<CBorderData>,
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.scroll_x)
    pub scroll_x: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.scroll_y)
    pub scroll_y: ::std::option::Option<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPushPanelContextInLayer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPushPanelContextInLayer {
    fn default() -> &'a CMsgPushPanelContextInLayer {
        <CMsgPushPanelContextInLayer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPushPanelContextInLayer {
    pub fn new() -> CMsgPushPanelContextInLayer {
        ::std::default::Default::default()
    }

    // optional double transform_m00 = 1;

    pub fn transform_m00(&self) -> f64 {
        self.transform_m00.unwrap_or(0.)
    }

    pub fn clear_transform_m00(&mut self) {
        self.transform_m00 = ::std::option::Option::None;
    }

    pub fn has_transform_m00(&self) -> bool {
        self.transform_m00.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m00(&mut self, v: f64) {
        self.transform_m00 = ::std::option::Option::Some(v);
    }

    // optional double transform_m01 = 2;

    pub fn transform_m01(&self) -> f64 {
        self.transform_m01.unwrap_or(0.)
    }

    pub fn clear_transform_m01(&mut self) {
        self.transform_m01 = ::std::option::Option::None;
    }

    pub fn has_transform_m01(&self) -> bool {
        self.transform_m01.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m01(&mut self, v: f64) {
        self.transform_m01 = ::std::option::Option::Some(v);
    }

    // optional double transform_m02 = 3;

    pub fn transform_m02(&self) -> f64 {
        self.transform_m02.unwrap_or(0.)
    }

    pub fn clear_transform_m02(&mut self) {
        self.transform_m02 = ::std::option::Option::None;
    }

    pub fn has_transform_m02(&self) -> bool {
        self.transform_m02.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m02(&mut self, v: f64) {
        self.transform_m02 = ::std::option::Option::Some(v);
    }

    // optional double transform_m03 = 4;

    pub fn transform_m03(&self) -> f64 {
        self.transform_m03.unwrap_or(0.)
    }

    pub fn clear_transform_m03(&mut self) {
        self.transform_m03 = ::std::option::Option::None;
    }

    pub fn has_transform_m03(&self) -> bool {
        self.transform_m03.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m03(&mut self, v: f64) {
        self.transform_m03 = ::std::option::Option::Some(v);
    }

    // optional double transform_m10 = 5;

    pub fn transform_m10(&self) -> f64 {
        self.transform_m10.unwrap_or(0.)
    }

    pub fn clear_transform_m10(&mut self) {
        self.transform_m10 = ::std::option::Option::None;
    }

    pub fn has_transform_m10(&self) -> bool {
        self.transform_m10.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m10(&mut self, v: f64) {
        self.transform_m10 = ::std::option::Option::Some(v);
    }

    // optional double transform_m11 = 6;

    pub fn transform_m11(&self) -> f64 {
        self.transform_m11.unwrap_or(0.)
    }

    pub fn clear_transform_m11(&mut self) {
        self.transform_m11 = ::std::option::Option::None;
    }

    pub fn has_transform_m11(&self) -> bool {
        self.transform_m11.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m11(&mut self, v: f64) {
        self.transform_m11 = ::std::option::Option::Some(v);
    }

    // optional double transform_m12 = 7;

    pub fn transform_m12(&self) -> f64 {
        self.transform_m12.unwrap_or(0.)
    }

    pub fn clear_transform_m12(&mut self) {
        self.transform_m12 = ::std::option::Option::None;
    }

    pub fn has_transform_m12(&self) -> bool {
        self.transform_m12.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m12(&mut self, v: f64) {
        self.transform_m12 = ::std::option::Option::Some(v);
    }

    // optional double transform_m13 = 8;

    pub fn transform_m13(&self) -> f64 {
        self.transform_m13.unwrap_or(0.)
    }

    pub fn clear_transform_m13(&mut self) {
        self.transform_m13 = ::std::option::Option::None;
    }

    pub fn has_transform_m13(&self) -> bool {
        self.transform_m13.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m13(&mut self, v: f64) {
        self.transform_m13 = ::std::option::Option::Some(v);
    }

    // optional double transform_m20 = 9;

    pub fn transform_m20(&self) -> f64 {
        self.transform_m20.unwrap_or(0.)
    }

    pub fn clear_transform_m20(&mut self) {
        self.transform_m20 = ::std::option::Option::None;
    }

    pub fn has_transform_m20(&self) -> bool {
        self.transform_m20.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m20(&mut self, v: f64) {
        self.transform_m20 = ::std::option::Option::Some(v);
    }

    // optional double transform_m21 = 10;

    pub fn transform_m21(&self) -> f64 {
        self.transform_m21.unwrap_or(0.)
    }

    pub fn clear_transform_m21(&mut self) {
        self.transform_m21 = ::std::option::Option::None;
    }

    pub fn has_transform_m21(&self) -> bool {
        self.transform_m21.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m21(&mut self, v: f64) {
        self.transform_m21 = ::std::option::Option::Some(v);
    }

    // optional double transform_m22 = 11;

    pub fn transform_m22(&self) -> f64 {
        self.transform_m22.unwrap_or(0.)
    }

    pub fn clear_transform_m22(&mut self) {
        self.transform_m22 = ::std::option::Option::None;
    }

    pub fn has_transform_m22(&self) -> bool {
        self.transform_m22.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m22(&mut self, v: f64) {
        self.transform_m22 = ::std::option::Option::Some(v);
    }

    // optional double transform_m23 = 12;

    pub fn transform_m23(&self) -> f64 {
        self.transform_m23.unwrap_or(0.)
    }

    pub fn clear_transform_m23(&mut self) {
        self.transform_m23 = ::std::option::Option::None;
    }

    pub fn has_transform_m23(&self) -> bool {
        self.transform_m23.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m23(&mut self, v: f64) {
        self.transform_m23 = ::std::option::Option::Some(v);
    }

    // optional double transform_m30 = 13;

    pub fn transform_m30(&self) -> f64 {
        self.transform_m30.unwrap_or(0.)
    }

    pub fn clear_transform_m30(&mut self) {
        self.transform_m30 = ::std::option::Option::None;
    }

    pub fn has_transform_m30(&self) -> bool {
        self.transform_m30.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m30(&mut self, v: f64) {
        self.transform_m30 = ::std::option::Option::Some(v);
    }

    // optional double transform_m31 = 14;

    pub fn transform_m31(&self) -> f64 {
        self.transform_m31.unwrap_or(0.)
    }

    pub fn clear_transform_m31(&mut self) {
        self.transform_m31 = ::std::option::Option::None;
    }

    pub fn has_transform_m31(&self) -> bool {
        self.transform_m31.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m31(&mut self, v: f64) {
        self.transform_m31 = ::std::option::Option::Some(v);
    }

    // optional double transform_m32 = 15;

    pub fn transform_m32(&self) -> f64 {
        self.transform_m32.unwrap_or(0.)
    }

    pub fn clear_transform_m32(&mut self) {
        self.transform_m32 = ::std::option::Option::None;
    }

    pub fn has_transform_m32(&self) -> bool {
        self.transform_m32.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m32(&mut self, v: f64) {
        self.transform_m32 = ::std::option::Option::Some(v);
    }

    // optional double transform_m33 = 16;

    pub fn transform_m33(&self) -> f64 {
        self.transform_m33.unwrap_or(0.)
    }

    pub fn clear_transform_m33(&mut self) {
        self.transform_m33 = ::std::option::Option::None;
    }

    pub fn has_transform_m33(&self) -> bool {
        self.transform_m33.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m33(&mut self, v: f64) {
        self.transform_m33 = ::std::option::Option::Some(v);
    }

    // optional double width = 18;

    pub fn width(&self) -> f64 {
        self.width.unwrap_or(0.)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: f64) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional double height = 19;

    pub fn height(&self) -> f64 {
        self.height.unwrap_or(0.)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: f64) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional double position_x = 20;

    pub fn position_x(&self) -> f64 {
        self.position_x.unwrap_or(0.)
    }

    pub fn clear_position_x(&mut self) {
        self.position_x = ::std::option::Option::None;
    }

    pub fn has_position_x(&self) -> bool {
        self.position_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position_x(&mut self, v: f64) {
        self.position_x = ::std::option::Option::Some(v);
    }

    // optional double position_y = 21;

    pub fn position_y(&self) -> f64 {
        self.position_y.unwrap_or(0.)
    }

    pub fn clear_position_y(&mut self) {
        self.position_y = ::std::option::Option::None;
    }

    pub fn has_position_y(&self) -> bool {
        self.position_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position_y(&mut self, v: f64) {
        self.position_y = ::std::option::Option::Some(v);
    }

    // optional double position_z = 22;

    pub fn position_z(&self) -> f64 {
        self.position_z.unwrap_or(0.)
    }

    pub fn clear_position_z(&mut self) {
        self.position_z = ::std::option::Option::None;
    }

    pub fn has_position_z(&self) -> bool {
        self.position_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position_z(&mut self, v: f64) {
        self.position_z = ::std::option::Option::Some(v);
    }

    // optional double scroll_x = 24;

    pub fn scroll_x(&self) -> f64 {
        self.scroll_x.unwrap_or(0.)
    }

    pub fn clear_scroll_x(&mut self) {
        self.scroll_x = ::std::option::Option::None;
    }

    pub fn has_scroll_x(&self) -> bool {
        self.scroll_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scroll_x(&mut self, v: f64) {
        self.scroll_x = ::std::option::Option::Some(v);
    }

    // optional double scroll_y = 25;

    pub fn scroll_y(&self) -> f64 {
        self.scroll_y.unwrap_or(0.)
    }

    pub fn clear_scroll_y(&mut self) {
        self.scroll_y = ::std::option::Option::None;
    }

    pub fn has_scroll_y(&self) -> bool {
        self.scroll_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scroll_y(&mut self, v: f64) {
        self.scroll_y = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgPushPanelContextInLayer {
    const NAME: &'static str = "CMsgPushPanelContextInLayer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.transform_m00 = ::std::option::Option::Some(is.read_double()?);
                },
                17 => {
                    self.transform_m01 = ::std::option::Option::Some(is.read_double()?);
                },
                25 => {
                    self.transform_m02 = ::std::option::Option::Some(is.read_double()?);
                },
                33 => {
                    self.transform_m03 = ::std::option::Option::Some(is.read_double()?);
                },
                41 => {
                    self.transform_m10 = ::std::option::Option::Some(is.read_double()?);
                },
                49 => {
                    self.transform_m11 = ::std::option::Option::Some(is.read_double()?);
                },
                57 => {
                    self.transform_m12 = ::std::option::Option::Some(is.read_double()?);
                },
                65 => {
                    self.transform_m13 = ::std::option::Option::Some(is.read_double()?);
                },
                73 => {
                    self.transform_m20 = ::std::option::Option::Some(is.read_double()?);
                },
                81 => {
                    self.transform_m21 = ::std::option::Option::Some(is.read_double()?);
                },
                89 => {
                    self.transform_m22 = ::std::option::Option::Some(is.read_double()?);
                },
                97 => {
                    self.transform_m23 = ::std::option::Option::Some(is.read_double()?);
                },
                105 => {
                    self.transform_m30 = ::std::option::Option::Some(is.read_double()?);
                },
                113 => {
                    self.transform_m31 = ::std::option::Option::Some(is.read_double()?);
                },
                121 => {
                    self.transform_m32 = ::std::option::Option::Some(is.read_double()?);
                },
                129 => {
                    self.transform_m33 = ::std::option::Option::Some(is.read_double()?);
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.box_shadow)?;
                },
                145 => {
                    self.width = ::std::option::Option::Some(is.read_double()?);
                },
                153 => {
                    self.height = ::std::option::Option::Some(is.read_double()?);
                },
                161 => {
                    self.position_x = ::std::option::Option::Some(is.read_double()?);
                },
                169 => {
                    self.position_y = ::std::option::Option::Some(is.read_double()?);
                },
                177 => {
                    self.position_z = ::std::option::Option::Some(is.read_double()?);
                },
                186 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.border)?;
                },
                193 => {
                    self.scroll_x = ::std::option::Option::Some(is.read_double()?);
                },
                201 => {
                    self.scroll_y = ::std::option::Option::Some(is.read_double()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.transform_m00 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transform_m01 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transform_m02 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transform_m03 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transform_m10 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transform_m11 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transform_m12 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transform_m13 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transform_m20 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transform_m21 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transform_m22 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transform_m23 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transform_m30 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transform_m31 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transform_m32 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transform_m33 {
            my_size += 2 + 8;
        }
        if let Some(v) = self.box_shadow.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.width {
            my_size += 2 + 8;
        }
        if let Some(v) = self.height {
            my_size += 2 + 8;
        }
        if let Some(v) = self.position_x {
            my_size += 2 + 8;
        }
        if let Some(v) = self.position_y {
            my_size += 2 + 8;
        }
        if let Some(v) = self.position_z {
            my_size += 2 + 8;
        }
        if let Some(v) = self.border.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.scroll_x {
            my_size += 2 + 8;
        }
        if let Some(v) = self.scroll_y {
            my_size += 2 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.transform_m00 {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.transform_m01 {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.transform_m02 {
            os.write_double(3, v)?;
        }
        if let Some(v) = self.transform_m03 {
            os.write_double(4, v)?;
        }
        if let Some(v) = self.transform_m10 {
            os.write_double(5, v)?;
        }
        if let Some(v) = self.transform_m11 {
            os.write_double(6, v)?;
        }
        if let Some(v) = self.transform_m12 {
            os.write_double(7, v)?;
        }
        if let Some(v) = self.transform_m13 {
            os.write_double(8, v)?;
        }
        if let Some(v) = self.transform_m20 {
            os.write_double(9, v)?;
        }
        if let Some(v) = self.transform_m21 {
            os.write_double(10, v)?;
        }
        if let Some(v) = self.transform_m22 {
            os.write_double(11, v)?;
        }
        if let Some(v) = self.transform_m23 {
            os.write_double(12, v)?;
        }
        if let Some(v) = self.transform_m30 {
            os.write_double(13, v)?;
        }
        if let Some(v) = self.transform_m31 {
            os.write_double(14, v)?;
        }
        if let Some(v) = self.transform_m32 {
            os.write_double(15, v)?;
        }
        if let Some(v) = self.transform_m33 {
            os.write_double(16, v)?;
        }
        if let Some(v) = self.box_shadow.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.width {
            os.write_double(18, v)?;
        }
        if let Some(v) = self.height {
            os.write_double(19, v)?;
        }
        if let Some(v) = self.position_x {
            os.write_double(20, v)?;
        }
        if let Some(v) = self.position_y {
            os.write_double(21, v)?;
        }
        if let Some(v) = self.position_z {
            os.write_double(22, v)?;
        }
        if let Some(v) = self.border.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
        }
        if let Some(v) = self.scroll_x {
            os.write_double(24, v)?;
        }
        if let Some(v) = self.scroll_y {
            os.write_double(25, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPushPanelContextInLayer {
        CMsgPushPanelContextInLayer::new()
    }

    fn clear(&mut self) {
        self.transform_m00 = ::std::option::Option::None;
        self.transform_m01 = ::std::option::Option::None;
        self.transform_m02 = ::std::option::Option::None;
        self.transform_m03 = ::std::option::Option::None;
        self.transform_m10 = ::std::option::Option::None;
        self.transform_m11 = ::std::option::Option::None;
        self.transform_m12 = ::std::option::Option::None;
        self.transform_m13 = ::std::option::Option::None;
        self.transform_m20 = ::std::option::Option::None;
        self.transform_m21 = ::std::option::Option::None;
        self.transform_m22 = ::std::option::Option::None;
        self.transform_m23 = ::std::option::Option::None;
        self.transform_m30 = ::std::option::Option::None;
        self.transform_m31 = ::std::option::Option::None;
        self.transform_m32 = ::std::option::Option::None;
        self.transform_m33 = ::std::option::Option::None;
        self.box_shadow.clear();
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.position_x = ::std::option::Option::None;
        self.position_y = ::std::option::Option::None;
        self.position_z = ::std::option::Option::None;
        self.border.clear();
        self.scroll_x = ::std::option::Option::None;
        self.scroll_y = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPushPanelContextInLayer {
        static instance: CMsgPushPanelContextInLayer = CMsgPushPanelContextInLayer {
            transform_m00: ::std::option::Option::None,
            transform_m01: ::std::option::Option::None,
            transform_m02: ::std::option::Option::None,
            transform_m03: ::std::option::Option::None,
            transform_m10: ::std::option::Option::None,
            transform_m11: ::std::option::Option::None,
            transform_m12: ::std::option::Option::None,
            transform_m13: ::std::option::Option::None,
            transform_m20: ::std::option::Option::None,
            transform_m21: ::std::option::Option::None,
            transform_m22: ::std::option::Option::None,
            transform_m23: ::std::option::Option::None,
            transform_m30: ::std::option::Option::None,
            transform_m31: ::std::option::Option::None,
            transform_m32: ::std::option::Option::None,
            transform_m33: ::std::option::Option::None,
            box_shadow: ::protobuf::MessageField::none(),
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            position_x: ::std::option::Option::None,
            position_y: ::std::option::Option::None,
            position_z: ::std::option::Option::None,
            border: ::protobuf::MessageField::none(),
            scroll_x: ::std::option::Option::None,
            scroll_y: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPopPanelContextInLayer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPopPanelContextInLayer {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPopPanelContextInLayer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPopPanelContextInLayer {
    fn default() -> &'a CMsgPopPanelContextInLayer {
        <CMsgPopPanelContextInLayer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPopPanelContextInLayer {
    pub fn new() -> CMsgPopPanelContextInLayer {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgPopPanelContextInLayer {
    const NAME: &'static str = "CMsgPopPanelContextInLayer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPopPanelContextInLayer {
        CMsgPopPanelContextInLayer::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPopPanelContextInLayer {
        static instance: CMsgPopPanelContextInLayer = CMsgPopPanelContextInLayer {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPushAAndTContext)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPushAAndTContext {
    // message fields
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.context_id)
    pub context_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.width)
    pub width: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.height)
    pub height: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.chilren_have_3dtransforms)
    pub chilren_have_3dtransforms: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.zindex)
    pub zindex: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.panel_position)
    pub panel_position: ::protobuf::MessageField<CMsgPanelPosition>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.transform_matrix)
    pub transform_matrix: ::protobuf::MessageField<CMsg3DTransformMatrix>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.transform_origin)
    pub transform_origin: ::protobuf::MessageField<CMsg3DTransformOrigin>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.transform_perspective)
    pub transform_perspective: ::protobuf::MessageField<CMsg3DTransformPerspective>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.transform_perspective_origin)
    pub transform_perspective_origin: ::protobuf::MessageField<CMsg3DTransformPerspectiveOrigin>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.opacity)
    pub opacity: ::protobuf::MessageField<CMsgOpacity>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.wash_color)
    pub wash_color: ::protobuf::MessageField<CMsgColor>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.hue_shift)
    pub hue_shift: ::protobuf::MessageField<CMsgHueShift>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.saturation)
    pub saturation: ::protobuf::MessageField<CMsgSaturation>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.brightness)
    pub brightness: ::protobuf::MessageField<CMsgBrightness>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.contrast)
    pub contrast: ::protobuf::MessageField<CMsgContrast>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.opacity_mask)
    pub opacity_mask: ::protobuf::MessageField<CMsgOpacityMask>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.border_radius)
    pub border_radius: ::protobuf::MessageField<CMsgBorderRadius>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.gaussian_blur)
    pub gaussian_blur: ::protobuf::MessageField<CMsgGaussianBlur>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.border)
    pub border: ::protobuf::MessageField<CMsgBorder>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.box_shadow)
    pub box_shadow: ::protobuf::MessageField<CMsgBoxShadow>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.scale_2d_centered)
    pub scale_2d_centered: ::protobuf::MessageField<CMsgPointWithTransition>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.rotate_2d_centered)
    pub rotate_2d_centered: ::protobuf::MessageField<CMsgRotate2D>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.text_shadow)
    pub text_shadow: ::protobuf::MessageField<CMsgTextShadow>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.clip)
    pub clip: ::protobuf::MessageField<CMsgClip>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.suppress_clip_to_bounds)
    pub suppress_clip_to_bounds: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.needs_full_repaint)
    pub needs_full_repaint: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.needs_intermediate_texture)
    pub needs_intermediate_texture: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.clip_after_transform)
    pub clip_after_transform: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.wants_hit_test)
    pub wants_hit_test: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.wants_hit_test_children)
    pub wants_hit_test_children: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.mix_blend_mode)
    pub mix_blend_mode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.opaque_background)
    pub opaque_background: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.child_panel_count)
    pub child_panel_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.wants_screenspace_quad_output)
    pub wants_screenspace_quad_output: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.motion_blur)
    pub motion_blur: ::protobuf::MessageField<CMsgMotionBlur>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.composition_layer_texture_name)
    pub composition_layer_texture_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPushAAndTContext.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPushAAndTContext {
    fn default() -> &'a CMsgPushAAndTContext {
        <CMsgPushAAndTContext as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPushAAndTContext {
    pub fn new() -> CMsgPushAAndTContext {
        ::std::default::Default::default()
    }

    // optional uint64 context_id = 1;

    pub fn context_id(&self) -> u64 {
        self.context_id.unwrap_or(0)
    }

    pub fn clear_context_id(&mut self) {
        self.context_id = ::std::option::Option::None;
    }

    pub fn has_context_id(&self) -> bool {
        self.context_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context_id(&mut self, v: u64) {
        self.context_id = ::std::option::Option::Some(v);
    }

    // optional double width = 3;

    pub fn width(&self) -> f64 {
        self.width.unwrap_or(0.)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: f64) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional double height = 4;

    pub fn height(&self) -> f64 {
        self.height.unwrap_or(0.)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: f64) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional bool chilren_have_3dtransforms = 5;

    pub fn chilren_have_3dtransforms(&self) -> bool {
        self.chilren_have_3dtransforms.unwrap_or(false)
    }

    pub fn clear_chilren_have_3dtransforms(&mut self) {
        self.chilren_have_3dtransforms = ::std::option::Option::None;
    }

    pub fn has_chilren_have_3dtransforms(&self) -> bool {
        self.chilren_have_3dtransforms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chilren_have_3dtransforms(&mut self, v: bool) {
        self.chilren_have_3dtransforms = ::std::option::Option::Some(v);
    }

    // optional float zindex = 6;

    pub fn zindex(&self) -> f32 {
        self.zindex.unwrap_or(0.)
    }

    pub fn clear_zindex(&mut self) {
        self.zindex = ::std::option::Option::None;
    }

    pub fn has_zindex(&self) -> bool {
        self.zindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_zindex(&mut self, v: f32) {
        self.zindex = ::std::option::Option::Some(v);
    }

    // optional bool suppress_clip_to_bounds = 27;

    pub fn suppress_clip_to_bounds(&self) -> bool {
        self.suppress_clip_to_bounds.unwrap_or(false)
    }

    pub fn clear_suppress_clip_to_bounds(&mut self) {
        self.suppress_clip_to_bounds = ::std::option::Option::None;
    }

    pub fn has_suppress_clip_to_bounds(&self) -> bool {
        self.suppress_clip_to_bounds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_suppress_clip_to_bounds(&mut self, v: bool) {
        self.suppress_clip_to_bounds = ::std::option::Option::Some(v);
    }

    // optional int32 needs_full_repaint = 28;

    pub fn needs_full_repaint(&self) -> i32 {
        self.needs_full_repaint.unwrap_or(0)
    }

    pub fn clear_needs_full_repaint(&mut self) {
        self.needs_full_repaint = ::std::option::Option::None;
    }

    pub fn has_needs_full_repaint(&self) -> bool {
        self.needs_full_repaint.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needs_full_repaint(&mut self, v: i32) {
        self.needs_full_repaint = ::std::option::Option::Some(v);
    }

    // optional bool needs_intermediate_texture = 29;

    pub fn needs_intermediate_texture(&self) -> bool {
        self.needs_intermediate_texture.unwrap_or(false)
    }

    pub fn clear_needs_intermediate_texture(&mut self) {
        self.needs_intermediate_texture = ::std::option::Option::None;
    }

    pub fn has_needs_intermediate_texture(&self) -> bool {
        self.needs_intermediate_texture.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needs_intermediate_texture(&mut self, v: bool) {
        self.needs_intermediate_texture = ::std::option::Option::Some(v);
    }

    // optional bool clip_after_transform = 30;

    pub fn clip_after_transform(&self) -> bool {
        self.clip_after_transform.unwrap_or(false)
    }

    pub fn clear_clip_after_transform(&mut self) {
        self.clip_after_transform = ::std::option::Option::None;
    }

    pub fn has_clip_after_transform(&self) -> bool {
        self.clip_after_transform.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clip_after_transform(&mut self, v: bool) {
        self.clip_after_transform = ::std::option::Option::Some(v);
    }

    // optional bool wants_hit_test = 31;

    pub fn wants_hit_test(&self) -> bool {
        self.wants_hit_test.unwrap_or(false)
    }

    pub fn clear_wants_hit_test(&mut self) {
        self.wants_hit_test = ::std::option::Option::None;
    }

    pub fn has_wants_hit_test(&self) -> bool {
        self.wants_hit_test.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wants_hit_test(&mut self, v: bool) {
        self.wants_hit_test = ::std::option::Option::Some(v);
    }

    // optional bool wants_hit_test_children = 32;

    pub fn wants_hit_test_children(&self) -> bool {
        self.wants_hit_test_children.unwrap_or(false)
    }

    pub fn clear_wants_hit_test_children(&mut self) {
        self.wants_hit_test_children = ::std::option::Option::None;
    }

    pub fn has_wants_hit_test_children(&self) -> bool {
        self.wants_hit_test_children.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wants_hit_test_children(&mut self, v: bool) {
        self.wants_hit_test_children = ::std::option::Option::Some(v);
    }

    // optional uint32 mix_blend_mode = 33;

    pub fn mix_blend_mode(&self) -> u32 {
        self.mix_blend_mode.unwrap_or(0)
    }

    pub fn clear_mix_blend_mode(&mut self) {
        self.mix_blend_mode = ::std::option::Option::None;
    }

    pub fn has_mix_blend_mode(&self) -> bool {
        self.mix_blend_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mix_blend_mode(&mut self, v: u32) {
        self.mix_blend_mode = ::std::option::Option::Some(v);
    }

    // optional bool opaque_background = 34;

    pub fn opaque_background(&self) -> bool {
        self.opaque_background.unwrap_or(false)
    }

    pub fn clear_opaque_background(&mut self) {
        self.opaque_background = ::std::option::Option::None;
    }

    pub fn has_opaque_background(&self) -> bool {
        self.opaque_background.is_some()
    }

    // Param is passed by value, moved
    pub fn set_opaque_background(&mut self, v: bool) {
        self.opaque_background = ::std::option::Option::Some(v);
    }

    // optional uint32 child_panel_count = 35;

    pub fn child_panel_count(&self) -> u32 {
        self.child_panel_count.unwrap_or(0)
    }

    pub fn clear_child_panel_count(&mut self) {
        self.child_panel_count = ::std::option::Option::None;
    }

    pub fn has_child_panel_count(&self) -> bool {
        self.child_panel_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_child_panel_count(&mut self, v: u32) {
        self.child_panel_count = ::std::option::Option::Some(v);
    }

    // optional bool wants_screenspace_quad_output = 36;

    pub fn wants_screenspace_quad_output(&self) -> bool {
        self.wants_screenspace_quad_output.unwrap_or(false)
    }

    pub fn clear_wants_screenspace_quad_output(&mut self) {
        self.wants_screenspace_quad_output = ::std::option::Option::None;
    }

    pub fn has_wants_screenspace_quad_output(&self) -> bool {
        self.wants_screenspace_quad_output.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wants_screenspace_quad_output(&mut self, v: bool) {
        self.wants_screenspace_quad_output = ::std::option::Option::Some(v);
    }

    // optional string composition_layer_texture_name = 38;

    pub fn composition_layer_texture_name(&self) -> &str {
        match self.composition_layer_texture_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_composition_layer_texture_name(&mut self) {
        self.composition_layer_texture_name = ::std::option::Option::None;
    }

    pub fn has_composition_layer_texture_name(&self) -> bool {
        self.composition_layer_texture_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_composition_layer_texture_name(&mut self, v: ::std::string::String) {
        self.composition_layer_texture_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_composition_layer_texture_name(&mut self) -> &mut ::std::string::String {
        if self.composition_layer_texture_name.is_none() {
            self.composition_layer_texture_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.composition_layer_texture_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_composition_layer_texture_name(&mut self) -> ::std::string::String {
        self.composition_layer_texture_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgPushAAndTContext {
    const NAME: &'static str = "CMsgPushAAndTContext";

    fn is_initialized(&self) -> bool {
        for v in &self.panel_position {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transform_matrix {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transform_origin {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transform_perspective {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transform_perspective_origin {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.opacity {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.wash_color {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.hue_shift {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.saturation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.brightness {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.contrast {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.opacity_mask {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.border_radius {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.gaussian_blur {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.border {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.box_shadow {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.scale_2d_centered {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rotate_2d_centered {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.text_shadow {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.clip {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.motion_blur {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.context_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                25 => {
                    self.width = ::std::option::Option::Some(is.read_double()?);
                },
                33 => {
                    self.height = ::std::option::Option::Some(is.read_double()?);
                },
                40 => {
                    self.chilren_have_3dtransforms = ::std::option::Option::Some(is.read_bool()?);
                },
                53 => {
                    self.zindex = ::std::option::Option::Some(is.read_float()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.panel_position)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transform_matrix)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transform_origin)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transform_perspective)?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transform_perspective_origin)?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.opacity)?;
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.wash_color)?;
                },
                114 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.hue_shift)?;
                },
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.saturation)?;
                },
                130 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.brightness)?;
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contrast)?;
                },
                146 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.opacity_mask)?;
                },
                154 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.border_radius)?;
                },
                162 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.gaussian_blur)?;
                },
                170 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.border)?;
                },
                178 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.box_shadow)?;
                },
                186 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.scale_2d_centered)?;
                },
                194 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rotate_2d_centered)?;
                },
                202 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.text_shadow)?;
                },
                210 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.clip)?;
                },
                216 => {
                    self.suppress_clip_to_bounds = ::std::option::Option::Some(is.read_bool()?);
                },
                224 => {
                    self.needs_full_repaint = ::std::option::Option::Some(is.read_int32()?);
                },
                232 => {
                    self.needs_intermediate_texture = ::std::option::Option::Some(is.read_bool()?);
                },
                240 => {
                    self.clip_after_transform = ::std::option::Option::Some(is.read_bool()?);
                },
                248 => {
                    self.wants_hit_test = ::std::option::Option::Some(is.read_bool()?);
                },
                256 => {
                    self.wants_hit_test_children = ::std::option::Option::Some(is.read_bool()?);
                },
                264 => {
                    self.mix_blend_mode = ::std::option::Option::Some(is.read_uint32()?);
                },
                272 => {
                    self.opaque_background = ::std::option::Option::Some(is.read_bool()?);
                },
                280 => {
                    self.child_panel_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                288 => {
                    self.wants_screenspace_quad_output = ::std::option::Option::Some(is.read_bool()?);
                },
                298 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.motion_blur)?;
                },
                306 => {
                    self.composition_layer_texture_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.context_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.width {
            my_size += 1 + 8;
        }
        if let Some(v) = self.height {
            my_size += 1 + 8;
        }
        if let Some(v) = self.chilren_have_3dtransforms {
            my_size += 1 + 1;
        }
        if let Some(v) = self.zindex {
            my_size += 1 + 4;
        }
        if let Some(v) = self.panel_position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transform_matrix.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transform_origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transform_perspective.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transform_perspective_origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.opacity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.wash_color.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.hue_shift.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.saturation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.brightness.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.contrast.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.opacity_mask.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.border_radius.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.gaussian_blur.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.border.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.box_shadow.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.scale_2d_centered.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.rotate_2d_centered.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.text_shadow.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.clip.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.suppress_clip_to_bounds {
            my_size += 2 + 1;
        }
        if let Some(v) = self.needs_full_repaint {
            my_size += ::protobuf::rt::int32_size(28, v);
        }
        if let Some(v) = self.needs_intermediate_texture {
            my_size += 2 + 1;
        }
        if let Some(v) = self.clip_after_transform {
            my_size += 2 + 1;
        }
        if let Some(v) = self.wants_hit_test {
            my_size += 2 + 1;
        }
        if let Some(v) = self.wants_hit_test_children {
            my_size += 2 + 1;
        }
        if let Some(v) = self.mix_blend_mode {
            my_size += ::protobuf::rt::uint32_size(33, v);
        }
        if let Some(v) = self.opaque_background {
            my_size += 2 + 1;
        }
        if let Some(v) = self.child_panel_count {
            my_size += ::protobuf::rt::uint32_size(35, v);
        }
        if let Some(v) = self.wants_screenspace_quad_output {
            my_size += 2 + 1;
        }
        if let Some(v) = self.motion_blur.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.composition_layer_texture_name.as_ref() {
            my_size += ::protobuf::rt::string_size(38, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.context_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.width {
            os.write_double(3, v)?;
        }
        if let Some(v) = self.height {
            os.write_double(4, v)?;
        }
        if let Some(v) = self.chilren_have_3dtransforms {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.zindex {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.panel_position.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.transform_matrix.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.transform_origin.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.transform_perspective.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.transform_perspective_origin.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.opacity.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.wash_color.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if let Some(v) = self.hue_shift.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        if let Some(v) = self.saturation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if let Some(v) = self.brightness.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        }
        if let Some(v) = self.contrast.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.opacity_mask.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        }
        if let Some(v) = self.border_radius.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        }
        if let Some(v) = self.gaussian_blur.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        }
        if let Some(v) = self.border.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
        }
        if let Some(v) = self.box_shadow.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
        }
        if let Some(v) = self.scale_2d_centered.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
        }
        if let Some(v) = self.rotate_2d_centered.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        }
        if let Some(v) = self.text_shadow.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
        }
        if let Some(v) = self.clip.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
        }
        if let Some(v) = self.suppress_clip_to_bounds {
            os.write_bool(27, v)?;
        }
        if let Some(v) = self.needs_full_repaint {
            os.write_int32(28, v)?;
        }
        if let Some(v) = self.needs_intermediate_texture {
            os.write_bool(29, v)?;
        }
        if let Some(v) = self.clip_after_transform {
            os.write_bool(30, v)?;
        }
        if let Some(v) = self.wants_hit_test {
            os.write_bool(31, v)?;
        }
        if let Some(v) = self.wants_hit_test_children {
            os.write_bool(32, v)?;
        }
        if let Some(v) = self.mix_blend_mode {
            os.write_uint32(33, v)?;
        }
        if let Some(v) = self.opaque_background {
            os.write_bool(34, v)?;
        }
        if let Some(v) = self.child_panel_count {
            os.write_uint32(35, v)?;
        }
        if let Some(v) = self.wants_screenspace_quad_output {
            os.write_bool(36, v)?;
        }
        if let Some(v) = self.motion_blur.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(37, v, os)?;
        }
        if let Some(v) = self.composition_layer_texture_name.as_ref() {
            os.write_string(38, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPushAAndTContext {
        CMsgPushAAndTContext::new()
    }

    fn clear(&mut self) {
        self.context_id = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.chilren_have_3dtransforms = ::std::option::Option::None;
        self.zindex = ::std::option::Option::None;
        self.panel_position.clear();
        self.transform_matrix.clear();
        self.transform_origin.clear();
        self.transform_perspective.clear();
        self.transform_perspective_origin.clear();
        self.opacity.clear();
        self.wash_color.clear();
        self.hue_shift.clear();
        self.saturation.clear();
        self.brightness.clear();
        self.contrast.clear();
        self.opacity_mask.clear();
        self.border_radius.clear();
        self.gaussian_blur.clear();
        self.border.clear();
        self.box_shadow.clear();
        self.scale_2d_centered.clear();
        self.rotate_2d_centered.clear();
        self.text_shadow.clear();
        self.clip.clear();
        self.suppress_clip_to_bounds = ::std::option::Option::None;
        self.needs_full_repaint = ::std::option::Option::None;
        self.needs_intermediate_texture = ::std::option::Option::None;
        self.clip_after_transform = ::std::option::Option::None;
        self.wants_hit_test = ::std::option::Option::None;
        self.wants_hit_test_children = ::std::option::Option::None;
        self.mix_blend_mode = ::std::option::Option::None;
        self.opaque_background = ::std::option::Option::None;
        self.child_panel_count = ::std::option::Option::None;
        self.wants_screenspace_quad_output = ::std::option::Option::None;
        self.motion_blur.clear();
        self.composition_layer_texture_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPushAAndTContext {
        static instance: CMsgPushAAndTContext = CMsgPushAAndTContext {
            context_id: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            chilren_have_3dtransforms: ::std::option::Option::None,
            zindex: ::std::option::Option::None,
            panel_position: ::protobuf::MessageField::none(),
            transform_matrix: ::protobuf::MessageField::none(),
            transform_origin: ::protobuf::MessageField::none(),
            transform_perspective: ::protobuf::MessageField::none(),
            transform_perspective_origin: ::protobuf::MessageField::none(),
            opacity: ::protobuf::MessageField::none(),
            wash_color: ::protobuf::MessageField::none(),
            hue_shift: ::protobuf::MessageField::none(),
            saturation: ::protobuf::MessageField::none(),
            brightness: ::protobuf::MessageField::none(),
            contrast: ::protobuf::MessageField::none(),
            opacity_mask: ::protobuf::MessageField::none(),
            border_radius: ::protobuf::MessageField::none(),
            gaussian_blur: ::protobuf::MessageField::none(),
            border: ::protobuf::MessageField::none(),
            box_shadow: ::protobuf::MessageField::none(),
            scale_2d_centered: ::protobuf::MessageField::none(),
            rotate_2d_centered: ::protobuf::MessageField::none(),
            text_shadow: ::protobuf::MessageField::none(),
            clip: ::protobuf::MessageField::none(),
            suppress_clip_to_bounds: ::std::option::Option::None,
            needs_full_repaint: ::std::option::Option::None,
            needs_intermediate_texture: ::std::option::Option::None,
            clip_after_transform: ::std::option::Option::None,
            wants_hit_test: ::std::option::Option::None,
            wants_hit_test_children: ::std::option::Option::None,
            mix_blend_mode: ::std::option::Option::None,
            opaque_background: ::std::option::Option::None,
            child_panel_count: ::std::option::Option::None,
            wants_screenspace_quad_output: ::std::option::Option::None,
            motion_blur: ::protobuf::MessageField::none(),
            composition_layer_texture_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPopAAndTContext)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPopAAndTContext {
    // message fields
    // @@protoc_insertion_point(field:CMsgPopAAndTContext.context_id)
    pub context_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPopAAndTContext.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPopAAndTContext {
    fn default() -> &'a CMsgPopAAndTContext {
        <CMsgPopAAndTContext as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPopAAndTContext {
    pub fn new() -> CMsgPopAAndTContext {
        ::std::default::Default::default()
    }

    // optional uint64 context_id = 1;

    pub fn context_id(&self) -> u64 {
        self.context_id.unwrap_or(0)
    }

    pub fn clear_context_id(&mut self) {
        self.context_id = ::std::option::Option::None;
    }

    pub fn has_context_id(&self) -> bool {
        self.context_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context_id(&mut self, v: u64) {
        self.context_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgPopAAndTContext {
    const NAME: &'static str = "CMsgPopAAndTContext";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.context_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.context_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.context_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPopAAndTContext {
        CMsgPopAAndTContext::new()
    }

    fn clear(&mut self) {
        self.context_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPopAAndTContext {
        static instance: CMsgPopAAndTContext = CMsgPopAAndTContext {
            context_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgBeginPaintBackground)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBeginPaintBackground {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBeginPaintBackground.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBeginPaintBackground {
    fn default() -> &'a CMsgBeginPaintBackground {
        <CMsgBeginPaintBackground as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBeginPaintBackground {
    pub fn new() -> CMsgBeginPaintBackground {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgBeginPaintBackground {
    const NAME: &'static str = "CMsgBeginPaintBackground";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBeginPaintBackground {
        CMsgBeginPaintBackground::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBeginPaintBackground {
        static instance: CMsgBeginPaintBackground = CMsgBeginPaintBackground {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgEndPaintBackground)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgEndPaintBackground {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgEndPaintBackground.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgEndPaintBackground {
    fn default() -> &'a CMsgEndPaintBackground {
        <CMsgEndPaintBackground as ::protobuf::Message>::default_instance()
    }
}

impl CMsgEndPaintBackground {
    pub fn new() -> CMsgEndPaintBackground {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgEndPaintBackground {
    const NAME: &'static str = "CMsgEndPaintBackground";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgEndPaintBackground {
        CMsgEndPaintBackground::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgEndPaintBackground {
        static instance: CMsgEndPaintBackground = CMsgEndPaintBackground {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgBeginPaintLast)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBeginPaintLast {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBeginPaintLast.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBeginPaintLast {
    fn default() -> &'a CMsgBeginPaintLast {
        <CMsgBeginPaintLast as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBeginPaintLast {
    pub fn new() -> CMsgBeginPaintLast {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgBeginPaintLast {
    const NAME: &'static str = "CMsgBeginPaintLast";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBeginPaintLast {
        CMsgBeginPaintLast::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBeginPaintLast {
        static instance: CMsgBeginPaintLast = CMsgBeginPaintLast {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgEndPaintLast)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgEndPaintLast {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgEndPaintLast.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgEndPaintLast {
    fn default() -> &'a CMsgEndPaintLast {
        <CMsgEndPaintLast as ::protobuf::Message>::default_instance()
    }
}

impl CMsgEndPaintLast {
    pub fn new() -> CMsgEndPaintLast {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgEndPaintLast {
    const NAME: &'static str = "CMsgEndPaintLast";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgEndPaintLast {
        CMsgEndPaintLast::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgEndPaintLast {
        static instance: CMsgEndPaintLast = CMsgEndPaintLast {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDrawFilledRect)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDrawFilledRect {
    // message fields
    // @@protoc_insertion_point(field:CMsgDrawFilledRect.top_left)
    pub top_left: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgDrawFilledRect.bottom_right)
    pub bottom_right: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgDrawFilledRect.fill_brush_collection)
    pub fill_brush_collection: ::protobuf::MessageField<CMsgFillBrushCollection>,
    // @@protoc_insertion_point(field:CMsgDrawFilledRect.antialiasing)
    pub antialiasing: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDrawFilledRect.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDrawFilledRect {
    fn default() -> &'a CMsgDrawFilledRect {
        <CMsgDrawFilledRect as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDrawFilledRect {
    pub fn new() -> CMsgDrawFilledRect {
        ::std::default::Default::default()
    }

    // optional uint32 antialiasing = 4;

    pub fn antialiasing(&self) -> u32 {
        self.antialiasing.unwrap_or(0)
    }

    pub fn clear_antialiasing(&mut self) {
        self.antialiasing = ::std::option::Option::None;
    }

    pub fn has_antialiasing(&self) -> bool {
        self.antialiasing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_antialiasing(&mut self, v: u32) {
        self.antialiasing = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgDrawFilledRect {
    const NAME: &'static str = "CMsgDrawFilledRect";

    fn is_initialized(&self) -> bool {
        for v in &self.top_left {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bottom_right {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fill_brush_collection {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.top_left)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.bottom_right)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fill_brush_collection)?;
                },
                32 => {
                    self.antialiasing = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.top_left.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.bottom_right.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.fill_brush_collection.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.antialiasing {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.top_left.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.bottom_right.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.fill_brush_collection.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.antialiasing {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDrawFilledRect {
        CMsgDrawFilledRect::new()
    }

    fn clear(&mut self) {
        self.top_left.clear();
        self.bottom_right.clear();
        self.fill_brush_collection.clear();
        self.antialiasing = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDrawFilledRect {
        static instance: CMsgDrawFilledRect = CMsgDrawFilledRect {
            top_left: ::protobuf::MessageField::none(),
            bottom_right: ::protobuf::MessageField::none(),
            fill_brush_collection: ::protobuf::MessageField::none(),
            antialiasing: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgRenderFilledRect)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRenderFilledRect {
    // message fields
    // @@protoc_insertion_point(field:CMsgRenderFilledRect.top_left)
    pub top_left: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgRenderFilledRect.bottom_right)
    pub bottom_right: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgRenderFilledRect.fill_brush_collection)
    pub fill_brush_collection: ::protobuf::MessageField<CMsgRenderFillBrushCollection>,
    // @@protoc_insertion_point(field:CMsgRenderFilledRect.antialiasing)
    pub antialiasing: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRenderFilledRect.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRenderFilledRect {
    fn default() -> &'a CMsgRenderFilledRect {
        <CMsgRenderFilledRect as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRenderFilledRect {
    pub fn new() -> CMsgRenderFilledRect {
        ::std::default::Default::default()
    }

    // optional uint32 antialiasing = 4;

    pub fn antialiasing(&self) -> u32 {
        self.antialiasing.unwrap_or(0)
    }

    pub fn clear_antialiasing(&mut self) {
        self.antialiasing = ::std::option::Option::None;
    }

    pub fn has_antialiasing(&self) -> bool {
        self.antialiasing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_antialiasing(&mut self, v: u32) {
        self.antialiasing = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgRenderFilledRect {
    const NAME: &'static str = "CMsgRenderFilledRect";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.top_left)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.bottom_right)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fill_brush_collection)?;
                },
                32 => {
                    self.antialiasing = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.top_left.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.bottom_right.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.fill_brush_collection.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.antialiasing {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.top_left.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.bottom_right.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.fill_brush_collection.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.antialiasing {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRenderFilledRect {
        CMsgRenderFilledRect::new()
    }

    fn clear(&mut self) {
        self.top_left.clear();
        self.bottom_right.clear();
        self.fill_brush_collection.clear();
        self.antialiasing = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRenderFilledRect {
        static instance: CMsgRenderFilledRect = CMsgRenderFilledRect {
            top_left: ::protobuf::MessageField::none(),
            bottom_right: ::protobuf::MessageField::none(),
            fill_brush_collection: ::protobuf::MessageField::none(),
            antialiasing: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDrawTexturedRect)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDrawTexturedRect {
    // message fields
    // @@protoc_insertion_point(field:CMsgDrawTexturedRect.top_left)
    pub top_left: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgDrawTexturedRect.bottom_right)
    pub bottom_right: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgDrawTexturedRect.texture_id)
    pub texture_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDrawTexturedRect.texture_top_left)
    pub texture_top_left: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgDrawTexturedRect.texture_bottom_right)
    pub texture_bottom_right: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgDrawTexturedRect.texture_serial)
    pub texture_serial: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgDrawTexturedRect.texture_sample_mode)
    pub texture_sample_mode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDrawTexturedRect.texture_opacity)
    pub texture_opacity: ::protobuf::MessageField<CMsgOpacity>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDrawTexturedRect.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDrawTexturedRect {
    fn default() -> &'a CMsgDrawTexturedRect {
        <CMsgDrawTexturedRect as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDrawTexturedRect {
    pub fn new() -> CMsgDrawTexturedRect {
        ::std::default::Default::default()
    }

    // optional uint32 texture_id = 3;

    pub fn texture_id(&self) -> u32 {
        self.texture_id.unwrap_or(0)
    }

    pub fn clear_texture_id(&mut self) {
        self.texture_id = ::std::option::Option::None;
    }

    pub fn has_texture_id(&self) -> bool {
        self.texture_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_texture_id(&mut self, v: u32) {
        self.texture_id = ::std::option::Option::Some(v);
    }

    // optional int32 texture_serial = 6;

    pub fn texture_serial(&self) -> i32 {
        self.texture_serial.unwrap_or(0i32)
    }

    pub fn clear_texture_serial(&mut self) {
        self.texture_serial = ::std::option::Option::None;
    }

    pub fn has_texture_serial(&self) -> bool {
        self.texture_serial.is_some()
    }

    // Param is passed by value, moved
    pub fn set_texture_serial(&mut self, v: i32) {
        self.texture_serial = ::std::option::Option::Some(v);
    }

    // optional uint32 texture_sample_mode = 7;

    pub fn texture_sample_mode(&self) -> u32 {
        self.texture_sample_mode.unwrap_or(0u32)
    }

    pub fn clear_texture_sample_mode(&mut self) {
        self.texture_sample_mode = ::std::option::Option::None;
    }

    pub fn has_texture_sample_mode(&self) -> bool {
        self.texture_sample_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_texture_sample_mode(&mut self, v: u32) {
        self.texture_sample_mode = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgDrawTexturedRect {
    const NAME: &'static str = "CMsgDrawTexturedRect";

    fn is_initialized(&self) -> bool {
        for v in &self.top_left {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bottom_right {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.texture_top_left {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.texture_bottom_right {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.texture_opacity {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.top_left)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.bottom_right)?;
                },
                24 => {
                    self.texture_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.texture_top_left)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.texture_bottom_right)?;
                },
                48 => {
                    self.texture_serial = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.texture_sample_mode = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.texture_opacity)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.top_left.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.bottom_right.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.texture_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.texture_top_left.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.texture_bottom_right.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.texture_serial {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.texture_sample_mode {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.texture_opacity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.top_left.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.bottom_right.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.texture_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.texture_top_left.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.texture_bottom_right.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.texture_serial {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.texture_sample_mode {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.texture_opacity.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDrawTexturedRect {
        CMsgDrawTexturedRect::new()
    }

    fn clear(&mut self) {
        self.top_left.clear();
        self.bottom_right.clear();
        self.texture_id = ::std::option::Option::None;
        self.texture_top_left.clear();
        self.texture_bottom_right.clear();
        self.texture_serial = ::std::option::Option::None;
        self.texture_sample_mode = ::std::option::Option::None;
        self.texture_opacity.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDrawTexturedRect {
        static instance: CMsgDrawTexturedRect = CMsgDrawTexturedRect {
            top_left: ::protobuf::MessageField::none(),
            bottom_right: ::protobuf::MessageField::none(),
            texture_id: ::std::option::Option::None,
            texture_top_left: ::protobuf::MessageField::none(),
            texture_bottom_right: ::protobuf::MessageField::none(),
            texture_serial: ::std::option::Option::None,
            texture_sample_mode: ::std::option::Option::None,
            texture_opacity: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgRenderTexturedRect)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRenderTexturedRect {
    // message fields
    // @@protoc_insertion_point(field:CMsgRenderTexturedRect.top_left)
    pub top_left: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgRenderTexturedRect.bottom_right)
    pub bottom_right: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgRenderTexturedRect.texture_id)
    pub texture_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRenderTexturedRect.texture_top_left)
    pub texture_top_left: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgRenderTexturedRect.texture_bottom_right)
    pub texture_bottom_right: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgRenderTexturedRect.texture_serial)
    pub texture_serial: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgRenderTexturedRect.texture_sample_mode)
    pub texture_sample_mode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRenderTexturedRect.texture_opacity)
    pub texture_opacity: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRenderTexturedRect.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRenderTexturedRect {
    fn default() -> &'a CMsgRenderTexturedRect {
        <CMsgRenderTexturedRect as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRenderTexturedRect {
    pub fn new() -> CMsgRenderTexturedRect {
        ::std::default::Default::default()
    }

    // optional uint32 texture_id = 3;

    pub fn texture_id(&self) -> u32 {
        self.texture_id.unwrap_or(0)
    }

    pub fn clear_texture_id(&mut self) {
        self.texture_id = ::std::option::Option::None;
    }

    pub fn has_texture_id(&self) -> bool {
        self.texture_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_texture_id(&mut self, v: u32) {
        self.texture_id = ::std::option::Option::Some(v);
    }

    // optional int32 texture_serial = 6;

    pub fn texture_serial(&self) -> i32 {
        self.texture_serial.unwrap_or(0i32)
    }

    pub fn clear_texture_serial(&mut self) {
        self.texture_serial = ::std::option::Option::None;
    }

    pub fn has_texture_serial(&self) -> bool {
        self.texture_serial.is_some()
    }

    // Param is passed by value, moved
    pub fn set_texture_serial(&mut self, v: i32) {
        self.texture_serial = ::std::option::Option::Some(v);
    }

    // optional uint32 texture_sample_mode = 7;

    pub fn texture_sample_mode(&self) -> u32 {
        self.texture_sample_mode.unwrap_or(0u32)
    }

    pub fn clear_texture_sample_mode(&mut self) {
        self.texture_sample_mode = ::std::option::Option::None;
    }

    pub fn has_texture_sample_mode(&self) -> bool {
        self.texture_sample_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_texture_sample_mode(&mut self, v: u32) {
        self.texture_sample_mode = ::std::option::Option::Some(v);
    }

    // optional float texture_opacity = 8;

    pub fn texture_opacity(&self) -> f32 {
        self.texture_opacity.unwrap_or(1.0f32)
    }

    pub fn clear_texture_opacity(&mut self) {
        self.texture_opacity = ::std::option::Option::None;
    }

    pub fn has_texture_opacity(&self) -> bool {
        self.texture_opacity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_texture_opacity(&mut self, v: f32) {
        self.texture_opacity = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgRenderTexturedRect {
    const NAME: &'static str = "CMsgRenderTexturedRect";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.top_left)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.bottom_right)?;
                },
                24 => {
                    self.texture_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.texture_top_left)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.texture_bottom_right)?;
                },
                48 => {
                    self.texture_serial = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.texture_sample_mode = ::std::option::Option::Some(is.read_uint32()?);
                },
                69 => {
                    self.texture_opacity = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.top_left.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.bottom_right.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.texture_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.texture_top_left.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.texture_bottom_right.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.texture_serial {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.texture_sample_mode {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.texture_opacity {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.top_left.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.bottom_right.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.texture_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.texture_top_left.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.texture_bottom_right.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.texture_serial {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.texture_sample_mode {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.texture_opacity {
            os.write_float(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRenderTexturedRect {
        CMsgRenderTexturedRect::new()
    }

    fn clear(&mut self) {
        self.top_left.clear();
        self.bottom_right.clear();
        self.texture_id = ::std::option::Option::None;
        self.texture_top_left.clear();
        self.texture_bottom_right.clear();
        self.texture_serial = ::std::option::Option::None;
        self.texture_sample_mode = ::std::option::Option::None;
        self.texture_opacity = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRenderTexturedRect {
        static instance: CMsgRenderTexturedRect = CMsgRenderTexturedRect {
            top_left: ::protobuf::MessageField::none(),
            bottom_right: ::protobuf::MessageField::none(),
            texture_id: ::std::option::Option::None,
            texture_top_left: ::protobuf::MessageField::none(),
            texture_bottom_right: ::protobuf::MessageField::none(),
            texture_serial: ::std::option::Option::None,
            texture_sample_mode: ::std::option::Option::None,
            texture_opacity: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgLockTexture)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLockTexture {
    // message fields
    // @@protoc_insertion_point(field:CMsgLockTexture.texture_id)
    pub texture_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLockTexture.texture_serial)
    pub texture_serial: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLockTexture.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLockTexture {
    fn default() -> &'a CMsgLockTexture {
        <CMsgLockTexture as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLockTexture {
    pub fn new() -> CMsgLockTexture {
        ::std::default::Default::default()
    }

    // optional uint32 texture_id = 1;

    pub fn texture_id(&self) -> u32 {
        self.texture_id.unwrap_or(0)
    }

    pub fn clear_texture_id(&mut self) {
        self.texture_id = ::std::option::Option::None;
    }

    pub fn has_texture_id(&self) -> bool {
        self.texture_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_texture_id(&mut self, v: u32) {
        self.texture_id = ::std::option::Option::Some(v);
    }

    // optional int32 texture_serial = 2;

    pub fn texture_serial(&self) -> i32 {
        self.texture_serial.unwrap_or(0i32)
    }

    pub fn clear_texture_serial(&mut self) {
        self.texture_serial = ::std::option::Option::None;
    }

    pub fn has_texture_serial(&self) -> bool {
        self.texture_serial.is_some()
    }

    // Param is passed by value, moved
    pub fn set_texture_serial(&mut self, v: i32) {
        self.texture_serial = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgLockTexture {
    const NAME: &'static str = "CMsgLockTexture";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.texture_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.texture_serial = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.texture_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.texture_serial {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.texture_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.texture_serial {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLockTexture {
        CMsgLockTexture::new()
    }

    fn clear(&mut self) {
        self.texture_id = ::std::option::Option::None;
        self.texture_serial = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLockTexture {
        static instance: CMsgLockTexture = CMsgLockTexture {
            texture_id: ::std::option::Option::None,
            texture_serial: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTextInlineObject)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTextInlineObject {
    // message fields
    // @@protoc_insertion_point(field:CMsgTextInlineObject.width)
    pub width: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgTextInlineObject.height)
    pub height: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTextInlineObject.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTextInlineObject {
    fn default() -> &'a CMsgTextInlineObject {
        <CMsgTextInlineObject as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTextInlineObject {
    pub fn new() -> CMsgTextInlineObject {
        ::std::default::Default::default()
    }

    // optional float width = 1;

    pub fn width(&self) -> f32 {
        self.width.unwrap_or(0.)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: f32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional float height = 2;

    pub fn height(&self) -> f32 {
        self.height.unwrap_or(0.)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: f32) {
        self.height = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgTextInlineObject {
    const NAME: &'static str = "CMsgTextInlineObject";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.width = ::std::option::Option::Some(is.read_float()?);
                },
                21 => {
                    self.height = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.width {
            my_size += 1 + 4;
        }
        if let Some(v) = self.height {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.width {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.height {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTextInlineObject {
        CMsgTextInlineObject::new()
    }

    fn clear(&mut self) {
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTextInlineObject {
        static instance: CMsgTextInlineObject = CMsgTextInlineObject {
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTextFormat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTextFormat {
    // message fields
    // @@protoc_insertion_point(field:CMsgTextFormat.font_name)
    pub font_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgTextFormat.font_size)
    pub font_size: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgTextFormat.font_weight)
    pub font_weight: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgTextFormat.font_style)
    pub font_style: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgTextFormat.underline)
    pub underline: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgTextFormat.strikethrough)
    pub strikethrough: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgTextFormat.fill_brush_collection)
    pub fill_brush_collection: ::protobuf::MessageField<CMsgFillBrushCollection>,
    // @@protoc_insertion_point(field:CMsgTextFormat.letter_spacing)
    pub letter_spacing: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgTextFormat.inline_object)
    pub inline_object: ::protobuf::MessageField<CMsgTextInlineObject>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTextFormat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTextFormat {
    fn default() -> &'a CMsgTextFormat {
        <CMsgTextFormat as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTextFormat {
    pub fn new() -> CMsgTextFormat {
        ::std::default::Default::default()
    }

    // optional string font_name = 1;

    pub fn font_name(&self) -> &str {
        match self.font_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_font_name(&mut self) {
        self.font_name = ::std::option::Option::None;
    }

    pub fn has_font_name(&self) -> bool {
        self.font_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_font_name(&mut self, v: ::std::string::String) {
        self.font_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_font_name(&mut self) -> &mut ::std::string::String {
        if self.font_name.is_none() {
            self.font_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.font_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_font_name(&mut self) -> ::std::string::String {
        self.font_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional double font_size = 2;

    pub fn font_size(&self) -> f64 {
        self.font_size.unwrap_or(0.)
    }

    pub fn clear_font_size(&mut self) {
        self.font_size = ::std::option::Option::None;
    }

    pub fn has_font_size(&self) -> bool {
        self.font_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_font_size(&mut self, v: f64) {
        self.font_size = ::std::option::Option::Some(v);
    }

    // optional int32 font_weight = 3;

    pub fn font_weight(&self) -> i32 {
        self.font_weight.unwrap_or(-1i32)
    }

    pub fn clear_font_weight(&mut self) {
        self.font_weight = ::std::option::Option::None;
    }

    pub fn has_font_weight(&self) -> bool {
        self.font_weight.is_some()
    }

    // Param is passed by value, moved
    pub fn set_font_weight(&mut self, v: i32) {
        self.font_weight = ::std::option::Option::Some(v);
    }

    // optional int32 font_style = 4;

    pub fn font_style(&self) -> i32 {
        self.font_style.unwrap_or(-1i32)
    }

    pub fn clear_font_style(&mut self) {
        self.font_style = ::std::option::Option::None;
    }

    pub fn has_font_style(&self) -> bool {
        self.font_style.is_some()
    }

    // Param is passed by value, moved
    pub fn set_font_style(&mut self, v: i32) {
        self.font_style = ::std::option::Option::Some(v);
    }

    // optional bool underline = 5;

    pub fn underline(&self) -> bool {
        self.underline.unwrap_or(false)
    }

    pub fn clear_underline(&mut self) {
        self.underline = ::std::option::Option::None;
    }

    pub fn has_underline(&self) -> bool {
        self.underline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_underline(&mut self, v: bool) {
        self.underline = ::std::option::Option::Some(v);
    }

    // optional bool strikethrough = 6;

    pub fn strikethrough(&self) -> bool {
        self.strikethrough.unwrap_or(false)
    }

    pub fn clear_strikethrough(&mut self) {
        self.strikethrough = ::std::option::Option::None;
    }

    pub fn has_strikethrough(&self) -> bool {
        self.strikethrough.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strikethrough(&mut self, v: bool) {
        self.strikethrough = ::std::option::Option::Some(v);
    }

    // optional int32 letter_spacing = 8;

    pub fn letter_spacing(&self) -> i32 {
        self.letter_spacing.unwrap_or(0i32)
    }

    pub fn clear_letter_spacing(&mut self) {
        self.letter_spacing = ::std::option::Option::None;
    }

    pub fn has_letter_spacing(&self) -> bool {
        self.letter_spacing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_letter_spacing(&mut self, v: i32) {
        self.letter_spacing = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgTextFormat {
    const NAME: &'static str = "CMsgTextFormat";

    fn is_initialized(&self) -> bool {
        for v in &self.fill_brush_collection {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.inline_object {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.font_name = ::std::option::Option::Some(is.read_string()?);
                },
                17 => {
                    self.font_size = ::std::option::Option::Some(is.read_double()?);
                },
                24 => {
                    self.font_weight = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.font_style = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.underline = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.strikethrough = ::std::option::Option::Some(is.read_bool()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fill_brush_collection)?;
                },
                64 => {
                    self.letter_spacing = ::std::option::Option::Some(is.read_int32()?);
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.inline_object)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.font_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.font_size {
            my_size += 1 + 8;
        }
        if let Some(v) = self.font_weight {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.font_style {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.underline {
            my_size += 1 + 1;
        }
        if let Some(v) = self.strikethrough {
            my_size += 1 + 1;
        }
        if let Some(v) = self.fill_brush_collection.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.letter_spacing {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.inline_object.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.font_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.font_size {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.font_weight {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.font_style {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.underline {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.strikethrough {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.fill_brush_collection.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.letter_spacing {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.inline_object.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTextFormat {
        CMsgTextFormat::new()
    }

    fn clear(&mut self) {
        self.font_name = ::std::option::Option::None;
        self.font_size = ::std::option::Option::None;
        self.font_weight = ::std::option::Option::None;
        self.font_style = ::std::option::Option::None;
        self.underline = ::std::option::Option::None;
        self.strikethrough = ::std::option::Option::None;
        self.fill_brush_collection.clear();
        self.letter_spacing = ::std::option::Option::None;
        self.inline_object.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTextFormat {
        static instance: CMsgTextFormat = CMsgTextFormat {
            font_name: ::std::option::Option::None,
            font_size: ::std::option::Option::None,
            font_weight: ::std::option::Option::None,
            font_style: ::std::option::Option::None,
            underline: ::std::option::Option::None,
            strikethrough: ::std::option::Option::None,
            fill_brush_collection: ::protobuf::MessageField::none(),
            letter_spacing: ::std::option::Option::None,
            inline_object: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTextRangeFormat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTextRangeFormat {
    // message fields
    // @@protoc_insertion_point(field:CMsgTextRangeFormat.start_index)
    pub start_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTextRangeFormat.end_index)
    pub end_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTextRangeFormat.format)
    pub format: ::protobuf::MessageField<CMsgTextFormat>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTextRangeFormat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTextRangeFormat {
    fn default() -> &'a CMsgTextRangeFormat {
        <CMsgTextRangeFormat as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTextRangeFormat {
    pub fn new() -> CMsgTextRangeFormat {
        ::std::default::Default::default()
    }

    // optional uint32 start_index = 1;

    pub fn start_index(&self) -> u32 {
        self.start_index.unwrap_or(0)
    }

    pub fn clear_start_index(&mut self) {
        self.start_index = ::std::option::Option::None;
    }

    pub fn has_start_index(&self) -> bool {
        self.start_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_index(&mut self, v: u32) {
        self.start_index = ::std::option::Option::Some(v);
    }

    // optional uint32 end_index = 2;

    pub fn end_index(&self) -> u32 {
        self.end_index.unwrap_or(0)
    }

    pub fn clear_end_index(&mut self) {
        self.end_index = ::std::option::Option::None;
    }

    pub fn has_end_index(&self) -> bool {
        self.end_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_index(&mut self, v: u32) {
        self.end_index = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgTextRangeFormat {
    const NAME: &'static str = "CMsgTextRangeFormat";

    fn is_initialized(&self) -> bool {
        for v in &self.format {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.start_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.end_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.format)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.start_index {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.end_index {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.format.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.start_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.end_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.format.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTextRangeFormat {
        CMsgTextRangeFormat::new()
    }

    fn clear(&mut self) {
        self.start_index = ::std::option::Option::None;
        self.end_index = ::std::option::Option::None;
        self.format.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTextRangeFormat {
        static instance: CMsgTextRangeFormat = CMsgTextRangeFormat {
            start_index: ::std::option::Option::None,
            end_index: ::std::option::Option::None,
            format: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgRenderTextFormat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRenderTextFormat {
    // message fields
    // @@protoc_insertion_point(field:CMsgRenderTextFormat.font_name)
    pub font_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgRenderTextFormat.font_size)
    pub font_size: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgRenderTextFormat.font_weight)
    pub font_weight: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgRenderTextFormat.font_style)
    pub font_style: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgRenderTextFormat.underline)
    pub underline: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgRenderTextFormat.strikethrough)
    pub strikethrough: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgRenderTextFormat.fill_brush_collection)
    pub fill_brush_collection: ::protobuf::MessageField<CMsgRenderFillBrushCollection>,
    // @@protoc_insertion_point(field:CMsgRenderTextFormat.letter_spacing)
    pub letter_spacing: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgRenderTextFormat.inline_object)
    pub inline_object: ::protobuf::MessageField<CMsgTextInlineObject>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRenderTextFormat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRenderTextFormat {
    fn default() -> &'a CMsgRenderTextFormat {
        <CMsgRenderTextFormat as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRenderTextFormat {
    pub fn new() -> CMsgRenderTextFormat {
        ::std::default::Default::default()
    }

    // optional string font_name = 1;

    pub fn font_name(&self) -> &str {
        match self.font_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_font_name(&mut self) {
        self.font_name = ::std::option::Option::None;
    }

    pub fn has_font_name(&self) -> bool {
        self.font_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_font_name(&mut self, v: ::std::string::String) {
        self.font_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_font_name(&mut self) -> &mut ::std::string::String {
        if self.font_name.is_none() {
            self.font_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.font_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_font_name(&mut self) -> ::std::string::String {
        self.font_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional double font_size = 2;

    pub fn font_size(&self) -> f64 {
        self.font_size.unwrap_or(0.)
    }

    pub fn clear_font_size(&mut self) {
        self.font_size = ::std::option::Option::None;
    }

    pub fn has_font_size(&self) -> bool {
        self.font_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_font_size(&mut self, v: f64) {
        self.font_size = ::std::option::Option::Some(v);
    }

    // optional int32 font_weight = 3;

    pub fn font_weight(&self) -> i32 {
        self.font_weight.unwrap_or(-1i32)
    }

    pub fn clear_font_weight(&mut self) {
        self.font_weight = ::std::option::Option::None;
    }

    pub fn has_font_weight(&self) -> bool {
        self.font_weight.is_some()
    }

    // Param is passed by value, moved
    pub fn set_font_weight(&mut self, v: i32) {
        self.font_weight = ::std::option::Option::Some(v);
    }

    // optional int32 font_style = 4;

    pub fn font_style(&self) -> i32 {
        self.font_style.unwrap_or(-1i32)
    }

    pub fn clear_font_style(&mut self) {
        self.font_style = ::std::option::Option::None;
    }

    pub fn has_font_style(&self) -> bool {
        self.font_style.is_some()
    }

    // Param is passed by value, moved
    pub fn set_font_style(&mut self, v: i32) {
        self.font_style = ::std::option::Option::Some(v);
    }

    // optional bool underline = 5;

    pub fn underline(&self) -> bool {
        self.underline.unwrap_or(false)
    }

    pub fn clear_underline(&mut self) {
        self.underline = ::std::option::Option::None;
    }

    pub fn has_underline(&self) -> bool {
        self.underline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_underline(&mut self, v: bool) {
        self.underline = ::std::option::Option::Some(v);
    }

    // optional bool strikethrough = 6;

    pub fn strikethrough(&self) -> bool {
        self.strikethrough.unwrap_or(false)
    }

    pub fn clear_strikethrough(&mut self) {
        self.strikethrough = ::std::option::Option::None;
    }

    pub fn has_strikethrough(&self) -> bool {
        self.strikethrough.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strikethrough(&mut self, v: bool) {
        self.strikethrough = ::std::option::Option::Some(v);
    }

    // optional int32 letter_spacing = 8;

    pub fn letter_spacing(&self) -> i32 {
        self.letter_spacing.unwrap_or(0i32)
    }

    pub fn clear_letter_spacing(&mut self) {
        self.letter_spacing = ::std::option::Option::None;
    }

    pub fn has_letter_spacing(&self) -> bool {
        self.letter_spacing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_letter_spacing(&mut self, v: i32) {
        self.letter_spacing = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgRenderTextFormat {
    const NAME: &'static str = "CMsgRenderTextFormat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.font_name = ::std::option::Option::Some(is.read_string()?);
                },
                17 => {
                    self.font_size = ::std::option::Option::Some(is.read_double()?);
                },
                24 => {
                    self.font_weight = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.font_style = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.underline = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.strikethrough = ::std::option::Option::Some(is.read_bool()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fill_brush_collection)?;
                },
                64 => {
                    self.letter_spacing = ::std::option::Option::Some(is.read_int32()?);
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.inline_object)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.font_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.font_size {
            my_size += 1 + 8;
        }
        if let Some(v) = self.font_weight {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.font_style {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.underline {
            my_size += 1 + 1;
        }
        if let Some(v) = self.strikethrough {
            my_size += 1 + 1;
        }
        if let Some(v) = self.fill_brush_collection.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.letter_spacing {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.inline_object.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.font_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.font_size {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.font_weight {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.font_style {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.underline {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.strikethrough {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.fill_brush_collection.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.letter_spacing {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.inline_object.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRenderTextFormat {
        CMsgRenderTextFormat::new()
    }

    fn clear(&mut self) {
        self.font_name = ::std::option::Option::None;
        self.font_size = ::std::option::Option::None;
        self.font_weight = ::std::option::Option::None;
        self.font_style = ::std::option::Option::None;
        self.underline = ::std::option::Option::None;
        self.strikethrough = ::std::option::Option::None;
        self.fill_brush_collection.clear();
        self.letter_spacing = ::std::option::Option::None;
        self.inline_object.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRenderTextFormat {
        static instance: CMsgRenderTextFormat = CMsgRenderTextFormat {
            font_name: ::std::option::Option::None,
            font_size: ::std::option::Option::None,
            font_weight: ::std::option::Option::None,
            font_style: ::std::option::Option::None,
            underline: ::std::option::Option::None,
            strikethrough: ::std::option::Option::None,
            fill_brush_collection: ::protobuf::MessageField::none(),
            letter_spacing: ::std::option::Option::None,
            inline_object: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgRenderTextRangeFormat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRenderTextRangeFormat {
    // message fields
    // @@protoc_insertion_point(field:CMsgRenderTextRangeFormat.start_index)
    pub start_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRenderTextRangeFormat.end_index)
    pub end_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRenderTextRangeFormat.format)
    pub format: ::protobuf::MessageField<CMsgRenderTextFormat>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRenderTextRangeFormat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRenderTextRangeFormat {
    fn default() -> &'a CMsgRenderTextRangeFormat {
        <CMsgRenderTextRangeFormat as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRenderTextRangeFormat {
    pub fn new() -> CMsgRenderTextRangeFormat {
        ::std::default::Default::default()
    }

    // optional uint32 start_index = 1;

    pub fn start_index(&self) -> u32 {
        self.start_index.unwrap_or(0)
    }

    pub fn clear_start_index(&mut self) {
        self.start_index = ::std::option::Option::None;
    }

    pub fn has_start_index(&self) -> bool {
        self.start_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_index(&mut self, v: u32) {
        self.start_index = ::std::option::Option::Some(v);
    }

    // optional uint32 end_index = 2;

    pub fn end_index(&self) -> u32 {
        self.end_index.unwrap_or(0)
    }

    pub fn clear_end_index(&mut self) {
        self.end_index = ::std::option::Option::None;
    }

    pub fn has_end_index(&self) -> bool {
        self.end_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_index(&mut self, v: u32) {
        self.end_index = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgRenderTextRangeFormat {
    const NAME: &'static str = "CMsgRenderTextRangeFormat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.start_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.end_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.format)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.start_index {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.end_index {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.format.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.start_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.end_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.format.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRenderTextRangeFormat {
        CMsgRenderTextRangeFormat::new()
    }

    fn clear(&mut self) {
        self.start_index = ::std::option::Option::None;
        self.end_index = ::std::option::Option::None;
        self.format.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRenderTextRangeFormat {
        static instance: CMsgRenderTextRangeFormat = CMsgRenderTextRangeFormat {
            start_index: ::std::option::Option::None,
            end_index: ::std::option::Option::None,
            format: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDrawTextRegion)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDrawTextRegion {
    // message fields
    // @@protoc_insertion_point(field:CMsgDrawTextRegion.raw_text)
    pub raw_text: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgDrawTextRegion.text_chars)
    pub text_chars: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgDrawTextRegion.text_encoding)
    pub text_encoding: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgDrawTextRegion.default_format)
    pub default_format: ::protobuf::MessageField<CMsgTextFormat>,
    // @@protoc_insertion_point(field:CMsgDrawTextRegion.text_align)
    pub text_align: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDrawTextRegion.line_height)
    pub line_height: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDrawTextRegion.top_left)
    pub top_left: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgDrawTextRegion.bottom_right)
    pub bottom_right: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgDrawTextRegion.wrapping)
    pub wrapping: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDrawTextRegion.ellipsis)
    pub ellipsis: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDrawTextRegion.range_formats)
    pub range_formats: ::std::vec::Vec<CMsgTextRangeFormat>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDrawTextRegion.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDrawTextRegion {
    fn default() -> &'a CMsgDrawTextRegion {
        <CMsgDrawTextRegion as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDrawTextRegion {
    pub fn new() -> CMsgDrawTextRegion {
        ::std::default::Default::default()
    }

    // optional bytes raw_text = 11;

    pub fn raw_text(&self) -> &[u8] {
        match self.raw_text.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_raw_text(&mut self) {
        self.raw_text = ::std::option::Option::None;
    }

    pub fn has_raw_text(&self) -> bool {
        self.raw_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_text(&mut self, v: ::std::vec::Vec<u8>) {
        self.raw_text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_raw_text(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.raw_text.is_none() {
            self.raw_text = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.raw_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_raw_text(&mut self) -> ::std::vec::Vec<u8> {
        self.raw_text.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 text_chars = 12;

    pub fn text_chars(&self) -> i32 {
        self.text_chars.unwrap_or(0)
    }

    pub fn clear_text_chars(&mut self) {
        self.text_chars = ::std::option::Option::None;
    }

    pub fn has_text_chars(&self) -> bool {
        self.text_chars.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text_chars(&mut self, v: i32) {
        self.text_chars = ::std::option::Option::Some(v);
    }

    // optional int32 text_encoding = 13;

    pub fn text_encoding(&self) -> i32 {
        self.text_encoding.unwrap_or(0)
    }

    pub fn clear_text_encoding(&mut self) {
        self.text_encoding = ::std::option::Option::None;
    }

    pub fn has_text_encoding(&self) -> bool {
        self.text_encoding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text_encoding(&mut self, v: i32) {
        self.text_encoding = ::std::option::Option::Some(v);
    }

    // optional uint32 text_align = 4;

    pub fn text_align(&self) -> u32 {
        self.text_align.unwrap_or(0)
    }

    pub fn clear_text_align(&mut self) {
        self.text_align = ::std::option::Option::None;
    }

    pub fn has_text_align(&self) -> bool {
        self.text_align.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text_align(&mut self, v: u32) {
        self.text_align = ::std::option::Option::Some(v);
    }

    // optional uint32 line_height = 5;

    pub fn line_height(&self) -> u32 {
        self.line_height.unwrap_or(0)
    }

    pub fn clear_line_height(&mut self) {
        self.line_height = ::std::option::Option::None;
    }

    pub fn has_line_height(&self) -> bool {
        self.line_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_line_height(&mut self, v: u32) {
        self.line_height = ::std::option::Option::Some(v);
    }

    // optional bool wrapping = 8;

    pub fn wrapping(&self) -> bool {
        self.wrapping.unwrap_or(false)
    }

    pub fn clear_wrapping(&mut self) {
        self.wrapping = ::std::option::Option::None;
    }

    pub fn has_wrapping(&self) -> bool {
        self.wrapping.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wrapping(&mut self, v: bool) {
        self.wrapping = ::std::option::Option::Some(v);
    }

    // optional bool ellipsis = 9;

    pub fn ellipsis(&self) -> bool {
        self.ellipsis.unwrap_or(false)
    }

    pub fn clear_ellipsis(&mut self) {
        self.ellipsis = ::std::option::Option::None;
    }

    pub fn has_ellipsis(&self) -> bool {
        self.ellipsis.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ellipsis(&mut self, v: bool) {
        self.ellipsis = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgDrawTextRegion {
    const NAME: &'static str = "CMsgDrawTextRegion";

    fn is_initialized(&self) -> bool {
        for v in &self.default_format {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.top_left {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bottom_right {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.range_formats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                90 => {
                    self.raw_text = ::std::option::Option::Some(is.read_bytes()?);
                },
                96 => {
                    self.text_chars = ::std::option::Option::Some(is.read_int32()?);
                },
                104 => {
                    self.text_encoding = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.default_format)?;
                },
                32 => {
                    self.text_align = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.line_height = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.top_left)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.bottom_right)?;
                },
                64 => {
                    self.wrapping = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.ellipsis = ::std::option::Option::Some(is.read_bool()?);
                },
                82 => {
                    self.range_formats.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.raw_text.as_ref() {
            my_size += ::protobuf::rt::bytes_size(11, &v);
        }
        if let Some(v) = self.text_chars {
            my_size += ::protobuf::rt::int32_size(12, v);
        }
        if let Some(v) = self.text_encoding {
            my_size += ::protobuf::rt::int32_size(13, v);
        }
        if let Some(v) = self.default_format.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.text_align {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.line_height {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.top_left.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.bottom_right.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.wrapping {
            my_size += 1 + 1;
        }
        if let Some(v) = self.ellipsis {
            my_size += 1 + 1;
        }
        for value in &self.range_formats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.raw_text.as_ref() {
            os.write_bytes(11, v)?;
        }
        if let Some(v) = self.text_chars {
            os.write_int32(12, v)?;
        }
        if let Some(v) = self.text_encoding {
            os.write_int32(13, v)?;
        }
        if let Some(v) = self.default_format.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.text_align {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.line_height {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.top_left.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.bottom_right.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.wrapping {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.ellipsis {
            os.write_bool(9, v)?;
        }
        for v in &self.range_formats {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDrawTextRegion {
        CMsgDrawTextRegion::new()
    }

    fn clear(&mut self) {
        self.raw_text = ::std::option::Option::None;
        self.text_chars = ::std::option::Option::None;
        self.text_encoding = ::std::option::Option::None;
        self.default_format.clear();
        self.text_align = ::std::option::Option::None;
        self.line_height = ::std::option::Option::None;
        self.top_left.clear();
        self.bottom_right.clear();
        self.wrapping = ::std::option::Option::None;
        self.ellipsis = ::std::option::Option::None;
        self.range_formats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDrawTextRegion {
        static instance: CMsgDrawTextRegion = CMsgDrawTextRegion {
            raw_text: ::std::option::Option::None,
            text_chars: ::std::option::Option::None,
            text_encoding: ::std::option::Option::None,
            default_format: ::protobuf::MessageField::none(),
            text_align: ::std::option::Option::None,
            line_height: ::std::option::Option::None,
            top_left: ::protobuf::MessageField::none(),
            bottom_right: ::protobuf::MessageField::none(),
            wrapping: ::std::option::Option::None,
            ellipsis: ::std::option::Option::None,
            range_formats: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgRenderTextRegion)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRenderTextRegion {
    // message fields
    // @@protoc_insertion_point(field:CMsgRenderTextRegion.raw_text)
    pub raw_text: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgRenderTextRegion.text_chars)
    pub text_chars: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgRenderTextRegion.text_encoding)
    pub text_encoding: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgRenderTextRegion.default_format)
    pub default_format: ::protobuf::MessageField<CMsgRenderTextFormat>,
    // @@protoc_insertion_point(field:CMsgRenderTextRegion.text_align)
    pub text_align: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRenderTextRegion.line_height)
    pub line_height: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRenderTextRegion.top_left)
    pub top_left: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgRenderTextRegion.bottom_right)
    pub bottom_right: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgRenderTextRegion.wrapping)
    pub wrapping: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgRenderTextRegion.ellipsis)
    pub ellipsis: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgRenderTextRegion.range_formats)
    pub range_formats: ::std::vec::Vec<CMsgRenderTextRangeFormat>,
    // @@protoc_insertion_point(field:CMsgRenderTextRegion.text_shadow)
    pub text_shadow: ::protobuf::MessageField<CTextShadowData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRenderTextRegion.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRenderTextRegion {
    fn default() -> &'a CMsgRenderTextRegion {
        <CMsgRenderTextRegion as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRenderTextRegion {
    pub fn new() -> CMsgRenderTextRegion {
        ::std::default::Default::default()
    }

    // optional bytes raw_text = 12;

    pub fn raw_text(&self) -> &[u8] {
        match self.raw_text.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_raw_text(&mut self) {
        self.raw_text = ::std::option::Option::None;
    }

    pub fn has_raw_text(&self) -> bool {
        self.raw_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_text(&mut self, v: ::std::vec::Vec<u8>) {
        self.raw_text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_raw_text(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.raw_text.is_none() {
            self.raw_text = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.raw_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_raw_text(&mut self) -> ::std::vec::Vec<u8> {
        self.raw_text.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 text_chars = 13;

    pub fn text_chars(&self) -> i32 {
        self.text_chars.unwrap_or(0)
    }

    pub fn clear_text_chars(&mut self) {
        self.text_chars = ::std::option::Option::None;
    }

    pub fn has_text_chars(&self) -> bool {
        self.text_chars.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text_chars(&mut self, v: i32) {
        self.text_chars = ::std::option::Option::Some(v);
    }

    // optional int32 text_encoding = 14;

    pub fn text_encoding(&self) -> i32 {
        self.text_encoding.unwrap_or(0)
    }

    pub fn clear_text_encoding(&mut self) {
        self.text_encoding = ::std::option::Option::None;
    }

    pub fn has_text_encoding(&self) -> bool {
        self.text_encoding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text_encoding(&mut self, v: i32) {
        self.text_encoding = ::std::option::Option::Some(v);
    }

    // optional uint32 text_align = 4;

    pub fn text_align(&self) -> u32 {
        self.text_align.unwrap_or(0)
    }

    pub fn clear_text_align(&mut self) {
        self.text_align = ::std::option::Option::None;
    }

    pub fn has_text_align(&self) -> bool {
        self.text_align.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text_align(&mut self, v: u32) {
        self.text_align = ::std::option::Option::Some(v);
    }

    // optional uint32 line_height = 5;

    pub fn line_height(&self) -> u32 {
        self.line_height.unwrap_or(0)
    }

    pub fn clear_line_height(&mut self) {
        self.line_height = ::std::option::Option::None;
    }

    pub fn has_line_height(&self) -> bool {
        self.line_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_line_height(&mut self, v: u32) {
        self.line_height = ::std::option::Option::Some(v);
    }

    // optional bool wrapping = 8;

    pub fn wrapping(&self) -> bool {
        self.wrapping.unwrap_or(false)
    }

    pub fn clear_wrapping(&mut self) {
        self.wrapping = ::std::option::Option::None;
    }

    pub fn has_wrapping(&self) -> bool {
        self.wrapping.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wrapping(&mut self, v: bool) {
        self.wrapping = ::std::option::Option::Some(v);
    }

    // optional bool ellipsis = 9;

    pub fn ellipsis(&self) -> bool {
        self.ellipsis.unwrap_or(false)
    }

    pub fn clear_ellipsis(&mut self) {
        self.ellipsis = ::std::option::Option::None;
    }

    pub fn has_ellipsis(&self) -> bool {
        self.ellipsis.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ellipsis(&mut self, v: bool) {
        self.ellipsis = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgRenderTextRegion {
    const NAME: &'static str = "CMsgRenderTextRegion";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                98 => {
                    self.raw_text = ::std::option::Option::Some(is.read_bytes()?);
                },
                104 => {
                    self.text_chars = ::std::option::Option::Some(is.read_int32()?);
                },
                112 => {
                    self.text_encoding = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.default_format)?;
                },
                32 => {
                    self.text_align = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.line_height = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.top_left)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.bottom_right)?;
                },
                64 => {
                    self.wrapping = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.ellipsis = ::std::option::Option::Some(is.read_bool()?);
                },
                82 => {
                    self.range_formats.push(is.read_message()?);
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.text_shadow)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.raw_text.as_ref() {
            my_size += ::protobuf::rt::bytes_size(12, &v);
        }
        if let Some(v) = self.text_chars {
            my_size += ::protobuf::rt::int32_size(13, v);
        }
        if let Some(v) = self.text_encoding {
            my_size += ::protobuf::rt::int32_size(14, v);
        }
        if let Some(v) = self.default_format.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.text_align {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.line_height {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.top_left.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.bottom_right.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.wrapping {
            my_size += 1 + 1;
        }
        if let Some(v) = self.ellipsis {
            my_size += 1 + 1;
        }
        for value in &self.range_formats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.text_shadow.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.raw_text.as_ref() {
            os.write_bytes(12, v)?;
        }
        if let Some(v) = self.text_chars {
            os.write_int32(13, v)?;
        }
        if let Some(v) = self.text_encoding {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.default_format.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.text_align {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.line_height {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.top_left.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.bottom_right.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.wrapping {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.ellipsis {
            os.write_bool(9, v)?;
        }
        for v in &self.range_formats {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        if let Some(v) = self.text_shadow.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRenderTextRegion {
        CMsgRenderTextRegion::new()
    }

    fn clear(&mut self) {
        self.raw_text = ::std::option::Option::None;
        self.text_chars = ::std::option::Option::None;
        self.text_encoding = ::std::option::Option::None;
        self.default_format.clear();
        self.text_align = ::std::option::Option::None;
        self.line_height = ::std::option::Option::None;
        self.top_left.clear();
        self.bottom_right.clear();
        self.wrapping = ::std::option::Option::None;
        self.ellipsis = ::std::option::Option::None;
        self.range_formats.clear();
        self.text_shadow.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRenderTextRegion {
        static instance: CMsgRenderTextRegion = CMsgRenderTextRegion {
            raw_text: ::std::option::Option::None,
            text_chars: ::std::option::Option::None,
            text_encoding: ::std::option::Option::None,
            default_format: ::protobuf::MessageField::none(),
            text_align: ::std::option::Option::None,
            line_height: ::std::option::Option::None,
            top_left: ::protobuf::MessageField::none(),
            bottom_right: ::protobuf::MessageField::none(),
            wrapping: ::std::option::Option::None,
            ellipsis: ::std::option::Option::None,
            range_formats: ::std::vec::Vec::new(),
            text_shadow: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgRequestRenderCallback)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRequestRenderCallback {
    // message fields
    // @@protoc_insertion_point(field:CMsgRequestRenderCallback.callback_obj)
    pub callback_obj: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgRequestRenderCallback.top_left)
    pub top_left: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgRequestRenderCallback.bottom_right)
    pub bottom_right: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgRequestRenderCallback.top_left_padding)
    pub top_left_padding: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgRequestRenderCallback.bottom_right_padding)
    pub bottom_right_padding: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgRequestRenderCallback.needs_redraw_every_frame)
    pub needs_redraw_every_frame: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRequestRenderCallback.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRequestRenderCallback {
    fn default() -> &'a CMsgRequestRenderCallback {
        <CMsgRequestRenderCallback as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRequestRenderCallback {
    pub fn new() -> CMsgRequestRenderCallback {
        ::std::default::Default::default()
    }

    // optional bytes callback_obj = 1;

    pub fn callback_obj(&self) -> &[u8] {
        match self.callback_obj.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_callback_obj(&mut self) {
        self.callback_obj = ::std::option::Option::None;
    }

    pub fn has_callback_obj(&self) -> bool {
        self.callback_obj.is_some()
    }

    // Param is passed by value, moved
    pub fn set_callback_obj(&mut self, v: ::std::vec::Vec<u8>) {
        self.callback_obj = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_callback_obj(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.callback_obj.is_none() {
            self.callback_obj = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.callback_obj.as_mut().unwrap()
    }

    // Take field
    pub fn take_callback_obj(&mut self) -> ::std::vec::Vec<u8> {
        self.callback_obj.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool needs_redraw_every_frame = 6;

    pub fn needs_redraw_every_frame(&self) -> bool {
        self.needs_redraw_every_frame.unwrap_or(false)
    }

    pub fn clear_needs_redraw_every_frame(&mut self) {
        self.needs_redraw_every_frame = ::std::option::Option::None;
    }

    pub fn has_needs_redraw_every_frame(&self) -> bool {
        self.needs_redraw_every_frame.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needs_redraw_every_frame(&mut self, v: bool) {
        self.needs_redraw_every_frame = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgRequestRenderCallback {
    const NAME: &'static str = "CMsgRequestRenderCallback";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.callback_obj = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.top_left)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.bottom_right)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.top_left_padding)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.bottom_right_padding)?;
                },
                48 => {
                    self.needs_redraw_every_frame = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.callback_obj.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.top_left.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.bottom_right.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.top_left_padding.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.bottom_right_padding.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.needs_redraw_every_frame {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.callback_obj.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.top_left.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.bottom_right.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.top_left_padding.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.bottom_right_padding.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.needs_redraw_every_frame {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRequestRenderCallback {
        CMsgRequestRenderCallback::new()
    }

    fn clear(&mut self) {
        self.callback_obj = ::std::option::Option::None;
        self.top_left.clear();
        self.bottom_right.clear();
        self.top_left_padding.clear();
        self.bottom_right_padding.clear();
        self.needs_redraw_every_frame = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRequestRenderCallback {
        static instance: CMsgRequestRenderCallback = CMsgRequestRenderCallback {
            callback_obj: ::std::option::Option::None,
            top_left: ::protobuf::MessageField::none(),
            bottom_right: ::protobuf::MessageField::none(),
            top_left_padding: ::protobuf::MessageField::none(),
            bottom_right_padding: ::protobuf::MessageField::none(),
            needs_redraw_every_frame: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}
