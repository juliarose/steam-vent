// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_storebrowse.steamclient.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:StoreItemID)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StoreItemID {
    // message fields
    // @@protoc_insertion_point(field:StoreItemID.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:StoreItemID.packageid)
    pub packageid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:StoreItemID.bundleid)
    pub bundleid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:StoreItemID.tagid)
    pub tagid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:StoreItemID.creatorid)
    pub creatorid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:StoreItemID.hubcategoryid)
    pub hubcategoryid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:StoreItemID.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StoreItemID {
    fn default() -> &'a StoreItemID {
        <StoreItemID as ::protobuf::Message>::default_instance()
    }
}

impl StoreItemID {
    pub fn new() -> StoreItemID {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 packageid = 2;

    pub fn packageid(&self) -> u32 {
        self.packageid.unwrap_or(0)
    }

    pub fn clear_packageid(&mut self) {
        self.packageid = ::std::option::Option::None;
    }

    pub fn has_packageid(&self) -> bool {
        self.packageid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packageid(&mut self, v: u32) {
        self.packageid = ::std::option::Option::Some(v);
    }

    // optional uint32 bundleid = 3;

    pub fn bundleid(&self) -> u32 {
        self.bundleid.unwrap_or(0)
    }

    pub fn clear_bundleid(&mut self) {
        self.bundleid = ::std::option::Option::None;
    }

    pub fn has_bundleid(&self) -> bool {
        self.bundleid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bundleid(&mut self, v: u32) {
        self.bundleid = ::std::option::Option::Some(v);
    }

    // optional uint32 tagid = 4;

    pub fn tagid(&self) -> u32 {
        self.tagid.unwrap_or(0)
    }

    pub fn clear_tagid(&mut self) {
        self.tagid = ::std::option::Option::None;
    }

    pub fn has_tagid(&self) -> bool {
        self.tagid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tagid(&mut self, v: u32) {
        self.tagid = ::std::option::Option::Some(v);
    }

    // optional uint32 creatorid = 5;

    pub fn creatorid(&self) -> u32 {
        self.creatorid.unwrap_or(0)
    }

    pub fn clear_creatorid(&mut self) {
        self.creatorid = ::std::option::Option::None;
    }

    pub fn has_creatorid(&self) -> bool {
        self.creatorid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creatorid(&mut self, v: u32) {
        self.creatorid = ::std::option::Option::Some(v);
    }

    // optional uint32 hubcategoryid = 6;

    pub fn hubcategoryid(&self) -> u32 {
        self.hubcategoryid.unwrap_or(0)
    }

    pub fn clear_hubcategoryid(&mut self) {
        self.hubcategoryid = ::std::option::Option::None;
    }

    pub fn has_hubcategoryid(&self) -> bool {
        self.hubcategoryid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hubcategoryid(&mut self, v: u32) {
        self.hubcategoryid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for StoreItemID {
    const NAME: &'static str = "StoreItemID";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.packageid = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.bundleid = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.tagid = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.creatorid = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.hubcategoryid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.packageid {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.bundleid {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.tagid {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.creatorid {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.hubcategoryid {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.packageid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.bundleid {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.tagid {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.creatorid {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.hubcategoryid {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StoreItemID {
        StoreItemID::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.packageid = ::std::option::Option::None;
        self.bundleid = ::std::option::Option::None;
        self.tagid = ::std::option::Option::None;
        self.creatorid = ::std::option::Option::None;
        self.hubcategoryid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StoreItemID {
        static instance: StoreItemID = StoreItemID {
            appid: ::std::option::Option::None,
            packageid: ::std::option::Option::None,
            bundleid: ::std::option::Option::None,
            tagid: ::std::option::Option::None,
            creatorid: ::std::option::Option::None,
            hubcategoryid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:StoreBrowseContext)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StoreBrowseContext {
    // message fields
    // @@protoc_insertion_point(field:StoreBrowseContext.language)
    pub language: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:StoreBrowseContext.elanguage)
    pub elanguage: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:StoreBrowseContext.country_code)
    pub country_code: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:StoreBrowseContext.steam_realm)
    pub steam_realm: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:StoreBrowseContext.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StoreBrowseContext {
    fn default() -> &'a StoreBrowseContext {
        <StoreBrowseContext as ::protobuf::Message>::default_instance()
    }
}

impl StoreBrowseContext {
    pub fn new() -> StoreBrowseContext {
        ::std::default::Default::default()
    }

    // optional string language = 1;

    pub fn language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language = ::std::option::Option::Some(::std::string::String::new());
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 elanguage = 2;

    pub fn elanguage(&self) -> i32 {
        self.elanguage.unwrap_or(0)
    }

    pub fn clear_elanguage(&mut self) {
        self.elanguage = ::std::option::Option::None;
    }

    pub fn has_elanguage(&self) -> bool {
        self.elanguage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_elanguage(&mut self, v: i32) {
        self.elanguage = ::std::option::Option::Some(v);
    }

    // optional string country_code = 3;

    pub fn country_code(&self) -> &str {
        match self.country_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_country_code(&mut self) {
        self.country_code = ::std::option::Option::None;
    }

    pub fn has_country_code(&self) -> bool {
        self.country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country_code(&mut self, v: ::std::string::String) {
        self.country_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_code(&mut self) -> &mut ::std::string::String {
        if self.country_code.is_none() {
            self.country_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_country_code(&mut self) -> ::std::string::String {
        self.country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 steam_realm = 4;

    pub fn steam_realm(&self) -> i32 {
        self.steam_realm.unwrap_or(0)
    }

    pub fn clear_steam_realm(&mut self) {
        self.steam_realm = ::std::option::Option::None;
    }

    pub fn has_steam_realm(&self) -> bool {
        self.steam_realm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_realm(&mut self, v: i32) {
        self.steam_realm = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for StoreBrowseContext {
    const NAME: &'static str = "StoreBrowseContext";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.language = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.elanguage = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.country_code = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.steam_realm = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.language.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.elanguage {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.country_code.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.steam_realm {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.language.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.elanguage {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.country_code.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.steam_realm {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StoreBrowseContext {
        StoreBrowseContext::new()
    }

    fn clear(&mut self) {
        self.language = ::std::option::Option::None;
        self.elanguage = ::std::option::Option::None;
        self.country_code = ::std::option::Option::None;
        self.steam_realm = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StoreBrowseContext {
        static instance: StoreBrowseContext = StoreBrowseContext {
            language: ::std::option::Option::None,
            elanguage: ::std::option::Option::None,
            country_code: ::std::option::Option::None,
            steam_realm: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:StoreBrowseItemDataRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StoreBrowseItemDataRequest {
    // message fields
    // @@protoc_insertion_point(field:StoreBrowseItemDataRequest.include_assets)
    pub include_assets: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:StoreBrowseItemDataRequest.include_release)
    pub include_release: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:StoreBrowseItemDataRequest.include_platforms)
    pub include_platforms: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:StoreBrowseItemDataRequest.include_all_purchase_options)
    pub include_all_purchase_options: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:StoreBrowseItemDataRequest.include_screenshots)
    pub include_screenshots: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:StoreBrowseItemDataRequest.include_trailers)
    pub include_trailers: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:StoreBrowseItemDataRequest.include_ratings)
    pub include_ratings: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:StoreBrowseItemDataRequest.include_tag_count)
    pub include_tag_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:StoreBrowseItemDataRequest.include_reviews)
    pub include_reviews: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:StoreBrowseItemDataRequest.include_basic_info)
    pub include_basic_info: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:StoreBrowseItemDataRequest.include_supported_languages)
    pub include_supported_languages: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:StoreBrowseItemDataRequest.include_full_description)
    pub include_full_description: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:StoreBrowseItemDataRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StoreBrowseItemDataRequest {
    fn default() -> &'a StoreBrowseItemDataRequest {
        <StoreBrowseItemDataRequest as ::protobuf::Message>::default_instance()
    }
}

impl StoreBrowseItemDataRequest {
    pub fn new() -> StoreBrowseItemDataRequest {
        ::std::default::Default::default()
    }

    // optional bool include_assets = 1;

    pub fn include_assets(&self) -> bool {
        self.include_assets.unwrap_or(false)
    }

    pub fn clear_include_assets(&mut self) {
        self.include_assets = ::std::option::Option::None;
    }

    pub fn has_include_assets(&self) -> bool {
        self.include_assets.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_assets(&mut self, v: bool) {
        self.include_assets = ::std::option::Option::Some(v);
    }

    // optional bool include_release = 2;

    pub fn include_release(&self) -> bool {
        self.include_release.unwrap_or(false)
    }

    pub fn clear_include_release(&mut self) {
        self.include_release = ::std::option::Option::None;
    }

    pub fn has_include_release(&self) -> bool {
        self.include_release.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_release(&mut self, v: bool) {
        self.include_release = ::std::option::Option::Some(v);
    }

    // optional bool include_platforms = 3;

    pub fn include_platforms(&self) -> bool {
        self.include_platforms.unwrap_or(false)
    }

    pub fn clear_include_platforms(&mut self) {
        self.include_platforms = ::std::option::Option::None;
    }

    pub fn has_include_platforms(&self) -> bool {
        self.include_platforms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_platforms(&mut self, v: bool) {
        self.include_platforms = ::std::option::Option::Some(v);
    }

    // optional bool include_all_purchase_options = 4;

    pub fn include_all_purchase_options(&self) -> bool {
        self.include_all_purchase_options.unwrap_or(false)
    }

    pub fn clear_include_all_purchase_options(&mut self) {
        self.include_all_purchase_options = ::std::option::Option::None;
    }

    pub fn has_include_all_purchase_options(&self) -> bool {
        self.include_all_purchase_options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_all_purchase_options(&mut self, v: bool) {
        self.include_all_purchase_options = ::std::option::Option::Some(v);
    }

    // optional bool include_screenshots = 5;

    pub fn include_screenshots(&self) -> bool {
        self.include_screenshots.unwrap_or(false)
    }

    pub fn clear_include_screenshots(&mut self) {
        self.include_screenshots = ::std::option::Option::None;
    }

    pub fn has_include_screenshots(&self) -> bool {
        self.include_screenshots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_screenshots(&mut self, v: bool) {
        self.include_screenshots = ::std::option::Option::Some(v);
    }

    // optional bool include_trailers = 6;

    pub fn include_trailers(&self) -> bool {
        self.include_trailers.unwrap_or(false)
    }

    pub fn clear_include_trailers(&mut self) {
        self.include_trailers = ::std::option::Option::None;
    }

    pub fn has_include_trailers(&self) -> bool {
        self.include_trailers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_trailers(&mut self, v: bool) {
        self.include_trailers = ::std::option::Option::Some(v);
    }

    // optional bool include_ratings = 7;

    pub fn include_ratings(&self) -> bool {
        self.include_ratings.unwrap_or(false)
    }

    pub fn clear_include_ratings(&mut self) {
        self.include_ratings = ::std::option::Option::None;
    }

    pub fn has_include_ratings(&self) -> bool {
        self.include_ratings.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_ratings(&mut self, v: bool) {
        self.include_ratings = ::std::option::Option::Some(v);
    }

    // optional int32 include_tag_count = 8;

    pub fn include_tag_count(&self) -> i32 {
        self.include_tag_count.unwrap_or(0)
    }

    pub fn clear_include_tag_count(&mut self) {
        self.include_tag_count = ::std::option::Option::None;
    }

    pub fn has_include_tag_count(&self) -> bool {
        self.include_tag_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_tag_count(&mut self, v: i32) {
        self.include_tag_count = ::std::option::Option::Some(v);
    }

    // optional bool include_reviews = 9;

    pub fn include_reviews(&self) -> bool {
        self.include_reviews.unwrap_or(false)
    }

    pub fn clear_include_reviews(&mut self) {
        self.include_reviews = ::std::option::Option::None;
    }

    pub fn has_include_reviews(&self) -> bool {
        self.include_reviews.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_reviews(&mut self, v: bool) {
        self.include_reviews = ::std::option::Option::Some(v);
    }

    // optional bool include_basic_info = 10;

    pub fn include_basic_info(&self) -> bool {
        self.include_basic_info.unwrap_or(false)
    }

    pub fn clear_include_basic_info(&mut self) {
        self.include_basic_info = ::std::option::Option::None;
    }

    pub fn has_include_basic_info(&self) -> bool {
        self.include_basic_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_basic_info(&mut self, v: bool) {
        self.include_basic_info = ::std::option::Option::Some(v);
    }

    // optional bool include_supported_languages = 11;

    pub fn include_supported_languages(&self) -> bool {
        self.include_supported_languages.unwrap_or(false)
    }

    pub fn clear_include_supported_languages(&mut self) {
        self.include_supported_languages = ::std::option::Option::None;
    }

    pub fn has_include_supported_languages(&self) -> bool {
        self.include_supported_languages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_supported_languages(&mut self, v: bool) {
        self.include_supported_languages = ::std::option::Option::Some(v);
    }

    // optional bool include_full_description = 12;

    pub fn include_full_description(&self) -> bool {
        self.include_full_description.unwrap_or(false)
    }

    pub fn clear_include_full_description(&mut self) {
        self.include_full_description = ::std::option::Option::None;
    }

    pub fn has_include_full_description(&self) -> bool {
        self.include_full_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_full_description(&mut self, v: bool) {
        self.include_full_description = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for StoreBrowseItemDataRequest {
    const NAME: &'static str = "StoreBrowseItemDataRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.include_assets = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.include_release = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.include_platforms = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.include_all_purchase_options = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.include_screenshots = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.include_trailers = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.include_ratings = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.include_tag_count = ::std::option::Option::Some(is.read_int32()?);
                },
                72 => {
                    self.include_reviews = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.include_basic_info = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.include_supported_languages = ::std::option::Option::Some(is.read_bool()?);
                },
                96 => {
                    self.include_full_description = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.include_assets {
            my_size += 1 + 1;
        }
        if let Some(v) = self.include_release {
            my_size += 1 + 1;
        }
        if let Some(v) = self.include_platforms {
            my_size += 1 + 1;
        }
        if let Some(v) = self.include_all_purchase_options {
            my_size += 1 + 1;
        }
        if let Some(v) = self.include_screenshots {
            my_size += 1 + 1;
        }
        if let Some(v) = self.include_trailers {
            my_size += 1 + 1;
        }
        if let Some(v) = self.include_ratings {
            my_size += 1 + 1;
        }
        if let Some(v) = self.include_tag_count {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.include_reviews {
            my_size += 1 + 1;
        }
        if let Some(v) = self.include_basic_info {
            my_size += 1 + 1;
        }
        if let Some(v) = self.include_supported_languages {
            my_size += 1 + 1;
        }
        if let Some(v) = self.include_full_description {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.include_assets {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.include_release {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.include_platforms {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.include_all_purchase_options {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.include_screenshots {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.include_trailers {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.include_ratings {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.include_tag_count {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.include_reviews {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.include_basic_info {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.include_supported_languages {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.include_full_description {
            os.write_bool(12, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StoreBrowseItemDataRequest {
        StoreBrowseItemDataRequest::new()
    }

    fn clear(&mut self) {
        self.include_assets = ::std::option::Option::None;
        self.include_release = ::std::option::Option::None;
        self.include_platforms = ::std::option::Option::None;
        self.include_all_purchase_options = ::std::option::Option::None;
        self.include_screenshots = ::std::option::Option::None;
        self.include_trailers = ::std::option::Option::None;
        self.include_ratings = ::std::option::Option::None;
        self.include_tag_count = ::std::option::Option::None;
        self.include_reviews = ::std::option::Option::None;
        self.include_basic_info = ::std::option::Option::None;
        self.include_supported_languages = ::std::option::Option::None;
        self.include_full_description = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StoreBrowseItemDataRequest {
        static instance: StoreBrowseItemDataRequest = StoreBrowseItemDataRequest {
            include_assets: ::std::option::Option::None,
            include_release: ::std::option::Option::None,
            include_platforms: ::std::option::Option::None,
            include_all_purchase_options: ::std::option::Option::None,
            include_screenshots: ::std::option::Option::None,
            include_trailers: ::std::option::Option::None,
            include_ratings: ::std::option::Option::None,
            include_tag_count: ::std::option::Option::None,
            include_reviews: ::std::option::Option::None,
            include_basic_info: ::std::option::Option::None,
            include_supported_languages: ::std::option::Option::None,
            include_full_description: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Get information about items on the store"]
// @@protoc_insertion_point(message:CStoreBrowse_GetItems_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStoreBrowse_GetItems_Request {
    // message fields
    // @@protoc_insertion_point(field:CStoreBrowse_GetItems_Request.ids)
    pub ids: ::std::vec::Vec<StoreItemID>,
    // @@protoc_insertion_point(field:CStoreBrowse_GetItems_Request.context)
    pub context: ::protobuf::MessageField<StoreBrowseContext>,
    // @@protoc_insertion_point(field:CStoreBrowse_GetItems_Request.data_request)
    pub data_request: ::protobuf::MessageField<StoreBrowseItemDataRequest>,
    // special fields
    // @@protoc_insertion_point(special_field:CStoreBrowse_GetItems_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStoreBrowse_GetItems_Request {
    fn default() -> &'a CStoreBrowse_GetItems_Request {
        <CStoreBrowse_GetItems_Request as ::protobuf::Message>::default_instance()
    }
}

impl CStoreBrowse_GetItems_Request {
    pub fn new() -> CStoreBrowse_GetItems_Request {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CStoreBrowse_GetItems_Request {
    const NAME: &'static str = "CStoreBrowse_GetItems_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.ids.push(is.read_message()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.context)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data_request)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.ids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.data_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.ids {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.context.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.data_request.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStoreBrowse_GetItems_Request {
        CStoreBrowse_GetItems_Request::new()
    }

    fn clear(&mut self) {
        self.ids.clear();
        self.context.clear();
        self.data_request.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStoreBrowse_GetItems_Request {
        static instance: CStoreBrowse_GetItems_Request = CStoreBrowse_GetItems_Request {
            ids: ::std::vec::Vec::new(),
            context: ::protobuf::MessageField::none(),
            data_request: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:StoreGameRating)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StoreGameRating {
    // message fields
    // @@protoc_insertion_point(field:StoreGameRating.type)
    pub type_: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:StoreGameRating.rating)
    pub rating: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:StoreGameRating.descriptors)
    pub descriptors: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:StoreGameRating.interactive_elements)
    pub interactive_elements: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:StoreGameRating.required_age)
    pub required_age: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:StoreGameRating.use_age_gate)
    pub use_age_gate: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:StoreGameRating.image_url)
    pub image_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:StoreGameRating.image_target)
    pub image_target: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:StoreGameRating.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StoreGameRating {
    fn default() -> &'a StoreGameRating {
        <StoreGameRating as ::protobuf::Message>::default_instance()
    }
}

impl StoreGameRating {
    pub fn new() -> StoreGameRating {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string rating = 2;

    pub fn rating(&self) -> &str {
        match self.rating.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_rating(&mut self) {
        self.rating = ::std::option::Option::None;
    }

    pub fn has_rating(&self) -> bool {
        self.rating.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rating(&mut self, v: ::std::string::String) {
        self.rating = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rating(&mut self) -> &mut ::std::string::String {
        if self.rating.is_none() {
            self.rating = ::std::option::Option::Some(::std::string::String::new());
        }
        self.rating.as_mut().unwrap()
    }

    // Take field
    pub fn take_rating(&mut self) -> ::std::string::String {
        self.rating.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string interactive_elements = 4;

    pub fn interactive_elements(&self) -> &str {
        match self.interactive_elements.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_interactive_elements(&mut self) {
        self.interactive_elements = ::std::option::Option::None;
    }

    pub fn has_interactive_elements(&self) -> bool {
        self.interactive_elements.is_some()
    }

    // Param is passed by value, moved
    pub fn set_interactive_elements(&mut self, v: ::std::string::String) {
        self.interactive_elements = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_interactive_elements(&mut self) -> &mut ::std::string::String {
        if self.interactive_elements.is_none() {
            self.interactive_elements = ::std::option::Option::Some(::std::string::String::new());
        }
        self.interactive_elements.as_mut().unwrap()
    }

    // Take field
    pub fn take_interactive_elements(&mut self) -> ::std::string::String {
        self.interactive_elements.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 required_age = 10;

    pub fn required_age(&self) -> i32 {
        self.required_age.unwrap_or(0)
    }

    pub fn clear_required_age(&mut self) {
        self.required_age = ::std::option::Option::None;
    }

    pub fn has_required_age(&self) -> bool {
        self.required_age.is_some()
    }

    // Param is passed by value, moved
    pub fn set_required_age(&mut self, v: i32) {
        self.required_age = ::std::option::Option::Some(v);
    }

    // optional bool use_age_gate = 11;

    pub fn use_age_gate(&self) -> bool {
        self.use_age_gate.unwrap_or(false)
    }

    pub fn clear_use_age_gate(&mut self) {
        self.use_age_gate = ::std::option::Option::None;
    }

    pub fn has_use_age_gate(&self) -> bool {
        self.use_age_gate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_age_gate(&mut self, v: bool) {
        self.use_age_gate = ::std::option::Option::Some(v);
    }

    // optional string image_url = 20;

    pub fn image_url(&self) -> &str {
        match self.image_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_image_url(&mut self) {
        self.image_url = ::std::option::Option::None;
    }

    pub fn has_image_url(&self) -> bool {
        self.image_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image_url(&mut self, v: ::std::string::String) {
        self.image_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image_url(&mut self) -> &mut ::std::string::String {
        if self.image_url.is_none() {
            self.image_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.image_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_image_url(&mut self) -> ::std::string::String {
        self.image_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string image_target = 21;

    pub fn image_target(&self) -> &str {
        match self.image_target.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_image_target(&mut self) {
        self.image_target = ::std::option::Option::None;
    }

    pub fn has_image_target(&self) -> bool {
        self.image_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image_target(&mut self, v: ::std::string::String) {
        self.image_target = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image_target(&mut self) -> &mut ::std::string::String {
        if self.image_target.is_none() {
            self.image_target = ::std::option::Option::Some(::std::string::String::new());
        }
        self.image_target.as_mut().unwrap()
    }

    // Take field
    pub fn take_image_target(&mut self) -> ::std::string::String {
        self.image_target.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for StoreGameRating {
    const NAME: &'static str = "StoreGameRating";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.rating = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.descriptors.push(is.read_string()?);
                },
                34 => {
                    self.interactive_elements = ::std::option::Option::Some(is.read_string()?);
                },
                80 => {
                    self.required_age = ::std::option::Option::Some(is.read_int32()?);
                },
                88 => {
                    self.use_age_gate = ::std::option::Option::Some(is.read_bool()?);
                },
                162 => {
                    self.image_url = ::std::option::Option::Some(is.read_string()?);
                },
                170 => {
                    self.image_target = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.rating.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.descriptors {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if let Some(v) = self.interactive_elements.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.required_age {
            my_size += ::protobuf::rt::int32_size(10, v);
        }
        if let Some(v) = self.use_age_gate {
            my_size += 1 + 1;
        }
        if let Some(v) = self.image_url.as_ref() {
            my_size += ::protobuf::rt::string_size(20, &v);
        }
        if let Some(v) = self.image_target.as_ref() {
            my_size += ::protobuf::rt::string_size(21, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.rating.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.descriptors {
            os.write_string(3, &v)?;
        };
        if let Some(v) = self.interactive_elements.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.required_age {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.use_age_gate {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.image_url.as_ref() {
            os.write_string(20, v)?;
        }
        if let Some(v) = self.image_target.as_ref() {
            os.write_string(21, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StoreGameRating {
        StoreGameRating::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.rating = ::std::option::Option::None;
        self.descriptors.clear();
        self.interactive_elements = ::std::option::Option::None;
        self.required_age = ::std::option::Option::None;
        self.use_age_gate = ::std::option::Option::None;
        self.image_url = ::std::option::Option::None;
        self.image_target = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StoreGameRating {
        static instance: StoreGameRating = StoreGameRating {
            type_: ::std::option::Option::None,
            rating: ::std::option::Option::None,
            descriptors: ::std::vec::Vec::new(),
            interactive_elements: ::std::option::Option::None,
            required_age: ::std::option::Option::None,
            use_age_gate: ::std::option::Option::None,
            image_url: ::std::option::Option::None,
            image_target: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:StoreItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StoreItem {
    // message fields
    // @@protoc_insertion_point(field:StoreItem.item_type)
    pub item_type: ::std::option::Option<::protobuf::EnumOrUnknown<EStoreItemType>>,
    // @@protoc_insertion_point(field:StoreItem.id)
    pub id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:StoreItem.success)
    pub success: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:StoreItem.visible)
    pub visible: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:StoreItem.unvailable_for_country_restriction)
    pub unvailable_for_country_restriction: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:StoreItem.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:StoreItem.store_url_path)
    pub store_url_path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:StoreItem.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:StoreItem.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<EStoreAppType>>,
    // @@protoc_insertion_point(field:StoreItem.included_types)
    pub included_types: ::std::vec::Vec<::protobuf::EnumOrUnknown<EStoreAppType>>,
    // @@protoc_insertion_point(field:StoreItem.included_appids)
    pub included_appids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:StoreItem.is_free)
    pub is_free: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:StoreItem.is_early_access)
    pub is_early_access: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:StoreItem.related_items)
    pub related_items: ::protobuf::MessageField<store_item::RelatedItems>,
    // @@protoc_insertion_point(field:StoreItem.content_descriptorids)
    pub content_descriptorids: ::std::vec::Vec<::protobuf::EnumOrUnknown<super::enums_productinfo::EContentDescriptorID>>,
    // @@protoc_insertion_point(field:StoreItem.tagids)
    pub tagids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:StoreItem.categories)
    pub categories: ::protobuf::MessageField<store_item::Categories>,
    // @@protoc_insertion_point(field:StoreItem.reviews)
    pub reviews: ::protobuf::MessageField<store_item::Reviews>,
    // @@protoc_insertion_point(field:StoreItem.basic_info)
    pub basic_info: ::protobuf::MessageField<store_item::BasicInfo>,
    // @@protoc_insertion_point(field:StoreItem.tags)
    pub tags: ::std::vec::Vec<store_item::Tag>,
    // @@protoc_insertion_point(field:StoreItem.assets)
    pub assets: ::protobuf::MessageField<store_item::Assets>,
    // @@protoc_insertion_point(field:StoreItem.release)
    pub release: ::protobuf::MessageField<store_item::ReleaseInfo>,
    // @@protoc_insertion_point(field:StoreItem.platforms)
    pub platforms: ::protobuf::MessageField<store_item::Platforms>,
    // @@protoc_insertion_point(field:StoreItem.game_rating)
    pub game_rating: ::protobuf::MessageField<StoreGameRating>,
    // @@protoc_insertion_point(field:StoreItem.best_purchase_option)
    pub best_purchase_option: ::protobuf::MessageField<store_item::PurchaseOption>,
    // @@protoc_insertion_point(field:StoreItem.purchase_options)
    pub purchase_options: ::std::vec::Vec<store_item::PurchaseOption>,
    // @@protoc_insertion_point(field:StoreItem.accessories)
    pub accessories: ::std::vec::Vec<store_item::PurchaseOption>,
    // @@protoc_insertion_point(field:StoreItem.screenshots)
    pub screenshots: ::protobuf::MessageField<store_item::Screenshots>,
    // @@protoc_insertion_point(field:StoreItem.trailers)
    pub trailers: ::protobuf::MessageField<store_item::Trailers>,
    // @@protoc_insertion_point(field:StoreItem.supported_languages)
    pub supported_languages: ::std::vec::Vec<store_item::SupportedLanguage>,
    // @@protoc_insertion_point(field:StoreItem.store_url_path_override)
    pub store_url_path_override: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:StoreItem.free_weekend)
    pub free_weekend: ::protobuf::MessageField<store_item::FreeWeekend>,
    // @@protoc_insertion_point(field:StoreItem.unlisted)
    pub unlisted: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:StoreItem.game_count)
    pub game_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:StoreItem.internal_name)
    pub internal_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:StoreItem.full_description)
    pub full_description: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:StoreItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StoreItem {
    fn default() -> &'a StoreItem {
        <StoreItem as ::protobuf::Message>::default_instance()
    }
}

impl StoreItem {
    pub fn new() -> StoreItem {
        ::std::default::Default::default()
    }

    // optional .EStoreItemType item_type = 1;

    pub fn item_type(&self) -> EStoreItemType {
        match self.item_type {
            Some(e) => e.enum_value_or(EStoreItemType::k_EStoreItemType_Invalid),
            None => EStoreItemType::k_EStoreItemType_Invalid,
        }
    }

    pub fn clear_item_type(&mut self) {
        self.item_type = ::std::option::Option::None;
    }

    pub fn has_item_type(&self) -> bool {
        self.item_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_type(&mut self, v: EStoreItemType) {
        self.item_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 id = 2;

    pub fn id(&self) -> u32 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional uint32 success = 3;

    pub fn success(&self) -> u32 {
        self.success.unwrap_or(0)
    }

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: u32) {
        self.success = ::std::option::Option::Some(v);
    }

    // optional bool visible = 4;

    pub fn visible(&self) -> bool {
        self.visible.unwrap_or(false)
    }

    pub fn clear_visible(&mut self) {
        self.visible = ::std::option::Option::None;
    }

    pub fn has_visible(&self) -> bool {
        self.visible.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visible(&mut self, v: bool) {
        self.visible = ::std::option::Option::Some(v);
    }

    // optional bool unvailable_for_country_restriction = 5;

    pub fn unvailable_for_country_restriction(&self) -> bool {
        self.unvailable_for_country_restriction.unwrap_or(false)
    }

    pub fn clear_unvailable_for_country_restriction(&mut self) {
        self.unvailable_for_country_restriction = ::std::option::Option::None;
    }

    pub fn has_unvailable_for_country_restriction(&self) -> bool {
        self.unvailable_for_country_restriction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unvailable_for_country_restriction(&mut self, v: bool) {
        self.unvailable_for_country_restriction = ::std::option::Option::Some(v);
    }

    // optional string name = 6;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string store_url_path = 7;

    pub fn store_url_path(&self) -> &str {
        match self.store_url_path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_store_url_path(&mut self) {
        self.store_url_path = ::std::option::Option::None;
    }

    pub fn has_store_url_path(&self) -> bool {
        self.store_url_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_store_url_path(&mut self, v: ::std::string::String) {
        self.store_url_path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_store_url_path(&mut self) -> &mut ::std::string::String {
        if self.store_url_path.is_none() {
            self.store_url_path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.store_url_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_store_url_path(&mut self) -> ::std::string::String {
        self.store_url_path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 appid = 9;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional .EStoreAppType type = 10;

    pub fn type_(&self) -> EStoreAppType {
        match self.type_ {
            Some(e) => e.enum_value_or(EStoreAppType::k_EStoreAppType_Game),
            None => EStoreAppType::k_EStoreAppType_Game,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: EStoreAppType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool is_free = 13;

    pub fn is_free(&self) -> bool {
        self.is_free.unwrap_or(false)
    }

    pub fn clear_is_free(&mut self) {
        self.is_free = ::std::option::Option::None;
    }

    pub fn has_is_free(&self) -> bool {
        self.is_free.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_free(&mut self, v: bool) {
        self.is_free = ::std::option::Option::Some(v);
    }

    // optional bool is_early_access = 14;

    pub fn is_early_access(&self) -> bool {
        self.is_early_access.unwrap_or(false)
    }

    pub fn clear_is_early_access(&mut self) {
        self.is_early_access = ::std::option::Option::None;
    }

    pub fn has_is_early_access(&self) -> bool {
        self.is_early_access.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_early_access(&mut self, v: bool) {
        self.is_early_access = ::std::option::Option::Some(v);
    }

    // optional string store_url_path_override = 53;

    pub fn store_url_path_override(&self) -> &str {
        match self.store_url_path_override.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_store_url_path_override(&mut self) {
        self.store_url_path_override = ::std::option::Option::None;
    }

    pub fn has_store_url_path_override(&self) -> bool {
        self.store_url_path_override.is_some()
    }

    // Param is passed by value, moved
    pub fn set_store_url_path_override(&mut self, v: ::std::string::String) {
        self.store_url_path_override = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_store_url_path_override(&mut self) -> &mut ::std::string::String {
        if self.store_url_path_override.is_none() {
            self.store_url_path_override = ::std::option::Option::Some(::std::string::String::new());
        }
        self.store_url_path_override.as_mut().unwrap()
    }

    // Take field
    pub fn take_store_url_path_override(&mut self) -> ::std::string::String {
        self.store_url_path_override.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool unlisted = 55;

    pub fn unlisted(&self) -> bool {
        self.unlisted.unwrap_or(false)
    }

    pub fn clear_unlisted(&mut self) {
        self.unlisted = ::std::option::Option::None;
    }

    pub fn has_unlisted(&self) -> bool {
        self.unlisted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unlisted(&mut self, v: bool) {
        self.unlisted = ::std::option::Option::Some(v);
    }

    // optional uint32 game_count = 56;

    pub fn game_count(&self) -> u32 {
        self.game_count.unwrap_or(0)
    }

    pub fn clear_game_count(&mut self) {
        self.game_count = ::std::option::Option::None;
    }

    pub fn has_game_count(&self) -> bool {
        self.game_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_count(&mut self, v: u32) {
        self.game_count = ::std::option::Option::Some(v);
    }

    // optional string internal_name = 57;

    pub fn internal_name(&self) -> &str {
        match self.internal_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_internal_name(&mut self) {
        self.internal_name = ::std::option::Option::None;
    }

    pub fn has_internal_name(&self) -> bool {
        self.internal_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_internal_name(&mut self, v: ::std::string::String) {
        self.internal_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_internal_name(&mut self) -> &mut ::std::string::String {
        if self.internal_name.is_none() {
            self.internal_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.internal_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_internal_name(&mut self) -> ::std::string::String {
        self.internal_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string full_description = 58;

    pub fn full_description(&self) -> &str {
        match self.full_description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_full_description(&mut self) {
        self.full_description = ::std::option::Option::None;
    }

    pub fn has_full_description(&self) -> bool {
        self.full_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_full_description(&mut self, v: ::std::string::String) {
        self.full_description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_full_description(&mut self) -> &mut ::std::string::String {
        if self.full_description.is_none() {
            self.full_description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.full_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_full_description(&mut self) -> ::std::string::String {
        self.full_description.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for StoreItem {
    const NAME: &'static str = "StoreItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.success = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.visible = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.unvailable_for_country_restriction = ::std::option::Option::Some(is.read_bool()?);
                },
                50 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.store_url_path = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                88 => {
                    self.included_types.push(is.read_enum_or_unknown()?);
                },
                90 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.included_types)?
                },
                98 => {
                    is.read_repeated_packed_uint32_into(&mut self.included_appids)?;
                },
                96 => {
                    self.included_appids.push(is.read_uint32()?);
                },
                104 => {
                    self.is_free = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.is_early_access = ::std::option::Option::Some(is.read_bool()?);
                },
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.related_items)?;
                },
                160 => {
                    self.content_descriptorids.push(is.read_enum_or_unknown()?);
                },
                162 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.content_descriptorids)?
                },
                170 => {
                    is.read_repeated_packed_uint32_into(&mut self.tagids)?;
                },
                168 => {
                    self.tagids.push(is.read_uint32()?);
                },
                178 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.categories)?;
                },
                186 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.reviews)?;
                },
                194 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.basic_info)?;
                },
                202 => {
                    self.tags.push(is.read_message()?);
                },
                242 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.assets)?;
                },
                250 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.release)?;
                },
                258 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.platforms)?;
                },
                266 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.game_rating)?;
                },
                322 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.best_purchase_option)?;
                },
                330 => {
                    self.purchase_options.push(is.read_message()?);
                },
                338 => {
                    self.accessories.push(is.read_message()?);
                },
                402 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.screenshots)?;
                },
                410 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.trailers)?;
                },
                418 => {
                    self.supported_languages.push(is.read_message()?);
                },
                426 => {
                    self.store_url_path_override = ::std::option::Option::Some(is.read_string()?);
                },
                434 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.free_weekend)?;
                },
                440 => {
                    self.unlisted = ::std::option::Option::Some(is.read_bool()?);
                },
                448 => {
                    self.game_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                458 => {
                    self.internal_name = ::std::option::Option::Some(is.read_string()?);
                },
                466 => {
                    self.full_description = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_type {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.success {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.visible {
            my_size += 1 + 1;
        }
        if let Some(v) = self.unvailable_for_country_restriction {
            my_size += 1 + 1;
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.store_url_path.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(10, v.value());
        }
        for value in &self.included_types {
            my_size += ::protobuf::rt::int32_size(11, value.value());
        };
        for value in &self.included_appids {
            my_size += ::protobuf::rt::uint32_size(12, *value);
        };
        if let Some(v) = self.is_free {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_early_access {
            my_size += 1 + 1;
        }
        if let Some(v) = self.related_items.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.content_descriptorids {
            my_size += ::protobuf::rt::int32_size(20, value.value());
        };
        for value in &self.tagids {
            my_size += ::protobuf::rt::uint32_size(21, *value);
        };
        if let Some(v) = self.categories.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.reviews.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.basic_info.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.tags {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.assets.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.release.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.platforms.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.game_rating.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.best_purchase_option.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.purchase_options {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.accessories {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.screenshots.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.trailers.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.supported_languages {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.store_url_path_override.as_ref() {
            my_size += ::protobuf::rt::string_size(53, &v);
        }
        if let Some(v) = self.free_weekend.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.unlisted {
            my_size += 2 + 1;
        }
        if let Some(v) = self.game_count {
            my_size += ::protobuf::rt::uint32_size(56, v);
        }
        if let Some(v) = self.internal_name.as_ref() {
            my_size += ::protobuf::rt::string_size(57, &v);
        }
        if let Some(v) = self.full_description.as_ref() {
            my_size += ::protobuf::rt::string_size(58, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_type {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.success {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.visible {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.unvailable_for_country_restriction {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.store_url_path.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(10, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.included_types {
            os.write_enum(11, ::protobuf::EnumOrUnknown::value(v))?;
        };
        for v in &self.included_appids {
            os.write_uint32(12, *v)?;
        };
        if let Some(v) = self.is_free {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.is_early_access {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.related_items.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        for v in &self.content_descriptorids {
            os.write_enum(20, ::protobuf::EnumOrUnknown::value(v))?;
        };
        for v in &self.tagids {
            os.write_uint32(21, *v)?;
        };
        if let Some(v) = self.categories.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
        }
        if let Some(v) = self.reviews.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
        }
        if let Some(v) = self.basic_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        }
        for v in &self.tags {
            ::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
        };
        if let Some(v) = self.assets.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(30, v, os)?;
        }
        if let Some(v) = self.release.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(31, v, os)?;
        }
        if let Some(v) = self.platforms.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(32, v, os)?;
        }
        if let Some(v) = self.game_rating.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(33, v, os)?;
        }
        if let Some(v) = self.best_purchase_option.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(40, v, os)?;
        }
        for v in &self.purchase_options {
            ::protobuf::rt::write_message_field_with_cached_size(41, v, os)?;
        };
        for v in &self.accessories {
            ::protobuf::rt::write_message_field_with_cached_size(42, v, os)?;
        };
        if let Some(v) = self.screenshots.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(50, v, os)?;
        }
        if let Some(v) = self.trailers.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(51, v, os)?;
        }
        for v in &self.supported_languages {
            ::protobuf::rt::write_message_field_with_cached_size(52, v, os)?;
        };
        if let Some(v) = self.store_url_path_override.as_ref() {
            os.write_string(53, v)?;
        }
        if let Some(v) = self.free_weekend.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(54, v, os)?;
        }
        if let Some(v) = self.unlisted {
            os.write_bool(55, v)?;
        }
        if let Some(v) = self.game_count {
            os.write_uint32(56, v)?;
        }
        if let Some(v) = self.internal_name.as_ref() {
            os.write_string(57, v)?;
        }
        if let Some(v) = self.full_description.as_ref() {
            os.write_string(58, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StoreItem {
        StoreItem::new()
    }

    fn clear(&mut self) {
        self.item_type = ::std::option::Option::None;
        self.id = ::std::option::Option::None;
        self.success = ::std::option::Option::None;
        self.visible = ::std::option::Option::None;
        self.unvailable_for_country_restriction = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.store_url_path = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.included_types.clear();
        self.included_appids.clear();
        self.is_free = ::std::option::Option::None;
        self.is_early_access = ::std::option::Option::None;
        self.related_items.clear();
        self.content_descriptorids.clear();
        self.tagids.clear();
        self.categories.clear();
        self.reviews.clear();
        self.basic_info.clear();
        self.tags.clear();
        self.assets.clear();
        self.release.clear();
        self.platforms.clear();
        self.game_rating.clear();
        self.best_purchase_option.clear();
        self.purchase_options.clear();
        self.accessories.clear();
        self.screenshots.clear();
        self.trailers.clear();
        self.supported_languages.clear();
        self.store_url_path_override = ::std::option::Option::None;
        self.free_weekend.clear();
        self.unlisted = ::std::option::Option::None;
        self.game_count = ::std::option::Option::None;
        self.internal_name = ::std::option::Option::None;
        self.full_description = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StoreItem {
        static instance: StoreItem = StoreItem {
            item_type: ::std::option::Option::None,
            id: ::std::option::Option::None,
            success: ::std::option::Option::None,
            visible: ::std::option::Option::None,
            unvailable_for_country_restriction: ::std::option::Option::None,
            name: ::std::option::Option::None,
            store_url_path: ::std::option::Option::None,
            appid: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            included_types: ::std::vec::Vec::new(),
            included_appids: ::std::vec::Vec::new(),
            is_free: ::std::option::Option::None,
            is_early_access: ::std::option::Option::None,
            related_items: ::protobuf::MessageField::none(),
            content_descriptorids: ::std::vec::Vec::new(),
            tagids: ::std::vec::Vec::new(),
            categories: ::protobuf::MessageField::none(),
            reviews: ::protobuf::MessageField::none(),
            basic_info: ::protobuf::MessageField::none(),
            tags: ::std::vec::Vec::new(),
            assets: ::protobuf::MessageField::none(),
            release: ::protobuf::MessageField::none(),
            platforms: ::protobuf::MessageField::none(),
            game_rating: ::protobuf::MessageField::none(),
            best_purchase_option: ::protobuf::MessageField::none(),
            purchase_options: ::std::vec::Vec::new(),
            accessories: ::std::vec::Vec::new(),
            screenshots: ::protobuf::MessageField::none(),
            trailers: ::protobuf::MessageField::none(),
            supported_languages: ::std::vec::Vec::new(),
            store_url_path_override: ::std::option::Option::None,
            free_weekend: ::protobuf::MessageField::none(),
            unlisted: ::std::option::Option::None,
            game_count: ::std::option::Option::None,
            internal_name: ::std::option::Option::None,
            full_description: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `StoreItem`
pub mod store_item {
    // @@protoc_insertion_point(message:StoreItem.RelatedItems)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RelatedItems {
        // message fields
        // @@protoc_insertion_point(field:StoreItem.RelatedItems.parent_appid)
        pub parent_appid: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:StoreItem.RelatedItems.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RelatedItems {
        fn default() -> &'a RelatedItems {
            <RelatedItems as ::protobuf::Message>::default_instance()
        }
    }

    impl RelatedItems {
        pub fn new() -> RelatedItems {
            ::std::default::Default::default()
        }

        // optional uint32 parent_appid = 1;

        pub fn parent_appid(&self) -> u32 {
            self.parent_appid.unwrap_or(0)
        }

        pub fn clear_parent_appid(&mut self) {
            self.parent_appid = ::std::option::Option::None;
        }

        pub fn has_parent_appid(&self) -> bool {
            self.parent_appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_parent_appid(&mut self, v: u32) {
            self.parent_appid = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for RelatedItems {
        const NAME: &'static str = "RelatedItems";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.parent_appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.parent_appid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.parent_appid {
                os.write_uint32(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RelatedItems {
            RelatedItems::new()
        }

        fn clear(&mut self) {
            self.parent_appid = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RelatedItems {
            static instance: RelatedItems = RelatedItems {
                parent_appid: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:StoreItem.Categories)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Categories {
        // message fields
        // @@protoc_insertion_point(field:StoreItem.Categories.supported_player_categoryids)
        pub supported_player_categoryids: ::std::vec::Vec<u32>,
        // @@protoc_insertion_point(field:StoreItem.Categories.feature_categoryids)
        pub feature_categoryids: ::std::vec::Vec<u32>,
        // @@protoc_insertion_point(field:StoreItem.Categories.controller_categoryids)
        pub controller_categoryids: ::std::vec::Vec<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:StoreItem.Categories.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Categories {
        fn default() -> &'a Categories {
            <Categories as ::protobuf::Message>::default_instance()
        }
    }

    impl Categories {
        pub fn new() -> Categories {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for Categories {
        const NAME: &'static str = "Categories";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    18 => {
                        is.read_repeated_packed_uint32_into(&mut self.supported_player_categoryids)?;
                    },
                    16 => {
                        self.supported_player_categoryids.push(is.read_uint32()?);
                    },
                    26 => {
                        is.read_repeated_packed_uint32_into(&mut self.feature_categoryids)?;
                    },
                    24 => {
                        self.feature_categoryids.push(is.read_uint32()?);
                    },
                    34 => {
                        is.read_repeated_packed_uint32_into(&mut self.controller_categoryids)?;
                    },
                    32 => {
                        self.controller_categoryids.push(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.supported_player_categoryids {
                my_size += ::protobuf::rt::uint32_size(2, *value);
            };
            for value in &self.feature_categoryids {
                my_size += ::protobuf::rt::uint32_size(3, *value);
            };
            for value in &self.controller_categoryids {
                my_size += ::protobuf::rt::uint32_size(4, *value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.supported_player_categoryids {
                os.write_uint32(2, *v)?;
            };
            for v in &self.feature_categoryids {
                os.write_uint32(3, *v)?;
            };
            for v in &self.controller_categoryids {
                os.write_uint32(4, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Categories {
            Categories::new()
        }

        fn clear(&mut self) {
            self.supported_player_categoryids.clear();
            self.feature_categoryids.clear();
            self.controller_categoryids.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Categories {
            static instance: Categories = Categories {
                supported_player_categoryids: ::std::vec::Vec::new(),
                feature_categoryids: ::std::vec::Vec::new(),
                controller_categoryids: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:StoreItem.Reviews)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Reviews {
        // message fields
        // @@protoc_insertion_point(field:StoreItem.Reviews.summary_filtered)
        pub summary_filtered: ::protobuf::MessageField<reviews::StoreReviewSummary>,
        // @@protoc_insertion_point(field:StoreItem.Reviews.summary_unfiltered)
        pub summary_unfiltered: ::protobuf::MessageField<reviews::StoreReviewSummary>,
        // special fields
        // @@protoc_insertion_point(special_field:StoreItem.Reviews.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Reviews {
        fn default() -> &'a Reviews {
            <Reviews as ::protobuf::Message>::default_instance()
        }
    }

    impl Reviews {
        pub fn new() -> Reviews {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for Reviews {
        const NAME: &'static str = "Reviews";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.summary_filtered)?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.summary_unfiltered)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.summary_filtered.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.summary_unfiltered.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.summary_filtered.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if let Some(v) = self.summary_unfiltered.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Reviews {
            Reviews::new()
        }

        fn clear(&mut self) {
            self.summary_filtered.clear();
            self.summary_unfiltered.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Reviews {
            static instance: Reviews = Reviews {
                summary_filtered: ::protobuf::MessageField::none(),
                summary_unfiltered: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `Reviews`
    pub mod reviews {
        // @@protoc_insertion_point(message:StoreItem.Reviews.StoreReviewSummary)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct StoreReviewSummary {
            // message fields
            // @@protoc_insertion_point(field:StoreItem.Reviews.StoreReviewSummary.review_count)
            pub review_count: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:StoreItem.Reviews.StoreReviewSummary.percent_positive)
            pub percent_positive: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:StoreItem.Reviews.StoreReviewSummary.review_score)
            pub review_score: ::std::option::Option<::protobuf::EnumOrUnknown<super::super::EUserReviewScore>>,
            // @@protoc_insertion_point(field:StoreItem.Reviews.StoreReviewSummary.review_score_label)
            pub review_score_label: ::std::option::Option<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:StoreItem.Reviews.StoreReviewSummary.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a StoreReviewSummary {
            fn default() -> &'a StoreReviewSummary {
                <StoreReviewSummary as ::protobuf::Message>::default_instance()
            }
        }

        impl StoreReviewSummary {
            pub fn new() -> StoreReviewSummary {
                ::std::default::Default::default()
            }

            // optional uint32 review_count = 1;

            pub fn review_count(&self) -> u32 {
                self.review_count.unwrap_or(0)
            }

            pub fn clear_review_count(&mut self) {
                self.review_count = ::std::option::Option::None;
            }

            pub fn has_review_count(&self) -> bool {
                self.review_count.is_some()
            }

            // Param is passed by value, moved
            pub fn set_review_count(&mut self, v: u32) {
                self.review_count = ::std::option::Option::Some(v);
            }

            // optional int32 percent_positive = 2;

            pub fn percent_positive(&self) -> i32 {
                self.percent_positive.unwrap_or(0)
            }

            pub fn clear_percent_positive(&mut self) {
                self.percent_positive = ::std::option::Option::None;
            }

            pub fn has_percent_positive(&self) -> bool {
                self.percent_positive.is_some()
            }

            // Param is passed by value, moved
            pub fn set_percent_positive(&mut self, v: i32) {
                self.percent_positive = ::std::option::Option::Some(v);
            }

            // optional .EUserReviewScore review_score = 3;

            pub fn review_score(&self) -> super::super::EUserReviewScore {
                match self.review_score {
                    Some(e) => e.enum_value_or(super::super::EUserReviewScore::k_EUserReviewScore_None),
                    None => super::super::EUserReviewScore::k_EUserReviewScore_None,
                }
            }

            pub fn clear_review_score(&mut self) {
                self.review_score = ::std::option::Option::None;
            }

            pub fn has_review_score(&self) -> bool {
                self.review_score.is_some()
            }

            // Param is passed by value, moved
            pub fn set_review_score(&mut self, v: super::super::EUserReviewScore) {
                self.review_score = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
            }

            // optional string review_score_label = 4;

            pub fn review_score_label(&self) -> &str {
                match self.review_score_label.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_review_score_label(&mut self) {
                self.review_score_label = ::std::option::Option::None;
            }

            pub fn has_review_score_label(&self) -> bool {
                self.review_score_label.is_some()
            }

            // Param is passed by value, moved
            pub fn set_review_score_label(&mut self, v: ::std::string::String) {
                self.review_score_label = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_review_score_label(&mut self) -> &mut ::std::string::String {
                if self.review_score_label.is_none() {
                    self.review_score_label = ::std::option::Option::Some(::std::string::String::new());
                }
                self.review_score_label.as_mut().unwrap()
            }

            // Take field
            pub fn take_review_score_label(&mut self) -> ::std::string::String {
                self.review_score_label.take().unwrap_or_else(|| ::std::string::String::new())
            }
        }

        impl ::protobuf::Message for StoreReviewSummary {
            const NAME: &'static str = "StoreReviewSummary";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.review_count = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        16 => {
                            self.percent_positive = ::std::option::Option::Some(is.read_int32()?);
                        },
                        24 => {
                            self.review_score = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                        },
                        34 => {
                            self.review_score_label = ::std::option::Option::Some(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.review_count {
                    my_size += ::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.percent_positive {
                    my_size += ::protobuf::rt::int32_size(2, v);
                }
                if let Some(v) = self.review_score {
                    my_size += ::protobuf::rt::int32_size(3, v.value());
                }
                if let Some(v) = self.review_score_label.as_ref() {
                    my_size += ::protobuf::rt::string_size(4, &v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.review_count {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.percent_positive {
                    os.write_int32(2, v)?;
                }
                if let Some(v) = self.review_score {
                    os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
                }
                if let Some(v) = self.review_score_label.as_ref() {
                    os.write_string(4, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> StoreReviewSummary {
                StoreReviewSummary::new()
            }

            fn clear(&mut self) {
                self.review_count = ::std::option::Option::None;
                self.percent_positive = ::std::option::Option::None;
                self.review_score = ::std::option::Option::None;
                self.review_score_label = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static StoreReviewSummary {
                static instance: StoreReviewSummary = StoreReviewSummary {
                    review_count: ::std::option::Option::None,
                    percent_positive: ::std::option::Option::None,
                    review_score: ::std::option::Option::None,
                    review_score_label: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }
    }

    // @@protoc_insertion_point(message:StoreItem.BasicInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct BasicInfo {
        // message fields
        // @@protoc_insertion_point(field:StoreItem.BasicInfo.short_description)
        pub short_description: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:StoreItem.BasicInfo.publishers)
        pub publishers: ::std::vec::Vec<basic_info::CreatorHomeLink>,
        // @@protoc_insertion_point(field:StoreItem.BasicInfo.developers)
        pub developers: ::std::vec::Vec<basic_info::CreatorHomeLink>,
        // @@protoc_insertion_point(field:StoreItem.BasicInfo.franchises)
        pub franchises: ::std::vec::Vec<basic_info::CreatorHomeLink>,
        // @@protoc_insertion_point(field:StoreItem.BasicInfo.capsule_headline)
        pub capsule_headline: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:StoreItem.BasicInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BasicInfo {
        fn default() -> &'a BasicInfo {
            <BasicInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl BasicInfo {
        pub fn new() -> BasicInfo {
            ::std::default::Default::default()
        }

        // optional string short_description = 1;

        pub fn short_description(&self) -> &str {
            match self.short_description.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_short_description(&mut self) {
            self.short_description = ::std::option::Option::None;
        }

        pub fn has_short_description(&self) -> bool {
            self.short_description.is_some()
        }

        // Param is passed by value, moved
        pub fn set_short_description(&mut self, v: ::std::string::String) {
            self.short_description = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_short_description(&mut self) -> &mut ::std::string::String {
            if self.short_description.is_none() {
                self.short_description = ::std::option::Option::Some(::std::string::String::new());
            }
            self.short_description.as_mut().unwrap()
        }

        // Take field
        pub fn take_short_description(&mut self) -> ::std::string::String {
            self.short_description.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string capsule_headline = 5;

        pub fn capsule_headline(&self) -> &str {
            match self.capsule_headline.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_capsule_headline(&mut self) {
            self.capsule_headline = ::std::option::Option::None;
        }

        pub fn has_capsule_headline(&self) -> bool {
            self.capsule_headline.is_some()
        }

        // Param is passed by value, moved
        pub fn set_capsule_headline(&mut self, v: ::std::string::String) {
            self.capsule_headline = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_capsule_headline(&mut self) -> &mut ::std::string::String {
            if self.capsule_headline.is_none() {
                self.capsule_headline = ::std::option::Option::Some(::std::string::String::new());
            }
            self.capsule_headline.as_mut().unwrap()
        }

        // Take field
        pub fn take_capsule_headline(&mut self) -> ::std::string::String {
            self.capsule_headline.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::protobuf::Message for BasicInfo {
        const NAME: &'static str = "BasicInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.short_description = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.publishers.push(is.read_message()?);
                    },
                    26 => {
                        self.developers.push(is.read_message()?);
                    },
                    34 => {
                        self.franchises.push(is.read_message()?);
                    },
                    42 => {
                        self.capsule_headline = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.short_description.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            for value in &self.publishers {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.developers {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.franchises {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.capsule_headline.as_ref() {
                my_size += ::protobuf::rt::string_size(5, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.short_description.as_ref() {
                os.write_string(1, v)?;
            }
            for v in &self.publishers {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            for v in &self.developers {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            for v in &self.franchises {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            };
            if let Some(v) = self.capsule_headline.as_ref() {
                os.write_string(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BasicInfo {
            BasicInfo::new()
        }

        fn clear(&mut self) {
            self.short_description = ::std::option::Option::None;
            self.publishers.clear();
            self.developers.clear();
            self.franchises.clear();
            self.capsule_headline = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BasicInfo {
            static instance: BasicInfo = BasicInfo {
                short_description: ::std::option::Option::None,
                publishers: ::std::vec::Vec::new(),
                developers: ::std::vec::Vec::new(),
                franchises: ::std::vec::Vec::new(),
                capsule_headline: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `BasicInfo`
    pub mod basic_info {
        // @@protoc_insertion_point(message:StoreItem.BasicInfo.CreatorHomeLink)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct CreatorHomeLink {
            // message fields
            // @@protoc_insertion_point(field:StoreItem.BasicInfo.CreatorHomeLink.name)
            pub name: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:StoreItem.BasicInfo.CreatorHomeLink.creator_clan_account_id)
            pub creator_clan_account_id: ::std::option::Option<u32>,
            // special fields
            // @@protoc_insertion_point(special_field:StoreItem.BasicInfo.CreatorHomeLink.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a CreatorHomeLink {
            fn default() -> &'a CreatorHomeLink {
                <CreatorHomeLink as ::protobuf::Message>::default_instance()
            }
        }

        impl CreatorHomeLink {
            pub fn new() -> CreatorHomeLink {
                ::std::default::Default::default()
            }

            // optional string name = 1;

            pub fn name(&self) -> &str {
                match self.name.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_name(&mut self) {
                self.name = ::std::option::Option::None;
            }

            pub fn has_name(&self) -> bool {
                self.name.is_some()
            }

            // Param is passed by value, moved
            pub fn set_name(&mut self, v: ::std::string::String) {
                self.name = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_name(&mut self) -> &mut ::std::string::String {
                if self.name.is_none() {
                    self.name = ::std::option::Option::Some(::std::string::String::new());
                }
                self.name.as_mut().unwrap()
            }

            // Take field
            pub fn take_name(&mut self) -> ::std::string::String {
                self.name.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional uint32 creator_clan_account_id = 2;

            pub fn creator_clan_account_id(&self) -> u32 {
                self.creator_clan_account_id.unwrap_or(0)
            }

            pub fn clear_creator_clan_account_id(&mut self) {
                self.creator_clan_account_id = ::std::option::Option::None;
            }

            pub fn has_creator_clan_account_id(&self) -> bool {
                self.creator_clan_account_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_creator_clan_account_id(&mut self, v: u32) {
                self.creator_clan_account_id = ::std::option::Option::Some(v);
            }
        }

        impl ::protobuf::Message for CreatorHomeLink {
            const NAME: &'static str = "CreatorHomeLink";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.name = ::std::option::Option::Some(is.read_string()?);
                        },
                        16 => {
                            self.creator_clan_account_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.name.as_ref() {
                    my_size += ::protobuf::rt::string_size(1, &v);
                }
                if let Some(v) = self.creator_clan_account_id {
                    my_size += ::protobuf::rt::uint32_size(2, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.name.as_ref() {
                    os.write_string(1, v)?;
                }
                if let Some(v) = self.creator_clan_account_id {
                    os.write_uint32(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> CreatorHomeLink {
                CreatorHomeLink::new()
            }

            fn clear(&mut self) {
                self.name = ::std::option::Option::None;
                self.creator_clan_account_id = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static CreatorHomeLink {
                static instance: CreatorHomeLink = CreatorHomeLink {
                    name: ::std::option::Option::None,
                    creator_clan_account_id: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }
    }

    // @@protoc_insertion_point(message:StoreItem.Tag)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Tag {
        // message fields
        // @@protoc_insertion_point(field:StoreItem.Tag.tagid)
        pub tagid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:StoreItem.Tag.weight)
        pub weight: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:StoreItem.Tag.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Tag {
        fn default() -> &'a Tag {
            <Tag as ::protobuf::Message>::default_instance()
        }
    }

    impl Tag {
        pub fn new() -> Tag {
            ::std::default::Default::default()
        }

        // optional uint32 tagid = 1;

        pub fn tagid(&self) -> u32 {
            self.tagid.unwrap_or(0)
        }

        pub fn clear_tagid(&mut self) {
            self.tagid = ::std::option::Option::None;
        }

        pub fn has_tagid(&self) -> bool {
            self.tagid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tagid(&mut self, v: u32) {
            self.tagid = ::std::option::Option::Some(v);
        }

        // optional uint32 weight = 2;

        pub fn weight(&self) -> u32 {
            self.weight.unwrap_or(0)
        }

        pub fn clear_weight(&mut self) {
            self.weight = ::std::option::Option::None;
        }

        pub fn has_weight(&self) -> bool {
            self.weight.is_some()
        }

        // Param is passed by value, moved
        pub fn set_weight(&mut self, v: u32) {
            self.weight = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Tag {
        const NAME: &'static str = "Tag";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.tagid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.weight = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.tagid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.weight {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.tagid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.weight {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Tag {
            Tag::new()
        }

        fn clear(&mut self) {
            self.tagid = ::std::option::Option::None;
            self.weight = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Tag {
            static instance: Tag = Tag {
                tagid: ::std::option::Option::None,
                weight: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:StoreItem.Assets)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Assets {
        // message fields
        // @@protoc_insertion_point(field:StoreItem.Assets.asset_url_format)
        pub asset_url_format: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:StoreItem.Assets.main_capsule)
        pub main_capsule: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:StoreItem.Assets.small_capsule)
        pub small_capsule: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:StoreItem.Assets.header)
        pub header: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:StoreItem.Assets.package_header)
        pub package_header: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:StoreItem.Assets.page_background)
        pub page_background: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:StoreItem.Assets.hero_capsule)
        pub hero_capsule: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:StoreItem.Assets.hero_capsule_2x)
        pub hero_capsule_2x: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:StoreItem.Assets.library_capsule)
        pub library_capsule: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:StoreItem.Assets.library_capsule_2x)
        pub library_capsule_2x: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:StoreItem.Assets.library_hero)
        pub library_hero: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:StoreItem.Assets.library_hero_2x)
        pub library_hero_2x: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:StoreItem.Assets.community_icon)
        pub community_icon: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:StoreItem.Assets.clan_avatar)
        pub clan_avatar: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:StoreItem.Assets.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Assets {
        fn default() -> &'a Assets {
            <Assets as ::protobuf::Message>::default_instance()
        }
    }

    impl Assets {
        pub fn new() -> Assets {
            ::std::default::Default::default()
        }

        // optional string asset_url_format = 1;

        pub fn asset_url_format(&self) -> &str {
            match self.asset_url_format.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_asset_url_format(&mut self) {
            self.asset_url_format = ::std::option::Option::None;
        }

        pub fn has_asset_url_format(&self) -> bool {
            self.asset_url_format.is_some()
        }

        // Param is passed by value, moved
        pub fn set_asset_url_format(&mut self, v: ::std::string::String) {
            self.asset_url_format = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_asset_url_format(&mut self) -> &mut ::std::string::String {
            if self.asset_url_format.is_none() {
                self.asset_url_format = ::std::option::Option::Some(::std::string::String::new());
            }
            self.asset_url_format.as_mut().unwrap()
        }

        // Take field
        pub fn take_asset_url_format(&mut self) -> ::std::string::String {
            self.asset_url_format.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string main_capsule = 2;

        pub fn main_capsule(&self) -> &str {
            match self.main_capsule.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_main_capsule(&mut self) {
            self.main_capsule = ::std::option::Option::None;
        }

        pub fn has_main_capsule(&self) -> bool {
            self.main_capsule.is_some()
        }

        // Param is passed by value, moved
        pub fn set_main_capsule(&mut self, v: ::std::string::String) {
            self.main_capsule = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_main_capsule(&mut self) -> &mut ::std::string::String {
            if self.main_capsule.is_none() {
                self.main_capsule = ::std::option::Option::Some(::std::string::String::new());
            }
            self.main_capsule.as_mut().unwrap()
        }

        // Take field
        pub fn take_main_capsule(&mut self) -> ::std::string::String {
            self.main_capsule.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string small_capsule = 3;

        pub fn small_capsule(&self) -> &str {
            match self.small_capsule.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_small_capsule(&mut self) {
            self.small_capsule = ::std::option::Option::None;
        }

        pub fn has_small_capsule(&self) -> bool {
            self.small_capsule.is_some()
        }

        // Param is passed by value, moved
        pub fn set_small_capsule(&mut self, v: ::std::string::String) {
            self.small_capsule = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_small_capsule(&mut self) -> &mut ::std::string::String {
            if self.small_capsule.is_none() {
                self.small_capsule = ::std::option::Option::Some(::std::string::String::new());
            }
            self.small_capsule.as_mut().unwrap()
        }

        // Take field
        pub fn take_small_capsule(&mut self) -> ::std::string::String {
            self.small_capsule.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string header = 4;

        pub fn header(&self) -> &str {
            match self.header.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_header(&mut self) {
            self.header = ::std::option::Option::None;
        }

        pub fn has_header(&self) -> bool {
            self.header.is_some()
        }

        // Param is passed by value, moved
        pub fn set_header(&mut self, v: ::std::string::String) {
            self.header = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_header(&mut self) -> &mut ::std::string::String {
            if self.header.is_none() {
                self.header = ::std::option::Option::Some(::std::string::String::new());
            }
            self.header.as_mut().unwrap()
        }

        // Take field
        pub fn take_header(&mut self) -> ::std::string::String {
            self.header.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string package_header = 5;

        pub fn package_header(&self) -> &str {
            match self.package_header.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_package_header(&mut self) {
            self.package_header = ::std::option::Option::None;
        }

        pub fn has_package_header(&self) -> bool {
            self.package_header.is_some()
        }

        // Param is passed by value, moved
        pub fn set_package_header(&mut self, v: ::std::string::String) {
            self.package_header = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_package_header(&mut self) -> &mut ::std::string::String {
            if self.package_header.is_none() {
                self.package_header = ::std::option::Option::Some(::std::string::String::new());
            }
            self.package_header.as_mut().unwrap()
        }

        // Take field
        pub fn take_package_header(&mut self) -> ::std::string::String {
            self.package_header.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string page_background = 6;

        pub fn page_background(&self) -> &str {
            match self.page_background.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_page_background(&mut self) {
            self.page_background = ::std::option::Option::None;
        }

        pub fn has_page_background(&self) -> bool {
            self.page_background.is_some()
        }

        // Param is passed by value, moved
        pub fn set_page_background(&mut self, v: ::std::string::String) {
            self.page_background = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_page_background(&mut self) -> &mut ::std::string::String {
            if self.page_background.is_none() {
                self.page_background = ::std::option::Option::Some(::std::string::String::new());
            }
            self.page_background.as_mut().unwrap()
        }

        // Take field
        pub fn take_page_background(&mut self) -> ::std::string::String {
            self.page_background.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string hero_capsule = 7;

        pub fn hero_capsule(&self) -> &str {
            match self.hero_capsule.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_hero_capsule(&mut self) {
            self.hero_capsule = ::std::option::Option::None;
        }

        pub fn has_hero_capsule(&self) -> bool {
            self.hero_capsule.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_capsule(&mut self, v: ::std::string::String) {
            self.hero_capsule = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_hero_capsule(&mut self) -> &mut ::std::string::String {
            if self.hero_capsule.is_none() {
                self.hero_capsule = ::std::option::Option::Some(::std::string::String::new());
            }
            self.hero_capsule.as_mut().unwrap()
        }

        // Take field
        pub fn take_hero_capsule(&mut self) -> ::std::string::String {
            self.hero_capsule.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string hero_capsule_2x = 8;

        pub fn hero_capsule_2x(&self) -> &str {
            match self.hero_capsule_2x.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_hero_capsule_2x(&mut self) {
            self.hero_capsule_2x = ::std::option::Option::None;
        }

        pub fn has_hero_capsule_2x(&self) -> bool {
            self.hero_capsule_2x.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_capsule_2x(&mut self, v: ::std::string::String) {
            self.hero_capsule_2x = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_hero_capsule_2x(&mut self) -> &mut ::std::string::String {
            if self.hero_capsule_2x.is_none() {
                self.hero_capsule_2x = ::std::option::Option::Some(::std::string::String::new());
            }
            self.hero_capsule_2x.as_mut().unwrap()
        }

        // Take field
        pub fn take_hero_capsule_2x(&mut self) -> ::std::string::String {
            self.hero_capsule_2x.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string library_capsule = 9;

        pub fn library_capsule(&self) -> &str {
            match self.library_capsule.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_library_capsule(&mut self) {
            self.library_capsule = ::std::option::Option::None;
        }

        pub fn has_library_capsule(&self) -> bool {
            self.library_capsule.is_some()
        }

        // Param is passed by value, moved
        pub fn set_library_capsule(&mut self, v: ::std::string::String) {
            self.library_capsule = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_library_capsule(&mut self) -> &mut ::std::string::String {
            if self.library_capsule.is_none() {
                self.library_capsule = ::std::option::Option::Some(::std::string::String::new());
            }
            self.library_capsule.as_mut().unwrap()
        }

        // Take field
        pub fn take_library_capsule(&mut self) -> ::std::string::String {
            self.library_capsule.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string library_capsule_2x = 10;

        pub fn library_capsule_2x(&self) -> &str {
            match self.library_capsule_2x.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_library_capsule_2x(&mut self) {
            self.library_capsule_2x = ::std::option::Option::None;
        }

        pub fn has_library_capsule_2x(&self) -> bool {
            self.library_capsule_2x.is_some()
        }

        // Param is passed by value, moved
        pub fn set_library_capsule_2x(&mut self, v: ::std::string::String) {
            self.library_capsule_2x = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_library_capsule_2x(&mut self) -> &mut ::std::string::String {
            if self.library_capsule_2x.is_none() {
                self.library_capsule_2x = ::std::option::Option::Some(::std::string::String::new());
            }
            self.library_capsule_2x.as_mut().unwrap()
        }

        // Take field
        pub fn take_library_capsule_2x(&mut self) -> ::std::string::String {
            self.library_capsule_2x.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string library_hero = 11;

        pub fn library_hero(&self) -> &str {
            match self.library_hero.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_library_hero(&mut self) {
            self.library_hero = ::std::option::Option::None;
        }

        pub fn has_library_hero(&self) -> bool {
            self.library_hero.is_some()
        }

        // Param is passed by value, moved
        pub fn set_library_hero(&mut self, v: ::std::string::String) {
            self.library_hero = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_library_hero(&mut self) -> &mut ::std::string::String {
            if self.library_hero.is_none() {
                self.library_hero = ::std::option::Option::Some(::std::string::String::new());
            }
            self.library_hero.as_mut().unwrap()
        }

        // Take field
        pub fn take_library_hero(&mut self) -> ::std::string::String {
            self.library_hero.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string library_hero_2x = 12;

        pub fn library_hero_2x(&self) -> &str {
            match self.library_hero_2x.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_library_hero_2x(&mut self) {
            self.library_hero_2x = ::std::option::Option::None;
        }

        pub fn has_library_hero_2x(&self) -> bool {
            self.library_hero_2x.is_some()
        }

        // Param is passed by value, moved
        pub fn set_library_hero_2x(&mut self, v: ::std::string::String) {
            self.library_hero_2x = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_library_hero_2x(&mut self) -> &mut ::std::string::String {
            if self.library_hero_2x.is_none() {
                self.library_hero_2x = ::std::option::Option::Some(::std::string::String::new());
            }
            self.library_hero_2x.as_mut().unwrap()
        }

        // Take field
        pub fn take_library_hero_2x(&mut self) -> ::std::string::String {
            self.library_hero_2x.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string community_icon = 13;

        pub fn community_icon(&self) -> &str {
            match self.community_icon.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_community_icon(&mut self) {
            self.community_icon = ::std::option::Option::None;
        }

        pub fn has_community_icon(&self) -> bool {
            self.community_icon.is_some()
        }

        // Param is passed by value, moved
        pub fn set_community_icon(&mut self, v: ::std::string::String) {
            self.community_icon = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_community_icon(&mut self) -> &mut ::std::string::String {
            if self.community_icon.is_none() {
                self.community_icon = ::std::option::Option::Some(::std::string::String::new());
            }
            self.community_icon.as_mut().unwrap()
        }

        // Take field
        pub fn take_community_icon(&mut self) -> ::std::string::String {
            self.community_icon.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string clan_avatar = 14;

        pub fn clan_avatar(&self) -> &str {
            match self.clan_avatar.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_clan_avatar(&mut self) {
            self.clan_avatar = ::std::option::Option::None;
        }

        pub fn has_clan_avatar(&self) -> bool {
            self.clan_avatar.is_some()
        }

        // Param is passed by value, moved
        pub fn set_clan_avatar(&mut self, v: ::std::string::String) {
            self.clan_avatar = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_clan_avatar(&mut self) -> &mut ::std::string::String {
            if self.clan_avatar.is_none() {
                self.clan_avatar = ::std::option::Option::Some(::std::string::String::new());
            }
            self.clan_avatar.as_mut().unwrap()
        }

        // Take field
        pub fn take_clan_avatar(&mut self) -> ::std::string::String {
            self.clan_avatar.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::protobuf::Message for Assets {
        const NAME: &'static str = "Assets";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.asset_url_format = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.main_capsule = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.small_capsule = ::std::option::Option::Some(is.read_string()?);
                    },
                    34 => {
                        self.header = ::std::option::Option::Some(is.read_string()?);
                    },
                    42 => {
                        self.package_header = ::std::option::Option::Some(is.read_string()?);
                    },
                    50 => {
                        self.page_background = ::std::option::Option::Some(is.read_string()?);
                    },
                    58 => {
                        self.hero_capsule = ::std::option::Option::Some(is.read_string()?);
                    },
                    66 => {
                        self.hero_capsule_2x = ::std::option::Option::Some(is.read_string()?);
                    },
                    74 => {
                        self.library_capsule = ::std::option::Option::Some(is.read_string()?);
                    },
                    82 => {
                        self.library_capsule_2x = ::std::option::Option::Some(is.read_string()?);
                    },
                    90 => {
                        self.library_hero = ::std::option::Option::Some(is.read_string()?);
                    },
                    98 => {
                        self.library_hero_2x = ::std::option::Option::Some(is.read_string()?);
                    },
                    106 => {
                        self.community_icon = ::std::option::Option::Some(is.read_string()?);
                    },
                    114 => {
                        self.clan_avatar = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.asset_url_format.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.main_capsule.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.small_capsule.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.header.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            if let Some(v) = self.package_header.as_ref() {
                my_size += ::protobuf::rt::string_size(5, &v);
            }
            if let Some(v) = self.page_background.as_ref() {
                my_size += ::protobuf::rt::string_size(6, &v);
            }
            if let Some(v) = self.hero_capsule.as_ref() {
                my_size += ::protobuf::rt::string_size(7, &v);
            }
            if let Some(v) = self.hero_capsule_2x.as_ref() {
                my_size += ::protobuf::rt::string_size(8, &v);
            }
            if let Some(v) = self.library_capsule.as_ref() {
                my_size += ::protobuf::rt::string_size(9, &v);
            }
            if let Some(v) = self.library_capsule_2x.as_ref() {
                my_size += ::protobuf::rt::string_size(10, &v);
            }
            if let Some(v) = self.library_hero.as_ref() {
                my_size += ::protobuf::rt::string_size(11, &v);
            }
            if let Some(v) = self.library_hero_2x.as_ref() {
                my_size += ::protobuf::rt::string_size(12, &v);
            }
            if let Some(v) = self.community_icon.as_ref() {
                my_size += ::protobuf::rt::string_size(13, &v);
            }
            if let Some(v) = self.clan_avatar.as_ref() {
                my_size += ::protobuf::rt::string_size(14, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.asset_url_format.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.main_capsule.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.small_capsule.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.header.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.package_header.as_ref() {
                os.write_string(5, v)?;
            }
            if let Some(v) = self.page_background.as_ref() {
                os.write_string(6, v)?;
            }
            if let Some(v) = self.hero_capsule.as_ref() {
                os.write_string(7, v)?;
            }
            if let Some(v) = self.hero_capsule_2x.as_ref() {
                os.write_string(8, v)?;
            }
            if let Some(v) = self.library_capsule.as_ref() {
                os.write_string(9, v)?;
            }
            if let Some(v) = self.library_capsule_2x.as_ref() {
                os.write_string(10, v)?;
            }
            if let Some(v) = self.library_hero.as_ref() {
                os.write_string(11, v)?;
            }
            if let Some(v) = self.library_hero_2x.as_ref() {
                os.write_string(12, v)?;
            }
            if let Some(v) = self.community_icon.as_ref() {
                os.write_string(13, v)?;
            }
            if let Some(v) = self.clan_avatar.as_ref() {
                os.write_string(14, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Assets {
            Assets::new()
        }

        fn clear(&mut self) {
            self.asset_url_format = ::std::option::Option::None;
            self.main_capsule = ::std::option::Option::None;
            self.small_capsule = ::std::option::Option::None;
            self.header = ::std::option::Option::None;
            self.package_header = ::std::option::Option::None;
            self.page_background = ::std::option::Option::None;
            self.hero_capsule = ::std::option::Option::None;
            self.hero_capsule_2x = ::std::option::Option::None;
            self.library_capsule = ::std::option::Option::None;
            self.library_capsule_2x = ::std::option::Option::None;
            self.library_hero = ::std::option::Option::None;
            self.library_hero_2x = ::std::option::Option::None;
            self.community_icon = ::std::option::Option::None;
            self.clan_avatar = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Assets {
            static instance: Assets = Assets {
                asset_url_format: ::std::option::Option::None,
                main_capsule: ::std::option::Option::None,
                small_capsule: ::std::option::Option::None,
                header: ::std::option::Option::None,
                package_header: ::std::option::Option::None,
                page_background: ::std::option::Option::None,
                hero_capsule: ::std::option::Option::None,
                hero_capsule_2x: ::std::option::Option::None,
                library_capsule: ::std::option::Option::None,
                library_capsule_2x: ::std::option::Option::None,
                library_hero: ::std::option::Option::None,
                library_hero_2x: ::std::option::Option::None,
                community_icon: ::std::option::Option::None,
                clan_avatar: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:StoreItem.ReleaseInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ReleaseInfo {
        // message fields
        // @@protoc_insertion_point(field:StoreItem.ReleaseInfo.steam_release_date)
        pub steam_release_date: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:StoreItem.ReleaseInfo.original_release_date)
        pub original_release_date: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:StoreItem.ReleaseInfo.original_steam_release_date)
        pub original_steam_release_date: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:StoreItem.ReleaseInfo.is_coming_soon)
        pub is_coming_soon: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:StoreItem.ReleaseInfo.is_preload)
        pub is_preload: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:StoreItem.ReleaseInfo.custom_release_date_message)
        pub custom_release_date_message: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:StoreItem.ReleaseInfo.is_abridged_release_date)
        pub is_abridged_release_date: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:StoreItem.ReleaseInfo.coming_soon_display)
        pub coming_soon_display: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:StoreItem.ReleaseInfo.is_early_access)
        pub is_early_access: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:StoreItem.ReleaseInfo.mac_release_date)
        pub mac_release_date: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:StoreItem.ReleaseInfo.linux_release_date)
        pub linux_release_date: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:StoreItem.ReleaseInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ReleaseInfo {
        fn default() -> &'a ReleaseInfo {
            <ReleaseInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl ReleaseInfo {
        pub fn new() -> ReleaseInfo {
            ::std::default::Default::default()
        }

        // optional uint32 steam_release_date = 1;

        pub fn steam_release_date(&self) -> u32 {
            self.steam_release_date.unwrap_or(0)
        }

        pub fn clear_steam_release_date(&mut self) {
            self.steam_release_date = ::std::option::Option::None;
        }

        pub fn has_steam_release_date(&self) -> bool {
            self.steam_release_date.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_release_date(&mut self, v: u32) {
            self.steam_release_date = ::std::option::Option::Some(v);
        }

        // optional uint32 original_release_date = 2;

        pub fn original_release_date(&self) -> u32 {
            self.original_release_date.unwrap_or(0)
        }

        pub fn clear_original_release_date(&mut self) {
            self.original_release_date = ::std::option::Option::None;
        }

        pub fn has_original_release_date(&self) -> bool {
            self.original_release_date.is_some()
        }

        // Param is passed by value, moved
        pub fn set_original_release_date(&mut self, v: u32) {
            self.original_release_date = ::std::option::Option::Some(v);
        }

        // optional uint32 original_steam_release_date = 3;

        pub fn original_steam_release_date(&self) -> u32 {
            self.original_steam_release_date.unwrap_or(0)
        }

        pub fn clear_original_steam_release_date(&mut self) {
            self.original_steam_release_date = ::std::option::Option::None;
        }

        pub fn has_original_steam_release_date(&self) -> bool {
            self.original_steam_release_date.is_some()
        }

        // Param is passed by value, moved
        pub fn set_original_steam_release_date(&mut self, v: u32) {
            self.original_steam_release_date = ::std::option::Option::Some(v);
        }

        // optional bool is_coming_soon = 4;

        pub fn is_coming_soon(&self) -> bool {
            self.is_coming_soon.unwrap_or(false)
        }

        pub fn clear_is_coming_soon(&mut self) {
            self.is_coming_soon = ::std::option::Option::None;
        }

        pub fn has_is_coming_soon(&self) -> bool {
            self.is_coming_soon.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_coming_soon(&mut self, v: bool) {
            self.is_coming_soon = ::std::option::Option::Some(v);
        }

        // optional bool is_preload = 5;

        pub fn is_preload(&self) -> bool {
            self.is_preload.unwrap_or(false)
        }

        pub fn clear_is_preload(&mut self) {
            self.is_preload = ::std::option::Option::None;
        }

        pub fn has_is_preload(&self) -> bool {
            self.is_preload.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_preload(&mut self, v: bool) {
            self.is_preload = ::std::option::Option::Some(v);
        }

        // optional string custom_release_date_message = 6;

        pub fn custom_release_date_message(&self) -> &str {
            match self.custom_release_date_message.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_custom_release_date_message(&mut self) {
            self.custom_release_date_message = ::std::option::Option::None;
        }

        pub fn has_custom_release_date_message(&self) -> bool {
            self.custom_release_date_message.is_some()
        }

        // Param is passed by value, moved
        pub fn set_custom_release_date_message(&mut self, v: ::std::string::String) {
            self.custom_release_date_message = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_custom_release_date_message(&mut self) -> &mut ::std::string::String {
            if self.custom_release_date_message.is_none() {
                self.custom_release_date_message = ::std::option::Option::Some(::std::string::String::new());
            }
            self.custom_release_date_message.as_mut().unwrap()
        }

        // Take field
        pub fn take_custom_release_date_message(&mut self) -> ::std::string::String {
            self.custom_release_date_message.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool is_abridged_release_date = 7;

        pub fn is_abridged_release_date(&self) -> bool {
            self.is_abridged_release_date.unwrap_or(false)
        }

        pub fn clear_is_abridged_release_date(&mut self) {
            self.is_abridged_release_date = ::std::option::Option::None;
        }

        pub fn has_is_abridged_release_date(&self) -> bool {
            self.is_abridged_release_date.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_abridged_release_date(&mut self, v: bool) {
            self.is_abridged_release_date = ::std::option::Option::Some(v);
        }

        // optional string coming_soon_display = 8;

        pub fn coming_soon_display(&self) -> &str {
            match self.coming_soon_display.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_coming_soon_display(&mut self) {
            self.coming_soon_display = ::std::option::Option::None;
        }

        pub fn has_coming_soon_display(&self) -> bool {
            self.coming_soon_display.is_some()
        }

        // Param is passed by value, moved
        pub fn set_coming_soon_display(&mut self, v: ::std::string::String) {
            self.coming_soon_display = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_coming_soon_display(&mut self) -> &mut ::std::string::String {
            if self.coming_soon_display.is_none() {
                self.coming_soon_display = ::std::option::Option::Some(::std::string::String::new());
            }
            self.coming_soon_display.as_mut().unwrap()
        }

        // Take field
        pub fn take_coming_soon_display(&mut self) -> ::std::string::String {
            self.coming_soon_display.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool is_early_access = 10;

        pub fn is_early_access(&self) -> bool {
            self.is_early_access.unwrap_or(false)
        }

        pub fn clear_is_early_access(&mut self) {
            self.is_early_access = ::std::option::Option::None;
        }

        pub fn has_is_early_access(&self) -> bool {
            self.is_early_access.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_early_access(&mut self, v: bool) {
            self.is_early_access = ::std::option::Option::Some(v);
        }

        // optional uint32 mac_release_date = 20;

        pub fn mac_release_date(&self) -> u32 {
            self.mac_release_date.unwrap_or(0)
        }

        pub fn clear_mac_release_date(&mut self) {
            self.mac_release_date = ::std::option::Option::None;
        }

        pub fn has_mac_release_date(&self) -> bool {
            self.mac_release_date.is_some()
        }

        // Param is passed by value, moved
        pub fn set_mac_release_date(&mut self, v: u32) {
            self.mac_release_date = ::std::option::Option::Some(v);
        }

        // optional uint32 linux_release_date = 21;

        pub fn linux_release_date(&self) -> u32 {
            self.linux_release_date.unwrap_or(0)
        }

        pub fn clear_linux_release_date(&mut self) {
            self.linux_release_date = ::std::option::Option::None;
        }

        pub fn has_linux_release_date(&self) -> bool {
            self.linux_release_date.is_some()
        }

        // Param is passed by value, moved
        pub fn set_linux_release_date(&mut self, v: u32) {
            self.linux_release_date = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for ReleaseInfo {
        const NAME: &'static str = "ReleaseInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.steam_release_date = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.original_release_date = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.original_steam_release_date = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.is_coming_soon = ::std::option::Option::Some(is.read_bool()?);
                    },
                    40 => {
                        self.is_preload = ::std::option::Option::Some(is.read_bool()?);
                    },
                    50 => {
                        self.custom_release_date_message = ::std::option::Option::Some(is.read_string()?);
                    },
                    56 => {
                        self.is_abridged_release_date = ::std::option::Option::Some(is.read_bool()?);
                    },
                    66 => {
                        self.coming_soon_display = ::std::option::Option::Some(is.read_string()?);
                    },
                    80 => {
                        self.is_early_access = ::std::option::Option::Some(is.read_bool()?);
                    },
                    160 => {
                        self.mac_release_date = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    168 => {
                        self.linux_release_date = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steam_release_date {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.original_release_date {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.original_steam_release_date {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.is_coming_soon {
                my_size += 1 + 1;
            }
            if let Some(v) = self.is_preload {
                my_size += 1 + 1;
            }
            if let Some(v) = self.custom_release_date_message.as_ref() {
                my_size += ::protobuf::rt::string_size(6, &v);
            }
            if let Some(v) = self.is_abridged_release_date {
                my_size += 1 + 1;
            }
            if let Some(v) = self.coming_soon_display.as_ref() {
                my_size += ::protobuf::rt::string_size(8, &v);
            }
            if let Some(v) = self.is_early_access {
                my_size += 1 + 1;
            }
            if let Some(v) = self.mac_release_date {
                my_size += ::protobuf::rt::uint32_size(20, v);
            }
            if let Some(v) = self.linux_release_date {
                my_size += ::protobuf::rt::uint32_size(21, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.steam_release_date {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.original_release_date {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.original_steam_release_date {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.is_coming_soon {
                os.write_bool(4, v)?;
            }
            if let Some(v) = self.is_preload {
                os.write_bool(5, v)?;
            }
            if let Some(v) = self.custom_release_date_message.as_ref() {
                os.write_string(6, v)?;
            }
            if let Some(v) = self.is_abridged_release_date {
                os.write_bool(7, v)?;
            }
            if let Some(v) = self.coming_soon_display.as_ref() {
                os.write_string(8, v)?;
            }
            if let Some(v) = self.is_early_access {
                os.write_bool(10, v)?;
            }
            if let Some(v) = self.mac_release_date {
                os.write_uint32(20, v)?;
            }
            if let Some(v) = self.linux_release_date {
                os.write_uint32(21, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ReleaseInfo {
            ReleaseInfo::new()
        }

        fn clear(&mut self) {
            self.steam_release_date = ::std::option::Option::None;
            self.original_release_date = ::std::option::Option::None;
            self.original_steam_release_date = ::std::option::Option::None;
            self.is_coming_soon = ::std::option::Option::None;
            self.is_preload = ::std::option::Option::None;
            self.custom_release_date_message = ::std::option::Option::None;
            self.is_abridged_release_date = ::std::option::Option::None;
            self.coming_soon_display = ::std::option::Option::None;
            self.is_early_access = ::std::option::Option::None;
            self.mac_release_date = ::std::option::Option::None;
            self.linux_release_date = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ReleaseInfo {
            static instance: ReleaseInfo = ReleaseInfo {
                steam_release_date: ::std::option::Option::None,
                original_release_date: ::std::option::Option::None,
                original_steam_release_date: ::std::option::Option::None,
                is_coming_soon: ::std::option::Option::None,
                is_preload: ::std::option::Option::None,
                custom_release_date_message: ::std::option::Option::None,
                is_abridged_release_date: ::std::option::Option::None,
                coming_soon_display: ::std::option::Option::None,
                is_early_access: ::std::option::Option::None,
                mac_release_date: ::std::option::Option::None,
                linux_release_date: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:StoreItem.Platforms)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Platforms {
        // message fields
        // @@protoc_insertion_point(field:StoreItem.Platforms.windows)
        pub windows: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:StoreItem.Platforms.mac)
        pub mac: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:StoreItem.Platforms.steamos_linux)
        pub steamos_linux: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:StoreItem.Platforms.vr_support)
        pub vr_support: ::protobuf::MessageField<platforms::VRSupport>,
        // @@protoc_insertion_point(field:StoreItem.Platforms.steam_deck_compat_category)
        pub steam_deck_compat_category: ::std::option::Option<::protobuf::EnumOrUnknown<super::super::enums::ESteamDeckCompatibilityCategory>>,
        // special fields
        // @@protoc_insertion_point(special_field:StoreItem.Platforms.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Platforms {
        fn default() -> &'a Platforms {
            <Platforms as ::protobuf::Message>::default_instance()
        }
    }

    impl Platforms {
        pub fn new() -> Platforms {
            ::std::default::Default::default()
        }

        // optional bool windows = 1;

        pub fn windows(&self) -> bool {
            self.windows.unwrap_or(false)
        }

        pub fn clear_windows(&mut self) {
            self.windows = ::std::option::Option::None;
        }

        pub fn has_windows(&self) -> bool {
            self.windows.is_some()
        }

        // Param is passed by value, moved
        pub fn set_windows(&mut self, v: bool) {
            self.windows = ::std::option::Option::Some(v);
        }

        // optional bool mac = 2;

        pub fn mac(&self) -> bool {
            self.mac.unwrap_or(false)
        }

        pub fn clear_mac(&mut self) {
            self.mac = ::std::option::Option::None;
        }

        pub fn has_mac(&self) -> bool {
            self.mac.is_some()
        }

        // Param is passed by value, moved
        pub fn set_mac(&mut self, v: bool) {
            self.mac = ::std::option::Option::Some(v);
        }

        // optional bool steamos_linux = 3;

        pub fn steamos_linux(&self) -> bool {
            self.steamos_linux.unwrap_or(false)
        }

        pub fn clear_steamos_linux(&mut self) {
            self.steamos_linux = ::std::option::Option::None;
        }

        pub fn has_steamos_linux(&self) -> bool {
            self.steamos_linux.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steamos_linux(&mut self, v: bool) {
            self.steamos_linux = ::std::option::Option::Some(v);
        }

        // optional .ESteamDeckCompatibilityCategory steam_deck_compat_category = 11;

        pub fn steam_deck_compat_category(&self) -> super::super::enums::ESteamDeckCompatibilityCategory {
            match self.steam_deck_compat_category {
                Some(e) => e.enum_value_or(super::super::enums::ESteamDeckCompatibilityCategory::k_ESteamDeckCompatibilityCategory_Unknown),
                None => super::super::enums::ESteamDeckCompatibilityCategory::k_ESteamDeckCompatibilityCategory_Unknown,
            }
        }

        pub fn clear_steam_deck_compat_category(&mut self) {
            self.steam_deck_compat_category = ::std::option::Option::None;
        }

        pub fn has_steam_deck_compat_category(&self) -> bool {
            self.steam_deck_compat_category.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_deck_compat_category(&mut self, v: super::super::enums::ESteamDeckCompatibilityCategory) {
            self.steam_deck_compat_category = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }
    }

    impl ::protobuf::Message for Platforms {
        const NAME: &'static str = "Platforms";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.windows = ::std::option::Option::Some(is.read_bool()?);
                    },
                    16 => {
                        self.mac = ::std::option::Option::Some(is.read_bool()?);
                    },
                    24 => {
                        self.steamos_linux = ::std::option::Option::Some(is.read_bool()?);
                    },
                    82 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.vr_support)?;
                    },
                    88 => {
                        self.steam_deck_compat_category = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.windows {
                my_size += 1 + 1;
            }
            if let Some(v) = self.mac {
                my_size += 1 + 1;
            }
            if let Some(v) = self.steamos_linux {
                my_size += 1 + 1;
            }
            if let Some(v) = self.vr_support.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.steam_deck_compat_category {
                my_size += ::protobuf::rt::int32_size(11, v.value());
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.windows {
                os.write_bool(1, v)?;
            }
            if let Some(v) = self.mac {
                os.write_bool(2, v)?;
            }
            if let Some(v) = self.steamos_linux {
                os.write_bool(3, v)?;
            }
            if let Some(v) = self.vr_support.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
            }
            if let Some(v) = self.steam_deck_compat_category {
                os.write_enum(11, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Platforms {
            Platforms::new()
        }

        fn clear(&mut self) {
            self.windows = ::std::option::Option::None;
            self.mac = ::std::option::Option::None;
            self.steamos_linux = ::std::option::Option::None;
            self.vr_support.clear();
            self.steam_deck_compat_category = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Platforms {
            static instance: Platforms = Platforms {
                windows: ::std::option::Option::None,
                mac: ::std::option::Option::None,
                steamos_linux: ::std::option::Option::None,
                vr_support: ::protobuf::MessageField::none(),
                steam_deck_compat_category: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `Platforms`
    pub mod platforms {
        // @@protoc_insertion_point(message:StoreItem.Platforms.VRSupport)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct VRSupport {
            // message fields
            // @@protoc_insertion_point(field:StoreItem.Platforms.VRSupport.vrhmd)
            pub vrhmd: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:StoreItem.Platforms.VRSupport.vrhmd_only)
            pub vrhmd_only: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:StoreItem.Platforms.VRSupport.htc_vive)
            pub htc_vive: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:StoreItem.Platforms.VRSupport.oculus_rift)
            pub oculus_rift: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:StoreItem.Platforms.VRSupport.windows_mr)
            pub windows_mr: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:StoreItem.Platforms.VRSupport.valve_index)
            pub valve_index: ::std::option::Option<bool>,
            // special fields
            // @@protoc_insertion_point(special_field:StoreItem.Platforms.VRSupport.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a VRSupport {
            fn default() -> &'a VRSupport {
                <VRSupport as ::protobuf::Message>::default_instance()
            }
        }

        impl VRSupport {
            pub fn new() -> VRSupport {
                ::std::default::Default::default()
            }

            // optional bool vrhmd = 1;

            pub fn vrhmd(&self) -> bool {
                self.vrhmd.unwrap_or(false)
            }

            pub fn clear_vrhmd(&mut self) {
                self.vrhmd = ::std::option::Option::None;
            }

            pub fn has_vrhmd(&self) -> bool {
                self.vrhmd.is_some()
            }

            // Param is passed by value, moved
            pub fn set_vrhmd(&mut self, v: bool) {
                self.vrhmd = ::std::option::Option::Some(v);
            }

            // optional bool vrhmd_only = 2;

            pub fn vrhmd_only(&self) -> bool {
                self.vrhmd_only.unwrap_or(false)
            }

            pub fn clear_vrhmd_only(&mut self) {
                self.vrhmd_only = ::std::option::Option::None;
            }

            pub fn has_vrhmd_only(&self) -> bool {
                self.vrhmd_only.is_some()
            }

            // Param is passed by value, moved
            pub fn set_vrhmd_only(&mut self, v: bool) {
                self.vrhmd_only = ::std::option::Option::Some(v);
            }

            // optional bool htc_vive = 40;

            pub fn htc_vive(&self) -> bool {
                self.htc_vive.unwrap_or(false)
            }

            pub fn clear_htc_vive(&mut self) {
                self.htc_vive = ::std::option::Option::None;
            }

            pub fn has_htc_vive(&self) -> bool {
                self.htc_vive.is_some()
            }

            // Param is passed by value, moved
            pub fn set_htc_vive(&mut self, v: bool) {
                self.htc_vive = ::std::option::Option::Some(v);
            }

            // optional bool oculus_rift = 41;

            pub fn oculus_rift(&self) -> bool {
                self.oculus_rift.unwrap_or(false)
            }

            pub fn clear_oculus_rift(&mut self) {
                self.oculus_rift = ::std::option::Option::None;
            }

            pub fn has_oculus_rift(&self) -> bool {
                self.oculus_rift.is_some()
            }

            // Param is passed by value, moved
            pub fn set_oculus_rift(&mut self, v: bool) {
                self.oculus_rift = ::std::option::Option::Some(v);
            }

            // optional bool windows_mr = 42;

            pub fn windows_mr(&self) -> bool {
                self.windows_mr.unwrap_or(false)
            }

            pub fn clear_windows_mr(&mut self) {
                self.windows_mr = ::std::option::Option::None;
            }

            pub fn has_windows_mr(&self) -> bool {
                self.windows_mr.is_some()
            }

            // Param is passed by value, moved
            pub fn set_windows_mr(&mut self, v: bool) {
                self.windows_mr = ::std::option::Option::Some(v);
            }

            // optional bool valve_index = 43;

            pub fn valve_index(&self) -> bool {
                self.valve_index.unwrap_or(false)
            }

            pub fn clear_valve_index(&mut self) {
                self.valve_index = ::std::option::Option::None;
            }

            pub fn has_valve_index(&self) -> bool {
                self.valve_index.is_some()
            }

            // Param is passed by value, moved
            pub fn set_valve_index(&mut self, v: bool) {
                self.valve_index = ::std::option::Option::Some(v);
            }
        }

        impl ::protobuf::Message for VRSupport {
            const NAME: &'static str = "VRSupport";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.vrhmd = ::std::option::Option::Some(is.read_bool()?);
                        },
                        16 => {
                            self.vrhmd_only = ::std::option::Option::Some(is.read_bool()?);
                        },
                        320 => {
                            self.htc_vive = ::std::option::Option::Some(is.read_bool()?);
                        },
                        328 => {
                            self.oculus_rift = ::std::option::Option::Some(is.read_bool()?);
                        },
                        336 => {
                            self.windows_mr = ::std::option::Option::Some(is.read_bool()?);
                        },
                        344 => {
                            self.valve_index = ::std::option::Option::Some(is.read_bool()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.vrhmd {
                    my_size += 1 + 1;
                }
                if let Some(v) = self.vrhmd_only {
                    my_size += 1 + 1;
                }
                if let Some(v) = self.htc_vive {
                    my_size += 2 + 1;
                }
                if let Some(v) = self.oculus_rift {
                    my_size += 2 + 1;
                }
                if let Some(v) = self.windows_mr {
                    my_size += 2 + 1;
                }
                if let Some(v) = self.valve_index {
                    my_size += 2 + 1;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.vrhmd {
                    os.write_bool(1, v)?;
                }
                if let Some(v) = self.vrhmd_only {
                    os.write_bool(2, v)?;
                }
                if let Some(v) = self.htc_vive {
                    os.write_bool(40, v)?;
                }
                if let Some(v) = self.oculus_rift {
                    os.write_bool(41, v)?;
                }
                if let Some(v) = self.windows_mr {
                    os.write_bool(42, v)?;
                }
                if let Some(v) = self.valve_index {
                    os.write_bool(43, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> VRSupport {
                VRSupport::new()
            }

            fn clear(&mut self) {
                self.vrhmd = ::std::option::Option::None;
                self.vrhmd_only = ::std::option::Option::None;
                self.htc_vive = ::std::option::Option::None;
                self.oculus_rift = ::std::option::Option::None;
                self.windows_mr = ::std::option::Option::None;
                self.valve_index = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static VRSupport {
                static instance: VRSupport = VRSupport {
                    vrhmd: ::std::option::Option::None,
                    vrhmd_only: ::std::option::Option::None,
                    htc_vive: ::std::option::Option::None,
                    oculus_rift: ::std::option::Option::None,
                    windows_mr: ::std::option::Option::None,
                    valve_index: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }
    }

    // @@protoc_insertion_point(message:StoreItem.PurchaseOption)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PurchaseOption {
        // message fields
        // @@protoc_insertion_point(field:StoreItem.PurchaseOption.packageid)
        pub packageid: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:StoreItem.PurchaseOption.bundleid)
        pub bundleid: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:StoreItem.PurchaseOption.purchase_option_name)
        pub purchase_option_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:StoreItem.PurchaseOption.final_price_in_cents)
        pub final_price_in_cents: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:StoreItem.PurchaseOption.original_price_in_cents)
        pub original_price_in_cents: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:StoreItem.PurchaseOption.user_final_price_in_cents)
        pub user_final_price_in_cents: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:StoreItem.PurchaseOption.formatted_final_price)
        pub formatted_final_price: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:StoreItem.PurchaseOption.formatted_original_price)
        pub formatted_original_price: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:StoreItem.PurchaseOption.discount_pct)
        pub discount_pct: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:StoreItem.PurchaseOption.user_discount_pct)
        pub user_discount_pct: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:StoreItem.PurchaseOption.bundle_discount_pct)
        pub bundle_discount_pct: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:StoreItem.PurchaseOption.active_discounts)
        pub active_discounts: ::std::vec::Vec<purchase_option::Discount>,
        // @@protoc_insertion_point(field:StoreItem.PurchaseOption.user_active_discounts)
        pub user_active_discounts: ::std::vec::Vec<purchase_option::Discount>,
        // @@protoc_insertion_point(field:StoreItem.PurchaseOption.inactive_discounts)
        pub inactive_discounts: ::std::vec::Vec<purchase_option::Discount>,
        // @@protoc_insertion_point(field:StoreItem.PurchaseOption.user_can_purchase)
        pub user_can_purchase: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:StoreItem.PurchaseOption.user_can_purchase_as_gift)
        pub user_can_purchase_as_gift: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:StoreItem.PurchaseOption.is_commercial_license)
        pub is_commercial_license: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:StoreItem.PurchaseOption.should_suppress_discount_pct)
        pub should_suppress_discount_pct: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:StoreItem.PurchaseOption.hide_discount_pct_for_compliance)
        pub hide_discount_pct_for_compliance: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:StoreItem.PurchaseOption.included_game_count)
        pub included_game_count: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:StoreItem.PurchaseOption.lowest_recent_price_in_cents)
        pub lowest_recent_price_in_cents: ::std::option::Option<i64>,
        // special fields
        // @@protoc_insertion_point(special_field:StoreItem.PurchaseOption.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PurchaseOption {
        fn default() -> &'a PurchaseOption {
            <PurchaseOption as ::protobuf::Message>::default_instance()
        }
    }

    impl PurchaseOption {
        pub fn new() -> PurchaseOption {
            ::std::default::Default::default()
        }

        // optional int32 packageid = 1;

        pub fn packageid(&self) -> i32 {
            self.packageid.unwrap_or(0)
        }

        pub fn clear_packageid(&mut self) {
            self.packageid = ::std::option::Option::None;
        }

        pub fn has_packageid(&self) -> bool {
            self.packageid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_packageid(&mut self, v: i32) {
            self.packageid = ::std::option::Option::Some(v);
        }

        // optional int32 bundleid = 2;

        pub fn bundleid(&self) -> i32 {
            self.bundleid.unwrap_or(0)
        }

        pub fn clear_bundleid(&mut self) {
            self.bundleid = ::std::option::Option::None;
        }

        pub fn has_bundleid(&self) -> bool {
            self.bundleid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bundleid(&mut self, v: i32) {
            self.bundleid = ::std::option::Option::Some(v);
        }

        // optional string purchase_option_name = 3;

        pub fn purchase_option_name(&self) -> &str {
            match self.purchase_option_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_purchase_option_name(&mut self) {
            self.purchase_option_name = ::std::option::Option::None;
        }

        pub fn has_purchase_option_name(&self) -> bool {
            self.purchase_option_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_purchase_option_name(&mut self, v: ::std::string::String) {
            self.purchase_option_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_purchase_option_name(&mut self) -> &mut ::std::string::String {
            if self.purchase_option_name.is_none() {
                self.purchase_option_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.purchase_option_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_purchase_option_name(&mut self) -> ::std::string::String {
            self.purchase_option_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int64 final_price_in_cents = 5;

        pub fn final_price_in_cents(&self) -> i64 {
            self.final_price_in_cents.unwrap_or(0)
        }

        pub fn clear_final_price_in_cents(&mut self) {
            self.final_price_in_cents = ::std::option::Option::None;
        }

        pub fn has_final_price_in_cents(&self) -> bool {
            self.final_price_in_cents.is_some()
        }

        // Param is passed by value, moved
        pub fn set_final_price_in_cents(&mut self, v: i64) {
            self.final_price_in_cents = ::std::option::Option::Some(v);
        }

        // optional int64 original_price_in_cents = 6;

        pub fn original_price_in_cents(&self) -> i64 {
            self.original_price_in_cents.unwrap_or(0)
        }

        pub fn clear_original_price_in_cents(&mut self) {
            self.original_price_in_cents = ::std::option::Option::None;
        }

        pub fn has_original_price_in_cents(&self) -> bool {
            self.original_price_in_cents.is_some()
        }

        // Param is passed by value, moved
        pub fn set_original_price_in_cents(&mut self, v: i64) {
            self.original_price_in_cents = ::std::option::Option::Some(v);
        }

        // optional int64 user_final_price_in_cents = 7;

        pub fn user_final_price_in_cents(&self) -> i64 {
            self.user_final_price_in_cents.unwrap_or(0)
        }

        pub fn clear_user_final_price_in_cents(&mut self) {
            self.user_final_price_in_cents = ::std::option::Option::None;
        }

        pub fn has_user_final_price_in_cents(&self) -> bool {
            self.user_final_price_in_cents.is_some()
        }

        // Param is passed by value, moved
        pub fn set_user_final_price_in_cents(&mut self, v: i64) {
            self.user_final_price_in_cents = ::std::option::Option::Some(v);
        }

        // optional string formatted_final_price = 8;

        pub fn formatted_final_price(&self) -> &str {
            match self.formatted_final_price.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_formatted_final_price(&mut self) {
            self.formatted_final_price = ::std::option::Option::None;
        }

        pub fn has_formatted_final_price(&self) -> bool {
            self.formatted_final_price.is_some()
        }

        // Param is passed by value, moved
        pub fn set_formatted_final_price(&mut self, v: ::std::string::String) {
            self.formatted_final_price = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_formatted_final_price(&mut self) -> &mut ::std::string::String {
            if self.formatted_final_price.is_none() {
                self.formatted_final_price = ::std::option::Option::Some(::std::string::String::new());
            }
            self.formatted_final_price.as_mut().unwrap()
        }

        // Take field
        pub fn take_formatted_final_price(&mut self) -> ::std::string::String {
            self.formatted_final_price.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string formatted_original_price = 9;

        pub fn formatted_original_price(&self) -> &str {
            match self.formatted_original_price.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_formatted_original_price(&mut self) {
            self.formatted_original_price = ::std::option::Option::None;
        }

        pub fn has_formatted_original_price(&self) -> bool {
            self.formatted_original_price.is_some()
        }

        // Param is passed by value, moved
        pub fn set_formatted_original_price(&mut self, v: ::std::string::String) {
            self.formatted_original_price = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_formatted_original_price(&mut self) -> &mut ::std::string::String {
            if self.formatted_original_price.is_none() {
                self.formatted_original_price = ::std::option::Option::Some(::std::string::String::new());
            }
            self.formatted_original_price.as_mut().unwrap()
        }

        // Take field
        pub fn take_formatted_original_price(&mut self) -> ::std::string::String {
            self.formatted_original_price.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 discount_pct = 10;

        pub fn discount_pct(&self) -> i32 {
            self.discount_pct.unwrap_or(0)
        }

        pub fn clear_discount_pct(&mut self) {
            self.discount_pct = ::std::option::Option::None;
        }

        pub fn has_discount_pct(&self) -> bool {
            self.discount_pct.is_some()
        }

        // Param is passed by value, moved
        pub fn set_discount_pct(&mut self, v: i32) {
            self.discount_pct = ::std::option::Option::Some(v);
        }

        // optional int32 user_discount_pct = 11;

        pub fn user_discount_pct(&self) -> i32 {
            self.user_discount_pct.unwrap_or(0)
        }

        pub fn clear_user_discount_pct(&mut self) {
            self.user_discount_pct = ::std::option::Option::None;
        }

        pub fn has_user_discount_pct(&self) -> bool {
            self.user_discount_pct.is_some()
        }

        // Param is passed by value, moved
        pub fn set_user_discount_pct(&mut self, v: i32) {
            self.user_discount_pct = ::std::option::Option::Some(v);
        }

        // optional int32 bundle_discount_pct = 12;

        pub fn bundle_discount_pct(&self) -> i32 {
            self.bundle_discount_pct.unwrap_or(0)
        }

        pub fn clear_bundle_discount_pct(&mut self) {
            self.bundle_discount_pct = ::std::option::Option::None;
        }

        pub fn has_bundle_discount_pct(&self) -> bool {
            self.bundle_discount_pct.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bundle_discount_pct(&mut self, v: i32) {
            self.bundle_discount_pct = ::std::option::Option::Some(v);
        }

        // optional bool user_can_purchase = 30;

        pub fn user_can_purchase(&self) -> bool {
            self.user_can_purchase.unwrap_or(false)
        }

        pub fn clear_user_can_purchase(&mut self) {
            self.user_can_purchase = ::std::option::Option::None;
        }

        pub fn has_user_can_purchase(&self) -> bool {
            self.user_can_purchase.is_some()
        }

        // Param is passed by value, moved
        pub fn set_user_can_purchase(&mut self, v: bool) {
            self.user_can_purchase = ::std::option::Option::Some(v);
        }

        // optional bool user_can_purchase_as_gift = 31;

        pub fn user_can_purchase_as_gift(&self) -> bool {
            self.user_can_purchase_as_gift.unwrap_or(false)
        }

        pub fn clear_user_can_purchase_as_gift(&mut self) {
            self.user_can_purchase_as_gift = ::std::option::Option::None;
        }

        pub fn has_user_can_purchase_as_gift(&self) -> bool {
            self.user_can_purchase_as_gift.is_some()
        }

        // Param is passed by value, moved
        pub fn set_user_can_purchase_as_gift(&mut self, v: bool) {
            self.user_can_purchase_as_gift = ::std::option::Option::Some(v);
        }

        // optional bool is_commercial_license = 40;

        pub fn is_commercial_license(&self) -> bool {
            self.is_commercial_license.unwrap_or(false)
        }

        pub fn clear_is_commercial_license(&mut self) {
            self.is_commercial_license = ::std::option::Option::None;
        }

        pub fn has_is_commercial_license(&self) -> bool {
            self.is_commercial_license.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_commercial_license(&mut self, v: bool) {
            self.is_commercial_license = ::std::option::Option::Some(v);
        }

        // optional bool should_suppress_discount_pct = 41;

        pub fn should_suppress_discount_pct(&self) -> bool {
            self.should_suppress_discount_pct.unwrap_or(false)
        }

        pub fn clear_should_suppress_discount_pct(&mut self) {
            self.should_suppress_discount_pct = ::std::option::Option::None;
        }

        pub fn has_should_suppress_discount_pct(&self) -> bool {
            self.should_suppress_discount_pct.is_some()
        }

        // Param is passed by value, moved
        pub fn set_should_suppress_discount_pct(&mut self, v: bool) {
            self.should_suppress_discount_pct = ::std::option::Option::Some(v);
        }

        // optional bool hide_discount_pct_for_compliance = 42;

        pub fn hide_discount_pct_for_compliance(&self) -> bool {
            self.hide_discount_pct_for_compliance.unwrap_or(false)
        }

        pub fn clear_hide_discount_pct_for_compliance(&mut self) {
            self.hide_discount_pct_for_compliance = ::std::option::Option::None;
        }

        pub fn has_hide_discount_pct_for_compliance(&self) -> bool {
            self.hide_discount_pct_for_compliance.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hide_discount_pct_for_compliance(&mut self, v: bool) {
            self.hide_discount_pct_for_compliance = ::std::option::Option::Some(v);
        }

        // optional int32 included_game_count = 43;

        pub fn included_game_count(&self) -> i32 {
            self.included_game_count.unwrap_or(0)
        }

        pub fn clear_included_game_count(&mut self) {
            self.included_game_count = ::std::option::Option::None;
        }

        pub fn has_included_game_count(&self) -> bool {
            self.included_game_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_included_game_count(&mut self, v: i32) {
            self.included_game_count = ::std::option::Option::Some(v);
        }

        // optional int64 lowest_recent_price_in_cents = 44;

        pub fn lowest_recent_price_in_cents(&self) -> i64 {
            self.lowest_recent_price_in_cents.unwrap_or(0)
        }

        pub fn clear_lowest_recent_price_in_cents(&mut self) {
            self.lowest_recent_price_in_cents = ::std::option::Option::None;
        }

        pub fn has_lowest_recent_price_in_cents(&self) -> bool {
            self.lowest_recent_price_in_cents.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lowest_recent_price_in_cents(&mut self, v: i64) {
            self.lowest_recent_price_in_cents = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for PurchaseOption {
        const NAME: &'static str = "PurchaseOption";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.packageid = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.bundleid = ::std::option::Option::Some(is.read_int32()?);
                    },
                    26 => {
                        self.purchase_option_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    40 => {
                        self.final_price_in_cents = ::std::option::Option::Some(is.read_int64()?);
                    },
                    48 => {
                        self.original_price_in_cents = ::std::option::Option::Some(is.read_int64()?);
                    },
                    56 => {
                        self.user_final_price_in_cents = ::std::option::Option::Some(is.read_int64()?);
                    },
                    66 => {
                        self.formatted_final_price = ::std::option::Option::Some(is.read_string()?);
                    },
                    74 => {
                        self.formatted_original_price = ::std::option::Option::Some(is.read_string()?);
                    },
                    80 => {
                        self.discount_pct = ::std::option::Option::Some(is.read_int32()?);
                    },
                    88 => {
                        self.user_discount_pct = ::std::option::Option::Some(is.read_int32()?);
                    },
                    96 => {
                        self.bundle_discount_pct = ::std::option::Option::Some(is.read_int32()?);
                    },
                    162 => {
                        self.active_discounts.push(is.read_message()?);
                    },
                    170 => {
                        self.user_active_discounts.push(is.read_message()?);
                    },
                    178 => {
                        self.inactive_discounts.push(is.read_message()?);
                    },
                    240 => {
                        self.user_can_purchase = ::std::option::Option::Some(is.read_bool()?);
                    },
                    248 => {
                        self.user_can_purchase_as_gift = ::std::option::Option::Some(is.read_bool()?);
                    },
                    320 => {
                        self.is_commercial_license = ::std::option::Option::Some(is.read_bool()?);
                    },
                    328 => {
                        self.should_suppress_discount_pct = ::std::option::Option::Some(is.read_bool()?);
                    },
                    336 => {
                        self.hide_discount_pct_for_compliance = ::std::option::Option::Some(is.read_bool()?);
                    },
                    344 => {
                        self.included_game_count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    352 => {
                        self.lowest_recent_price_in_cents = ::std::option::Option::Some(is.read_int64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.packageid {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.bundleid {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.purchase_option_name.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.final_price_in_cents {
                my_size += ::protobuf::rt::int64_size(5, v);
            }
            if let Some(v) = self.original_price_in_cents {
                my_size += ::protobuf::rt::int64_size(6, v);
            }
            if let Some(v) = self.user_final_price_in_cents {
                my_size += ::protobuf::rt::int64_size(7, v);
            }
            if let Some(v) = self.formatted_final_price.as_ref() {
                my_size += ::protobuf::rt::string_size(8, &v);
            }
            if let Some(v) = self.formatted_original_price.as_ref() {
                my_size += ::protobuf::rt::string_size(9, &v);
            }
            if let Some(v) = self.discount_pct {
                my_size += ::protobuf::rt::int32_size(10, v);
            }
            if let Some(v) = self.user_discount_pct {
                my_size += ::protobuf::rt::int32_size(11, v);
            }
            if let Some(v) = self.bundle_discount_pct {
                my_size += ::protobuf::rt::int32_size(12, v);
            }
            for value in &self.active_discounts {
                let len = value.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.user_active_discounts {
                let len = value.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.inactive_discounts {
                let len = value.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.user_can_purchase {
                my_size += 2 + 1;
            }
            if let Some(v) = self.user_can_purchase_as_gift {
                my_size += 2 + 1;
            }
            if let Some(v) = self.is_commercial_license {
                my_size += 2 + 1;
            }
            if let Some(v) = self.should_suppress_discount_pct {
                my_size += 2 + 1;
            }
            if let Some(v) = self.hide_discount_pct_for_compliance {
                my_size += 2 + 1;
            }
            if let Some(v) = self.included_game_count {
                my_size += ::protobuf::rt::int32_size(43, v);
            }
            if let Some(v) = self.lowest_recent_price_in_cents {
                my_size += ::protobuf::rt::int64_size(44, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.packageid {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.bundleid {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.purchase_option_name.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.final_price_in_cents {
                os.write_int64(5, v)?;
            }
            if let Some(v) = self.original_price_in_cents {
                os.write_int64(6, v)?;
            }
            if let Some(v) = self.user_final_price_in_cents {
                os.write_int64(7, v)?;
            }
            if let Some(v) = self.formatted_final_price.as_ref() {
                os.write_string(8, v)?;
            }
            if let Some(v) = self.formatted_original_price.as_ref() {
                os.write_string(9, v)?;
            }
            if let Some(v) = self.discount_pct {
                os.write_int32(10, v)?;
            }
            if let Some(v) = self.user_discount_pct {
                os.write_int32(11, v)?;
            }
            if let Some(v) = self.bundle_discount_pct {
                os.write_int32(12, v)?;
            }
            for v in &self.active_discounts {
                ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
            };
            for v in &self.user_active_discounts {
                ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
            };
            for v in &self.inactive_discounts {
                ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
            };
            if let Some(v) = self.user_can_purchase {
                os.write_bool(30, v)?;
            }
            if let Some(v) = self.user_can_purchase_as_gift {
                os.write_bool(31, v)?;
            }
            if let Some(v) = self.is_commercial_license {
                os.write_bool(40, v)?;
            }
            if let Some(v) = self.should_suppress_discount_pct {
                os.write_bool(41, v)?;
            }
            if let Some(v) = self.hide_discount_pct_for_compliance {
                os.write_bool(42, v)?;
            }
            if let Some(v) = self.included_game_count {
                os.write_int32(43, v)?;
            }
            if let Some(v) = self.lowest_recent_price_in_cents {
                os.write_int64(44, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PurchaseOption {
            PurchaseOption::new()
        }

        fn clear(&mut self) {
            self.packageid = ::std::option::Option::None;
            self.bundleid = ::std::option::Option::None;
            self.purchase_option_name = ::std::option::Option::None;
            self.final_price_in_cents = ::std::option::Option::None;
            self.original_price_in_cents = ::std::option::Option::None;
            self.user_final_price_in_cents = ::std::option::Option::None;
            self.formatted_final_price = ::std::option::Option::None;
            self.formatted_original_price = ::std::option::Option::None;
            self.discount_pct = ::std::option::Option::None;
            self.user_discount_pct = ::std::option::Option::None;
            self.bundle_discount_pct = ::std::option::Option::None;
            self.active_discounts.clear();
            self.user_active_discounts.clear();
            self.inactive_discounts.clear();
            self.user_can_purchase = ::std::option::Option::None;
            self.user_can_purchase_as_gift = ::std::option::Option::None;
            self.is_commercial_license = ::std::option::Option::None;
            self.should_suppress_discount_pct = ::std::option::Option::None;
            self.hide_discount_pct_for_compliance = ::std::option::Option::None;
            self.included_game_count = ::std::option::Option::None;
            self.lowest_recent_price_in_cents = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PurchaseOption {
            static instance: PurchaseOption = PurchaseOption {
                packageid: ::std::option::Option::None,
                bundleid: ::std::option::Option::None,
                purchase_option_name: ::std::option::Option::None,
                final_price_in_cents: ::std::option::Option::None,
                original_price_in_cents: ::std::option::Option::None,
                user_final_price_in_cents: ::std::option::Option::None,
                formatted_final_price: ::std::option::Option::None,
                formatted_original_price: ::std::option::Option::None,
                discount_pct: ::std::option::Option::None,
                user_discount_pct: ::std::option::Option::None,
                bundle_discount_pct: ::std::option::Option::None,
                active_discounts: ::std::vec::Vec::new(),
                user_active_discounts: ::std::vec::Vec::new(),
                inactive_discounts: ::std::vec::Vec::new(),
                user_can_purchase: ::std::option::Option::None,
                user_can_purchase_as_gift: ::std::option::Option::None,
                is_commercial_license: ::std::option::Option::None,
                should_suppress_discount_pct: ::std::option::Option::None,
                hide_discount_pct_for_compliance: ::std::option::Option::None,
                included_game_count: ::std::option::Option::None,
                lowest_recent_price_in_cents: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `PurchaseOption`
    pub mod purchase_option {
        // @@protoc_insertion_point(message:StoreItem.PurchaseOption.Discount)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Discount {
            // message fields
            // @@protoc_insertion_point(field:StoreItem.PurchaseOption.Discount.discount_amount)
            pub discount_amount: ::std::option::Option<i64>,
            // @@protoc_insertion_point(field:StoreItem.PurchaseOption.Discount.discount_description)
            pub discount_description: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:StoreItem.PurchaseOption.Discount.discount_end_date)
            pub discount_end_date: ::std::option::Option<u32>,
            // special fields
            // @@protoc_insertion_point(special_field:StoreItem.PurchaseOption.Discount.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Discount {
            fn default() -> &'a Discount {
                <Discount as ::protobuf::Message>::default_instance()
            }
        }

        impl Discount {
            pub fn new() -> Discount {
                ::std::default::Default::default()
            }

            // optional int64 discount_amount = 1;

            pub fn discount_amount(&self) -> i64 {
                self.discount_amount.unwrap_or(0)
            }

            pub fn clear_discount_amount(&mut self) {
                self.discount_amount = ::std::option::Option::None;
            }

            pub fn has_discount_amount(&self) -> bool {
                self.discount_amount.is_some()
            }

            // Param is passed by value, moved
            pub fn set_discount_amount(&mut self, v: i64) {
                self.discount_amount = ::std::option::Option::Some(v);
            }

            // optional string discount_description = 2;

            pub fn discount_description(&self) -> &str {
                match self.discount_description.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_discount_description(&mut self) {
                self.discount_description = ::std::option::Option::None;
            }

            pub fn has_discount_description(&self) -> bool {
                self.discount_description.is_some()
            }

            // Param is passed by value, moved
            pub fn set_discount_description(&mut self, v: ::std::string::String) {
                self.discount_description = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_discount_description(&mut self) -> &mut ::std::string::String {
                if self.discount_description.is_none() {
                    self.discount_description = ::std::option::Option::Some(::std::string::String::new());
                }
                self.discount_description.as_mut().unwrap()
            }

            // Take field
            pub fn take_discount_description(&mut self) -> ::std::string::String {
                self.discount_description.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional uint32 discount_end_date = 3;

            pub fn discount_end_date(&self) -> u32 {
                self.discount_end_date.unwrap_or(0)
            }

            pub fn clear_discount_end_date(&mut self) {
                self.discount_end_date = ::std::option::Option::None;
            }

            pub fn has_discount_end_date(&self) -> bool {
                self.discount_end_date.is_some()
            }

            // Param is passed by value, moved
            pub fn set_discount_end_date(&mut self, v: u32) {
                self.discount_end_date = ::std::option::Option::Some(v);
            }
        }

        impl ::protobuf::Message for Discount {
            const NAME: &'static str = "Discount";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.discount_amount = ::std::option::Option::Some(is.read_int64()?);
                        },
                        18 => {
                            self.discount_description = ::std::option::Option::Some(is.read_string()?);
                        },
                        24 => {
                            self.discount_end_date = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.discount_amount {
                    my_size += ::protobuf::rt::int64_size(1, v);
                }
                if let Some(v) = self.discount_description.as_ref() {
                    my_size += ::protobuf::rt::string_size(2, &v);
                }
                if let Some(v) = self.discount_end_date {
                    my_size += ::protobuf::rt::uint32_size(3, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.discount_amount {
                    os.write_int64(1, v)?;
                }
                if let Some(v) = self.discount_description.as_ref() {
                    os.write_string(2, v)?;
                }
                if let Some(v) = self.discount_end_date {
                    os.write_uint32(3, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Discount {
                Discount::new()
            }

            fn clear(&mut self) {
                self.discount_amount = ::std::option::Option::None;
                self.discount_description = ::std::option::Option::None;
                self.discount_end_date = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Discount {
                static instance: Discount = Discount {
                    discount_amount: ::std::option::Option::None,
                    discount_description: ::std::option::Option::None,
                    discount_end_date: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }
    }

    // @@protoc_insertion_point(message:StoreItem.Screenshots)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Screenshots {
        // message fields
        // @@protoc_insertion_point(field:StoreItem.Screenshots.all_ages_screenshots)
        pub all_ages_screenshots: ::std::vec::Vec<screenshots::Screenshot>,
        // @@protoc_insertion_point(field:StoreItem.Screenshots.mature_content_screenshots)
        pub mature_content_screenshots: ::std::vec::Vec<screenshots::Screenshot>,
        // special fields
        // @@protoc_insertion_point(special_field:StoreItem.Screenshots.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Screenshots {
        fn default() -> &'a Screenshots {
            <Screenshots as ::protobuf::Message>::default_instance()
        }
    }

    impl Screenshots {
        pub fn new() -> Screenshots {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for Screenshots {
        const NAME: &'static str = "Screenshots";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    18 => {
                        self.all_ages_screenshots.push(is.read_message()?);
                    },
                    26 => {
                        self.mature_content_screenshots.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.all_ages_screenshots {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.mature_content_screenshots {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.all_ages_screenshots {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            for v in &self.mature_content_screenshots {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Screenshots {
            Screenshots::new()
        }

        fn clear(&mut self) {
            self.all_ages_screenshots.clear();
            self.mature_content_screenshots.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Screenshots {
            static instance: Screenshots = Screenshots {
                all_ages_screenshots: ::std::vec::Vec::new(),
                mature_content_screenshots: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `Screenshots`
    pub mod screenshots {
        // @@protoc_insertion_point(message:StoreItem.Screenshots.Screenshot)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Screenshot {
            // message fields
            // @@protoc_insertion_point(field:StoreItem.Screenshots.Screenshot.filename)
            pub filename: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:StoreItem.Screenshots.Screenshot.ordinal)
            pub ordinal: ::std::option::Option<i32>,
            // special fields
            // @@protoc_insertion_point(special_field:StoreItem.Screenshots.Screenshot.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Screenshot {
            fn default() -> &'a Screenshot {
                <Screenshot as ::protobuf::Message>::default_instance()
            }
        }

        impl Screenshot {
            pub fn new() -> Screenshot {
                ::std::default::Default::default()
            }

            // optional string filename = 1;

            pub fn filename(&self) -> &str {
                match self.filename.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_filename(&mut self) {
                self.filename = ::std::option::Option::None;
            }

            pub fn has_filename(&self) -> bool {
                self.filename.is_some()
            }

            // Param is passed by value, moved
            pub fn set_filename(&mut self, v: ::std::string::String) {
                self.filename = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_filename(&mut self) -> &mut ::std::string::String {
                if self.filename.is_none() {
                    self.filename = ::std::option::Option::Some(::std::string::String::new());
                }
                self.filename.as_mut().unwrap()
            }

            // Take field
            pub fn take_filename(&mut self) -> ::std::string::String {
                self.filename.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional int32 ordinal = 2;

            pub fn ordinal(&self) -> i32 {
                self.ordinal.unwrap_or(0)
            }

            pub fn clear_ordinal(&mut self) {
                self.ordinal = ::std::option::Option::None;
            }

            pub fn has_ordinal(&self) -> bool {
                self.ordinal.is_some()
            }

            // Param is passed by value, moved
            pub fn set_ordinal(&mut self, v: i32) {
                self.ordinal = ::std::option::Option::Some(v);
            }
        }

        impl ::protobuf::Message for Screenshot {
            const NAME: &'static str = "Screenshot";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.filename = ::std::option::Option::Some(is.read_string()?);
                        },
                        16 => {
                            self.ordinal = ::std::option::Option::Some(is.read_int32()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.filename.as_ref() {
                    my_size += ::protobuf::rt::string_size(1, &v);
                }
                if let Some(v) = self.ordinal {
                    my_size += ::protobuf::rt::int32_size(2, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.filename.as_ref() {
                    os.write_string(1, v)?;
                }
                if let Some(v) = self.ordinal {
                    os.write_int32(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Screenshot {
                Screenshot::new()
            }

            fn clear(&mut self) {
                self.filename = ::std::option::Option::None;
                self.ordinal = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Screenshot {
                static instance: Screenshot = Screenshot {
                    filename: ::std::option::Option::None,
                    ordinal: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }
    }

    // @@protoc_insertion_point(message:StoreItem.Trailers)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Trailers {
        // message fields
        // @@protoc_insertion_point(field:StoreItem.Trailers.highlights)
        pub highlights: ::std::vec::Vec<trailers::Trailer>,
        // @@protoc_insertion_point(field:StoreItem.Trailers.other_trailers)
        pub other_trailers: ::std::vec::Vec<trailers::Trailer>,
        // special fields
        // @@protoc_insertion_point(special_field:StoreItem.Trailers.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Trailers {
        fn default() -> &'a Trailers {
            <Trailers as ::protobuf::Message>::default_instance()
        }
    }

    impl Trailers {
        pub fn new() -> Trailers {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for Trailers {
        const NAME: &'static str = "Trailers";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.highlights.push(is.read_message()?);
                    },
                    18 => {
                        self.other_trailers.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.highlights {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.other_trailers {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.highlights {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            for v in &self.other_trailers {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Trailers {
            Trailers::new()
        }

        fn clear(&mut self) {
            self.highlights.clear();
            self.other_trailers.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Trailers {
            static instance: Trailers = Trailers {
                highlights: ::std::vec::Vec::new(),
                other_trailers: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `Trailers`
    pub mod trailers {
        // @@protoc_insertion_point(message:StoreItem.Trailers.VideoSource)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct VideoSource {
            // message fields
            // @@protoc_insertion_point(field:StoreItem.Trailers.VideoSource.filename)
            pub filename: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:StoreItem.Trailers.VideoSource.type)
            pub type_: ::std::option::Option<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:StoreItem.Trailers.VideoSource.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a VideoSource {
            fn default() -> &'a VideoSource {
                <VideoSource as ::protobuf::Message>::default_instance()
            }
        }

        impl VideoSource {
            pub fn new() -> VideoSource {
                ::std::default::Default::default()
            }

            // optional string filename = 1;

            pub fn filename(&self) -> &str {
                match self.filename.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_filename(&mut self) {
                self.filename = ::std::option::Option::None;
            }

            pub fn has_filename(&self) -> bool {
                self.filename.is_some()
            }

            // Param is passed by value, moved
            pub fn set_filename(&mut self, v: ::std::string::String) {
                self.filename = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_filename(&mut self) -> &mut ::std::string::String {
                if self.filename.is_none() {
                    self.filename = ::std::option::Option::Some(::std::string::String::new());
                }
                self.filename.as_mut().unwrap()
            }

            // Take field
            pub fn take_filename(&mut self) -> ::std::string::String {
                self.filename.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional string type = 2;

            pub fn type_(&self) -> &str {
                match self.type_.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_type_(&mut self) {
                self.type_ = ::std::option::Option::None;
            }

            pub fn has_type(&self) -> bool {
                self.type_.is_some()
            }

            // Param is passed by value, moved
            pub fn set_type(&mut self, v: ::std::string::String) {
                self.type_ = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_type(&mut self) -> &mut ::std::string::String {
                if self.type_.is_none() {
                    self.type_ = ::std::option::Option::Some(::std::string::String::new());
                }
                self.type_.as_mut().unwrap()
            }

            // Take field
            pub fn take_type_(&mut self) -> ::std::string::String {
                self.type_.take().unwrap_or_else(|| ::std::string::String::new())
            }
        }

        impl ::protobuf::Message for VideoSource {
            const NAME: &'static str = "VideoSource";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.filename = ::std::option::Option::Some(is.read_string()?);
                        },
                        18 => {
                            self.type_ = ::std::option::Option::Some(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.filename.as_ref() {
                    my_size += ::protobuf::rt::string_size(1, &v);
                }
                if let Some(v) = self.type_.as_ref() {
                    my_size += ::protobuf::rt::string_size(2, &v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.filename.as_ref() {
                    os.write_string(1, v)?;
                }
                if let Some(v) = self.type_.as_ref() {
                    os.write_string(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> VideoSource {
                VideoSource::new()
            }

            fn clear(&mut self) {
                self.filename = ::std::option::Option::None;
                self.type_ = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static VideoSource {
                static instance: VideoSource = VideoSource {
                    filename: ::std::option::Option::None,
                    type_: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        // @@protoc_insertion_point(message:StoreItem.Trailers.Trailer)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Trailer {
            // message fields
            // @@protoc_insertion_point(field:StoreItem.Trailers.Trailer.trailer_name)
            pub trailer_name: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:StoreItem.Trailers.Trailer.trailer_url_format)
            pub trailer_url_format: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:StoreItem.Trailers.Trailer.trailer_480p)
            pub trailer_480p: ::std::vec::Vec<VideoSource>,
            // @@protoc_insertion_point(field:StoreItem.Trailers.Trailer.trailer_max)
            pub trailer_max: ::std::vec::Vec<VideoSource>,
            // @@protoc_insertion_point(field:StoreItem.Trailers.Trailer.microtrailer)
            pub microtrailer: ::std::vec::Vec<VideoSource>,
            // @@protoc_insertion_point(field:StoreItem.Trailers.Trailer.screenshot_medium)
            pub screenshot_medium: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:StoreItem.Trailers.Trailer.screenshot_full)
            pub screenshot_full: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:StoreItem.Trailers.Trailer.trailer_base_id)
            pub trailer_base_id: ::std::option::Option<i32>,
            // special fields
            // @@protoc_insertion_point(special_field:StoreItem.Trailers.Trailer.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Trailer {
            fn default() -> &'a Trailer {
                <Trailer as ::protobuf::Message>::default_instance()
            }
        }

        impl Trailer {
            pub fn new() -> Trailer {
                ::std::default::Default::default()
            }

            // optional string trailer_name = 1;

            pub fn trailer_name(&self) -> &str {
                match self.trailer_name.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_trailer_name(&mut self) {
                self.trailer_name = ::std::option::Option::None;
            }

            pub fn has_trailer_name(&self) -> bool {
                self.trailer_name.is_some()
            }

            // Param is passed by value, moved
            pub fn set_trailer_name(&mut self, v: ::std::string::String) {
                self.trailer_name = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_trailer_name(&mut self) -> &mut ::std::string::String {
                if self.trailer_name.is_none() {
                    self.trailer_name = ::std::option::Option::Some(::std::string::String::new());
                }
                self.trailer_name.as_mut().unwrap()
            }

            // Take field
            pub fn take_trailer_name(&mut self) -> ::std::string::String {
                self.trailer_name.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional string trailer_url_format = 2;

            pub fn trailer_url_format(&self) -> &str {
                match self.trailer_url_format.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_trailer_url_format(&mut self) {
                self.trailer_url_format = ::std::option::Option::None;
            }

            pub fn has_trailer_url_format(&self) -> bool {
                self.trailer_url_format.is_some()
            }

            // Param is passed by value, moved
            pub fn set_trailer_url_format(&mut self, v: ::std::string::String) {
                self.trailer_url_format = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_trailer_url_format(&mut self) -> &mut ::std::string::String {
                if self.trailer_url_format.is_none() {
                    self.trailer_url_format = ::std::option::Option::Some(::std::string::String::new());
                }
                self.trailer_url_format.as_mut().unwrap()
            }

            // Take field
            pub fn take_trailer_url_format(&mut self) -> ::std::string::String {
                self.trailer_url_format.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional string screenshot_medium = 10;

            pub fn screenshot_medium(&self) -> &str {
                match self.screenshot_medium.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_screenshot_medium(&mut self) {
                self.screenshot_medium = ::std::option::Option::None;
            }

            pub fn has_screenshot_medium(&self) -> bool {
                self.screenshot_medium.is_some()
            }

            // Param is passed by value, moved
            pub fn set_screenshot_medium(&mut self, v: ::std::string::String) {
                self.screenshot_medium = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_screenshot_medium(&mut self) -> &mut ::std::string::String {
                if self.screenshot_medium.is_none() {
                    self.screenshot_medium = ::std::option::Option::Some(::std::string::String::new());
                }
                self.screenshot_medium.as_mut().unwrap()
            }

            // Take field
            pub fn take_screenshot_medium(&mut self) -> ::std::string::String {
                self.screenshot_medium.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional string screenshot_full = 11;

            pub fn screenshot_full(&self) -> &str {
                match self.screenshot_full.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_screenshot_full(&mut self) {
                self.screenshot_full = ::std::option::Option::None;
            }

            pub fn has_screenshot_full(&self) -> bool {
                self.screenshot_full.is_some()
            }

            // Param is passed by value, moved
            pub fn set_screenshot_full(&mut self, v: ::std::string::String) {
                self.screenshot_full = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_screenshot_full(&mut self) -> &mut ::std::string::String {
                if self.screenshot_full.is_none() {
                    self.screenshot_full = ::std::option::Option::Some(::std::string::String::new());
                }
                self.screenshot_full.as_mut().unwrap()
            }

            // Take field
            pub fn take_screenshot_full(&mut self) -> ::std::string::String {
                self.screenshot_full.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional int32 trailer_base_id = 12;

            pub fn trailer_base_id(&self) -> i32 {
                self.trailer_base_id.unwrap_or(0)
            }

            pub fn clear_trailer_base_id(&mut self) {
                self.trailer_base_id = ::std::option::Option::None;
            }

            pub fn has_trailer_base_id(&self) -> bool {
                self.trailer_base_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_trailer_base_id(&mut self, v: i32) {
                self.trailer_base_id = ::std::option::Option::Some(v);
            }
        }

        impl ::protobuf::Message for Trailer {
            const NAME: &'static str = "Trailer";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.trailer_name = ::std::option::Option::Some(is.read_string()?);
                        },
                        18 => {
                            self.trailer_url_format = ::std::option::Option::Some(is.read_string()?);
                        },
                        26 => {
                            self.trailer_480p.push(is.read_message()?);
                        },
                        34 => {
                            self.trailer_max.push(is.read_message()?);
                        },
                        42 => {
                            self.microtrailer.push(is.read_message()?);
                        },
                        82 => {
                            self.screenshot_medium = ::std::option::Option::Some(is.read_string()?);
                        },
                        90 => {
                            self.screenshot_full = ::std::option::Option::Some(is.read_string()?);
                        },
                        96 => {
                            self.trailer_base_id = ::std::option::Option::Some(is.read_int32()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.trailer_name.as_ref() {
                    my_size += ::protobuf::rt::string_size(1, &v);
                }
                if let Some(v) = self.trailer_url_format.as_ref() {
                    my_size += ::protobuf::rt::string_size(2, &v);
                }
                for value in &self.trailer_480p {
                    let len = value.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                for value in &self.trailer_max {
                    let len = value.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                for value in &self.microtrailer {
                    let len = value.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                if let Some(v) = self.screenshot_medium.as_ref() {
                    my_size += ::protobuf::rt::string_size(10, &v);
                }
                if let Some(v) = self.screenshot_full.as_ref() {
                    my_size += ::protobuf::rt::string_size(11, &v);
                }
                if let Some(v) = self.trailer_base_id {
                    my_size += ::protobuf::rt::int32_size(12, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.trailer_name.as_ref() {
                    os.write_string(1, v)?;
                }
                if let Some(v) = self.trailer_url_format.as_ref() {
                    os.write_string(2, v)?;
                }
                for v in &self.trailer_480p {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                };
                for v in &self.trailer_max {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                };
                for v in &self.microtrailer {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                };
                if let Some(v) = self.screenshot_medium.as_ref() {
                    os.write_string(10, v)?;
                }
                if let Some(v) = self.screenshot_full.as_ref() {
                    os.write_string(11, v)?;
                }
                if let Some(v) = self.trailer_base_id {
                    os.write_int32(12, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Trailer {
                Trailer::new()
            }

            fn clear(&mut self) {
                self.trailer_name = ::std::option::Option::None;
                self.trailer_url_format = ::std::option::Option::None;
                self.trailer_480p.clear();
                self.trailer_max.clear();
                self.microtrailer.clear();
                self.screenshot_medium = ::std::option::Option::None;
                self.screenshot_full = ::std::option::Option::None;
                self.trailer_base_id = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Trailer {
                static instance: Trailer = Trailer {
                    trailer_name: ::std::option::Option::None,
                    trailer_url_format: ::std::option::Option::None,
                    trailer_480p: ::std::vec::Vec::new(),
                    trailer_max: ::std::vec::Vec::new(),
                    microtrailer: ::std::vec::Vec::new(),
                    screenshot_medium: ::std::option::Option::None,
                    screenshot_full: ::std::option::Option::None,
                    trailer_base_id: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }
    }

    // @@protoc_insertion_point(message:StoreItem.SupportedLanguage)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SupportedLanguage {
        // message fields
        // @@protoc_insertion_point(field:StoreItem.SupportedLanguage.elanguage)
        pub elanguage: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:StoreItem.SupportedLanguage.supported)
        pub supported: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:StoreItem.SupportedLanguage.full_audio)
        pub full_audio: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:StoreItem.SupportedLanguage.subtitles)
        pub subtitles: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:StoreItem.SupportedLanguage.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SupportedLanguage {
        fn default() -> &'a SupportedLanguage {
            <SupportedLanguage as ::protobuf::Message>::default_instance()
        }
    }

    impl SupportedLanguage {
        pub fn new() -> SupportedLanguage {
            ::std::default::Default::default()
        }

        // optional int32 elanguage = 1;

        pub fn elanguage(&self) -> i32 {
            self.elanguage.unwrap_or(0)
        }

        pub fn clear_elanguage(&mut self) {
            self.elanguage = ::std::option::Option::None;
        }

        pub fn has_elanguage(&self) -> bool {
            self.elanguage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_elanguage(&mut self, v: i32) {
            self.elanguage = ::std::option::Option::Some(v);
        }

        // optional bool supported = 2;

        pub fn supported(&self) -> bool {
            self.supported.unwrap_or(false)
        }

        pub fn clear_supported(&mut self) {
            self.supported = ::std::option::Option::None;
        }

        pub fn has_supported(&self) -> bool {
            self.supported.is_some()
        }

        // Param is passed by value, moved
        pub fn set_supported(&mut self, v: bool) {
            self.supported = ::std::option::Option::Some(v);
        }

        // optional bool full_audio = 3;

        pub fn full_audio(&self) -> bool {
            self.full_audio.unwrap_or(false)
        }

        pub fn clear_full_audio(&mut self) {
            self.full_audio = ::std::option::Option::None;
        }

        pub fn has_full_audio(&self) -> bool {
            self.full_audio.is_some()
        }

        // Param is passed by value, moved
        pub fn set_full_audio(&mut self, v: bool) {
            self.full_audio = ::std::option::Option::Some(v);
        }

        // optional bool subtitles = 4;

        pub fn subtitles(&self) -> bool {
            self.subtitles.unwrap_or(false)
        }

        pub fn clear_subtitles(&mut self) {
            self.subtitles = ::std::option::Option::None;
        }

        pub fn has_subtitles(&self) -> bool {
            self.subtitles.is_some()
        }

        // Param is passed by value, moved
        pub fn set_subtitles(&mut self, v: bool) {
            self.subtitles = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for SupportedLanguage {
        const NAME: &'static str = "SupportedLanguage";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.elanguage = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.supported = ::std::option::Option::Some(is.read_bool()?);
                    },
                    24 => {
                        self.full_audio = ::std::option::Option::Some(is.read_bool()?);
                    },
                    32 => {
                        self.subtitles = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.elanguage {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.supported {
                my_size += 1 + 1;
            }
            if let Some(v) = self.full_audio {
                my_size += 1 + 1;
            }
            if let Some(v) = self.subtitles {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.elanguage {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.supported {
                os.write_bool(2, v)?;
            }
            if let Some(v) = self.full_audio {
                os.write_bool(3, v)?;
            }
            if let Some(v) = self.subtitles {
                os.write_bool(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SupportedLanguage {
            SupportedLanguage::new()
        }

        fn clear(&mut self) {
            self.elanguage = ::std::option::Option::None;
            self.supported = ::std::option::Option::None;
            self.full_audio = ::std::option::Option::None;
            self.subtitles = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SupportedLanguage {
            static instance: SupportedLanguage = SupportedLanguage {
                elanguage: ::std::option::Option::None,
                supported: ::std::option::Option::None,
                full_audio: ::std::option::Option::None,
                subtitles: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:StoreItem.FreeWeekend)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct FreeWeekend {
        // message fields
        // @@protoc_insertion_point(field:StoreItem.FreeWeekend.start_time)
        pub start_time: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:StoreItem.FreeWeekend.end_time)
        pub end_time: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:StoreItem.FreeWeekend.text)
        pub text: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:StoreItem.FreeWeekend.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FreeWeekend {
        fn default() -> &'a FreeWeekend {
            <FreeWeekend as ::protobuf::Message>::default_instance()
        }
    }

    impl FreeWeekend {
        pub fn new() -> FreeWeekend {
            ::std::default::Default::default()
        }

        // optional uint32 start_time = 1;

        pub fn start_time(&self) -> u32 {
            self.start_time.unwrap_or(0)
        }

        pub fn clear_start_time(&mut self) {
            self.start_time = ::std::option::Option::None;
        }

        pub fn has_start_time(&self) -> bool {
            self.start_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_start_time(&mut self, v: u32) {
            self.start_time = ::std::option::Option::Some(v);
        }

        // optional uint32 end_time = 2;

        pub fn end_time(&self) -> u32 {
            self.end_time.unwrap_or(0)
        }

        pub fn clear_end_time(&mut self) {
            self.end_time = ::std::option::Option::None;
        }

        pub fn has_end_time(&self) -> bool {
            self.end_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_end_time(&mut self, v: u32) {
            self.end_time = ::std::option::Option::Some(v);
        }

        // optional string text = 3;

        pub fn text(&self) -> &str {
            match self.text.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_text(&mut self) {
            self.text = ::std::option::Option::None;
        }

        pub fn has_text(&self) -> bool {
            self.text.is_some()
        }

        // Param is passed by value, moved
        pub fn set_text(&mut self, v: ::std::string::String) {
            self.text = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_text(&mut self) -> &mut ::std::string::String {
            if self.text.is_none() {
                self.text = ::std::option::Option::Some(::std::string::String::new());
            }
            self.text.as_mut().unwrap()
        }

        // Take field
        pub fn take_text(&mut self) -> ::std::string::String {
            self.text.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::protobuf::Message for FreeWeekend {
        const NAME: &'static str = "FreeWeekend";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.start_time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.end_time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.text = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.start_time {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.end_time {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.text.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.start_time {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.end_time {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.text.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FreeWeekend {
            FreeWeekend::new()
        }

        fn clear(&mut self) {
            self.start_time = ::std::option::Option::None;
            self.end_time = ::std::option::Option::None;
            self.text = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FreeWeekend {
            static instance: FreeWeekend = FreeWeekend {
                start_time: ::std::option::Option::None,
                end_time: ::std::option::Option::None,
                text: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CStoreBrowse_GetItems_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStoreBrowse_GetItems_Response {
    // message fields
    // @@protoc_insertion_point(field:CStoreBrowse_GetItems_Response.store_items)
    pub store_items: ::std::vec::Vec<StoreItem>,
    // special fields
    // @@protoc_insertion_point(special_field:CStoreBrowse_GetItems_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStoreBrowse_GetItems_Response {
    fn default() -> &'a CStoreBrowse_GetItems_Response {
        <CStoreBrowse_GetItems_Response as ::protobuf::Message>::default_instance()
    }
}

impl CStoreBrowse_GetItems_Response {
    pub fn new() -> CStoreBrowse_GetItems_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CStoreBrowse_GetItems_Response {
    const NAME: &'static str = "CStoreBrowse_GetItems_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.store_items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.store_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.store_items {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStoreBrowse_GetItems_Response {
        CStoreBrowse_GetItems_Response::new()
    }

    fn clear(&mut self) {
        self.store_items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStoreBrowse_GetItems_Response {
        static instance: CStoreBrowse_GetItems_Response = CStoreBrowse_GetItems_Response {
            store_items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Get category definitions for store.  This is a public-facing API (as compared to StoreCatalog.GetCategories, which is intended for PHP)"]
// @@protoc_insertion_point(message:CStoreBrowse_GetStoreCategories_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStoreBrowse_GetStoreCategories_Request {
    // message fields
    // @@protoc_insertion_point(field:CStoreBrowse_GetStoreCategories_Request.language)
    pub language: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CStoreBrowse_GetStoreCategories_Request.elanguage)
    pub elanguage: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CStoreBrowse_GetStoreCategories_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStoreBrowse_GetStoreCategories_Request {
    fn default() -> &'a CStoreBrowse_GetStoreCategories_Request {
        <CStoreBrowse_GetStoreCategories_Request as ::protobuf::Message>::default_instance()
    }
}

impl CStoreBrowse_GetStoreCategories_Request {
    pub fn new() -> CStoreBrowse_GetStoreCategories_Request {
        ::std::default::Default::default()
    }

    // optional string language = 1;

    pub fn language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language = ::std::option::Option::Some(::std::string::String::new());
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 elanguage = 2;

    pub fn elanguage(&self) -> i32 {
        self.elanguage.unwrap_or(-1i32)
    }

    pub fn clear_elanguage(&mut self) {
        self.elanguage = ::std::option::Option::None;
    }

    pub fn has_elanguage(&self) -> bool {
        self.elanguage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_elanguage(&mut self, v: i32) {
        self.elanguage = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CStoreBrowse_GetStoreCategories_Request {
    const NAME: &'static str = "CStoreBrowse_GetStoreCategories_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.language = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.elanguage = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.language.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.elanguage {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.language.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.elanguage {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStoreBrowse_GetStoreCategories_Request {
        CStoreBrowse_GetStoreCategories_Request::new()
    }

    fn clear(&mut self) {
        self.language = ::std::option::Option::None;
        self.elanguage = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStoreBrowse_GetStoreCategories_Request {
        static instance: CStoreBrowse_GetStoreCategories_Request = CStoreBrowse_GetStoreCategories_Request {
            language: ::std::option::Option::None,
            elanguage: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CStoreBrowse_GetStoreCategories_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStoreBrowse_GetStoreCategories_Response {
    // message fields
    // @@protoc_insertion_point(field:CStoreBrowse_GetStoreCategories_Response.categories)
    pub categories: ::std::vec::Vec<cstore_browse_get_store_categories_response::Category>,
    // special fields
    // @@protoc_insertion_point(special_field:CStoreBrowse_GetStoreCategories_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStoreBrowse_GetStoreCategories_Response {
    fn default() -> &'a CStoreBrowse_GetStoreCategories_Response {
        <CStoreBrowse_GetStoreCategories_Response as ::protobuf::Message>::default_instance()
    }
}

impl CStoreBrowse_GetStoreCategories_Response {
    pub fn new() -> CStoreBrowse_GetStoreCategories_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CStoreBrowse_GetStoreCategories_Response {
    const NAME: &'static str = "CStoreBrowse_GetStoreCategories_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.categories.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.categories {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.categories {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStoreBrowse_GetStoreCategories_Response {
        CStoreBrowse_GetStoreCategories_Response::new()
    }

    fn clear(&mut self) {
        self.categories.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStoreBrowse_GetStoreCategories_Response {
        static instance: CStoreBrowse_GetStoreCategories_Response = CStoreBrowse_GetStoreCategories_Response {
            categories: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CStoreBrowse_GetStoreCategories_Response`
pub mod cstore_browse_get_store_categories_response {
    // @@protoc_insertion_point(message:CStoreBrowse_GetStoreCategories_Response.Category)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Category {
        // message fields
        // @@protoc_insertion_point(field:CStoreBrowse_GetStoreCategories_Response.Category.categoryid)
        pub categoryid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CStoreBrowse_GetStoreCategories_Response.Category.type)
        pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<super::EStoreCategoryType>>,
        // @@protoc_insertion_point(field:CStoreBrowse_GetStoreCategories_Response.Category.internal_name)
        pub internal_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CStoreBrowse_GetStoreCategories_Response.Category.display_name)
        pub display_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CStoreBrowse_GetStoreCategories_Response.Category.image_url)
        pub image_url: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CStoreBrowse_GetStoreCategories_Response.Category.show_in_search)
        pub show_in_search: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CStoreBrowse_GetStoreCategories_Response.Category.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Category {
        fn default() -> &'a Category {
            <Category as ::protobuf::Message>::default_instance()
        }
    }

    impl Category {
        pub fn new() -> Category {
            ::std::default::Default::default()
        }

        // optional uint32 categoryid = 1;

        pub fn categoryid(&self) -> u32 {
            self.categoryid.unwrap_or(0)
        }

        pub fn clear_categoryid(&mut self) {
            self.categoryid = ::std::option::Option::None;
        }

        pub fn has_categoryid(&self) -> bool {
            self.categoryid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_categoryid(&mut self, v: u32) {
            self.categoryid = ::std::option::Option::Some(v);
        }

        // optional .EStoreCategoryType type = 2;

        pub fn type_(&self) -> super::EStoreCategoryType {
            match self.type_ {
                Some(e) => e.enum_value_or(super::EStoreCategoryType::k_EStoreCategoryType_Category),
                None => super::EStoreCategoryType::k_EStoreCategoryType_Category,
            }
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: super::EStoreCategoryType) {
            self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional string internal_name = 3;

        pub fn internal_name(&self) -> &str {
            match self.internal_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_internal_name(&mut self) {
            self.internal_name = ::std::option::Option::None;
        }

        pub fn has_internal_name(&self) -> bool {
            self.internal_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_internal_name(&mut self, v: ::std::string::String) {
            self.internal_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_internal_name(&mut self) -> &mut ::std::string::String {
            if self.internal_name.is_none() {
                self.internal_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.internal_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_internal_name(&mut self) -> ::std::string::String {
            self.internal_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string display_name = 4;

        pub fn display_name(&self) -> &str {
            match self.display_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_display_name(&mut self) {
            self.display_name = ::std::option::Option::None;
        }

        pub fn has_display_name(&self) -> bool {
            self.display_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_display_name(&mut self, v: ::std::string::String) {
            self.display_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_display_name(&mut self) -> &mut ::std::string::String {
            if self.display_name.is_none() {
                self.display_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.display_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_display_name(&mut self) -> ::std::string::String {
            self.display_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string image_url = 5;

        pub fn image_url(&self) -> &str {
            match self.image_url.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_image_url(&mut self) {
            self.image_url = ::std::option::Option::None;
        }

        pub fn has_image_url(&self) -> bool {
            self.image_url.is_some()
        }

        // Param is passed by value, moved
        pub fn set_image_url(&mut self, v: ::std::string::String) {
            self.image_url = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_image_url(&mut self) -> &mut ::std::string::String {
            if self.image_url.is_none() {
                self.image_url = ::std::option::Option::Some(::std::string::String::new());
            }
            self.image_url.as_mut().unwrap()
        }

        // Take field
        pub fn take_image_url(&mut self) -> ::std::string::String {
            self.image_url.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool show_in_search = 6;

        pub fn show_in_search(&self) -> bool {
            self.show_in_search.unwrap_or(false)
        }

        pub fn clear_show_in_search(&mut self) {
            self.show_in_search = ::std::option::Option::None;
        }

        pub fn has_show_in_search(&self) -> bool {
            self.show_in_search.is_some()
        }

        // Param is passed by value, moved
        pub fn set_show_in_search(&mut self, v: bool) {
            self.show_in_search = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Category {
        const NAME: &'static str = "Category";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.categoryid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    26 => {
                        self.internal_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    34 => {
                        self.display_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    42 => {
                        self.image_url = ::std::option::Option::Some(is.read_string()?);
                    },
                    48 => {
                        self.show_in_search = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.categoryid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.type_ {
                my_size += ::protobuf::rt::int32_size(2, v.value());
            }
            if let Some(v) = self.internal_name.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.display_name.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            if let Some(v) = self.image_url.as_ref() {
                my_size += ::protobuf::rt::string_size(5, &v);
            }
            if let Some(v) = self.show_in_search {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.categoryid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.type_ {
                os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.internal_name.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.display_name.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.image_url.as_ref() {
                os.write_string(5, v)?;
            }
            if let Some(v) = self.show_in_search {
                os.write_bool(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Category {
            Category::new()
        }

        fn clear(&mut self) {
            self.categoryid = ::std::option::Option::None;
            self.type_ = ::std::option::Option::None;
            self.internal_name = ::std::option::Option::None;
            self.display_name = ::std::option::Option::None;
            self.image_url = ::std::option::Option::None;
            self.show_in_search = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Category {
            static instance: Category = Category {
                categoryid: ::std::option::Option::None,
                type_: ::std::option::Option::None,
                internal_name: ::std::option::Option::None,
                display_name: ::std::option::Option::None,
                image_url: ::std::option::Option::None,
                show_in_search: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

#[doc = "Returns all DLC appids for games owned by the user."]
// @@protoc_insertion_point(message:CStoreBrowse_GetDLCForApps_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStoreBrowse_GetDLCForApps_Request {
    // message fields
    // @@protoc_insertion_point(field:CStoreBrowse_GetDLCForApps_Request.context)
    pub context: ::protobuf::MessageField<StoreBrowseContext>,
    // @@protoc_insertion_point(field:CStoreBrowse_GetDLCForApps_Request.store_page_filter)
    pub store_page_filter: ::protobuf::MessageField<super::contenthubs::CStorePageFilter>,
    // @@protoc_insertion_point(field:CStoreBrowse_GetDLCForApps_Request.appids)
    pub appids: ::std::vec::Vec<StoreItemID>,
    // @@protoc_insertion_point(field:CStoreBrowse_GetDLCForApps_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CStoreBrowse_GetDLCForApps_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStoreBrowse_GetDLCForApps_Request {
    fn default() -> &'a CStoreBrowse_GetDLCForApps_Request {
        <CStoreBrowse_GetDLCForApps_Request as ::protobuf::Message>::default_instance()
    }
}

impl CStoreBrowse_GetDLCForApps_Request {
    pub fn new() -> CStoreBrowse_GetDLCForApps_Request {
        ::std::default::Default::default()
    }

    // optional uint64 steamid = 4;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CStoreBrowse_GetDLCForApps_Request {
    const NAME: &'static str = "CStoreBrowse_GetDLCForApps_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.context)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.store_page_filter)?;
                },
                26 => {
                    self.appids.push(is.read_message()?);
                },
                32 => {
                    self.steamid = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.store_page_filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.appids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.steamid {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.context.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.store_page_filter.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.appids {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.steamid {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStoreBrowse_GetDLCForApps_Request {
        CStoreBrowse_GetDLCForApps_Request::new()
    }

    fn clear(&mut self) {
        self.context.clear();
        self.store_page_filter.clear();
        self.appids.clear();
        self.steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStoreBrowse_GetDLCForApps_Request {
        static instance: CStoreBrowse_GetDLCForApps_Request = CStoreBrowse_GetDLCForApps_Request {
            context: ::protobuf::MessageField::none(),
            store_page_filter: ::protobuf::MessageField::none(),
            appids: ::std::vec::Vec::new(),
            steamid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CStoreBrowse_GetDLCForApps_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStoreBrowse_GetDLCForApps_Response {
    // message fields
    // @@protoc_insertion_point(field:CStoreBrowse_GetDLCForApps_Response.dlc_data)
    pub dlc_data: ::std::vec::Vec<cstore_browse_get_dlcfor_apps_response::DLCData>,
    // @@protoc_insertion_point(field:CStoreBrowse_GetDLCForApps_Response.playtime)
    pub playtime: ::std::vec::Vec<cstore_browse_get_dlcfor_apps_response::PlaytimeForApp>,
    // special fields
    // @@protoc_insertion_point(special_field:CStoreBrowse_GetDLCForApps_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStoreBrowse_GetDLCForApps_Response {
    fn default() -> &'a CStoreBrowse_GetDLCForApps_Response {
        <CStoreBrowse_GetDLCForApps_Response as ::protobuf::Message>::default_instance()
    }
}

impl CStoreBrowse_GetDLCForApps_Response {
    pub fn new() -> CStoreBrowse_GetDLCForApps_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CStoreBrowse_GetDLCForApps_Response {
    const NAME: &'static str = "CStoreBrowse_GetDLCForApps_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.dlc_data.push(is.read_message()?);
                },
                18 => {
                    self.playtime.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.dlc_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.playtime {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.dlc_data {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.playtime {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStoreBrowse_GetDLCForApps_Response {
        CStoreBrowse_GetDLCForApps_Response::new()
    }

    fn clear(&mut self) {
        self.dlc_data.clear();
        self.playtime.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStoreBrowse_GetDLCForApps_Response {
        static instance: CStoreBrowse_GetDLCForApps_Response = CStoreBrowse_GetDLCForApps_Response {
            dlc_data: ::std::vec::Vec::new(),
            playtime: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CStoreBrowse_GetDLCForApps_Response`
pub mod cstore_browse_get_dlcfor_apps_response {
    // @@protoc_insertion_point(message:CStoreBrowse_GetDLCForApps_Response.DLCData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DLCData {
        // message fields
        // @@protoc_insertion_point(field:CStoreBrowse_GetDLCForApps_Response.DLCData.appid)
        pub appid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CStoreBrowse_GetDLCForApps_Response.DLCData.parentappid)
        pub parentappid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CStoreBrowse_GetDLCForApps_Response.DLCData.release_date)
        pub release_date: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CStoreBrowse_GetDLCForApps_Response.DLCData.coming_soon)
        pub coming_soon: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CStoreBrowse_GetDLCForApps_Response.DLCData.price)
        pub price: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:CStoreBrowse_GetDLCForApps_Response.DLCData.discount)
        pub discount: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CStoreBrowse_GetDLCForApps_Response.DLCData.free)
        pub free: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CStoreBrowse_GetDLCForApps_Response.DLCData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DLCData {
        fn default() -> &'a DLCData {
            <DLCData as ::protobuf::Message>::default_instance()
        }
    }

    impl DLCData {
        pub fn new() -> DLCData {
            ::std::default::Default::default()
        }

        // optional uint32 appid = 1;

        pub fn appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }

        // optional uint32 parentappid = 2;

        pub fn parentappid(&self) -> u32 {
            self.parentappid.unwrap_or(0)
        }

        pub fn clear_parentappid(&mut self) {
            self.parentappid = ::std::option::Option::None;
        }

        pub fn has_parentappid(&self) -> bool {
            self.parentappid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_parentappid(&mut self, v: u32) {
            self.parentappid = ::std::option::Option::Some(v);
        }

        // optional uint32 release_date = 3;

        pub fn release_date(&self) -> u32 {
            self.release_date.unwrap_or(0)
        }

        pub fn clear_release_date(&mut self) {
            self.release_date = ::std::option::Option::None;
        }

        pub fn has_release_date(&self) -> bool {
            self.release_date.is_some()
        }

        // Param is passed by value, moved
        pub fn set_release_date(&mut self, v: u32) {
            self.release_date = ::std::option::Option::Some(v);
        }

        // optional bool coming_soon = 4;

        pub fn coming_soon(&self) -> bool {
            self.coming_soon.unwrap_or(false)
        }

        pub fn clear_coming_soon(&mut self) {
            self.coming_soon = ::std::option::Option::None;
        }

        pub fn has_coming_soon(&self) -> bool {
            self.coming_soon.is_some()
        }

        // Param is passed by value, moved
        pub fn set_coming_soon(&mut self, v: bool) {
            self.coming_soon = ::std::option::Option::Some(v);
        }

        // optional int64 price = 5;

        pub fn price(&self) -> i64 {
            self.price.unwrap_or(0)
        }

        pub fn clear_price(&mut self) {
            self.price = ::std::option::Option::None;
        }

        pub fn has_price(&self) -> bool {
            self.price.is_some()
        }

        // Param is passed by value, moved
        pub fn set_price(&mut self, v: i64) {
            self.price = ::std::option::Option::Some(v);
        }

        // optional uint32 discount = 6;

        pub fn discount(&self) -> u32 {
            self.discount.unwrap_or(0)
        }

        pub fn clear_discount(&mut self) {
            self.discount = ::std::option::Option::None;
        }

        pub fn has_discount(&self) -> bool {
            self.discount.is_some()
        }

        // Param is passed by value, moved
        pub fn set_discount(&mut self, v: u32) {
            self.discount = ::std::option::Option::Some(v);
        }

        // optional bool free = 7;

        pub fn free(&self) -> bool {
            self.free.unwrap_or(false)
        }

        pub fn clear_free(&mut self) {
            self.free = ::std::option::Option::None;
        }

        pub fn has_free(&self) -> bool {
            self.free.is_some()
        }

        // Param is passed by value, moved
        pub fn set_free(&mut self, v: bool) {
            self.free = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for DLCData {
        const NAME: &'static str = "DLCData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.parentappid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.release_date = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.coming_soon = ::std::option::Option::Some(is.read_bool()?);
                    },
                    40 => {
                        self.price = ::std::option::Option::Some(is.read_int64()?);
                    },
                    48 => {
                        self.discount = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.free = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.appid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.parentappid {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.release_date {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.coming_soon {
                my_size += 1 + 1;
            }
            if let Some(v) = self.price {
                my_size += ::protobuf::rt::int64_size(5, v);
            }
            if let Some(v) = self.discount {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.free {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.appid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.parentappid {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.release_date {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.coming_soon {
                os.write_bool(4, v)?;
            }
            if let Some(v) = self.price {
                os.write_int64(5, v)?;
            }
            if let Some(v) = self.discount {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.free {
                os.write_bool(7, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DLCData {
            DLCData::new()
        }

        fn clear(&mut self) {
            self.appid = ::std::option::Option::None;
            self.parentappid = ::std::option::Option::None;
            self.release_date = ::std::option::Option::None;
            self.coming_soon = ::std::option::Option::None;
            self.price = ::std::option::Option::None;
            self.discount = ::std::option::Option::None;
            self.free = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DLCData {
            static instance: DLCData = DLCData {
                appid: ::std::option::Option::None,
                parentappid: ::std::option::Option::None,
                release_date: ::std::option::Option::None,
                coming_soon: ::std::option::Option::None,
                price: ::std::option::Option::None,
                discount: ::std::option::Option::None,
                free: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CStoreBrowse_GetDLCForApps_Response.PlaytimeForApp)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlaytimeForApp {
        // message fields
        // @@protoc_insertion_point(field:CStoreBrowse_GetDLCForApps_Response.PlaytimeForApp.appid)
        pub appid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CStoreBrowse_GetDLCForApps_Response.PlaytimeForApp.playtime)
        pub playtime: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CStoreBrowse_GetDLCForApps_Response.PlaytimeForApp.last_played)
        pub last_played: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CStoreBrowse_GetDLCForApps_Response.PlaytimeForApp.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlaytimeForApp {
        fn default() -> &'a PlaytimeForApp {
            <PlaytimeForApp as ::protobuf::Message>::default_instance()
        }
    }

    impl PlaytimeForApp {
        pub fn new() -> PlaytimeForApp {
            ::std::default::Default::default()
        }

        // optional uint32 appid = 1;

        pub fn appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }

        // optional uint32 playtime = 2;

        pub fn playtime(&self) -> u32 {
            self.playtime.unwrap_or(0)
        }

        pub fn clear_playtime(&mut self) {
            self.playtime = ::std::option::Option::None;
        }

        pub fn has_playtime(&self) -> bool {
            self.playtime.is_some()
        }

        // Param is passed by value, moved
        pub fn set_playtime(&mut self, v: u32) {
            self.playtime = ::std::option::Option::Some(v);
        }

        // optional uint32 last_played = 3;

        pub fn last_played(&self) -> u32 {
            self.last_played.unwrap_or(0)
        }

        pub fn clear_last_played(&mut self) {
            self.last_played = ::std::option::Option::None;
        }

        pub fn has_last_played(&self) -> bool {
            self.last_played.is_some()
        }

        // Param is passed by value, moved
        pub fn set_last_played(&mut self, v: u32) {
            self.last_played = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for PlaytimeForApp {
        const NAME: &'static str = "PlaytimeForApp";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.playtime = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.last_played = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.appid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.playtime {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.last_played {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.appid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.playtime {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.last_played {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlaytimeForApp {
            PlaytimeForApp::new()
        }

        fn clear(&mut self) {
            self.appid = ::std::option::Option::None;
            self.playtime = ::std::option::Option::None;
            self.last_played = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlaytimeForApp {
            static instance: PlaytimeForApp = PlaytimeForApp {
                appid: ::std::option::Option::None,
                playtime: ::std::option::Option::None,
                last_played: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

#[doc = "Returns all DLC appids for the specified games."]
// @@protoc_insertion_point(message:CStoreBrowse_GetDLCForAppsSolr_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStoreBrowse_GetDLCForAppsSolr_Request {
    // message fields
    // @@protoc_insertion_point(field:CStoreBrowse_GetDLCForAppsSolr_Request.context)
    pub context: ::protobuf::MessageField<StoreBrowseContext>,
    // @@protoc_insertion_point(field:CStoreBrowse_GetDLCForAppsSolr_Request.appids)
    pub appids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CStoreBrowse_GetDLCForAppsSolr_Request.flavor)
    pub flavor: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CStoreBrowse_GetDLCForAppsSolr_Request.count)
    pub count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStoreBrowse_GetDLCForAppsSolr_Request.store_page_filter)
    pub store_page_filter: ::protobuf::MessageField<super::contenthubs::CStorePageFilter>,
    // special fields
    // @@protoc_insertion_point(special_field:CStoreBrowse_GetDLCForAppsSolr_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStoreBrowse_GetDLCForAppsSolr_Request {
    fn default() -> &'a CStoreBrowse_GetDLCForAppsSolr_Request {
        <CStoreBrowse_GetDLCForAppsSolr_Request as ::protobuf::Message>::default_instance()
    }
}

impl CStoreBrowse_GetDLCForAppsSolr_Request {
    pub fn new() -> CStoreBrowse_GetDLCForAppsSolr_Request {
        ::std::default::Default::default()
    }

    // optional string flavor = 3;

    pub fn flavor(&self) -> &str {
        match self.flavor.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_flavor(&mut self) {
        self.flavor = ::std::option::Option::None;
    }

    pub fn has_flavor(&self) -> bool {
        self.flavor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flavor(&mut self, v: ::std::string::String) {
        self.flavor = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_flavor(&mut self) -> &mut ::std::string::String {
        if self.flavor.is_none() {
            self.flavor = ::std::option::Option::Some(::std::string::String::new());
        }
        self.flavor.as_mut().unwrap()
    }

    // Take field
    pub fn take_flavor(&mut self) -> ::std::string::String {
        self.flavor.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 count = 4;

    pub fn count(&self) -> u32 {
        self.count.unwrap_or(0)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u32) {
        self.count = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CStoreBrowse_GetDLCForAppsSolr_Request {
    const NAME: &'static str = "CStoreBrowse_GetDLCForAppsSolr_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.context)?;
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.appids)?;
                },
                16 => {
                    self.appids.push(is.read_uint32()?);
                },
                26 => {
                    self.flavor = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.count = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.store_page_filter)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.appids {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        if let Some(v) = self.flavor.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.store_page_filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.context.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.appids {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.flavor.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.count {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.store_page_filter.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStoreBrowse_GetDLCForAppsSolr_Request {
        CStoreBrowse_GetDLCForAppsSolr_Request::new()
    }

    fn clear(&mut self) {
        self.context.clear();
        self.appids.clear();
        self.flavor = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.store_page_filter.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStoreBrowse_GetDLCForAppsSolr_Request {
        static instance: CStoreBrowse_GetDLCForAppsSolr_Request = CStoreBrowse_GetDLCForAppsSolr_Request {
            context: ::protobuf::MessageField::none(),
            appids: ::std::vec::Vec::new(),
            flavor: ::std::option::Option::None,
            count: ::std::option::Option::None,
            store_page_filter: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CStoreBrowse_GetDLCForAppsSolr_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStoreBrowse_GetDLCForAppsSolr_Response {
    // message fields
    // @@protoc_insertion_point(field:CStoreBrowse_GetDLCForAppsSolr_Response.dlc_lists)
    pub dlc_lists: ::std::vec::Vec<cstore_browse_get_dlcfor_apps_solr_response::DLCList>,
    // special fields
    // @@protoc_insertion_point(special_field:CStoreBrowse_GetDLCForAppsSolr_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStoreBrowse_GetDLCForAppsSolr_Response {
    fn default() -> &'a CStoreBrowse_GetDLCForAppsSolr_Response {
        <CStoreBrowse_GetDLCForAppsSolr_Response as ::protobuf::Message>::default_instance()
    }
}

impl CStoreBrowse_GetDLCForAppsSolr_Response {
    pub fn new() -> CStoreBrowse_GetDLCForAppsSolr_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CStoreBrowse_GetDLCForAppsSolr_Response {
    const NAME: &'static str = "CStoreBrowse_GetDLCForAppsSolr_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.dlc_lists.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.dlc_lists {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.dlc_lists {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStoreBrowse_GetDLCForAppsSolr_Response {
        CStoreBrowse_GetDLCForAppsSolr_Response::new()
    }

    fn clear(&mut self) {
        self.dlc_lists.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStoreBrowse_GetDLCForAppsSolr_Response {
        static instance: CStoreBrowse_GetDLCForAppsSolr_Response = CStoreBrowse_GetDLCForAppsSolr_Response {
            dlc_lists: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CStoreBrowse_GetDLCForAppsSolr_Response`
pub mod cstore_browse_get_dlcfor_apps_solr_response {
    // @@protoc_insertion_point(message:CStoreBrowse_GetDLCForAppsSolr_Response.DLCList)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DLCList {
        // message fields
        // @@protoc_insertion_point(field:CStoreBrowse_GetDLCForAppsSolr_Response.DLCList.parent_appid)
        pub parent_appid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CStoreBrowse_GetDLCForAppsSolr_Response.DLCList.dlc_appids)
        pub dlc_appids: ::std::vec::Vec<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CStoreBrowse_GetDLCForAppsSolr_Response.DLCList.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DLCList {
        fn default() -> &'a DLCList {
            <DLCList as ::protobuf::Message>::default_instance()
        }
    }

    impl DLCList {
        pub fn new() -> DLCList {
            ::std::default::Default::default()
        }

        // optional uint32 parent_appid = 1;

        pub fn parent_appid(&self) -> u32 {
            self.parent_appid.unwrap_or(0)
        }

        pub fn clear_parent_appid(&mut self) {
            self.parent_appid = ::std::option::Option::None;
        }

        pub fn has_parent_appid(&self) -> bool {
            self.parent_appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_parent_appid(&mut self, v: u32) {
            self.parent_appid = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for DLCList {
        const NAME: &'static str = "DLCList";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.parent_appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        is.read_repeated_packed_uint32_into(&mut self.dlc_appids)?;
                    },
                    16 => {
                        self.dlc_appids.push(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.parent_appid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            for value in &self.dlc_appids {
                my_size += ::protobuf::rt::uint32_size(2, *value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.parent_appid {
                os.write_uint32(1, v)?;
            }
            for v in &self.dlc_appids {
                os.write_uint32(2, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DLCList {
            DLCList::new()
        }

        fn clear(&mut self) {
            self.parent_appid = ::std::option::Option::None;
            self.dlc_appids.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DLCList {
            static instance: DLCList = DLCList {
                parent_appid: ::std::option::Option::None,
                dlc_appids: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStoreItemType)
pub enum EStoreItemType {
    // @@protoc_insertion_point(enum_value:EStoreItemType.k_EStoreItemType_Invalid)
    k_EStoreItemType_Invalid = -1,
    // @@protoc_insertion_point(enum_value:EStoreItemType.k_EStoreItemType_App)
    k_EStoreItemType_App = 0,
    // @@protoc_insertion_point(enum_value:EStoreItemType.k_EStoreItemType_Package)
    k_EStoreItemType_Package = 1,
    // @@protoc_insertion_point(enum_value:EStoreItemType.k_EStoreItemType_Bundle)
    k_EStoreItemType_Bundle = 2,
    // @@protoc_insertion_point(enum_value:EStoreItemType.k_EStoreItemType_Mtx)
    k_EStoreItemType_Mtx = 3,
    // @@protoc_insertion_point(enum_value:EStoreItemType.k_EStoreItemType_Tag)
    k_EStoreItemType_Tag = 4,
    // @@protoc_insertion_point(enum_value:EStoreItemType.k_EStoreItemType_Creator)
    k_EStoreItemType_Creator = 5,
    // @@protoc_insertion_point(enum_value:EStoreItemType.k_EStoreItemType_HubCategory)
    k_EStoreItemType_HubCategory = 6,
}

impl ::protobuf::Enum for EStoreItemType {
    const NAME: &'static str = "EStoreItemType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStoreItemType> {
        match value {
            -1 => ::std::option::Option::Some(EStoreItemType::k_EStoreItemType_Invalid),
            0 => ::std::option::Option::Some(EStoreItemType::k_EStoreItemType_App),
            1 => ::std::option::Option::Some(EStoreItemType::k_EStoreItemType_Package),
            2 => ::std::option::Option::Some(EStoreItemType::k_EStoreItemType_Bundle),
            3 => ::std::option::Option::Some(EStoreItemType::k_EStoreItemType_Mtx),
            4 => ::std::option::Option::Some(EStoreItemType::k_EStoreItemType_Tag),
            5 => ::std::option::Option::Some(EStoreItemType::k_EStoreItemType_Creator),
            6 => ::std::option::Option::Some(EStoreItemType::k_EStoreItemType_HubCategory),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStoreItemType> {
        match str {
            "k_EStoreItemType_Invalid" => ::std::option::Option::Some(EStoreItemType::k_EStoreItemType_Invalid),
            "k_EStoreItemType_App" => ::std::option::Option::Some(EStoreItemType::k_EStoreItemType_App),
            "k_EStoreItemType_Package" => ::std::option::Option::Some(EStoreItemType::k_EStoreItemType_Package),
            "k_EStoreItemType_Bundle" => ::std::option::Option::Some(EStoreItemType::k_EStoreItemType_Bundle),
            "k_EStoreItemType_Mtx" => ::std::option::Option::Some(EStoreItemType::k_EStoreItemType_Mtx),
            "k_EStoreItemType_Tag" => ::std::option::Option::Some(EStoreItemType::k_EStoreItemType_Tag),
            "k_EStoreItemType_Creator" => ::std::option::Option::Some(EStoreItemType::k_EStoreItemType_Creator),
            "k_EStoreItemType_HubCategory" => ::std::option::Option::Some(EStoreItemType::k_EStoreItemType_HubCategory),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStoreItemType] = &[
        EStoreItemType::k_EStoreItemType_Invalid,
        EStoreItemType::k_EStoreItemType_App,
        EStoreItemType::k_EStoreItemType_Package,
        EStoreItemType::k_EStoreItemType_Bundle,
        EStoreItemType::k_EStoreItemType_Mtx,
        EStoreItemType::k_EStoreItemType_Tag,
        EStoreItemType::k_EStoreItemType_Creator,
        EStoreItemType::k_EStoreItemType_HubCategory,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EStoreItemType {
    fn default() -> Self {
        EStoreItemType::k_EStoreItemType_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStoreAppType)
pub enum EStoreAppType {
    // @@protoc_insertion_point(enum_value:EStoreAppType.k_EStoreAppType_Game)
    k_EStoreAppType_Game = 0,
    // @@protoc_insertion_point(enum_value:EStoreAppType.k_EStoreAppType_Demo)
    k_EStoreAppType_Demo = 1,
    // @@protoc_insertion_point(enum_value:EStoreAppType.k_EStoreAppType_Mod)
    k_EStoreAppType_Mod = 2,
    // @@protoc_insertion_point(enum_value:EStoreAppType.k_EStoreAppType_Movie)
    k_EStoreAppType_Movie = 3,
    // @@protoc_insertion_point(enum_value:EStoreAppType.k_EStoreAppType_DLC)
    k_EStoreAppType_DLC = 4,
    // @@protoc_insertion_point(enum_value:EStoreAppType.k_EStoreAppType_Guide)
    k_EStoreAppType_Guide = 5,
    // @@protoc_insertion_point(enum_value:EStoreAppType.k_EStoreAppType_Software)
    k_EStoreAppType_Software = 6,
    // @@protoc_insertion_point(enum_value:EStoreAppType.k_EStoreAppType_Video)
    k_EStoreAppType_Video = 7,
    // @@protoc_insertion_point(enum_value:EStoreAppType.k_EStoreAppType_Series)
    k_EStoreAppType_Series = 8,
    // @@protoc_insertion_point(enum_value:EStoreAppType.k_EStoreAppType_Episode)
    k_EStoreAppType_Episode = 9,
    // @@protoc_insertion_point(enum_value:EStoreAppType.k_EStoreAppType_Hardware)
    k_EStoreAppType_Hardware = 10,
    // @@protoc_insertion_point(enum_value:EStoreAppType.k_EStoreAppType_Music)
    k_EStoreAppType_Music = 11,
    // @@protoc_insertion_point(enum_value:EStoreAppType.k_EStoreAppType_Beta)
    k_EStoreAppType_Beta = 12,
    // @@protoc_insertion_point(enum_value:EStoreAppType.k_EStoreAppType_Tool)
    k_EStoreAppType_Tool = 13,
    // @@protoc_insertion_point(enum_value:EStoreAppType.k_EStoreAppType_Advertising)
    k_EStoreAppType_Advertising = 14,
}

impl ::protobuf::Enum for EStoreAppType {
    const NAME: &'static str = "EStoreAppType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStoreAppType> {
        match value {
            0 => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Game),
            1 => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Demo),
            2 => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Mod),
            3 => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Movie),
            4 => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_DLC),
            5 => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Guide),
            6 => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Software),
            7 => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Video),
            8 => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Series),
            9 => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Episode),
            10 => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Hardware),
            11 => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Music),
            12 => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Beta),
            13 => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Tool),
            14 => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Advertising),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStoreAppType> {
        match str {
            "k_EStoreAppType_Game" => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Game),
            "k_EStoreAppType_Demo" => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Demo),
            "k_EStoreAppType_Mod" => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Mod),
            "k_EStoreAppType_Movie" => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Movie),
            "k_EStoreAppType_DLC" => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_DLC),
            "k_EStoreAppType_Guide" => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Guide),
            "k_EStoreAppType_Software" => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Software),
            "k_EStoreAppType_Video" => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Video),
            "k_EStoreAppType_Series" => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Series),
            "k_EStoreAppType_Episode" => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Episode),
            "k_EStoreAppType_Hardware" => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Hardware),
            "k_EStoreAppType_Music" => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Music),
            "k_EStoreAppType_Beta" => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Beta),
            "k_EStoreAppType_Tool" => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Tool),
            "k_EStoreAppType_Advertising" => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Advertising),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStoreAppType] = &[
        EStoreAppType::k_EStoreAppType_Game,
        EStoreAppType::k_EStoreAppType_Demo,
        EStoreAppType::k_EStoreAppType_Mod,
        EStoreAppType::k_EStoreAppType_Movie,
        EStoreAppType::k_EStoreAppType_DLC,
        EStoreAppType::k_EStoreAppType_Guide,
        EStoreAppType::k_EStoreAppType_Software,
        EStoreAppType::k_EStoreAppType_Video,
        EStoreAppType::k_EStoreAppType_Series,
        EStoreAppType::k_EStoreAppType_Episode,
        EStoreAppType::k_EStoreAppType_Hardware,
        EStoreAppType::k_EStoreAppType_Music,
        EStoreAppType::k_EStoreAppType_Beta,
        EStoreAppType::k_EStoreAppType_Tool,
        EStoreAppType::k_EStoreAppType_Advertising,
    ];
}

impl ::std::default::Default for EStoreAppType {
    fn default() -> Self {
        EStoreAppType::k_EStoreAppType_Game
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EUserReviewScore)
pub enum EUserReviewScore {
    // @@protoc_insertion_point(enum_value:EUserReviewScore.k_EUserReviewScore_None)
    k_EUserReviewScore_None = 0,
    // @@protoc_insertion_point(enum_value:EUserReviewScore.k_EUserReviewScore_OverwhelminglyNegative)
    k_EUserReviewScore_OverwhelminglyNegative = 1,
    // @@protoc_insertion_point(enum_value:EUserReviewScore.k_EUserReviewScore_VeryNegative)
    k_EUserReviewScore_VeryNegative = 2,
    // @@protoc_insertion_point(enum_value:EUserReviewScore.k_EUserReviewScore_Negative)
    k_EUserReviewScore_Negative = 3,
    // @@protoc_insertion_point(enum_value:EUserReviewScore.k_EUserReviewScore_MostlyNegative)
    k_EUserReviewScore_MostlyNegative = 4,
    // @@protoc_insertion_point(enum_value:EUserReviewScore.k_EUserReviewScore_Mixed)
    k_EUserReviewScore_Mixed = 5,
    // @@protoc_insertion_point(enum_value:EUserReviewScore.k_EUserReviewScore_MostlyPositive)
    k_EUserReviewScore_MostlyPositive = 6,
    // @@protoc_insertion_point(enum_value:EUserReviewScore.k_EUserReviewScore_Positive)
    k_EUserReviewScore_Positive = 7,
    // @@protoc_insertion_point(enum_value:EUserReviewScore.k_EUserReviewScore_VeryPositive)
    k_EUserReviewScore_VeryPositive = 8,
    // @@protoc_insertion_point(enum_value:EUserReviewScore.k_EUserReviewScore_OverwhelminglyPositive)
    k_EUserReviewScore_OverwhelminglyPositive = 9,
}

impl ::protobuf::Enum for EUserReviewScore {
    const NAME: &'static str = "EUserReviewScore";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EUserReviewScore> {
        match value {
            0 => ::std::option::Option::Some(EUserReviewScore::k_EUserReviewScore_None),
            1 => ::std::option::Option::Some(EUserReviewScore::k_EUserReviewScore_OverwhelminglyNegative),
            2 => ::std::option::Option::Some(EUserReviewScore::k_EUserReviewScore_VeryNegative),
            3 => ::std::option::Option::Some(EUserReviewScore::k_EUserReviewScore_Negative),
            4 => ::std::option::Option::Some(EUserReviewScore::k_EUserReviewScore_MostlyNegative),
            5 => ::std::option::Option::Some(EUserReviewScore::k_EUserReviewScore_Mixed),
            6 => ::std::option::Option::Some(EUserReviewScore::k_EUserReviewScore_MostlyPositive),
            7 => ::std::option::Option::Some(EUserReviewScore::k_EUserReviewScore_Positive),
            8 => ::std::option::Option::Some(EUserReviewScore::k_EUserReviewScore_VeryPositive),
            9 => ::std::option::Option::Some(EUserReviewScore::k_EUserReviewScore_OverwhelminglyPositive),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EUserReviewScore> {
        match str {
            "k_EUserReviewScore_None" => ::std::option::Option::Some(EUserReviewScore::k_EUserReviewScore_None),
            "k_EUserReviewScore_OverwhelminglyNegative" => ::std::option::Option::Some(EUserReviewScore::k_EUserReviewScore_OverwhelminglyNegative),
            "k_EUserReviewScore_VeryNegative" => ::std::option::Option::Some(EUserReviewScore::k_EUserReviewScore_VeryNegative),
            "k_EUserReviewScore_Negative" => ::std::option::Option::Some(EUserReviewScore::k_EUserReviewScore_Negative),
            "k_EUserReviewScore_MostlyNegative" => ::std::option::Option::Some(EUserReviewScore::k_EUserReviewScore_MostlyNegative),
            "k_EUserReviewScore_Mixed" => ::std::option::Option::Some(EUserReviewScore::k_EUserReviewScore_Mixed),
            "k_EUserReviewScore_MostlyPositive" => ::std::option::Option::Some(EUserReviewScore::k_EUserReviewScore_MostlyPositive),
            "k_EUserReviewScore_Positive" => ::std::option::Option::Some(EUserReviewScore::k_EUserReviewScore_Positive),
            "k_EUserReviewScore_VeryPositive" => ::std::option::Option::Some(EUserReviewScore::k_EUserReviewScore_VeryPositive),
            "k_EUserReviewScore_OverwhelminglyPositive" => ::std::option::Option::Some(EUserReviewScore::k_EUserReviewScore_OverwhelminglyPositive),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EUserReviewScore] = &[
        EUserReviewScore::k_EUserReviewScore_None,
        EUserReviewScore::k_EUserReviewScore_OverwhelminglyNegative,
        EUserReviewScore::k_EUserReviewScore_VeryNegative,
        EUserReviewScore::k_EUserReviewScore_Negative,
        EUserReviewScore::k_EUserReviewScore_MostlyNegative,
        EUserReviewScore::k_EUserReviewScore_Mixed,
        EUserReviewScore::k_EUserReviewScore_MostlyPositive,
        EUserReviewScore::k_EUserReviewScore_Positive,
        EUserReviewScore::k_EUserReviewScore_VeryPositive,
        EUserReviewScore::k_EUserReviewScore_OverwhelminglyPositive,
    ];
}

impl ::std::default::Default for EUserReviewScore {
    fn default() -> Self {
        EUserReviewScore::k_EUserReviewScore_None
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStoreCategoryType)
pub enum EStoreCategoryType {
    // @@protoc_insertion_point(enum_value:EStoreCategoryType.k_EStoreCategoryType_Category)
    k_EStoreCategoryType_Category = 0,
    // @@protoc_insertion_point(enum_value:EStoreCategoryType.k_EStoreCategoryType_SupportedPlayers)
    k_EStoreCategoryType_SupportedPlayers = 1,
    // @@protoc_insertion_point(enum_value:EStoreCategoryType.k_EStoreCategoryType_Feature)
    k_EStoreCategoryType_Feature = 2,
    // @@protoc_insertion_point(enum_value:EStoreCategoryType.k_EStoreCategoryType_ControllerSupport)
    k_EStoreCategoryType_ControllerSupport = 3,
    // @@protoc_insertion_point(enum_value:EStoreCategoryType.k_EStoreCategoryType_CloudGaming)
    k_EStoreCategoryType_CloudGaming = 4,
    // @@protoc_insertion_point(enum_value:EStoreCategoryType.k_EStoreCategoryType_MAX)
    k_EStoreCategoryType_MAX = 5,
}

impl ::protobuf::Enum for EStoreCategoryType {
    const NAME: &'static str = "EStoreCategoryType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStoreCategoryType> {
        match value {
            0 => ::std::option::Option::Some(EStoreCategoryType::k_EStoreCategoryType_Category),
            1 => ::std::option::Option::Some(EStoreCategoryType::k_EStoreCategoryType_SupportedPlayers),
            2 => ::std::option::Option::Some(EStoreCategoryType::k_EStoreCategoryType_Feature),
            3 => ::std::option::Option::Some(EStoreCategoryType::k_EStoreCategoryType_ControllerSupport),
            4 => ::std::option::Option::Some(EStoreCategoryType::k_EStoreCategoryType_CloudGaming),
            5 => ::std::option::Option::Some(EStoreCategoryType::k_EStoreCategoryType_MAX),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStoreCategoryType> {
        match str {
            "k_EStoreCategoryType_Category" => ::std::option::Option::Some(EStoreCategoryType::k_EStoreCategoryType_Category),
            "k_EStoreCategoryType_SupportedPlayers" => ::std::option::Option::Some(EStoreCategoryType::k_EStoreCategoryType_SupportedPlayers),
            "k_EStoreCategoryType_Feature" => ::std::option::Option::Some(EStoreCategoryType::k_EStoreCategoryType_Feature),
            "k_EStoreCategoryType_ControllerSupport" => ::std::option::Option::Some(EStoreCategoryType::k_EStoreCategoryType_ControllerSupport),
            "k_EStoreCategoryType_CloudGaming" => ::std::option::Option::Some(EStoreCategoryType::k_EStoreCategoryType_CloudGaming),
            "k_EStoreCategoryType_MAX" => ::std::option::Option::Some(EStoreCategoryType::k_EStoreCategoryType_MAX),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStoreCategoryType] = &[
        EStoreCategoryType::k_EStoreCategoryType_Category,
        EStoreCategoryType::k_EStoreCategoryType_SupportedPlayers,
        EStoreCategoryType::k_EStoreCategoryType_Feature,
        EStoreCategoryType::k_EStoreCategoryType_ControllerSupport,
        EStoreCategoryType::k_EStoreCategoryType_CloudGaming,
        EStoreCategoryType::k_EStoreCategoryType_MAX,
    ];
}

impl ::std::default::Default for EStoreCategoryType {
    fn default() -> Self {
        EStoreCategoryType::k_EStoreCategoryType_Category
    }
}

#[allow(unused_imports)]
use crate::steammessages_base::*;
#[allow(unused_imports)]
use crate::steammessages_unified_base_steamclient::*;
#[allow(unused_imports)]
use crate::enums_productinfo::*;
#[allow(unused_imports)]
use crate::enums::*;
#[allow(unused_imports)]
use crate::contenthubs::*;
impl crate::RpcMessage for StoreItemID {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for StoreBrowseContext {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for StoreBrowseItemDataRequest {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStoreBrowse_GetItems_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for StoreGameRating {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for StoreItem {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStoreBrowse_GetItems_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStoreBrowse_GetStoreCategories_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStoreBrowse_GetStoreCategories_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStoreBrowse_GetDLCForApps_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStoreBrowse_GetDLCForApps_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStoreBrowse_GetDLCForAppsSolr_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStoreBrowse_GetDLCForAppsSolr_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
///APIs for accessing store item data
struct StoreBrowse {}
impl crate::RpcService for StoreBrowse {
    const SERVICE_NAME: &'static str = "StoreBrowse";
}
impl crate::RpcMethod for CStoreBrowse_GetDLCForAppsSolr_Request {
    const METHOD_NAME: &'static str = "StoreBrowse.GetDLCForAppsSolr#1";
    type Response = CStoreBrowse_GetDLCForAppsSolr_Response;
}
impl crate::RpcMethod for CStoreBrowse_GetDLCForApps_Request {
    const METHOD_NAME: &'static str = "StoreBrowse.GetDLCForApps#1";
    type Response = CStoreBrowse_GetDLCForApps_Response;
}
impl crate::RpcMethod for CStoreBrowse_GetItems_Request {
    const METHOD_NAME: &'static str = "StoreBrowse.GetItems#1";
    type Response = CStoreBrowse_GetItems_Response;
}
impl crate::RpcMethod for CStoreBrowse_GetStoreCategories_Request {
    const METHOD_NAME: &'static str = "StoreBrowse.GetStoreCategories#1";
    type Response = CStoreBrowse_GetStoreCategories_Response;
}
