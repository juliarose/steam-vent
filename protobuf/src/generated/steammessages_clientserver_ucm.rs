// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_clientserver_ucm.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:CMsgClientUCMAddScreenshot)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMAddScreenshot {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshot.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshot.filename)
    pub filename: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshot.thumbname)
    pub thumbname: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshot.vr_filename)
    pub vr_filename: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshot.rtime32_created)
    pub rtime32_created: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshot.width)
    pub width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshot.height)
    pub height: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshot.permissions)
    pub permissions: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshot.caption)
    pub caption: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshot.shortcut_name)
    pub shortcut_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshot.tag)
    pub tag: ::std::vec::Vec<cmsg_client_ucmadd_screenshot::Tag>,
    // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshot.tagged_steamid)
    pub tagged_steamid: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshot.spoiler_tag)
    pub spoiler_tag: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshot.tagged_publishedfileid)
    pub tagged_publishedfileid: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMAddScreenshot.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMAddScreenshot {
    fn default() -> &'a CMsgClientUCMAddScreenshot {
        <CMsgClientUCMAddScreenshot as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMAddScreenshot {
    pub fn new() -> CMsgClientUCMAddScreenshot {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string filename = 2;

    pub fn filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename(&mut self) {
        self.filename = ::std::option::Option::None;
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string thumbname = 3;

    pub fn thumbname(&self) -> &str {
        match self.thumbname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_thumbname(&mut self) {
        self.thumbname = ::std::option::Option::None;
    }

    pub fn has_thumbname(&self) -> bool {
        self.thumbname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbname(&mut self, v: ::std::string::String) {
        self.thumbname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbname(&mut self) -> &mut ::std::string::String {
        if self.thumbname.is_none() {
            self.thumbname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.thumbname.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbname(&mut self) -> ::std::string::String {
        self.thumbname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string vr_filename = 14;

    pub fn vr_filename(&self) -> &str {
        match self.vr_filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_vr_filename(&mut self) {
        self.vr_filename = ::std::option::Option::None;
    }

    pub fn has_vr_filename(&self) -> bool {
        self.vr_filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vr_filename(&mut self, v: ::std::string::String) {
        self.vr_filename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vr_filename(&mut self) -> &mut ::std::string::String {
        if self.vr_filename.is_none() {
            self.vr_filename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.vr_filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_vr_filename(&mut self) -> ::std::string::String {
        self.vr_filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed32 rtime32_created = 4;

    pub fn rtime32_created(&self) -> u32 {
        self.rtime32_created.unwrap_or(0)
    }

    pub fn clear_rtime32_created(&mut self) {
        self.rtime32_created = ::std::option::Option::None;
    }

    pub fn has_rtime32_created(&self) -> bool {
        self.rtime32_created.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_created(&mut self, v: u32) {
        self.rtime32_created = ::std::option::Option::Some(v);
    }

    // optional uint32 width = 5;

    pub fn width(&self) -> u32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional uint32 height = 6;

    pub fn height(&self) -> u32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional uint32 permissions = 7;

    pub fn permissions(&self) -> u32 {
        self.permissions.unwrap_or(0)
    }

    pub fn clear_permissions(&mut self) {
        self.permissions = ::std::option::Option::None;
    }

    pub fn has_permissions(&self) -> bool {
        self.permissions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permissions(&mut self, v: u32) {
        self.permissions = ::std::option::Option::Some(v);
    }

    // optional string caption = 8;

    pub fn caption(&self) -> &str {
        match self.caption.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_caption(&mut self) {
        self.caption = ::std::option::Option::None;
    }

    pub fn has_caption(&self) -> bool {
        self.caption.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caption(&mut self, v: ::std::string::String) {
        self.caption = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caption(&mut self) -> &mut ::std::string::String {
        if self.caption.is_none() {
            self.caption = ::std::option::Option::Some(::std::string::String::new());
        }
        self.caption.as_mut().unwrap()
    }

    // Take field
    pub fn take_caption(&mut self) -> ::std::string::String {
        self.caption.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string shortcut_name = 9;

    pub fn shortcut_name(&self) -> &str {
        match self.shortcut_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_shortcut_name(&mut self) {
        self.shortcut_name = ::std::option::Option::None;
    }

    pub fn has_shortcut_name(&self) -> bool {
        self.shortcut_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shortcut_name(&mut self, v: ::std::string::String) {
        self.shortcut_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shortcut_name(&mut self) -> &mut ::std::string::String {
        if self.shortcut_name.is_none() {
            self.shortcut_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.shortcut_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_shortcut_name(&mut self) -> ::std::string::String {
        self.shortcut_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool spoiler_tag = 12;

    pub fn spoiler_tag(&self) -> bool {
        self.spoiler_tag.unwrap_or(false)
    }

    pub fn clear_spoiler_tag(&mut self) {
        self.spoiler_tag = ::std::option::Option::None;
    }

    pub fn has_spoiler_tag(&self) -> bool {
        self.spoiler_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spoiler_tag(&mut self, v: bool) {
        self.spoiler_tag = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMAddScreenshot {
    const NAME: &'static str = "CMsgClientUCMAddScreenshot";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.filename = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.thumbname = ::std::option::Option::Some(is.read_string()?);
                },
                114 => {
                    self.vr_filename = ::std::option::Option::Some(is.read_string()?);
                },
                37 => {
                    self.rtime32_created = ::std::option::Option::Some(is.read_fixed32()?);
                },
                40 => {
                    self.width = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.height = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.permissions = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.caption = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.shortcut_name = ::std::option::Option::Some(is.read_string()?);
                },
                82 => {
                    self.tag.push(is.read_message()?);
                },
                90 => {
                    is.read_repeated_packed_fixed64_into(&mut self.tagged_steamid)?;
                },
                89 => {
                    self.tagged_steamid.push(is.read_fixed64()?);
                },
                96 => {
                    self.spoiler_tag = ::std::option::Option::Some(is.read_bool()?);
                },
                106 => {
                    is.read_repeated_packed_uint64_into(&mut self.tagged_publishedfileid)?;
                },
                104 => {
                    self.tagged_publishedfileid.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.thumbname.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.vr_filename.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(v) = self.rtime32_created {
            my_size += 1 + 4;
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.permissions {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.caption.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.shortcut_name.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        for value in &self.tag {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += 9 * self.tagged_steamid.len() as u64;
        if let Some(v) = self.spoiler_tag {
            my_size += 1 + 1;
        }
        for value in &self.tagged_publishedfileid {
            my_size += ::protobuf::rt::uint64_size(13, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.filename.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.thumbname.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.vr_filename.as_ref() {
            os.write_string(14, v)?;
        }
        if let Some(v) = self.rtime32_created {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.width {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.permissions {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.caption.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.shortcut_name.as_ref() {
            os.write_string(9, v)?;
        }
        for v in &self.tag {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        for v in &self.tagged_steamid {
            os.write_fixed64(11, *v)?;
        };
        if let Some(v) = self.spoiler_tag {
            os.write_bool(12, v)?;
        }
        for v in &self.tagged_publishedfileid {
            os.write_uint64(13, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMAddScreenshot {
        CMsgClientUCMAddScreenshot::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.filename = ::std::option::Option::None;
        self.thumbname = ::std::option::Option::None;
        self.vr_filename = ::std::option::Option::None;
        self.rtime32_created = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.permissions = ::std::option::Option::None;
        self.caption = ::std::option::Option::None;
        self.shortcut_name = ::std::option::Option::None;
        self.tag.clear();
        self.tagged_steamid.clear();
        self.spoiler_tag = ::std::option::Option::None;
        self.tagged_publishedfileid.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMAddScreenshot {
        static instance: CMsgClientUCMAddScreenshot = CMsgClientUCMAddScreenshot {
            appid: ::std::option::Option::None,
            filename: ::std::option::Option::None,
            thumbname: ::std::option::Option::None,
            vr_filename: ::std::option::Option::None,
            rtime32_created: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            permissions: ::std::option::Option::None,
            caption: ::std::option::Option::None,
            shortcut_name: ::std::option::Option::None,
            tag: ::std::vec::Vec::new(),
            tagged_steamid: ::std::vec::Vec::new(),
            spoiler_tag: ::std::option::Option::None,
            tagged_publishedfileid: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientUCMAddScreenshot`
pub mod cmsg_client_ucmadd_screenshot {
    // @@protoc_insertion_point(message:CMsgClientUCMAddScreenshot.Tag)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Tag {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshot.Tag.tag_name)
        pub tag_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshot.Tag.tag_value)
        pub tag_value: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientUCMAddScreenshot.Tag.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Tag {
        fn default() -> &'a Tag {
            <Tag as ::protobuf::Message>::default_instance()
        }
    }

    impl Tag {
        pub fn new() -> Tag {
            ::std::default::Default::default()
        }

        // optional string tag_name = 1;

        pub fn tag_name(&self) -> &str {
            match self.tag_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_tag_name(&mut self) {
            self.tag_name = ::std::option::Option::None;
        }

        pub fn has_tag_name(&self) -> bool {
            self.tag_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tag_name(&mut self, v: ::std::string::String) {
            self.tag_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_tag_name(&mut self) -> &mut ::std::string::String {
            if self.tag_name.is_none() {
                self.tag_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.tag_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_tag_name(&mut self) -> ::std::string::String {
            self.tag_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string tag_value = 2;

        pub fn tag_value(&self) -> &str {
            match self.tag_value.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_tag_value(&mut self) {
            self.tag_value = ::std::option::Option::None;
        }

        pub fn has_tag_value(&self) -> bool {
            self.tag_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tag_value(&mut self, v: ::std::string::String) {
            self.tag_value = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_tag_value(&mut self) -> &mut ::std::string::String {
            if self.tag_value.is_none() {
                self.tag_value = ::std::option::Option::Some(::std::string::String::new());
            }
            self.tag_value.as_mut().unwrap()
        }

        // Take field
        pub fn take_tag_value(&mut self) -> ::std::string::String {
            self.tag_value.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::protobuf::Message for Tag {
        const NAME: &'static str = "Tag";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.tag_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.tag_value = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.tag_name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.tag_value.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.tag_name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.tag_value.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Tag {
            Tag::new()
        }

        fn clear(&mut self) {
            self.tag_name = ::std::option::Option::None;
            self.tag_value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Tag {
            static instance: Tag = Tag {
                tag_name: ::std::option::Option::None,
                tag_value: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientUCMAddScreenshotResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMAddScreenshotResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshotResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshotResponse.screenshotid)
    pub screenshotid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMAddScreenshotResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMAddScreenshotResponse {
    fn default() -> &'a CMsgClientUCMAddScreenshotResponse {
        <CMsgClientUCMAddScreenshotResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMAddScreenshotResponse {
    pub fn new() -> CMsgClientUCMAddScreenshotResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional fixed64 screenshotid = 2;

    pub fn screenshotid(&self) -> u64 {
        self.screenshotid.unwrap_or(18446744073709551615u64)
    }

    pub fn clear_screenshotid(&mut self) {
        self.screenshotid = ::std::option::Option::None;
    }

    pub fn has_screenshotid(&self) -> bool {
        self.screenshotid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screenshotid(&mut self, v: u64) {
        self.screenshotid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMAddScreenshotResponse {
    const NAME: &'static str = "CMsgClientUCMAddScreenshotResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                17 => {
                    self.screenshotid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.screenshotid {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.screenshotid {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMAddScreenshotResponse {
        CMsgClientUCMAddScreenshotResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.screenshotid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMAddScreenshotResponse {
        static instance: CMsgClientUCMAddScreenshotResponse = CMsgClientUCMAddScreenshotResponse {
            eresult: ::std::option::Option::None,
            screenshotid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientUCMDeleteScreenshot)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMDeleteScreenshot {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMDeleteScreenshot.screenshotid)
    pub screenshotid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMDeleteScreenshot.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMDeleteScreenshot {
    fn default() -> &'a CMsgClientUCMDeleteScreenshot {
        <CMsgClientUCMDeleteScreenshot as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMDeleteScreenshot {
    pub fn new() -> CMsgClientUCMDeleteScreenshot {
        ::std::default::Default::default()
    }

    // optional fixed64 screenshotid = 1;

    pub fn screenshotid(&self) -> u64 {
        self.screenshotid.unwrap_or(18446744073709551615u64)
    }

    pub fn clear_screenshotid(&mut self) {
        self.screenshotid = ::std::option::Option::None;
    }

    pub fn has_screenshotid(&self) -> bool {
        self.screenshotid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screenshotid(&mut self, v: u64) {
        self.screenshotid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMDeleteScreenshot {
    const NAME: &'static str = "CMsgClientUCMDeleteScreenshot";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.screenshotid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.screenshotid {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.screenshotid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMDeleteScreenshot {
        CMsgClientUCMDeleteScreenshot::new()
    }

    fn clear(&mut self) {
        self.screenshotid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMDeleteScreenshot {
        static instance: CMsgClientUCMDeleteScreenshot = CMsgClientUCMDeleteScreenshot {
            screenshotid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientUCMDeleteScreenshotResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMDeleteScreenshotResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMDeleteScreenshotResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMDeleteScreenshotResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMDeleteScreenshotResponse {
    fn default() -> &'a CMsgClientUCMDeleteScreenshotResponse {
        <CMsgClientUCMDeleteScreenshotResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMDeleteScreenshotResponse {
    pub fn new() -> CMsgClientUCMDeleteScreenshotResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMDeleteScreenshotResponse {
    const NAME: &'static str = "CMsgClientUCMDeleteScreenshotResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMDeleteScreenshotResponse {
        CMsgClientUCMDeleteScreenshotResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMDeleteScreenshotResponse {
        static instance: CMsgClientUCMDeleteScreenshotResponse = CMsgClientUCMDeleteScreenshotResponse {
            eresult: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientUCMPublishFile)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMPublishFile {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFile.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFile.file_name)
    pub file_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFile.preview_file_name)
    pub preview_file_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFile.consumer_app_id)
    pub consumer_app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFile.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFile.description)
    pub description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFile.tags)
    pub tags: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFile.workshop_file)
    pub workshop_file: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFile.visibility)
    pub visibility: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFile.file_type)
    pub file_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFile.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFile.video_provider)
    pub video_provider: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFile.video_account_name)
    pub video_account_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFile.video_identifier)
    pub video_identifier: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFile.in_progress)
    pub in_progress: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMPublishFile.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMPublishFile {
    fn default() -> &'a CMsgClientUCMPublishFile {
        <CMsgClientUCMPublishFile as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMPublishFile {
    pub fn new() -> CMsgClientUCMPublishFile {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional string file_name = 2;

    pub fn file_name(&self) -> &str {
        match self.file_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_file_name(&mut self) {
        self.file_name = ::std::option::Option::None;
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string preview_file_name = 3;

    pub fn preview_file_name(&self) -> &str {
        match self.preview_file_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_preview_file_name(&mut self) {
        self.preview_file_name = ::std::option::Option::None;
    }

    pub fn has_preview_file_name(&self) -> bool {
        self.preview_file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preview_file_name(&mut self, v: ::std::string::String) {
        self.preview_file_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preview_file_name(&mut self) -> &mut ::std::string::String {
        if self.preview_file_name.is_none() {
            self.preview_file_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.preview_file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_preview_file_name(&mut self) -> ::std::string::String {
        self.preview_file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 consumer_app_id = 4;

    pub fn consumer_app_id(&self) -> u32 {
        self.consumer_app_id.unwrap_or(0)
    }

    pub fn clear_consumer_app_id(&mut self) {
        self.consumer_app_id = ::std::option::Option::None;
    }

    pub fn has_consumer_app_id(&self) -> bool {
        self.consumer_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumer_app_id(&mut self, v: u32) {
        self.consumer_app_id = ::std::option::Option::Some(v);
    }

    // optional string title = 5;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string description = 6;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool workshop_file = 9;

    pub fn workshop_file(&self) -> bool {
        self.workshop_file.unwrap_or(false)
    }

    pub fn clear_workshop_file(&mut self) {
        self.workshop_file = ::std::option::Option::None;
    }

    pub fn has_workshop_file(&self) -> bool {
        self.workshop_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_workshop_file(&mut self, v: bool) {
        self.workshop_file = ::std::option::Option::Some(v);
    }

    // optional int32 visibility = 10;

    pub fn visibility(&self) -> i32 {
        self.visibility.unwrap_or(0)
    }

    pub fn clear_visibility(&mut self) {
        self.visibility = ::std::option::Option::None;
    }

    pub fn has_visibility(&self) -> bool {
        self.visibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visibility(&mut self, v: i32) {
        self.visibility = ::std::option::Option::Some(v);
    }

    // optional uint32 file_type = 11;

    pub fn file_type(&self) -> u32 {
        self.file_type.unwrap_or(0)
    }

    pub fn clear_file_type(&mut self) {
        self.file_type = ::std::option::Option::None;
    }

    pub fn has_file_type(&self) -> bool {
        self.file_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_type(&mut self, v: u32) {
        self.file_type = ::std::option::Option::Some(v);
    }

    // optional string url = 12;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 video_provider = 13;

    pub fn video_provider(&self) -> u32 {
        self.video_provider.unwrap_or(0)
    }

    pub fn clear_video_provider(&mut self) {
        self.video_provider = ::std::option::Option::None;
    }

    pub fn has_video_provider(&self) -> bool {
        self.video_provider.is_some()
    }

    // Param is passed by value, moved
    pub fn set_video_provider(&mut self, v: u32) {
        self.video_provider = ::std::option::Option::Some(v);
    }

    // optional string video_account_name = 14;

    pub fn video_account_name(&self) -> &str {
        match self.video_account_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_video_account_name(&mut self) {
        self.video_account_name = ::std::option::Option::None;
    }

    pub fn has_video_account_name(&self) -> bool {
        self.video_account_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_video_account_name(&mut self, v: ::std::string::String) {
        self.video_account_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_video_account_name(&mut self) -> &mut ::std::string::String {
        if self.video_account_name.is_none() {
            self.video_account_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.video_account_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_video_account_name(&mut self) -> ::std::string::String {
        self.video_account_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string video_identifier = 15;

    pub fn video_identifier(&self) -> &str {
        match self.video_identifier.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_video_identifier(&mut self) {
        self.video_identifier = ::std::option::Option::None;
    }

    pub fn has_video_identifier(&self) -> bool {
        self.video_identifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_video_identifier(&mut self, v: ::std::string::String) {
        self.video_identifier = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_video_identifier(&mut self) -> &mut ::std::string::String {
        if self.video_identifier.is_none() {
            self.video_identifier = ::std::option::Option::Some(::std::string::String::new());
        }
        self.video_identifier.as_mut().unwrap()
    }

    // Take field
    pub fn take_video_identifier(&mut self) -> ::std::string::String {
        self.video_identifier.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool in_progress = 16;

    pub fn in_progress(&self) -> bool {
        self.in_progress.unwrap_or(false)
    }

    pub fn clear_in_progress(&mut self) {
        self.in_progress = ::std::option::Option::None;
    }

    pub fn has_in_progress(&self) -> bool {
        self.in_progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_progress(&mut self, v: bool) {
        self.in_progress = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMPublishFile {
    const NAME: &'static str = "CMsgClientUCMPublishFile";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.file_name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.preview_file_name = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.consumer_app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.tags.push(is.read_string()?);
                },
                72 => {
                    self.workshop_file = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.visibility = ::std::option::Option::Some(is.read_int32()?);
                },
                88 => {
                    self.file_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                98 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                104 => {
                    self.video_provider = ::std::option::Option::Some(is.read_uint32()?);
                },
                114 => {
                    self.video_account_name = ::std::option::Option::Some(is.read_string()?);
                },
                122 => {
                    self.video_identifier = ::std::option::Option::Some(is.read_string()?);
                },
                128 => {
                    self.in_progress = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.preview_file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.consumer_app_id {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        if let Some(v) = self.workshop_file {
            my_size += 1 + 1;
        }
        if let Some(v) = self.visibility {
            my_size += ::protobuf::rt::int32_size(10, v);
        }
        if let Some(v) = self.file_type {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(v) = self.video_provider {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.video_account_name.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(v) = self.video_identifier.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.in_progress {
            my_size += 2 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.file_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.preview_file_name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.consumer_app_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(6, v)?;
        }
        for v in &self.tags {
            os.write_string(8, &v)?;
        };
        if let Some(v) = self.workshop_file {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.visibility {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.file_type {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(12, v)?;
        }
        if let Some(v) = self.video_provider {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.video_account_name.as_ref() {
            os.write_string(14, v)?;
        }
        if let Some(v) = self.video_identifier.as_ref() {
            os.write_string(15, v)?;
        }
        if let Some(v) = self.in_progress {
            os.write_bool(16, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMPublishFile {
        CMsgClientUCMPublishFile::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.file_name = ::std::option::Option::None;
        self.preview_file_name = ::std::option::Option::None;
        self.consumer_app_id = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.description = ::std::option::Option::None;
        self.tags.clear();
        self.workshop_file = ::std::option::Option::None;
        self.visibility = ::std::option::Option::None;
        self.file_type = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.video_provider = ::std::option::Option::None;
        self.video_account_name = ::std::option::Option::None;
        self.video_identifier = ::std::option::Option::None;
        self.in_progress = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMPublishFile {
        static instance: CMsgClientUCMPublishFile = CMsgClientUCMPublishFile {
            app_id: ::std::option::Option::None,
            file_name: ::std::option::Option::None,
            preview_file_name: ::std::option::Option::None,
            consumer_app_id: ::std::option::Option::None,
            title: ::std::option::Option::None,
            description: ::std::option::Option::None,
            tags: ::std::vec::Vec::new(),
            workshop_file: ::std::option::Option::None,
            visibility: ::std::option::Option::None,
            file_type: ::std::option::Option::None,
            url: ::std::option::Option::None,
            video_provider: ::std::option::Option::None,
            video_account_name: ::std::option::Option::None,
            video_identifier: ::std::option::Option::None,
            in_progress: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientUCMPublishFileResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMPublishFileResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFileResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFileResponse.published_file_id)
    pub published_file_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFileResponse.needs_workshop_legal_agreement_acceptance)
    pub needs_workshop_legal_agreement_acceptance: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMPublishFileResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMPublishFileResponse {
    fn default() -> &'a CMsgClientUCMPublishFileResponse {
        <CMsgClientUCMPublishFileResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMPublishFileResponse {
    pub fn new() -> CMsgClientUCMPublishFileResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional fixed64 published_file_id = 2;

    pub fn published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(18446744073709551615u64)
    }

    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }

    // optional bool needs_workshop_legal_agreement_acceptance = 3;

    pub fn needs_workshop_legal_agreement_acceptance(&self) -> bool {
        self.needs_workshop_legal_agreement_acceptance.unwrap_or(false)
    }

    pub fn clear_needs_workshop_legal_agreement_acceptance(&mut self) {
        self.needs_workshop_legal_agreement_acceptance = ::std::option::Option::None;
    }

    pub fn has_needs_workshop_legal_agreement_acceptance(&self) -> bool {
        self.needs_workshop_legal_agreement_acceptance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needs_workshop_legal_agreement_acceptance(&mut self, v: bool) {
        self.needs_workshop_legal_agreement_acceptance = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMPublishFileResponse {
    const NAME: &'static str = "CMsgClientUCMPublishFileResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                17 => {
                    self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.needs_workshop_legal_agreement_acceptance = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.published_file_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.needs_workshop_legal_agreement_acceptance {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.published_file_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.needs_workshop_legal_agreement_acceptance {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMPublishFileResponse {
        CMsgClientUCMPublishFileResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.published_file_id = ::std::option::Option::None;
        self.needs_workshop_legal_agreement_acceptance = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMPublishFileResponse {
        static instance: CMsgClientUCMPublishFileResponse = CMsgClientUCMPublishFileResponse {
            eresult: ::std::option::Option::None,
            published_file_id: ::std::option::Option::None,
            needs_workshop_legal_agreement_acceptance: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientUCMUpdatePublishedFile)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMUpdatePublishedFile {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.published_file_id)
    pub published_file_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.file_name)
    pub file_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.preview_file_name)
    pub preview_file_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.description)
    pub description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.tags)
    pub tags: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.visibility)
    pub visibility: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.update_file)
    pub update_file: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.update_preview_file)
    pub update_preview_file: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.update_title)
    pub update_title: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.update_description)
    pub update_description: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.update_tags)
    pub update_tags: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.update_visibility)
    pub update_visibility: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.change_description)
    pub change_description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.update_url)
    pub update_url: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.update_content_manifest)
    pub update_content_manifest: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.content_manifest)
    pub content_manifest: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.metadata)
    pub metadata: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.update_metadata)
    pub update_metadata: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.language)
    pub language: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.removed_kvtags)
    pub removed_kvtags: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.kvtags)
    pub kvtags: ::std::vec::Vec<cmsg_client_ucmupdate_published_file::KeyValueTag>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.previews)
    pub previews: ::std::vec::Vec<cmsg_client_ucmupdate_published_file::AdditionalPreview>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.previews_to_remove)
    pub previews_to_remove: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.clear_in_progress)
    pub clear_in_progress: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.remove_all_kvtags)
    pub remove_all_kvtags: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.content_descriptors_to_add)
    pub content_descriptors_to_add: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.content_descriptors_to_remove)
    pub content_descriptors_to_remove: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMUpdatePublishedFile.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMUpdatePublishedFile {
    fn default() -> &'a CMsgClientUCMUpdatePublishedFile {
        <CMsgClientUCMUpdatePublishedFile as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMUpdatePublishedFile {
    pub fn new() -> CMsgClientUCMUpdatePublishedFile {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 published_file_id = 2;

    pub fn published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(0)
    }

    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }

    // optional string file_name = 3;

    pub fn file_name(&self) -> &str {
        match self.file_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_file_name(&mut self) {
        self.file_name = ::std::option::Option::None;
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string preview_file_name = 4;

    pub fn preview_file_name(&self) -> &str {
        match self.preview_file_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_preview_file_name(&mut self) {
        self.preview_file_name = ::std::option::Option::None;
    }

    pub fn has_preview_file_name(&self) -> bool {
        self.preview_file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preview_file_name(&mut self, v: ::std::string::String) {
        self.preview_file_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preview_file_name(&mut self) -> &mut ::std::string::String {
        if self.preview_file_name.is_none() {
            self.preview_file_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.preview_file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_preview_file_name(&mut self) -> ::std::string::String {
        self.preview_file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string title = 5;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string description = 6;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 visibility = 8;

    pub fn visibility(&self) -> i32 {
        self.visibility.unwrap_or(0)
    }

    pub fn clear_visibility(&mut self) {
        self.visibility = ::std::option::Option::None;
    }

    pub fn has_visibility(&self) -> bool {
        self.visibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visibility(&mut self, v: i32) {
        self.visibility = ::std::option::Option::Some(v);
    }

    // optional bool update_file = 9;

    pub fn update_file(&self) -> bool {
        self.update_file.unwrap_or(false)
    }

    pub fn clear_update_file(&mut self) {
        self.update_file = ::std::option::Option::None;
    }

    pub fn has_update_file(&self) -> bool {
        self.update_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_file(&mut self, v: bool) {
        self.update_file = ::std::option::Option::Some(v);
    }

    // optional bool update_preview_file = 10;

    pub fn update_preview_file(&self) -> bool {
        self.update_preview_file.unwrap_or(false)
    }

    pub fn clear_update_preview_file(&mut self) {
        self.update_preview_file = ::std::option::Option::None;
    }

    pub fn has_update_preview_file(&self) -> bool {
        self.update_preview_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_preview_file(&mut self, v: bool) {
        self.update_preview_file = ::std::option::Option::Some(v);
    }

    // optional bool update_title = 11;

    pub fn update_title(&self) -> bool {
        self.update_title.unwrap_or(false)
    }

    pub fn clear_update_title(&mut self) {
        self.update_title = ::std::option::Option::None;
    }

    pub fn has_update_title(&self) -> bool {
        self.update_title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_title(&mut self, v: bool) {
        self.update_title = ::std::option::Option::Some(v);
    }

    // optional bool update_description = 12;

    pub fn update_description(&self) -> bool {
        self.update_description.unwrap_or(false)
    }

    pub fn clear_update_description(&mut self) {
        self.update_description = ::std::option::Option::None;
    }

    pub fn has_update_description(&self) -> bool {
        self.update_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_description(&mut self, v: bool) {
        self.update_description = ::std::option::Option::Some(v);
    }

    // optional bool update_tags = 13;

    pub fn update_tags(&self) -> bool {
        self.update_tags.unwrap_or(false)
    }

    pub fn clear_update_tags(&mut self) {
        self.update_tags = ::std::option::Option::None;
    }

    pub fn has_update_tags(&self) -> bool {
        self.update_tags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_tags(&mut self, v: bool) {
        self.update_tags = ::std::option::Option::Some(v);
    }

    // optional bool update_visibility = 14;

    pub fn update_visibility(&self) -> bool {
        self.update_visibility.unwrap_or(false)
    }

    pub fn clear_update_visibility(&mut self) {
        self.update_visibility = ::std::option::Option::None;
    }

    pub fn has_update_visibility(&self) -> bool {
        self.update_visibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_visibility(&mut self, v: bool) {
        self.update_visibility = ::std::option::Option::Some(v);
    }

    // optional string change_description = 15;

    pub fn change_description(&self) -> &str {
        match self.change_description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_change_description(&mut self) {
        self.change_description = ::std::option::Option::None;
    }

    pub fn has_change_description(&self) -> bool {
        self.change_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_change_description(&mut self, v: ::std::string::String) {
        self.change_description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_change_description(&mut self) -> &mut ::std::string::String {
        if self.change_description.is_none() {
            self.change_description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.change_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_change_description(&mut self) -> ::std::string::String {
        self.change_description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool update_url = 16;

    pub fn update_url(&self) -> bool {
        self.update_url.unwrap_or(false)
    }

    pub fn clear_update_url(&mut self) {
        self.update_url = ::std::option::Option::None;
    }

    pub fn has_update_url(&self) -> bool {
        self.update_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_url(&mut self, v: bool) {
        self.update_url = ::std::option::Option::Some(v);
    }

    // optional string url = 17;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool update_content_manifest = 18;

    pub fn update_content_manifest(&self) -> bool {
        self.update_content_manifest.unwrap_or(false)
    }

    pub fn clear_update_content_manifest(&mut self) {
        self.update_content_manifest = ::std::option::Option::None;
    }

    pub fn has_update_content_manifest(&self) -> bool {
        self.update_content_manifest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_content_manifest(&mut self, v: bool) {
        self.update_content_manifest = ::std::option::Option::Some(v);
    }

    // optional fixed64 content_manifest = 19;

    pub fn content_manifest(&self) -> u64 {
        self.content_manifest.unwrap_or(0)
    }

    pub fn clear_content_manifest(&mut self) {
        self.content_manifest = ::std::option::Option::None;
    }

    pub fn has_content_manifest(&self) -> bool {
        self.content_manifest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_content_manifest(&mut self, v: u64) {
        self.content_manifest = ::std::option::Option::Some(v);
    }

    // optional string metadata = 20;

    pub fn metadata(&self) -> &str {
        match self.metadata.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_metadata(&mut self) {
        self.metadata = ::std::option::Option::None;
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::string::String) {
        self.metadata = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::std::string::String {
        if self.metadata.is_none() {
            self.metadata = ::std::option::Option::Some(::std::string::String::new());
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::string::String {
        self.metadata.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool update_metadata = 21;

    pub fn update_metadata(&self) -> bool {
        self.update_metadata.unwrap_or(false)
    }

    pub fn clear_update_metadata(&mut self) {
        self.update_metadata = ::std::option::Option::None;
    }

    pub fn has_update_metadata(&self) -> bool {
        self.update_metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_metadata(&mut self, v: bool) {
        self.update_metadata = ::std::option::Option::Some(v);
    }

    // optional int32 language = 22;

    pub fn language(&self) -> i32 {
        self.language.unwrap_or(0i32)
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: i32) {
        self.language = ::std::option::Option::Some(v);
    }

    // optional bool clear_in_progress = 27;

    pub fn clear_in_progress(&self) -> bool {
        self.clear_in_progress.unwrap_or(false)
    }

    pub fn clear_clear_in_progress(&mut self) {
        self.clear_in_progress = ::std::option::Option::None;
    }

    pub fn has_clear_in_progress(&self) -> bool {
        self.clear_in_progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clear_in_progress(&mut self, v: bool) {
        self.clear_in_progress = ::std::option::Option::Some(v);
    }

    // optional bool remove_all_kvtags = 28;

    pub fn remove_all_kvtags(&self) -> bool {
        self.remove_all_kvtags.unwrap_or(false)
    }

    pub fn clear_remove_all_kvtags(&mut self) {
        self.remove_all_kvtags = ::std::option::Option::None;
    }

    pub fn has_remove_all_kvtags(&self) -> bool {
        self.remove_all_kvtags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remove_all_kvtags(&mut self, v: bool) {
        self.remove_all_kvtags = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMUpdatePublishedFile {
    const NAME: &'static str = "CMsgClientUCMUpdatePublishedFile";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    self.file_name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.preview_file_name = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.tags.push(is.read_string()?);
                },
                64 => {
                    self.visibility = ::std::option::Option::Some(is.read_int32()?);
                },
                72 => {
                    self.update_file = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.update_preview_file = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.update_title = ::std::option::Option::Some(is.read_bool()?);
                },
                96 => {
                    self.update_description = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.update_tags = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.update_visibility = ::std::option::Option::Some(is.read_bool()?);
                },
                122 => {
                    self.change_description = ::std::option::Option::Some(is.read_string()?);
                },
                128 => {
                    self.update_url = ::std::option::Option::Some(is.read_bool()?);
                },
                138 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                144 => {
                    self.update_content_manifest = ::std::option::Option::Some(is.read_bool()?);
                },
                153 => {
                    self.content_manifest = ::std::option::Option::Some(is.read_fixed64()?);
                },
                162 => {
                    self.metadata = ::std::option::Option::Some(is.read_string()?);
                },
                168 => {
                    self.update_metadata = ::std::option::Option::Some(is.read_bool()?);
                },
                176 => {
                    self.language = ::std::option::Option::Some(is.read_int32()?);
                },
                186 => {
                    self.removed_kvtags.push(is.read_string()?);
                },
                194 => {
                    self.kvtags.push(is.read_message()?);
                },
                202 => {
                    self.previews.push(is.read_message()?);
                },
                210 => {
                    is.read_repeated_packed_int32_into(&mut self.previews_to_remove)?;
                },
                208 => {
                    self.previews_to_remove.push(is.read_int32()?);
                },
                216 => {
                    self.clear_in_progress = ::std::option::Option::Some(is.read_bool()?);
                },
                224 => {
                    self.remove_all_kvtags = ::std::option::Option::Some(is.read_bool()?);
                },
                234 => {
                    is.read_repeated_packed_int32_into(&mut self.content_descriptors_to_add)?;
                },
                232 => {
                    self.content_descriptors_to_add.push(is.read_int32()?);
                },
                242 => {
                    is.read_repeated_packed_int32_into(&mut self.content_descriptors_to_remove)?;
                },
                240 => {
                    self.content_descriptors_to_remove.push(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.published_file_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.preview_file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        if let Some(v) = self.visibility {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.update_file {
            my_size += 1 + 1;
        }
        if let Some(v) = self.update_preview_file {
            my_size += 1 + 1;
        }
        if let Some(v) = self.update_title {
            my_size += 1 + 1;
        }
        if let Some(v) = self.update_description {
            my_size += 1 + 1;
        }
        if let Some(v) = self.update_tags {
            my_size += 1 + 1;
        }
        if let Some(v) = self.update_visibility {
            my_size += 1 + 1;
        }
        if let Some(v) = self.change_description.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.update_url {
            my_size += 2 + 1;
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(17, &v);
        }
        if let Some(v) = self.update_content_manifest {
            my_size += 2 + 1;
        }
        if let Some(v) = self.content_manifest {
            my_size += 2 + 8;
        }
        if let Some(v) = self.metadata.as_ref() {
            my_size += ::protobuf::rt::string_size(20, &v);
        }
        if let Some(v) = self.update_metadata {
            my_size += 2 + 1;
        }
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::int32_size(22, v);
        }
        for value in &self.removed_kvtags {
            my_size += ::protobuf::rt::string_size(23, &value);
        };
        for value in &self.kvtags {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.previews {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.previews_to_remove {
            my_size += ::protobuf::rt::int32_size(26, *value);
        };
        if let Some(v) = self.clear_in_progress {
            my_size += 2 + 1;
        }
        if let Some(v) = self.remove_all_kvtags {
            my_size += 2 + 1;
        }
        for value in &self.content_descriptors_to_add {
            my_size += ::protobuf::rt::int32_size(29, *value);
        };
        for value in &self.content_descriptors_to_remove {
            my_size += ::protobuf::rt::int32_size(30, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.published_file_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.file_name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.preview_file_name.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(6, v)?;
        }
        for v in &self.tags {
            os.write_string(7, &v)?;
        };
        if let Some(v) = self.visibility {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.update_file {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.update_preview_file {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.update_title {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.update_description {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.update_tags {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.update_visibility {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.change_description.as_ref() {
            os.write_string(15, v)?;
        }
        if let Some(v) = self.update_url {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(17, v)?;
        }
        if let Some(v) = self.update_content_manifest {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.content_manifest {
            os.write_fixed64(19, v)?;
        }
        if let Some(v) = self.metadata.as_ref() {
            os.write_string(20, v)?;
        }
        if let Some(v) = self.update_metadata {
            os.write_bool(21, v)?;
        }
        if let Some(v) = self.language {
            os.write_int32(22, v)?;
        }
        for v in &self.removed_kvtags {
            os.write_string(23, &v)?;
        };
        for v in &self.kvtags {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        };
        for v in &self.previews {
            ::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
        };
        for v in &self.previews_to_remove {
            os.write_int32(26, *v)?;
        };
        if let Some(v) = self.clear_in_progress {
            os.write_bool(27, v)?;
        }
        if let Some(v) = self.remove_all_kvtags {
            os.write_bool(28, v)?;
        }
        for v in &self.content_descriptors_to_add {
            os.write_int32(29, *v)?;
        };
        for v in &self.content_descriptors_to_remove {
            os.write_int32(30, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMUpdatePublishedFile {
        CMsgClientUCMUpdatePublishedFile::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.published_file_id = ::std::option::Option::None;
        self.file_name = ::std::option::Option::None;
        self.preview_file_name = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.description = ::std::option::Option::None;
        self.tags.clear();
        self.visibility = ::std::option::Option::None;
        self.update_file = ::std::option::Option::None;
        self.update_preview_file = ::std::option::Option::None;
        self.update_title = ::std::option::Option::None;
        self.update_description = ::std::option::Option::None;
        self.update_tags = ::std::option::Option::None;
        self.update_visibility = ::std::option::Option::None;
        self.change_description = ::std::option::Option::None;
        self.update_url = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.update_content_manifest = ::std::option::Option::None;
        self.content_manifest = ::std::option::Option::None;
        self.metadata = ::std::option::Option::None;
        self.update_metadata = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.removed_kvtags.clear();
        self.kvtags.clear();
        self.previews.clear();
        self.previews_to_remove.clear();
        self.clear_in_progress = ::std::option::Option::None;
        self.remove_all_kvtags = ::std::option::Option::None;
        self.content_descriptors_to_add.clear();
        self.content_descriptors_to_remove.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMUpdatePublishedFile {
        static instance: CMsgClientUCMUpdatePublishedFile = CMsgClientUCMUpdatePublishedFile {
            app_id: ::std::option::Option::None,
            published_file_id: ::std::option::Option::None,
            file_name: ::std::option::Option::None,
            preview_file_name: ::std::option::Option::None,
            title: ::std::option::Option::None,
            description: ::std::option::Option::None,
            tags: ::std::vec::Vec::new(),
            visibility: ::std::option::Option::None,
            update_file: ::std::option::Option::None,
            update_preview_file: ::std::option::Option::None,
            update_title: ::std::option::Option::None,
            update_description: ::std::option::Option::None,
            update_tags: ::std::option::Option::None,
            update_visibility: ::std::option::Option::None,
            change_description: ::std::option::Option::None,
            update_url: ::std::option::Option::None,
            url: ::std::option::Option::None,
            update_content_manifest: ::std::option::Option::None,
            content_manifest: ::std::option::Option::None,
            metadata: ::std::option::Option::None,
            update_metadata: ::std::option::Option::None,
            language: ::std::option::Option::None,
            removed_kvtags: ::std::vec::Vec::new(),
            kvtags: ::std::vec::Vec::new(),
            previews: ::std::vec::Vec::new(),
            previews_to_remove: ::std::vec::Vec::new(),
            clear_in_progress: ::std::option::Option::None,
            remove_all_kvtags: ::std::option::Option::None,
            content_descriptors_to_add: ::std::vec::Vec::new(),
            content_descriptors_to_remove: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientUCMUpdatePublishedFile`
pub mod cmsg_client_ucmupdate_published_file {
    // @@protoc_insertion_point(message:CMsgClientUCMUpdatePublishedFile.KeyValueTag)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct KeyValueTag {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.KeyValueTag.key)
        pub key: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.KeyValueTag.value)
        pub value: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientUCMUpdatePublishedFile.KeyValueTag.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a KeyValueTag {
        fn default() -> &'a KeyValueTag {
            <KeyValueTag as ::protobuf::Message>::default_instance()
        }
    }

    impl KeyValueTag {
        pub fn new() -> KeyValueTag {
            ::std::default::Default::default()
        }

        // optional string key = 1;

        pub fn key(&self) -> &str {
            match self.key.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_key(&mut self) {
            self.key = ::std::option::Option::None;
        }

        pub fn has_key(&self) -> bool {
            self.key.is_some()
        }

        // Param is passed by value, moved
        pub fn set_key(&mut self, v: ::std::string::String) {
            self.key = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_key(&mut self) -> &mut ::std::string::String {
            if self.key.is_none() {
                self.key = ::std::option::Option::Some(::std::string::String::new());
            }
            self.key.as_mut().unwrap()
        }

        // Take field
        pub fn take_key(&mut self) -> ::std::string::String {
            self.key.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string value = 2;

        pub fn value(&self) -> &str {
            match self.value.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_value(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: ::std::string::String) {
            self.value = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_value(&mut self) -> &mut ::std::string::String {
            if self.value.is_none() {
                self.value = ::std::option::Option::Some(::std::string::String::new());
            }
            self.value.as_mut().unwrap()
        }

        // Take field
        pub fn take_value(&mut self) -> ::std::string::String {
            self.value.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::protobuf::Message for KeyValueTag {
        const NAME: &'static str = "KeyValueTag";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.key = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.value = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.key.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.value.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.key.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.value.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> KeyValueTag {
            KeyValueTag::new()
        }

        fn clear(&mut self) {
            self.key = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static KeyValueTag {
            static instance: KeyValueTag = KeyValueTag {
                key: ::std::option::Option::None,
                value: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgClientUCMUpdatePublishedFile.AdditionalPreview)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AdditionalPreview {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.AdditionalPreview.original_file_name)
        pub original_file_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.AdditionalPreview.internal_file_name)
        pub internal_file_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.AdditionalPreview.videoid)
        pub videoid: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.AdditionalPreview.preview_type)
        pub preview_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.AdditionalPreview.update_index)
        pub update_index: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientUCMUpdatePublishedFile.AdditionalPreview.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AdditionalPreview {
        fn default() -> &'a AdditionalPreview {
            <AdditionalPreview as ::protobuf::Message>::default_instance()
        }
    }

    impl AdditionalPreview {
        pub fn new() -> AdditionalPreview {
            ::std::default::Default::default()
        }

        // optional string original_file_name = 1;

        pub fn original_file_name(&self) -> &str {
            match self.original_file_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_original_file_name(&mut self) {
            self.original_file_name = ::std::option::Option::None;
        }

        pub fn has_original_file_name(&self) -> bool {
            self.original_file_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_original_file_name(&mut self, v: ::std::string::String) {
            self.original_file_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_original_file_name(&mut self) -> &mut ::std::string::String {
            if self.original_file_name.is_none() {
                self.original_file_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.original_file_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_original_file_name(&mut self) -> ::std::string::String {
            self.original_file_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string internal_file_name = 2;

        pub fn internal_file_name(&self) -> &str {
            match self.internal_file_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_internal_file_name(&mut self) {
            self.internal_file_name = ::std::option::Option::None;
        }

        pub fn has_internal_file_name(&self) -> bool {
            self.internal_file_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_internal_file_name(&mut self, v: ::std::string::String) {
            self.internal_file_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_internal_file_name(&mut self) -> &mut ::std::string::String {
            if self.internal_file_name.is_none() {
                self.internal_file_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.internal_file_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_internal_file_name(&mut self) -> ::std::string::String {
            self.internal_file_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string videoid = 3;

        pub fn videoid(&self) -> &str {
            match self.videoid.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_videoid(&mut self) {
            self.videoid = ::std::option::Option::None;
        }

        pub fn has_videoid(&self) -> bool {
            self.videoid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_videoid(&mut self, v: ::std::string::String) {
            self.videoid = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_videoid(&mut self) -> &mut ::std::string::String {
            if self.videoid.is_none() {
                self.videoid = ::std::option::Option::Some(::std::string::String::new());
            }
            self.videoid.as_mut().unwrap()
        }

        // Take field
        pub fn take_videoid(&mut self) -> ::std::string::String {
            self.videoid.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 preview_type = 4;

        pub fn preview_type(&self) -> u32 {
            self.preview_type.unwrap_or(0)
        }

        pub fn clear_preview_type(&mut self) {
            self.preview_type = ::std::option::Option::None;
        }

        pub fn has_preview_type(&self) -> bool {
            self.preview_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_preview_type(&mut self, v: u32) {
            self.preview_type = ::std::option::Option::Some(v);
        }

        // optional int32 update_index = 5;

        pub fn update_index(&self) -> i32 {
            self.update_index.unwrap_or(-1i32)
        }

        pub fn clear_update_index(&mut self) {
            self.update_index = ::std::option::Option::None;
        }

        pub fn has_update_index(&self) -> bool {
            self.update_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_update_index(&mut self, v: i32) {
            self.update_index = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for AdditionalPreview {
        const NAME: &'static str = "AdditionalPreview";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.original_file_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.internal_file_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.videoid = ::std::option::Option::Some(is.read_string()?);
                    },
                    32 => {
                        self.preview_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.update_index = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.original_file_name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.internal_file_name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.videoid.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.preview_type {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.update_index {
                my_size += ::protobuf::rt::int32_size(5, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.original_file_name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.internal_file_name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.videoid.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.preview_type {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.update_index {
                os.write_int32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AdditionalPreview {
            AdditionalPreview::new()
        }

        fn clear(&mut self) {
            self.original_file_name = ::std::option::Option::None;
            self.internal_file_name = ::std::option::Option::None;
            self.videoid = ::std::option::Option::None;
            self.preview_type = ::std::option::Option::None;
            self.update_index = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AdditionalPreview {
            static instance: AdditionalPreview = AdditionalPreview {
                original_file_name: ::std::option::Option::None,
                internal_file_name: ::std::option::Option::None,
                videoid: ::std::option::Option::None,
                preview_type: ::std::option::Option::None,
                update_index: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientUCMUpdatePublishedFileResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMUpdatePublishedFileResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFileResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFileResponse.needs_workshop_legal_agreement_acceptance)
    pub needs_workshop_legal_agreement_acceptance: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMUpdatePublishedFileResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMUpdatePublishedFileResponse {
    fn default() -> &'a CMsgClientUCMUpdatePublishedFileResponse {
        <CMsgClientUCMUpdatePublishedFileResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMUpdatePublishedFileResponse {
    pub fn new() -> CMsgClientUCMUpdatePublishedFileResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional bool needs_workshop_legal_agreement_acceptance = 2;

    pub fn needs_workshop_legal_agreement_acceptance(&self) -> bool {
        self.needs_workshop_legal_agreement_acceptance.unwrap_or(false)
    }

    pub fn clear_needs_workshop_legal_agreement_acceptance(&mut self) {
        self.needs_workshop_legal_agreement_acceptance = ::std::option::Option::None;
    }

    pub fn has_needs_workshop_legal_agreement_acceptance(&self) -> bool {
        self.needs_workshop_legal_agreement_acceptance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needs_workshop_legal_agreement_acceptance(&mut self, v: bool) {
        self.needs_workshop_legal_agreement_acceptance = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMUpdatePublishedFileResponse {
    const NAME: &'static str = "CMsgClientUCMUpdatePublishedFileResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.needs_workshop_legal_agreement_acceptance = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.needs_workshop_legal_agreement_acceptance {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.needs_workshop_legal_agreement_acceptance {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMUpdatePublishedFileResponse {
        CMsgClientUCMUpdatePublishedFileResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.needs_workshop_legal_agreement_acceptance = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMUpdatePublishedFileResponse {
        static instance: CMsgClientUCMUpdatePublishedFileResponse = CMsgClientUCMUpdatePublishedFileResponse {
            eresult: ::std::option::Option::None,
            needs_workshop_legal_agreement_acceptance: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientUCMDeletePublishedFile)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMDeletePublishedFile {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMDeletePublishedFile.published_file_id)
    pub published_file_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUCMDeletePublishedFile.app_id)
    pub app_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMDeletePublishedFile.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMDeletePublishedFile {
    fn default() -> &'a CMsgClientUCMDeletePublishedFile {
        <CMsgClientUCMDeletePublishedFile as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMDeletePublishedFile {
    pub fn new() -> CMsgClientUCMDeletePublishedFile {
        ::std::default::Default::default()
    }

    // optional fixed64 published_file_id = 1;

    pub fn published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(0)
    }

    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMDeletePublishedFile {
    const NAME: &'static str = "CMsgClientUCMDeletePublishedFile";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.published_file_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.published_file_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMDeletePublishedFile {
        CMsgClientUCMDeletePublishedFile::new()
    }

    fn clear(&mut self) {
        self.published_file_id = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMDeletePublishedFile {
        static instance: CMsgClientUCMDeletePublishedFile = CMsgClientUCMDeletePublishedFile {
            published_file_id: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientUCMDeletePublishedFileResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMDeletePublishedFileResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMDeletePublishedFileResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMDeletePublishedFileResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMDeletePublishedFileResponse {
    fn default() -> &'a CMsgClientUCMDeletePublishedFileResponse {
        <CMsgClientUCMDeletePublishedFileResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMDeletePublishedFileResponse {
    pub fn new() -> CMsgClientUCMDeletePublishedFileResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMDeletePublishedFileResponse {
    const NAME: &'static str = "CMsgClientUCMDeletePublishedFileResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMDeletePublishedFileResponse {
        CMsgClientUCMDeletePublishedFileResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMDeletePublishedFileResponse {
        static instance: CMsgClientUCMDeletePublishedFileResponse = CMsgClientUCMDeletePublishedFileResponse {
            eresult: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates.start_index)
    pub start_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates.start_time)
    pub start_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates.desired_revision)
    pub desired_revision: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
    fn default() -> &'a CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
        <CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
    pub fn new() -> CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 start_index = 2;

    pub fn start_index(&self) -> u32 {
        self.start_index.unwrap_or(0)
    }

    pub fn clear_start_index(&mut self) {
        self.start_index = ::std::option::Option::None;
    }

    pub fn has_start_index(&self) -> bool {
        self.start_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_index(&mut self, v: u32) {
        self.start_index = ::std::option::Option::Some(v);
    }

    // optional fixed32 start_time = 3;

    pub fn start_time(&self) -> u32 {
        self.start_time.unwrap_or(0)
    }

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: u32) {
        self.start_time = ::std::option::Option::Some(v);
    }

    // optional uint32 desired_revision = 4;

    pub fn desired_revision(&self) -> u32 {
        self.desired_revision.unwrap_or(0u32)
    }

    pub fn clear_desired_revision(&mut self) {
        self.desired_revision = ::std::option::Option::None;
    }

    pub fn has_desired_revision(&self) -> bool {
        self.desired_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desired_revision(&mut self, v: u32) {
        self.desired_revision = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
    const NAME: &'static str = "CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.start_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                29 => {
                    self.start_time = ::std::option::Option::Some(is.read_fixed32()?);
                },
                32 => {
                    self.desired_revision = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.start_index {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.start_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.desired_revision {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.start_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.start_time {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.desired_revision {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
        CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.start_index = ::std::option::Option::None;
        self.start_time = ::std::option::Option::None;
        self.desired_revision = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
        static instance: CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates = CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
            app_id: ::std::option::Option::None,
            start_index: ::std::option::Option::None,
            start_time: ::std::option::Option::None,
            desired_revision: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.subscribed_files)
    pub subscribed_files: ::std::vec::Vec<cmsg_client_ucmenumerate_user_subscribed_files_with_updates_response::PublishedFileId>,
    // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.total_results)
    pub total_results: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
    fn default() -> &'a CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
        <CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
    pub fn new() -> CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 total_results = 3;

    pub fn total_results(&self) -> u32 {
        self.total_results.unwrap_or(0)
    }

    pub fn clear_total_results(&mut self) {
        self.total_results = ::std::option::Option::None;
    }

    pub fn has_total_results(&self) -> bool {
        self.total_results.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_results(&mut self, v: u32) {
        self.total_results = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
    const NAME: &'static str = "CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.subscribed_files.push(is.read_message()?);
                },
                24 => {
                    self.total_results = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        for value in &self.subscribed_files {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.total_results {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        for v in &self.subscribed_files {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.total_results {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
        CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.subscribed_files.clear();
        self.total_results = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
        static instance: CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse = CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
            eresult: ::std::option::Option::None,
            subscribed_files: ::std::vec::Vec::new(),
            total_results: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse`
pub mod cmsg_client_ucmenumerate_user_subscribed_files_with_updates_response {
    // @@protoc_insertion_point(message:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.PublishedFileId)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PublishedFileId {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.PublishedFileId.published_file_id)
        pub published_file_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.PublishedFileId.rtime32_subscribed)
        pub rtime32_subscribed: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.PublishedFileId.appid)
        pub appid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.PublishedFileId.file_hcontent)
        pub file_hcontent: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.PublishedFileId.file_size)
        pub file_size: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.PublishedFileId.rtime32_last_updated)
        pub rtime32_last_updated: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.PublishedFileId.is_depot_content)
        pub is_depot_content: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.PublishedFileId.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PublishedFileId {
        fn default() -> &'a PublishedFileId {
            <PublishedFileId as ::protobuf::Message>::default_instance()
        }
    }

    impl PublishedFileId {
        pub fn new() -> PublishedFileId {
            ::std::default::Default::default()
        }

        // optional fixed64 published_file_id = 1;

        pub fn published_file_id(&self) -> u64 {
            self.published_file_id.unwrap_or(0)
        }

        pub fn clear_published_file_id(&mut self) {
            self.published_file_id = ::std::option::Option::None;
        }

        pub fn has_published_file_id(&self) -> bool {
            self.published_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_published_file_id(&mut self, v: u64) {
            self.published_file_id = ::std::option::Option::Some(v);
        }

        // optional fixed32 rtime32_subscribed = 2;

        pub fn rtime32_subscribed(&self) -> u32 {
            self.rtime32_subscribed.unwrap_or(0u32)
        }

        pub fn clear_rtime32_subscribed(&mut self) {
            self.rtime32_subscribed = ::std::option::Option::None;
        }

        pub fn has_rtime32_subscribed(&self) -> bool {
            self.rtime32_subscribed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rtime32_subscribed(&mut self, v: u32) {
            self.rtime32_subscribed = ::std::option::Option::Some(v);
        }

        // optional uint32 appid = 3;

        pub fn appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }

        // optional fixed64 file_hcontent = 4;

        pub fn file_hcontent(&self) -> u64 {
            self.file_hcontent.unwrap_or(0)
        }

        pub fn clear_file_hcontent(&mut self) {
            self.file_hcontent = ::std::option::Option::None;
        }

        pub fn has_file_hcontent(&self) -> bool {
            self.file_hcontent.is_some()
        }

        // Param is passed by value, moved
        pub fn set_file_hcontent(&mut self, v: u64) {
            self.file_hcontent = ::std::option::Option::Some(v);
        }

        // optional uint32 file_size = 5;

        pub fn file_size(&self) -> u32 {
            self.file_size.unwrap_or(0)
        }

        pub fn clear_file_size(&mut self) {
            self.file_size = ::std::option::Option::None;
        }

        pub fn has_file_size(&self) -> bool {
            self.file_size.is_some()
        }

        // Param is passed by value, moved
        pub fn set_file_size(&mut self, v: u32) {
            self.file_size = ::std::option::Option::Some(v);
        }

        // optional fixed32 rtime32_last_updated = 6;

        pub fn rtime32_last_updated(&self) -> u32 {
            self.rtime32_last_updated.unwrap_or(0)
        }

        pub fn clear_rtime32_last_updated(&mut self) {
            self.rtime32_last_updated = ::std::option::Option::None;
        }

        pub fn has_rtime32_last_updated(&self) -> bool {
            self.rtime32_last_updated.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rtime32_last_updated(&mut self, v: u32) {
            self.rtime32_last_updated = ::std::option::Option::Some(v);
        }

        // optional bool is_depot_content = 7;

        pub fn is_depot_content(&self) -> bool {
            self.is_depot_content.unwrap_or(false)
        }

        pub fn clear_is_depot_content(&mut self) {
            self.is_depot_content = ::std::option::Option::None;
        }

        pub fn has_is_depot_content(&self) -> bool {
            self.is_depot_content.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_depot_content(&mut self, v: bool) {
            self.is_depot_content = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for PublishedFileId {
        const NAME: &'static str = "PublishedFileId";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    21 => {
                        self.rtime32_subscribed = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    24 => {
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    33 => {
                        self.file_hcontent = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    40 => {
                        self.file_size = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    53 => {
                        self.rtime32_last_updated = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    56 => {
                        self.is_depot_content = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.published_file_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.rtime32_subscribed {
                my_size += 1 + 4;
            }
            if let Some(v) = self.appid {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.file_hcontent {
                my_size += 1 + 8;
            }
            if let Some(v) = self.file_size {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.rtime32_last_updated {
                my_size += 1 + 4;
            }
            if let Some(v) = self.is_depot_content {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.published_file_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.rtime32_subscribed {
                os.write_fixed32(2, v)?;
            }
            if let Some(v) = self.appid {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.file_hcontent {
                os.write_fixed64(4, v)?;
            }
            if let Some(v) = self.file_size {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.rtime32_last_updated {
                os.write_fixed32(6, v)?;
            }
            if let Some(v) = self.is_depot_content {
                os.write_bool(7, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PublishedFileId {
            PublishedFileId::new()
        }

        fn clear(&mut self) {
            self.published_file_id = ::std::option::Option::None;
            self.rtime32_subscribed = ::std::option::Option::None;
            self.appid = ::std::option::Option::None;
            self.file_hcontent = ::std::option::Option::None;
            self.file_size = ::std::option::Option::None;
            self.rtime32_last_updated = ::std::option::Option::None;
            self.is_depot_content = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PublishedFileId {
            static instance: PublishedFileId = PublishedFileId {
                published_file_id: ::std::option::Option::None,
                rtime32_subscribed: ::std::option::Option::None,
                appid: ::std::option::Option::None,
                file_hcontent: ::std::option::Option::None,
                file_size: ::std::option::Option::None,
                rtime32_last_updated: ::std::option::Option::None,
                is_depot_content: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientUCMPublishedFileUpdated)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMPublishedFileUpdated {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMPublishedFileUpdated.published_file_id)
    pub published_file_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishedFileUpdated.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishedFileUpdated.time_updated)
    pub time_updated: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishedFileUpdated.hcontent)
    pub hcontent: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishedFileUpdated.file_size)
    pub file_size: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishedFileUpdated.is_depot_content)
    pub is_depot_content: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishedFileUpdated.revision)
    pub revision: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMPublishedFileUpdated.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMPublishedFileUpdated {
    fn default() -> &'a CMsgClientUCMPublishedFileUpdated {
        <CMsgClientUCMPublishedFileUpdated as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMPublishedFileUpdated {
    pub fn new() -> CMsgClientUCMPublishedFileUpdated {
        ::std::default::Default::default()
    }

    // optional fixed64 published_file_id = 1;

    pub fn published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(0)
    }

    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 time_updated = 3;

    pub fn time_updated(&self) -> u32 {
        self.time_updated.unwrap_or(0)
    }

    pub fn clear_time_updated(&mut self) {
        self.time_updated = ::std::option::Option::None;
    }

    pub fn has_time_updated(&self) -> bool {
        self.time_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_updated(&mut self, v: u32) {
        self.time_updated = ::std::option::Option::Some(v);
    }

    // optional fixed64 hcontent = 4;

    pub fn hcontent(&self) -> u64 {
        self.hcontent.unwrap_or(0)
    }

    pub fn clear_hcontent(&mut self) {
        self.hcontent = ::std::option::Option::None;
    }

    pub fn has_hcontent(&self) -> bool {
        self.hcontent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hcontent(&mut self, v: u64) {
        self.hcontent = ::std::option::Option::Some(v);
    }

    // optional fixed32 file_size = 5;

    pub fn file_size(&self) -> u32 {
        self.file_size.unwrap_or(0)
    }

    pub fn clear_file_size(&mut self) {
        self.file_size = ::std::option::Option::None;
    }

    pub fn has_file_size(&self) -> bool {
        self.file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_size(&mut self, v: u32) {
        self.file_size = ::std::option::Option::Some(v);
    }

    // optional bool is_depot_content = 6;

    pub fn is_depot_content(&self) -> bool {
        self.is_depot_content.unwrap_or(false)
    }

    pub fn clear_is_depot_content(&mut self) {
        self.is_depot_content = ::std::option::Option::None;
    }

    pub fn has_is_depot_content(&self) -> bool {
        self.is_depot_content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_depot_content(&mut self, v: bool) {
        self.is_depot_content = ::std::option::Option::Some(v);
    }

    // optional uint32 revision = 7;

    pub fn revision(&self) -> u32 {
        self.revision.unwrap_or(0)
    }

    pub fn clear_revision(&mut self) {
        self.revision = ::std::option::Option::None;
    }

    pub fn has_revision(&self) -> bool {
        self.revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: u32) {
        self.revision = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMPublishedFileUpdated {
    const NAME: &'static str = "CMsgClientUCMPublishedFileUpdated";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.time_updated = ::std::option::Option::Some(is.read_uint32()?);
                },
                33 => {
                    self.hcontent = ::std::option::Option::Some(is.read_fixed64()?);
                },
                45 => {
                    self.file_size = ::std::option::Option::Some(is.read_fixed32()?);
                },
                48 => {
                    self.is_depot_content = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.revision = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.published_file_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.time_updated {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.hcontent {
            my_size += 1 + 8;
        }
        if let Some(v) = self.file_size {
            my_size += 1 + 4;
        }
        if let Some(v) = self.is_depot_content {
            my_size += 1 + 1;
        }
        if let Some(v) = self.revision {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.published_file_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.time_updated {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.hcontent {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.file_size {
            os.write_fixed32(5, v)?;
        }
        if let Some(v) = self.is_depot_content {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.revision {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMPublishedFileUpdated {
        CMsgClientUCMPublishedFileUpdated::new()
    }

    fn clear(&mut self) {
        self.published_file_id = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.time_updated = ::std::option::Option::None;
        self.hcontent = ::std::option::Option::None;
        self.file_size = ::std::option::Option::None;
        self.is_depot_content = ::std::option::Option::None;
        self.revision = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMPublishedFileUpdated {
        static instance: CMsgClientUCMPublishedFileUpdated = CMsgClientUCMPublishedFileUpdated {
            published_file_id: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            time_updated: ::std::option::Option::None,
            hcontent: ::std::option::Option::None,
            file_size: ::std::option::Option::None,
            is_depot_content: ::std::option::Option::None,
            revision: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientWorkshopItemChangesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientWorkshopItemChangesRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientWorkshopItemChangesRequest.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientWorkshopItemChangesRequest.last_time_updated)
    pub last_time_updated: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientWorkshopItemChangesRequest.num_items_needed)
    pub num_items_needed: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientWorkshopItemChangesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientWorkshopItemChangesRequest {
    fn default() -> &'a CMsgClientWorkshopItemChangesRequest {
        <CMsgClientWorkshopItemChangesRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientWorkshopItemChangesRequest {
    pub fn new() -> CMsgClientWorkshopItemChangesRequest {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 last_time_updated = 2;

    pub fn last_time_updated(&self) -> u32 {
        self.last_time_updated.unwrap_or(0)
    }

    pub fn clear_last_time_updated(&mut self) {
        self.last_time_updated = ::std::option::Option::None;
    }

    pub fn has_last_time_updated(&self) -> bool {
        self.last_time_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_time_updated(&mut self, v: u32) {
        self.last_time_updated = ::std::option::Option::Some(v);
    }

    // optional uint32 num_items_needed = 3;

    pub fn num_items_needed(&self) -> u32 {
        self.num_items_needed.unwrap_or(0)
    }

    pub fn clear_num_items_needed(&mut self) {
        self.num_items_needed = ::std::option::Option::None;
    }

    pub fn has_num_items_needed(&self) -> bool {
        self.num_items_needed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_items_needed(&mut self, v: u32) {
        self.num_items_needed = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientWorkshopItemChangesRequest {
    const NAME: &'static str = "CMsgClientWorkshopItemChangesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.last_time_updated = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.num_items_needed = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.last_time_updated {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.num_items_needed {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.last_time_updated {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.num_items_needed {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientWorkshopItemChangesRequest {
        CMsgClientWorkshopItemChangesRequest::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.last_time_updated = ::std::option::Option::None;
        self.num_items_needed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientWorkshopItemChangesRequest {
        static instance: CMsgClientWorkshopItemChangesRequest = CMsgClientWorkshopItemChangesRequest {
            app_id: ::std::option::Option::None,
            last_time_updated: ::std::option::Option::None,
            num_items_needed: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientWorkshopItemChangesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientWorkshopItemChangesResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientWorkshopItemChangesResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientWorkshopItemChangesResponse.update_time)
    pub update_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientWorkshopItemChangesResponse.workshop_items)
    pub workshop_items: ::std::vec::Vec<cmsg_client_workshop_item_changes_response::WorkshopItemInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientWorkshopItemChangesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientWorkshopItemChangesResponse {
    fn default() -> &'a CMsgClientWorkshopItemChangesResponse {
        <CMsgClientWorkshopItemChangesResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientWorkshopItemChangesResponse {
    pub fn new() -> CMsgClientWorkshopItemChangesResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 update_time = 2;

    pub fn update_time(&self) -> u32 {
        self.update_time.unwrap_or(0)
    }

    pub fn clear_update_time(&mut self) {
        self.update_time = ::std::option::Option::None;
    }

    pub fn has_update_time(&self) -> bool {
        self.update_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_time(&mut self, v: u32) {
        self.update_time = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientWorkshopItemChangesResponse {
    const NAME: &'static str = "CMsgClientWorkshopItemChangesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.update_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.workshop_items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.update_time {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.workshop_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.update_time {
            os.write_uint32(2, v)?;
        }
        for v in &self.workshop_items {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientWorkshopItemChangesResponse {
        CMsgClientWorkshopItemChangesResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.update_time = ::std::option::Option::None;
        self.workshop_items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientWorkshopItemChangesResponse {
        static instance: CMsgClientWorkshopItemChangesResponse = CMsgClientWorkshopItemChangesResponse {
            eresult: ::std::option::Option::None,
            update_time: ::std::option::Option::None,
            workshop_items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientWorkshopItemChangesResponse`
pub mod cmsg_client_workshop_item_changes_response {
    // @@protoc_insertion_point(message:CMsgClientWorkshopItemChangesResponse.WorkshopItemInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct WorkshopItemInfo {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientWorkshopItemChangesResponse.WorkshopItemInfo.published_file_id)
        pub published_file_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientWorkshopItemChangesResponse.WorkshopItemInfo.time_updated)
        pub time_updated: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientWorkshopItemChangesResponse.WorkshopItemInfo.manifest_id)
        pub manifest_id: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientWorkshopItemChangesResponse.WorkshopItemInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a WorkshopItemInfo {
        fn default() -> &'a WorkshopItemInfo {
            <WorkshopItemInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl WorkshopItemInfo {
        pub fn new() -> WorkshopItemInfo {
            ::std::default::Default::default()
        }

        // optional fixed64 published_file_id = 1;

        pub fn published_file_id(&self) -> u64 {
            self.published_file_id.unwrap_or(0)
        }

        pub fn clear_published_file_id(&mut self) {
            self.published_file_id = ::std::option::Option::None;
        }

        pub fn has_published_file_id(&self) -> bool {
            self.published_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_published_file_id(&mut self, v: u64) {
            self.published_file_id = ::std::option::Option::Some(v);
        }

        // optional uint32 time_updated = 2;

        pub fn time_updated(&self) -> u32 {
            self.time_updated.unwrap_or(0)
        }

        pub fn clear_time_updated(&mut self) {
            self.time_updated = ::std::option::Option::None;
        }

        pub fn has_time_updated(&self) -> bool {
            self.time_updated.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_updated(&mut self, v: u32) {
            self.time_updated = ::std::option::Option::Some(v);
        }

        // optional fixed64 manifest_id = 3;

        pub fn manifest_id(&self) -> u64 {
            self.manifest_id.unwrap_or(0)
        }

        pub fn clear_manifest_id(&mut self) {
            self.manifest_id = ::std::option::Option::None;
        }

        pub fn has_manifest_id(&self) -> bool {
            self.manifest_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_manifest_id(&mut self, v: u64) {
            self.manifest_id = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for WorkshopItemInfo {
        const NAME: &'static str = "WorkshopItemInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.time_updated = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    25 => {
                        self.manifest_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.published_file_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.time_updated {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.manifest_id {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.published_file_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.time_updated {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.manifest_id {
                os.write_fixed64(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> WorkshopItemInfo {
            WorkshopItemInfo::new()
        }

        fn clear(&mut self) {
            self.published_file_id = ::std::option::Option::None;
            self.time_updated = ::std::option::Option::None;
            self.manifest_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static WorkshopItemInfo {
            static instance: WorkshopItemInfo = WorkshopItemInfo {
                published_file_id: ::std::option::Option::None,
                time_updated: ::std::option::Option::None,
                manifest_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientUCMSetUserPublishedFileAction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMSetUserPublishedFileAction {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMSetUserPublishedFileAction.published_file_id)
    pub published_file_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUCMSetUserPublishedFileAction.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMSetUserPublishedFileAction.action)
    pub action: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMSetUserPublishedFileAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMSetUserPublishedFileAction {
    fn default() -> &'a CMsgClientUCMSetUserPublishedFileAction {
        <CMsgClientUCMSetUserPublishedFileAction as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMSetUserPublishedFileAction {
    pub fn new() -> CMsgClientUCMSetUserPublishedFileAction {
        ::std::default::Default::default()
    }

    // optional fixed64 published_file_id = 1;

    pub fn published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(0)
    }

    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional int32 action = 3;

    pub fn action(&self) -> i32 {
        self.action.unwrap_or(0)
    }

    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: i32) {
        self.action = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMSetUserPublishedFileAction {
    const NAME: &'static str = "CMsgClientUCMSetUserPublishedFileAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.action = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.published_file_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.action {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.published_file_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.action {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMSetUserPublishedFileAction {
        CMsgClientUCMSetUserPublishedFileAction::new()
    }

    fn clear(&mut self) {
        self.published_file_id = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMSetUserPublishedFileAction {
        static instance: CMsgClientUCMSetUserPublishedFileAction = CMsgClientUCMSetUserPublishedFileAction {
            published_file_id: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            action: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientUCMSetUserPublishedFileActionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMSetUserPublishedFileActionResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMSetUserPublishedFileActionResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMSetUserPublishedFileActionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMSetUserPublishedFileActionResponse {
    fn default() -> &'a CMsgClientUCMSetUserPublishedFileActionResponse {
        <CMsgClientUCMSetUserPublishedFileActionResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMSetUserPublishedFileActionResponse {
    pub fn new() -> CMsgClientUCMSetUserPublishedFileActionResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMSetUserPublishedFileActionResponse {
    const NAME: &'static str = "CMsgClientUCMSetUserPublishedFileActionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMSetUserPublishedFileActionResponse {
        CMsgClientUCMSetUserPublishedFileActionResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMSetUserPublishedFileActionResponse {
        static instance: CMsgClientUCMSetUserPublishedFileActionResponse = CMsgClientUCMSetUserPublishedFileActionResponse {
            eresult: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientUCMEnumeratePublishedFilesByUserAction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMEnumeratePublishedFilesByUserAction {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMEnumeratePublishedFilesByUserAction.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMEnumeratePublishedFilesByUserAction.start_index)
    pub start_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMEnumeratePublishedFilesByUserAction.action)
    pub action: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMEnumeratePublishedFilesByUserAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMEnumeratePublishedFilesByUserAction {
    fn default() -> &'a CMsgClientUCMEnumeratePublishedFilesByUserAction {
        <CMsgClientUCMEnumeratePublishedFilesByUserAction as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMEnumeratePublishedFilesByUserAction {
    pub fn new() -> CMsgClientUCMEnumeratePublishedFilesByUserAction {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 start_index = 2;

    pub fn start_index(&self) -> u32 {
        self.start_index.unwrap_or(0)
    }

    pub fn clear_start_index(&mut self) {
        self.start_index = ::std::option::Option::None;
    }

    pub fn has_start_index(&self) -> bool {
        self.start_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_index(&mut self, v: u32) {
        self.start_index = ::std::option::Option::Some(v);
    }

    // optional int32 action = 3;

    pub fn action(&self) -> i32 {
        self.action.unwrap_or(0)
    }

    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: i32) {
        self.action = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMEnumeratePublishedFilesByUserAction {
    const NAME: &'static str = "CMsgClientUCMEnumeratePublishedFilesByUserAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.start_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.action = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.start_index {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.action {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.start_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.action {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMEnumeratePublishedFilesByUserAction {
        CMsgClientUCMEnumeratePublishedFilesByUserAction::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.start_index = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMEnumeratePublishedFilesByUserAction {
        static instance: CMsgClientUCMEnumeratePublishedFilesByUserAction = CMsgClientUCMEnumeratePublishedFilesByUserAction {
            app_id: ::std::option::Option::None,
            start_index: ::std::option::Option::None,
            action: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientUCMEnumeratePublishedFilesByUserActionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMEnumeratePublishedFilesByUserActionResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUCMEnumeratePublishedFilesByUserActionResponse.published_files)
    pub published_files: ::std::vec::Vec<cmsg_client_ucmenumerate_published_files_by_user_action_response::PublishedFileId>,
    // @@protoc_insertion_point(field:CMsgClientUCMEnumeratePublishedFilesByUserActionResponse.total_results)
    pub total_results: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMEnumeratePublishedFilesByUserActionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
    fn default() -> &'a CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
        <CMsgClientUCMEnumeratePublishedFilesByUserActionResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
    pub fn new() -> CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 total_results = 3;

    pub fn total_results(&self) -> u32 {
        self.total_results.unwrap_or(0)
    }

    pub fn clear_total_results(&mut self) {
        self.total_results = ::std::option::Option::None;
    }

    pub fn has_total_results(&self) -> bool {
        self.total_results.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_results(&mut self, v: u32) {
        self.total_results = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
    const NAME: &'static str = "CMsgClientUCMEnumeratePublishedFilesByUserActionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.published_files.push(is.read_message()?);
                },
                24 => {
                    self.total_results = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        for value in &self.published_files {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.total_results {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        for v in &self.published_files {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.total_results {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
        CMsgClientUCMEnumeratePublishedFilesByUserActionResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.published_files.clear();
        self.total_results = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
        static instance: CMsgClientUCMEnumeratePublishedFilesByUserActionResponse = CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
            eresult: ::std::option::Option::None,
            published_files: ::std::vec::Vec::new(),
            total_results: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientUCMEnumeratePublishedFilesByUserActionResponse`
pub mod cmsg_client_ucmenumerate_published_files_by_user_action_response {
    // @@protoc_insertion_point(message:CMsgClientUCMEnumeratePublishedFilesByUserActionResponse.PublishedFileId)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PublishedFileId {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientUCMEnumeratePublishedFilesByUserActionResponse.PublishedFileId.published_file_id)
        pub published_file_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientUCMEnumeratePublishedFilesByUserActionResponse.PublishedFileId.rtime_time_stamp)
        pub rtime_time_stamp: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientUCMEnumeratePublishedFilesByUserActionResponse.PublishedFileId.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PublishedFileId {
        fn default() -> &'a PublishedFileId {
            <PublishedFileId as ::protobuf::Message>::default_instance()
        }
    }

    impl PublishedFileId {
        pub fn new() -> PublishedFileId {
            ::std::default::Default::default()
        }

        // optional fixed64 published_file_id = 1;

        pub fn published_file_id(&self) -> u64 {
            self.published_file_id.unwrap_or(0)
        }

        pub fn clear_published_file_id(&mut self) {
            self.published_file_id = ::std::option::Option::None;
        }

        pub fn has_published_file_id(&self) -> bool {
            self.published_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_published_file_id(&mut self, v: u64) {
            self.published_file_id = ::std::option::Option::Some(v);
        }

        // optional fixed32 rtime_time_stamp = 2;

        pub fn rtime_time_stamp(&self) -> u32 {
            self.rtime_time_stamp.unwrap_or(0u32)
        }

        pub fn clear_rtime_time_stamp(&mut self) {
            self.rtime_time_stamp = ::std::option::Option::None;
        }

        pub fn has_rtime_time_stamp(&self) -> bool {
            self.rtime_time_stamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rtime_time_stamp(&mut self, v: u32) {
            self.rtime_time_stamp = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for PublishedFileId {
        const NAME: &'static str = "PublishedFileId";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    21 => {
                        self.rtime_time_stamp = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.published_file_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.rtime_time_stamp {
                my_size += 1 + 4;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.published_file_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.rtime_time_stamp {
                os.write_fixed32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PublishedFileId {
            PublishedFileId::new()
        }

        fn clear(&mut self) {
            self.published_file_id = ::std::option::Option::None;
            self.rtime_time_stamp = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PublishedFileId {
            static instance: PublishedFileId = PublishedFileId {
                published_file_id: ::std::option::Option::None,
                rtime_time_stamp: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientScreenshotsChanged)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientScreenshotsChanged {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientScreenshotsChanged.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientScreenshotsChanged {
    fn default() -> &'a CMsgClientScreenshotsChanged {
        <CMsgClientScreenshotsChanged as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientScreenshotsChanged {
    pub fn new() -> CMsgClientScreenshotsChanged {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientScreenshotsChanged {
    const NAME: &'static str = "CMsgClientScreenshotsChanged";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientScreenshotsChanged {
        CMsgClientScreenshotsChanged::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientScreenshotsChanged {
        static instance: CMsgClientScreenshotsChanged = CMsgClientScreenshotsChanged {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}
#[allow(unused_imports)]
use crate::steammessages_base::*;
impl crate::RpcMessage for CMsgClientUCMAddScreenshot {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientUCMAddScreenshot {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientUCMAddScreenshot;
}
impl crate::RpcMessage for CMsgClientUCMAddScreenshotResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientUCMAddScreenshotResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientUCMAddScreenshotResponse;
}
impl crate::RpcMessage for CMsgClientUCMDeleteScreenshot {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientUCMDeleteScreenshot {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientUCMDeleteScreenshot;
}
impl crate::RpcMessage for CMsgClientUCMDeleteScreenshotResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientUCMDeleteScreenshotResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientUCMDeleteScreenshotResponse;
}
impl crate::RpcMessage for CMsgClientUCMPublishFile {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientUCMPublishFile {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientUCMPublishFile;
}
impl crate::RpcMessage for CMsgClientUCMPublishFileResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientUCMPublishFileResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientUCMPublishFileResponse;
}
impl crate::RpcMessage for CMsgClientUCMUpdatePublishedFile {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientUCMUpdatePublishedFile {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientUCMUpdatePublishedFile;
}
impl crate::RpcMessage for CMsgClientUCMUpdatePublishedFileResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientUCMUpdatePublishedFileResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientUCMUpdatePublishedFileResponse;
}
impl crate::RpcMessage for CMsgClientUCMDeletePublishedFile {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientUCMDeletePublishedFile {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientUCMDeletePublishedFile;
}
impl crate::RpcMessage for CMsgClientUCMDeletePublishedFileResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientUCMDeletePublishedFileResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientUCMDeletePublishedFileResponse;
}
impl crate::RpcMessage for CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientUCMEnumerateUserSubscribedFilesWithUpdates;
}
impl crate::RpcMessage for CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind
for CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse;
}
impl crate::RpcMessage for CMsgClientUCMPublishedFileUpdated {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientUCMPublishedFileUpdated {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientUCMPublishedFileUpdated;
}
impl crate::RpcMessage for CMsgClientWorkshopItemChangesRequest {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgClientWorkshopItemChangesResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgClientUCMSetUserPublishedFileAction {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientUCMSetUserPublishedFileAction {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientUCMSetUserPublishedFileAction;
}
impl crate::RpcMessage for CMsgClientUCMSetUserPublishedFileActionResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientUCMSetUserPublishedFileActionResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientUCMSetUserPublishedFileActionResponse;
}
impl crate::RpcMessage for CMsgClientUCMEnumeratePublishedFilesByUserAction {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientUCMEnumeratePublishedFilesByUserAction {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientUCMEnumeratePublishedFilesByUserAction;
}
impl crate::RpcMessage for CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind
for CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientUCMEnumeratePublishedFilesByUserActionResponse;
}
impl crate::RpcMessage for CMsgClientScreenshotsChanged {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientScreenshotsChanged {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientScreenshotsChanged;
}
