// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_clientserver_gameservers.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:CMsgGSServerType)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGSServerType {
    // message fields
    // @@protoc_insertion_point(field:CMsgGSServerType.app_id_served)
    pub app_id_served: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGSServerType.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGSServerType.deprecated_game_ip_address)
    pub deprecated_game_ip_address: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGSServerType.game_port)
    pub game_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGSServerType.game_dir)
    pub game_dir: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGSServerType.game_version)
    pub game_version: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGSServerType.game_query_port)
    pub game_query_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGSServerType.game_port_local)
    pub game_port_local: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGSServerType.sdr_logon)
    pub sdr_logon: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgGSServerType.fake_ip)
    pub fake_ip: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGSServerType.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGSServerType {
    fn default() -> &'a CMsgGSServerType {
        <CMsgGSServerType as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSServerType {
    pub fn new() -> CMsgGSServerType {
        ::std::default::Default::default()
    }

    // optional uint32 app_id_served = 1;

    pub fn app_id_served(&self) -> u32 {
        self.app_id_served.unwrap_or(0)
    }

    pub fn clear_app_id_served(&mut self) {
        self.app_id_served = ::std::option::Option::None;
    }

    pub fn has_app_id_served(&self) -> bool {
        self.app_id_served.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id_served(&mut self, v: u32) {
        self.app_id_served = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 2;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 deprecated_game_ip_address = 3;

    pub fn deprecated_game_ip_address(&self) -> u32 {
        self.deprecated_game_ip_address.unwrap_or(0)
    }

    pub fn clear_deprecated_game_ip_address(&mut self) {
        self.deprecated_game_ip_address = ::std::option::Option::None;
    }

    pub fn has_deprecated_game_ip_address(&self) -> bool {
        self.deprecated_game_ip_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated_game_ip_address(&mut self, v: u32) {
        self.deprecated_game_ip_address = ::std::option::Option::Some(v);
    }

    // optional uint32 game_port = 4;

    pub fn game_port(&self) -> u32 {
        self.game_port.unwrap_or(0)
    }

    pub fn clear_game_port(&mut self) {
        self.game_port = ::std::option::Option::None;
    }

    pub fn has_game_port(&self) -> bool {
        self.game_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_port(&mut self, v: u32) {
        self.game_port = ::std::option::Option::Some(v);
    }

    // optional string game_dir = 5;

    pub fn game_dir(&self) -> &str {
        match self.game_dir.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_dir(&mut self) {
        self.game_dir = ::std::option::Option::None;
    }

    pub fn has_game_dir(&self) -> bool {
        self.game_dir.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_dir(&mut self, v: ::std::string::String) {
        self.game_dir = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_dir(&mut self) -> &mut ::std::string::String {
        if self.game_dir.is_none() {
            self.game_dir = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_dir.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_dir(&mut self) -> ::std::string::String {
        self.game_dir.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string game_version = 6;

    pub fn game_version(&self) -> &str {
        match self.game_version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_version(&mut self) {
        self.game_version = ::std::option::Option::None;
    }

    pub fn has_game_version(&self) -> bool {
        self.game_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_version(&mut self, v: ::std::string::String) {
        self.game_version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_version(&mut self) -> &mut ::std::string::String {
        if self.game_version.is_none() {
            self.game_version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_version(&mut self) -> ::std::string::String {
        self.game_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 game_query_port = 7;

    pub fn game_query_port(&self) -> u32 {
        self.game_query_port.unwrap_or(0)
    }

    pub fn clear_game_query_port(&mut self) {
        self.game_query_port = ::std::option::Option::None;
    }

    pub fn has_game_query_port(&self) -> bool {
        self.game_query_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_query_port(&mut self, v: u32) {
        self.game_query_port = ::std::option::Option::Some(v);
    }

    // optional uint32 game_port_local = 10;

    pub fn game_port_local(&self) -> u32 {
        self.game_port_local.unwrap_or(0)
    }

    pub fn clear_game_port_local(&mut self) {
        self.game_port_local = ::std::option::Option::None;
    }

    pub fn has_game_port_local(&self) -> bool {
        self.game_port_local.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_port_local(&mut self, v: u32) {
        self.game_port_local = ::std::option::Option::Some(v);
    }

    // optional bytes sdr_logon = 8;

    pub fn sdr_logon(&self) -> &[u8] {
        match self.sdr_logon.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_sdr_logon(&mut self) {
        self.sdr_logon = ::std::option::Option::None;
    }

    pub fn has_sdr_logon(&self) -> bool {
        self.sdr_logon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sdr_logon(&mut self, v: ::std::vec::Vec<u8>) {
        self.sdr_logon = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sdr_logon(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sdr_logon.is_none() {
            self.sdr_logon = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.sdr_logon.as_mut().unwrap()
    }

    // Take field
    pub fn take_sdr_logon(&mut self) -> ::std::vec::Vec<u8> {
        self.sdr_logon.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed32 fake_ip = 9;

    pub fn fake_ip(&self) -> u32 {
        self.fake_ip.unwrap_or(0)
    }

    pub fn clear_fake_ip(&mut self) {
        self.fake_ip = ::std::option::Option::None;
    }

    pub fn has_fake_ip(&self) -> bool {
        self.fake_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fake_ip(&mut self, v: u32) {
        self.fake_ip = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGSServerType {
    const NAME: &'static str = "CMsgGSServerType";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id_served = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.deprecated_game_ip_address = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.game_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.game_dir = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.game_version = ::std::option::Option::Some(is.read_string()?);
                },
                56 => {
                    self.game_query_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.game_port_local = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.sdr_logon = ::std::option::Option::Some(is.read_bytes()?);
                },
                77 => {
                    self.fake_ip = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id_served {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.deprecated_game_ip_address {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.game_port {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.game_dir.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.game_version.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.game_query_port {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.game_port_local {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.sdr_logon.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.fake_ip {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id_served {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.deprecated_game_ip_address {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.game_port {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.game_dir.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.game_version.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.game_query_port {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.game_port_local {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.sdr_logon.as_ref() {
            os.write_bytes(8, v)?;
        }
        if let Some(v) = self.fake_ip {
            os.write_fixed32(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGSServerType {
        CMsgGSServerType::new()
    }

    fn clear(&mut self) {
        self.app_id_served = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.deprecated_game_ip_address = ::std::option::Option::None;
        self.game_port = ::std::option::Option::None;
        self.game_dir = ::std::option::Option::None;
        self.game_version = ::std::option::Option::None;
        self.game_query_port = ::std::option::Option::None;
        self.game_port_local = ::std::option::Option::None;
        self.sdr_logon = ::std::option::Option::None;
        self.fake_ip = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGSServerType {
        static instance: CMsgGSServerType = CMsgGSServerType {
            app_id_served: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            deprecated_game_ip_address: ::std::option::Option::None,
            game_port: ::std::option::Option::None,
            game_dir: ::std::option::Option::None,
            game_version: ::std::option::Option::None,
            game_query_port: ::std::option::Option::None,
            game_port_local: ::std::option::Option::None,
            sdr_logon: ::std::option::Option::None,
            fake_ip: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGSStatusReply)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGSStatusReply {
    // message fields
    // @@protoc_insertion_point(field:CMsgGSStatusReply.is_secure)
    pub is_secure: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGSStatusReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGSStatusReply {
    fn default() -> &'a CMsgGSStatusReply {
        <CMsgGSStatusReply as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSStatusReply {
    pub fn new() -> CMsgGSStatusReply {
        ::std::default::Default::default()
    }

    // optional bool is_secure = 1;

    pub fn is_secure(&self) -> bool {
        self.is_secure.unwrap_or(false)
    }

    pub fn clear_is_secure(&mut self) {
        self.is_secure = ::std::option::Option::None;
    }

    pub fn has_is_secure(&self) -> bool {
        self.is_secure.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_secure(&mut self, v: bool) {
        self.is_secure = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGSStatusReply {
    const NAME: &'static str = "CMsgGSStatusReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.is_secure = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.is_secure {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.is_secure {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGSStatusReply {
        CMsgGSStatusReply::new()
    }

    fn clear(&mut self) {
        self.is_secure = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGSStatusReply {
        static instance: CMsgGSStatusReply = CMsgGSStatusReply {
            is_secure: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGSPlayerList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGSPlayerList {
    // message fields
    // @@protoc_insertion_point(field:CMsgGSPlayerList.players)
    pub players: ::std::vec::Vec<cmsg_gsplayer_list::Player>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGSPlayerList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGSPlayerList {
    fn default() -> &'a CMsgGSPlayerList {
        <CMsgGSPlayerList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSPlayerList {
    pub fn new() -> CMsgGSPlayerList {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgGSPlayerList {
    const NAME: &'static str = "CMsgGSPlayerList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.players.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.players {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGSPlayerList {
        CMsgGSPlayerList::new()
    }

    fn clear(&mut self) {
        self.players.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGSPlayerList {
        static instance: CMsgGSPlayerList = CMsgGSPlayerList {
            players: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGSPlayerList`
pub mod cmsg_gsplayer_list {
    // @@protoc_insertion_point(message:CMsgGSPlayerList.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:CMsgGSPlayerList.Player.steam_id)
        pub steam_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgGSPlayerList.Player.deprecated_public_ip)
        pub deprecated_public_ip: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGSPlayerList.Player.token)
        pub token: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:CMsgGSPlayerList.Player.public_ip)
        pub public_ip: ::protobuf::MessageField<super::super::steammessages_base::CMsgIPAddress>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGSPlayerList.Player.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional uint64 steam_id = 1;

        pub fn steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }

        // optional uint32 deprecated_public_ip = 2;

        pub fn deprecated_public_ip(&self) -> u32 {
            self.deprecated_public_ip.unwrap_or(0)
        }

        pub fn clear_deprecated_public_ip(&mut self) {
            self.deprecated_public_ip = ::std::option::Option::None;
        }

        pub fn has_deprecated_public_ip(&self) -> bool {
            self.deprecated_public_ip.is_some()
        }

        // Param is passed by value, moved
        pub fn set_deprecated_public_ip(&mut self, v: u32) {
            self.deprecated_public_ip = ::std::option::Option::Some(v);
        }

        // optional bytes token = 3;

        pub fn token(&self) -> &[u8] {
            match self.token.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_token(&mut self) {
            self.token = ::std::option::Option::None;
        }

        pub fn has_token(&self) -> bool {
            self.token.is_some()
        }

        // Param is passed by value, moved
        pub fn set_token(&mut self, v: ::std::vec::Vec<u8>) {
            self.token = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_token(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.token.is_none() {
                self.token = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.token.as_mut().unwrap()
        }

        // Take field
        pub fn take_token(&mut self) -> ::std::vec::Vec<u8> {
            self.token.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }
    }

    impl ::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.steam_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        self.deprecated_public_ip = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.token = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    34 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.public_ip)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steam_id {
                my_size += ::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.deprecated_public_ip {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.token.as_ref() {
                my_size += ::protobuf::rt::bytes_size(3, &v);
            }
            if let Some(v) = self.public_ip.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.steam_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.deprecated_public_ip {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.token.as_ref() {
                os.write_bytes(3, v)?;
            }
            if let Some(v) = self.public_ip.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.steam_id = ::std::option::Option::None;
            self.deprecated_public_ip = ::std::option::Option::None;
            self.token = ::std::option::Option::None;
            self.public_ip.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                steam_id: ::std::option::Option::None,
                deprecated_public_ip: ::std::option::Option::None,
                token: ::std::option::Option::None,
                public_ip: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgGSUserPlaying)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGSUserPlaying {
    // message fields
    // @@protoc_insertion_point(field:CMsgGSUserPlaying.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGSUserPlaying.deprecated_public_ip)
    pub deprecated_public_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGSUserPlaying.token)
    pub token: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgGSUserPlaying.public_ip)
    pub public_ip: ::protobuf::MessageField<super::steammessages_base::CMsgIPAddress>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGSUserPlaying.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGSUserPlaying {
    fn default() -> &'a CMsgGSUserPlaying {
        <CMsgGSUserPlaying as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSUserPlaying {
    pub fn new() -> CMsgGSUserPlaying {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 deprecated_public_ip = 2;

    pub fn deprecated_public_ip(&self) -> u32 {
        self.deprecated_public_ip.unwrap_or(0)
    }

    pub fn clear_deprecated_public_ip(&mut self) {
        self.deprecated_public_ip = ::std::option::Option::None;
    }

    pub fn has_deprecated_public_ip(&self) -> bool {
        self.deprecated_public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated_public_ip(&mut self, v: u32) {
        self.deprecated_public_ip = ::std::option::Option::Some(v);
    }

    // optional bytes token = 3;

    pub fn token(&self) -> &[u8] {
        match self.token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.token.is_none() {
            self.token = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::vec::Vec<u8> {
        self.token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgGSUserPlaying {
    const NAME: &'static str = "CMsgGSUserPlaying";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.deprecated_public_ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.token = ::std::option::Option::Some(is.read_bytes()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.public_ip)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.deprecated_public_ip {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.public_ip.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.deprecated_public_ip {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.token.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.public_ip.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGSUserPlaying {
        CMsgGSUserPlaying::new()
    }

    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.deprecated_public_ip = ::std::option::Option::None;
        self.token = ::std::option::Option::None;
        self.public_ip.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGSUserPlaying {
        static instance: CMsgGSUserPlaying = CMsgGSUserPlaying {
            steam_id: ::std::option::Option::None,
            deprecated_public_ip: ::std::option::Option::None,
            token: ::std::option::Option::None,
            public_ip: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGSDisconnectNotice)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGSDisconnectNotice {
    // message fields
    // @@protoc_insertion_point(field:CMsgGSDisconnectNotice.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGSDisconnectNotice.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGSDisconnectNotice {
    fn default() -> &'a CMsgGSDisconnectNotice {
        <CMsgGSDisconnectNotice as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSDisconnectNotice {
    pub fn new() -> CMsgGSDisconnectNotice {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGSDisconnectNotice {
    const NAME: &'static str = "CMsgGSDisconnectNotice";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGSDisconnectNotice {
        CMsgGSDisconnectNotice::new()
    }

    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGSDisconnectNotice {
        static instance: CMsgGSDisconnectNotice = CMsgGSDisconnectNotice {
            steam_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGameServerData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameServerData {
    // message fields
    // @@protoc_insertion_point(field:CMsgGameServerData.revision)
    pub revision: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerData.query_port)
    pub query_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerData.game_port)
    pub game_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerData.spectator_port)
    pub spectator_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerData.server_name)
    pub server_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameServerData.game_description)
    pub game_description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameServerData.spectator_server_name)
    pub spectator_server_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameServerData.fake_ip)
    pub fake_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerData.sdr_ping_location)
    pub sdr_ping_location: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameServerData.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerData.gamedir)
    pub gamedir: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameServerData.version)
    pub version: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameServerData.product)
    pub product: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameServerData.region)
    pub region: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameServerData.players)
    pub players: ::std::vec::Vec<cmsg_game_server_data::Player>,
    // @@protoc_insertion_point(field:CMsgGameServerData.max_players)
    pub max_players: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerData.bot_count)
    pub bot_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerData.password)
    pub password: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGameServerData.secure)
    pub secure: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGameServerData.dedicated)
    pub dedicated: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGameServerData.os)
    pub os: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameServerData.game_data)
    pub game_data: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameServerData.game_type)
    pub game_type: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameServerData.map)
    pub map: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGameServerData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameServerData {
    fn default() -> &'a CMsgGameServerData {
        <CMsgGameServerData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameServerData {
    pub fn new() -> CMsgGameServerData {
        ::std::default::Default::default()
    }

    // optional uint32 revision = 24;

    pub fn revision(&self) -> u32 {
        self.revision.unwrap_or(0)
    }

    pub fn clear_revision(&mut self) {
        self.revision = ::std::option::Option::None;
    }

    pub fn has_revision(&self) -> bool {
        self.revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: u32) {
        self.revision = ::std::option::Option::Some(v);
    }

    // optional uint32 query_port = 3;

    pub fn query_port(&self) -> u32 {
        self.query_port.unwrap_or(0)
    }

    pub fn clear_query_port(&mut self) {
        self.query_port = ::std::option::Option::None;
    }

    pub fn has_query_port(&self) -> bool {
        self.query_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_query_port(&mut self, v: u32) {
        self.query_port = ::std::option::Option::Some(v);
    }

    // optional uint32 game_port = 4;

    pub fn game_port(&self) -> u32 {
        self.game_port.unwrap_or(0)
    }

    pub fn clear_game_port(&mut self) {
        self.game_port = ::std::option::Option::None;
    }

    pub fn has_game_port(&self) -> bool {
        self.game_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_port(&mut self, v: u32) {
        self.game_port = ::std::option::Option::Some(v);
    }

    // optional uint32 spectator_port = 5;

    pub fn spectator_port(&self) -> u32 {
        self.spectator_port.unwrap_or(0)
    }

    pub fn clear_spectator_port(&mut self) {
        self.spectator_port = ::std::option::Option::None;
    }

    pub fn has_spectator_port(&self) -> bool {
        self.spectator_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spectator_port(&mut self, v: u32) {
        self.spectator_port = ::std::option::Option::Some(v);
    }

    // optional string server_name = 22;

    pub fn server_name(&self) -> &str {
        match self.server_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_server_name(&mut self) {
        self.server_name = ::std::option::Option::None;
    }

    pub fn has_server_name(&self) -> bool {
        self.server_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_name(&mut self, v: ::std::string::String) {
        self.server_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_name(&mut self) -> &mut ::std::string::String {
        if self.server_name.is_none() {
            self.server_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.server_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_name(&mut self) -> ::std::string::String {
        self.server_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string game_description = 29;

    pub fn game_description(&self) -> &str {
        match self.game_description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_description(&mut self) {
        self.game_description = ::std::option::Option::None;
    }

    pub fn has_game_description(&self) -> bool {
        self.game_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_description(&mut self, v: ::std::string::String) {
        self.game_description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_description(&mut self) -> &mut ::std::string::String {
        if self.game_description.is_none() {
            self.game_description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_description(&mut self) -> ::std::string::String {
        self.game_description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string spectator_server_name = 27;

    pub fn spectator_server_name(&self) -> &str {
        match self.spectator_server_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_spectator_server_name(&mut self) {
        self.spectator_server_name = ::std::option::Option::None;
    }

    pub fn has_spectator_server_name(&self) -> bool {
        self.spectator_server_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spectator_server_name(&mut self, v: ::std::string::String) {
        self.spectator_server_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spectator_server_name(&mut self) -> &mut ::std::string::String {
        if self.spectator_server_name.is_none() {
            self.spectator_server_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.spectator_server_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_spectator_server_name(&mut self) -> ::std::string::String {
        self.spectator_server_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed32 fake_ip = 28;

    pub fn fake_ip(&self) -> u32 {
        self.fake_ip.unwrap_or(0)
    }

    pub fn clear_fake_ip(&mut self) {
        self.fake_ip = ::std::option::Option::None;
    }

    pub fn has_fake_ip(&self) -> bool {
        self.fake_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fake_ip(&mut self, v: u32) {
        self.fake_ip = ::std::option::Option::Some(v);
    }

    // optional string sdr_ping_location = 30;

    pub fn sdr_ping_location(&self) -> &str {
        match self.sdr_ping_location.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_sdr_ping_location(&mut self) {
        self.sdr_ping_location = ::std::option::Option::None;
    }

    pub fn has_sdr_ping_location(&self) -> bool {
        self.sdr_ping_location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sdr_ping_location(&mut self, v: ::std::string::String) {
        self.sdr_ping_location = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sdr_ping_location(&mut self) -> &mut ::std::string::String {
        if self.sdr_ping_location.is_none() {
            self.sdr_ping_location = ::std::option::Option::Some(::std::string::String::new());
        }
        self.sdr_ping_location.as_mut().unwrap()
    }

    // Take field
    pub fn take_sdr_ping_location(&mut self) -> ::std::string::String {
        self.sdr_ping_location.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 app_id = 6;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional string gamedir = 7;

    pub fn gamedir(&self) -> &str {
        match self.gamedir.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_gamedir(&mut self) {
        self.gamedir = ::std::option::Option::None;
    }

    pub fn has_gamedir(&self) -> bool {
        self.gamedir.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gamedir(&mut self, v: ::std::string::String) {
        self.gamedir = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gamedir(&mut self) -> &mut ::std::string::String {
        if self.gamedir.is_none() {
            self.gamedir = ::std::option::Option::Some(::std::string::String::new());
        }
        self.gamedir.as_mut().unwrap()
    }

    // Take field
    pub fn take_gamedir(&mut self) -> ::std::string::String {
        self.gamedir.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string version = 8;

    pub fn version(&self) -> &str {
        match self.version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        if self.version.is_none() {
            self.version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        self.version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string product = 9;

    pub fn product(&self) -> &str {
        match self.product.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_product(&mut self) {
        self.product = ::std::option::Option::None;
    }

    pub fn has_product(&self) -> bool {
        self.product.is_some()
    }

    // Param is passed by value, moved
    pub fn set_product(&mut self, v: ::std::string::String) {
        self.product = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_product(&mut self) -> &mut ::std::string::String {
        if self.product.is_none() {
            self.product = ::std::option::Option::Some(::std::string::String::new());
        }
        self.product.as_mut().unwrap()
    }

    // Take field
    pub fn take_product(&mut self) -> ::std::string::String {
        self.product.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string region = 10;

    pub fn region(&self) -> &str {
        match self.region.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_region(&mut self) {
        self.region = ::std::option::Option::None;
    }

    pub fn has_region(&self) -> bool {
        self.region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region(&mut self, v: ::std::string::String) {
        self.region = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region(&mut self) -> &mut ::std::string::String {
        if self.region.is_none() {
            self.region = ::std::option::Option::Some(::std::string::String::new());
        }
        self.region.as_mut().unwrap()
    }

    // Take field
    pub fn take_region(&mut self) -> ::std::string::String {
        self.region.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 max_players = 12;

    pub fn max_players(&self) -> u32 {
        self.max_players.unwrap_or(0)
    }

    pub fn clear_max_players(&mut self) {
        self.max_players = ::std::option::Option::None;
    }

    pub fn has_max_players(&self) -> bool {
        self.max_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_players(&mut self, v: u32) {
        self.max_players = ::std::option::Option::Some(v);
    }

    // optional uint32 bot_count = 13;

    pub fn bot_count(&self) -> u32 {
        self.bot_count.unwrap_or(0)
    }

    pub fn clear_bot_count(&mut self) {
        self.bot_count = ::std::option::Option::None;
    }

    pub fn has_bot_count(&self) -> bool {
        self.bot_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bot_count(&mut self, v: u32) {
        self.bot_count = ::std::option::Option::Some(v);
    }

    // optional bool password = 14;

    pub fn password(&self) -> bool {
        self.password.unwrap_or(false)
    }

    pub fn clear_password(&mut self) {
        self.password = ::std::option::Option::None;
    }

    pub fn has_password(&self) -> bool {
        self.password.is_some()
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: bool) {
        self.password = ::std::option::Option::Some(v);
    }

    // optional bool secure = 15;

    pub fn secure(&self) -> bool {
        self.secure.unwrap_or(false)
    }

    pub fn clear_secure(&mut self) {
        self.secure = ::std::option::Option::None;
    }

    pub fn has_secure(&self) -> bool {
        self.secure.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secure(&mut self, v: bool) {
        self.secure = ::std::option::Option::Some(v);
    }

    // optional bool dedicated = 16;

    pub fn dedicated(&self) -> bool {
        self.dedicated.unwrap_or(false)
    }

    pub fn clear_dedicated(&mut self) {
        self.dedicated = ::std::option::Option::None;
    }

    pub fn has_dedicated(&self) -> bool {
        self.dedicated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dedicated(&mut self, v: bool) {
        self.dedicated = ::std::option::Option::Some(v);
    }

    // optional string os = 17;

    pub fn os(&self) -> &str {
        match self.os.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_os(&mut self) {
        self.os = ::std::option::Option::None;
    }

    pub fn has_os(&self) -> bool {
        self.os.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os(&mut self, v: ::std::string::String) {
        self.os = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_os(&mut self) -> &mut ::std::string::String {
        if self.os.is_none() {
            self.os = ::std::option::Option::Some(::std::string::String::new());
        }
        self.os.as_mut().unwrap()
    }

    // Take field
    pub fn take_os(&mut self) -> ::std::string::String {
        self.os.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string game_data = 18;

    pub fn game_data(&self) -> &str {
        match self.game_data.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_data(&mut self) {
        self.game_data = ::std::option::Option::None;
    }

    pub fn has_game_data(&self) -> bool {
        self.game_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_data(&mut self, v: ::std::string::String) {
        self.game_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_data(&mut self) -> &mut ::std::string::String {
        if self.game_data.is_none() {
            self.game_data = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_data(&mut self) -> ::std::string::String {
        self.game_data.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string game_type = 20;

    pub fn game_type(&self) -> &str {
        match self.game_type.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_type(&mut self) {
        self.game_type = ::std::option::Option::None;
    }

    pub fn has_game_type(&self) -> bool {
        self.game_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_type(&mut self, v: ::std::string::String) {
        self.game_type = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_type(&mut self) -> &mut ::std::string::String {
        if self.game_type.is_none() {
            self.game_type = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_type(&mut self) -> ::std::string::String {
        self.game_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string map = 21;

    pub fn map(&self) -> &str {
        match self.map.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_map(&mut self) {
        self.map = ::std::option::Option::None;
    }

    pub fn has_map(&self) -> bool {
        self.map.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map(&mut self, v: ::std::string::String) {
        self.map = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map(&mut self) -> &mut ::std::string::String {
        if self.map.is_none() {
            self.map = ::std::option::Option::Some(::std::string::String::new());
        }
        self.map.as_mut().unwrap()
    }

    // Take field
    pub fn take_map(&mut self) -> ::std::string::String {
        self.map.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgGameServerData {
    const NAME: &'static str = "CMsgGameServerData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                192 => {
                    self.revision = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.query_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.game_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.spectator_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                178 => {
                    self.server_name = ::std::option::Option::Some(is.read_string()?);
                },
                234 => {
                    self.game_description = ::std::option::Option::Some(is.read_string()?);
                },
                218 => {
                    self.spectator_server_name = ::std::option::Option::Some(is.read_string()?);
                },
                229 => {
                    self.fake_ip = ::std::option::Option::Some(is.read_fixed32()?);
                },
                242 => {
                    self.sdr_ping_location = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.gamedir = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.version = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.product = ::std::option::Option::Some(is.read_string()?);
                },
                82 => {
                    self.region = ::std::option::Option::Some(is.read_string()?);
                },
                90 => {
                    self.players.push(is.read_message()?);
                },
                96 => {
                    self.max_players = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.bot_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.password = ::std::option::Option::Some(is.read_bool()?);
                },
                120 => {
                    self.secure = ::std::option::Option::Some(is.read_bool()?);
                },
                128 => {
                    self.dedicated = ::std::option::Option::Some(is.read_bool()?);
                },
                138 => {
                    self.os = ::std::option::Option::Some(is.read_string()?);
                },
                146 => {
                    self.game_data = ::std::option::Option::Some(is.read_string()?);
                },
                162 => {
                    self.game_type = ::std::option::Option::Some(is.read_string()?);
                },
                170 => {
                    self.map = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.revision {
            my_size += ::protobuf::rt::uint32_size(24, v);
        }
        if let Some(v) = self.query_port {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.game_port {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.spectator_port {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.server_name.as_ref() {
            my_size += ::protobuf::rt::string_size(22, &v);
        }
        if let Some(v) = self.game_description.as_ref() {
            my_size += ::protobuf::rt::string_size(29, &v);
        }
        if let Some(v) = self.spectator_server_name.as_ref() {
            my_size += ::protobuf::rt::string_size(27, &v);
        }
        if let Some(v) = self.fake_ip {
            my_size += 2 + 4;
        }
        if let Some(v) = self.sdr_ping_location.as_ref() {
            my_size += ::protobuf::rt::string_size(30, &v);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.gamedir.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.version.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.product.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.region.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.max_players {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.bot_count {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.password {
            my_size += 1 + 1;
        }
        if let Some(v) = self.secure {
            my_size += 1 + 1;
        }
        if let Some(v) = self.dedicated {
            my_size += 2 + 1;
        }
        if let Some(v) = self.os.as_ref() {
            my_size += ::protobuf::rt::string_size(17, &v);
        }
        if let Some(v) = self.game_data.as_ref() {
            my_size += ::protobuf::rt::string_size(18, &v);
        }
        if let Some(v) = self.game_type.as_ref() {
            my_size += ::protobuf::rt::string_size(20, &v);
        }
        if let Some(v) = self.map.as_ref() {
            my_size += ::protobuf::rt::string_size(21, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.revision {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.query_port {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.game_port {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.spectator_port {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.server_name.as_ref() {
            os.write_string(22, v)?;
        }
        if let Some(v) = self.game_description.as_ref() {
            os.write_string(29, v)?;
        }
        if let Some(v) = self.spectator_server_name.as_ref() {
            os.write_string(27, v)?;
        }
        if let Some(v) = self.fake_ip {
            os.write_fixed32(28, v)?;
        }
        if let Some(v) = self.sdr_ping_location.as_ref() {
            os.write_string(30, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.gamedir.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.version.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.product.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.region.as_ref() {
            os.write_string(10, v)?;
        }
        for v in &self.players {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        if let Some(v) = self.max_players {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.bot_count {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.password {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.secure {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.dedicated {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.os.as_ref() {
            os.write_string(17, v)?;
        }
        if let Some(v) = self.game_data.as_ref() {
            os.write_string(18, v)?;
        }
        if let Some(v) = self.game_type.as_ref() {
            os.write_string(20, v)?;
        }
        if let Some(v) = self.map.as_ref() {
            os.write_string(21, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameServerData {
        CMsgGameServerData::new()
    }

    fn clear(&mut self) {
        self.revision = ::std::option::Option::None;
        self.query_port = ::std::option::Option::None;
        self.game_port = ::std::option::Option::None;
        self.spectator_port = ::std::option::Option::None;
        self.server_name = ::std::option::Option::None;
        self.game_description = ::std::option::Option::None;
        self.spectator_server_name = ::std::option::Option::None;
        self.fake_ip = ::std::option::Option::None;
        self.sdr_ping_location = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.gamedir = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.product = ::std::option::Option::None;
        self.region = ::std::option::Option::None;
        self.players.clear();
        self.max_players = ::std::option::Option::None;
        self.bot_count = ::std::option::Option::None;
        self.password = ::std::option::Option::None;
        self.secure = ::std::option::Option::None;
        self.dedicated = ::std::option::Option::None;
        self.os = ::std::option::Option::None;
        self.game_data = ::std::option::Option::None;
        self.game_type = ::std::option::Option::None;
        self.map = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameServerData {
        static instance: CMsgGameServerData = CMsgGameServerData {
            revision: ::std::option::Option::None,
            query_port: ::std::option::Option::None,
            game_port: ::std::option::Option::None,
            spectator_port: ::std::option::Option::None,
            server_name: ::std::option::Option::None,
            game_description: ::std::option::Option::None,
            spectator_server_name: ::std::option::Option::None,
            fake_ip: ::std::option::Option::None,
            sdr_ping_location: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            gamedir: ::std::option::Option::None,
            version: ::std::option::Option::None,
            product: ::std::option::Option::None,
            region: ::std::option::Option::None,
            players: ::std::vec::Vec::new(),
            max_players: ::std::option::Option::None,
            bot_count: ::std::option::Option::None,
            password: ::std::option::Option::None,
            secure: ::std::option::Option::None,
            dedicated: ::std::option::Option::None,
            os: ::std::option::Option::None,
            game_data: ::std::option::Option::None,
            game_type: ::std::option::Option::None,
            map: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGameServerData`
pub mod cmsg_game_server_data {
    // @@protoc_insertion_point(message:CMsgGameServerData.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:CMsgGameServerData.Player.steam_id)
        pub steam_id: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGameServerData.Player.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional fixed64 steam_id = 1;

        pub fn steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steam_id {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.steam_id {
                os.write_fixed64(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.steam_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                steam_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgGameServerRemove)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameServerRemove {
    // message fields
    // @@protoc_insertion_point(field:CMsgGameServerRemove.legacy_steam_id_gs)
    pub legacy_steam_id_gs: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGameServerRemove.legacy_query_port)
    pub legacy_query_port: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGameServerRemove.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameServerRemove {
    fn default() -> &'a CMsgGameServerRemove {
        <CMsgGameServerRemove as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameServerRemove {
    pub fn new() -> CMsgGameServerRemove {
        ::std::default::Default::default()
    }

    // optional fixed64 legacy_steam_id_gs = 1;

    pub fn legacy_steam_id_gs(&self) -> u64 {
        self.legacy_steam_id_gs.unwrap_or(0)
    }

    pub fn clear_legacy_steam_id_gs(&mut self) {
        self.legacy_steam_id_gs = ::std::option::Option::None;
    }

    pub fn has_legacy_steam_id_gs(&self) -> bool {
        self.legacy_steam_id_gs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_steam_id_gs(&mut self, v: u64) {
        self.legacy_steam_id_gs = ::std::option::Option::Some(v);
    }

    // optional uint32 legacy_query_port = 3;

    pub fn legacy_query_port(&self) -> u32 {
        self.legacy_query_port.unwrap_or(0)
    }

    pub fn clear_legacy_query_port(&mut self) {
        self.legacy_query_port = ::std::option::Option::None;
    }

    pub fn has_legacy_query_port(&self) -> bool {
        self.legacy_query_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_query_port(&mut self, v: u32) {
        self.legacy_query_port = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGameServerRemove {
    const NAME: &'static str = "CMsgGameServerRemove";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.legacy_steam_id_gs = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.legacy_query_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.legacy_steam_id_gs {
            my_size += 1 + 8;
        }
        if let Some(v) = self.legacy_query_port {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.legacy_steam_id_gs {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.legacy_query_port {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameServerRemove {
        CMsgGameServerRemove::new()
    }

    fn clear(&mut self) {
        self.legacy_steam_id_gs = ::std::option::Option::None;
        self.legacy_query_port = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameServerRemove {
        static instance: CMsgGameServerRemove = CMsgGameServerRemove {
            legacy_steam_id_gs: ::std::option::Option::None,
            legacy_query_port: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientGMSServerQuery)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGMSServerQuery {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGMSServerQuery.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientGMSServerQuery.geo_location_ip)
    pub geo_location_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientGMSServerQuery.region_code)
    pub region_code: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientGMSServerQuery.filter_text)
    pub filter_text: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientGMSServerQuery.max_servers)
    pub max_servers: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGMSServerQuery.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGMSServerQuery {
    fn default() -> &'a CMsgClientGMSServerQuery {
        <CMsgClientGMSServerQuery as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGMSServerQuery {
    pub fn new() -> CMsgClientGMSServerQuery {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 geo_location_ip = 2;

    pub fn geo_location_ip(&self) -> u32 {
        self.geo_location_ip.unwrap_or(0)
    }

    pub fn clear_geo_location_ip(&mut self) {
        self.geo_location_ip = ::std::option::Option::None;
    }

    pub fn has_geo_location_ip(&self) -> bool {
        self.geo_location_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_geo_location_ip(&mut self, v: u32) {
        self.geo_location_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 region_code = 3;

    pub fn region_code(&self) -> u32 {
        self.region_code.unwrap_or(0)
    }

    pub fn clear_region_code(&mut self) {
        self.region_code = ::std::option::Option::None;
    }

    pub fn has_region_code(&self) -> bool {
        self.region_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_code(&mut self, v: u32) {
        self.region_code = ::std::option::Option::Some(v);
    }

    // optional string filter_text = 4;

    pub fn filter_text(&self) -> &str {
        match self.filter_text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filter_text(&mut self) {
        self.filter_text = ::std::option::Option::None;
    }

    pub fn has_filter_text(&self) -> bool {
        self.filter_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter_text(&mut self, v: ::std::string::String) {
        self.filter_text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter_text(&mut self) -> &mut ::std::string::String {
        if self.filter_text.is_none() {
            self.filter_text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.filter_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_filter_text(&mut self) -> ::std::string::String {
        self.filter_text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 max_servers = 5;

    pub fn max_servers(&self) -> u32 {
        self.max_servers.unwrap_or(0)
    }

    pub fn clear_max_servers(&mut self) {
        self.max_servers = ::std::option::Option::None;
    }

    pub fn has_max_servers(&self) -> bool {
        self.max_servers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_servers(&mut self, v: u32) {
        self.max_servers = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientGMSServerQuery {
    const NAME: &'static str = "CMsgClientGMSServerQuery";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.geo_location_ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.region_code = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.filter_text = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.max_servers = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.geo_location_ip {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.region_code {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.filter_text.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.max_servers {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.geo_location_ip {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.region_code {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.filter_text.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.max_servers {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGMSServerQuery {
        CMsgClientGMSServerQuery::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.geo_location_ip = ::std::option::Option::None;
        self.region_code = ::std::option::Option::None;
        self.filter_text = ::std::option::Option::None;
        self.max_servers = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGMSServerQuery {
        static instance: CMsgClientGMSServerQuery = CMsgClientGMSServerQuery {
            app_id: ::std::option::Option::None,
            geo_location_ip: ::std::option::Option::None,
            region_code: ::std::option::Option::None,
            filter_text: ::std::option::Option::None,
            max_servers: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGMSClientServerQueryResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGMSClientServerQueryResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.servers)
    pub servers: ::std::vec::Vec<cmsg_gmsclient_server_query_response::Server>,
    // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.error)
    pub error: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.default_server_data)
    pub default_server_data: ::protobuf::MessageField<cmsg_gmsclient_server_query_response::Server>,
    // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.server_strings)
    pub server_strings: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGMSClientServerQueryResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGMSClientServerQueryResponse {
    fn default() -> &'a CMsgGMSClientServerQueryResponse {
        <CMsgGMSClientServerQueryResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGMSClientServerQueryResponse {
    pub fn new() -> CMsgGMSClientServerQueryResponse {
        ::std::default::Default::default()
    }

    // optional string error = 2;

    pub fn error(&self) -> &str {
        match self.error.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        if self.error.is_none() {
            self.error = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        self.error.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgGMSClientServerQueryResponse {
    const NAME: &'static str = "CMsgGMSClientServerQueryResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.servers.push(is.read_message()?);
                },
                18 => {
                    self.error = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.default_server_data)?;
                },
                34 => {
                    self.server_strings.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.servers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.error.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.default_server_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.server_strings {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.servers {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.error.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.default_server_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.server_strings {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGMSClientServerQueryResponse {
        CMsgGMSClientServerQueryResponse::new()
    }

    fn clear(&mut self) {
        self.servers.clear();
        self.error = ::std::option::Option::None;
        self.default_server_data.clear();
        self.server_strings.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGMSClientServerQueryResponse {
        static instance: CMsgGMSClientServerQueryResponse = CMsgGMSClientServerQueryResponse {
            servers: ::std::vec::Vec::new(),
            error: ::std::option::Option::None,
            default_server_data: ::protobuf::MessageField::none(),
            server_strings: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGMSClientServerQueryResponse`
pub mod cmsg_gmsclient_server_query_response {
    // @@protoc_insertion_point(message:CMsgGMSClientServerQueryResponse.Server)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Server {
        // message fields
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.deprecated_server_ip)
        pub deprecated_server_ip: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.query_port)
        pub query_port: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.auth_players)
        pub auth_players: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.server_ip)
        pub server_ip: ::protobuf::MessageField<super::super::steammessages_base::CMsgIPAddress>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.steam_id)
        pub steam_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.revision)
        pub revision: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.players)
        pub players: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.game_port)
        pub game_port: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.sdr_popid)
        pub sdr_popid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.sdr_ping_location)
        pub sdr_ping_location: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.flags)
        pub flags: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.app_id)
        pub app_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.max_players)
        pub max_players: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.bots)
        pub bots: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.spectator_port)
        pub spectator_port: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.gamedir_str)
        pub gamedir_str: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.gamedir_strindex)
        pub gamedir_strindex: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.map_str)
        pub map_str: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.map_strindex)
        pub map_strindex: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.name_str)
        pub name_str: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.name_strindex)
        pub name_strindex: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.game_description_str)
        pub game_description_str: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.game_description_strindex)
        pub game_description_strindex: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.version_str)
        pub version_str: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.version_strindex)
        pub version_strindex: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.gametype_str)
        pub gametype_str: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.gametype_strindex)
        pub gametype_strindex: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.spectator_name_str)
        pub spectator_name_str: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.spectator_name_strindex)
        pub spectator_name_strindex: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGMSClientServerQueryResponse.Server.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Server {
        fn default() -> &'a Server {
            <Server as ::protobuf::Message>::default_instance()
        }
    }

    impl Server {
        pub fn new() -> Server {
            ::std::default::Default::default()
        }

        // optional uint32 deprecated_server_ip = 1;

        pub fn deprecated_server_ip(&self) -> u32 {
            self.deprecated_server_ip.unwrap_or(0)
        }

        pub fn clear_deprecated_server_ip(&mut self) {
            self.deprecated_server_ip = ::std::option::Option::None;
        }

        pub fn has_deprecated_server_ip(&self) -> bool {
            self.deprecated_server_ip.is_some()
        }

        // Param is passed by value, moved
        pub fn set_deprecated_server_ip(&mut self, v: u32) {
            self.deprecated_server_ip = ::std::option::Option::Some(v);
        }

        // optional uint32 query_port = 2;

        pub fn query_port(&self) -> u32 {
            self.query_port.unwrap_or(0)
        }

        pub fn clear_query_port(&mut self) {
            self.query_port = ::std::option::Option::None;
        }

        pub fn has_query_port(&self) -> bool {
            self.query_port.is_some()
        }

        // Param is passed by value, moved
        pub fn set_query_port(&mut self, v: u32) {
            self.query_port = ::std::option::Option::Some(v);
        }

        // optional uint32 auth_players = 3;

        pub fn auth_players(&self) -> u32 {
            self.auth_players.unwrap_or(0)
        }

        pub fn clear_auth_players(&mut self) {
            self.auth_players = ::std::option::Option::None;
        }

        pub fn has_auth_players(&self) -> bool {
            self.auth_players.is_some()
        }

        // Param is passed by value, moved
        pub fn set_auth_players(&mut self, v: u32) {
            self.auth_players = ::std::option::Option::Some(v);
        }

        // optional fixed64 steam_id = 6;

        pub fn steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }

        // optional uint32 revision = 7;

        pub fn revision(&self) -> u32 {
            self.revision.unwrap_or(0)
        }

        pub fn clear_revision(&mut self) {
            self.revision = ::std::option::Option::None;
        }

        pub fn has_revision(&self) -> bool {
            self.revision.is_some()
        }

        // Param is passed by value, moved
        pub fn set_revision(&mut self, v: u32) {
            self.revision = ::std::option::Option::Some(v);
        }

        // optional uint32 players = 8;

        pub fn players(&self) -> u32 {
            self.players.unwrap_or(0)
        }

        pub fn clear_players(&mut self) {
            self.players = ::std::option::Option::None;
        }

        pub fn has_players(&self) -> bool {
            self.players.is_some()
        }

        // Param is passed by value, moved
        pub fn set_players(&mut self, v: u32) {
            self.players = ::std::option::Option::Some(v);
        }

        // optional uint32 game_port = 9;

        pub fn game_port(&self) -> u32 {
            self.game_port.unwrap_or(0)
        }

        pub fn clear_game_port(&mut self) {
            self.game_port = ::std::option::Option::None;
        }

        pub fn has_game_port(&self) -> bool {
            self.game_port.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_port(&mut self, v: u32) {
            self.game_port = ::std::option::Option::Some(v);
        }

        // optional fixed32 sdr_popid = 10;

        pub fn sdr_popid(&self) -> u32 {
            self.sdr_popid.unwrap_or(0)
        }

        pub fn clear_sdr_popid(&mut self) {
            self.sdr_popid = ::std::option::Option::None;
        }

        pub fn has_sdr_popid(&self) -> bool {
            self.sdr_popid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sdr_popid(&mut self, v: u32) {
            self.sdr_popid = ::std::option::Option::Some(v);
        }

        // optional string sdr_ping_location = 32;

        pub fn sdr_ping_location(&self) -> &str {
            match self.sdr_ping_location.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_sdr_ping_location(&mut self) {
            self.sdr_ping_location = ::std::option::Option::None;
        }

        pub fn has_sdr_ping_location(&self) -> bool {
            self.sdr_ping_location.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sdr_ping_location(&mut self, v: ::std::string::String) {
            self.sdr_ping_location = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_sdr_ping_location(&mut self) -> &mut ::std::string::String {
            if self.sdr_ping_location.is_none() {
                self.sdr_ping_location = ::std::option::Option::Some(::std::string::String::new());
            }
            self.sdr_ping_location.as_mut().unwrap()
        }

        // Take field
        pub fn take_sdr_ping_location(&mut self) -> ::std::string::String {
            self.sdr_ping_location.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 flags = 11;

        pub fn flags(&self) -> u32 {
            self.flags.unwrap_or(0)
        }

        pub fn clear_flags(&mut self) {
            self.flags = ::std::option::Option::None;
        }

        pub fn has_flags(&self) -> bool {
            self.flags.is_some()
        }

        // Param is passed by value, moved
        pub fn set_flags(&mut self, v: u32) {
            self.flags = ::std::option::Option::Some(v);
        }

        // optional uint32 app_id = 12;

        pub fn app_id(&self) -> u32 {
            self.app_id.unwrap_or(0)
        }

        pub fn clear_app_id(&mut self) {
            self.app_id = ::std::option::Option::None;
        }

        pub fn has_app_id(&self) -> bool {
            self.app_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_app_id(&mut self, v: u32) {
            self.app_id = ::std::option::Option::Some(v);
        }

        // optional uint32 max_players = 13;

        pub fn max_players(&self) -> u32 {
            self.max_players.unwrap_or(0)
        }

        pub fn clear_max_players(&mut self) {
            self.max_players = ::std::option::Option::None;
        }

        pub fn has_max_players(&self) -> bool {
            self.max_players.is_some()
        }

        // Param is passed by value, moved
        pub fn set_max_players(&mut self, v: u32) {
            self.max_players = ::std::option::Option::Some(v);
        }

        // optional uint32 bots = 14;

        pub fn bots(&self) -> u32 {
            self.bots.unwrap_or(0)
        }

        pub fn clear_bots(&mut self) {
            self.bots = ::std::option::Option::None;
        }

        pub fn has_bots(&self) -> bool {
            self.bots.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bots(&mut self, v: u32) {
            self.bots = ::std::option::Option::Some(v);
        }

        // optional uint32 spectator_port = 15;

        pub fn spectator_port(&self) -> u32 {
            self.spectator_port.unwrap_or(0)
        }

        pub fn clear_spectator_port(&mut self) {
            self.spectator_port = ::std::option::Option::None;
        }

        pub fn has_spectator_port(&self) -> bool {
            self.spectator_port.is_some()
        }

        // Param is passed by value, moved
        pub fn set_spectator_port(&mut self, v: u32) {
            self.spectator_port = ::std::option::Option::Some(v);
        }

        // optional string gamedir_str = 16;

        pub fn gamedir_str(&self) -> &str {
            match self.gamedir_str.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_gamedir_str(&mut self) {
            self.gamedir_str = ::std::option::Option::None;
        }

        pub fn has_gamedir_str(&self) -> bool {
            self.gamedir_str.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gamedir_str(&mut self, v: ::std::string::String) {
            self.gamedir_str = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_gamedir_str(&mut self) -> &mut ::std::string::String {
            if self.gamedir_str.is_none() {
                self.gamedir_str = ::std::option::Option::Some(::std::string::String::new());
            }
            self.gamedir_str.as_mut().unwrap()
        }

        // Take field
        pub fn take_gamedir_str(&mut self) -> ::std::string::String {
            self.gamedir_str.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 gamedir_strindex = 17;

        pub fn gamedir_strindex(&self) -> u32 {
            self.gamedir_strindex.unwrap_or(0)
        }

        pub fn clear_gamedir_strindex(&mut self) {
            self.gamedir_strindex = ::std::option::Option::None;
        }

        pub fn has_gamedir_strindex(&self) -> bool {
            self.gamedir_strindex.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gamedir_strindex(&mut self, v: u32) {
            self.gamedir_strindex = ::std::option::Option::Some(v);
        }

        // optional string map_str = 18;

        pub fn map_str(&self) -> &str {
            match self.map_str.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_map_str(&mut self) {
            self.map_str = ::std::option::Option::None;
        }

        pub fn has_map_str(&self) -> bool {
            self.map_str.is_some()
        }

        // Param is passed by value, moved
        pub fn set_map_str(&mut self, v: ::std::string::String) {
            self.map_str = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_map_str(&mut self) -> &mut ::std::string::String {
            if self.map_str.is_none() {
                self.map_str = ::std::option::Option::Some(::std::string::String::new());
            }
            self.map_str.as_mut().unwrap()
        }

        // Take field
        pub fn take_map_str(&mut self) -> ::std::string::String {
            self.map_str.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 map_strindex = 19;

        pub fn map_strindex(&self) -> u32 {
            self.map_strindex.unwrap_or(0)
        }

        pub fn clear_map_strindex(&mut self) {
            self.map_strindex = ::std::option::Option::None;
        }

        pub fn has_map_strindex(&self) -> bool {
            self.map_strindex.is_some()
        }

        // Param is passed by value, moved
        pub fn set_map_strindex(&mut self, v: u32) {
            self.map_strindex = ::std::option::Option::Some(v);
        }

        // optional string name_str = 20;

        pub fn name_str(&self) -> &str {
            match self.name_str.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name_str(&mut self) {
            self.name_str = ::std::option::Option::None;
        }

        pub fn has_name_str(&self) -> bool {
            self.name_str.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name_str(&mut self, v: ::std::string::String) {
            self.name_str = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name_str(&mut self) -> &mut ::std::string::String {
            if self.name_str.is_none() {
                self.name_str = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name_str.as_mut().unwrap()
        }

        // Take field
        pub fn take_name_str(&mut self) -> ::std::string::String {
            self.name_str.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 name_strindex = 21;

        pub fn name_strindex(&self) -> u32 {
            self.name_strindex.unwrap_or(0)
        }

        pub fn clear_name_strindex(&mut self) {
            self.name_strindex = ::std::option::Option::None;
        }

        pub fn has_name_strindex(&self) -> bool {
            self.name_strindex.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name_strindex(&mut self, v: u32) {
            self.name_strindex = ::std::option::Option::Some(v);
        }

        // optional string game_description_str = 22;

        pub fn game_description_str(&self) -> &str {
            match self.game_description_str.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_game_description_str(&mut self) {
            self.game_description_str = ::std::option::Option::None;
        }

        pub fn has_game_description_str(&self) -> bool {
            self.game_description_str.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_description_str(&mut self, v: ::std::string::String) {
            self.game_description_str = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_game_description_str(&mut self) -> &mut ::std::string::String {
            if self.game_description_str.is_none() {
                self.game_description_str = ::std::option::Option::Some(::std::string::String::new());
            }
            self.game_description_str.as_mut().unwrap()
        }

        // Take field
        pub fn take_game_description_str(&mut self) -> ::std::string::String {
            self.game_description_str.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 game_description_strindex = 23;

        pub fn game_description_strindex(&self) -> u32 {
            self.game_description_strindex.unwrap_or(0)
        }

        pub fn clear_game_description_strindex(&mut self) {
            self.game_description_strindex = ::std::option::Option::None;
        }

        pub fn has_game_description_strindex(&self) -> bool {
            self.game_description_strindex.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_description_strindex(&mut self, v: u32) {
            self.game_description_strindex = ::std::option::Option::Some(v);
        }

        // optional string version_str = 24;

        pub fn version_str(&self) -> &str {
            match self.version_str.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_version_str(&mut self) {
            self.version_str = ::std::option::Option::None;
        }

        pub fn has_version_str(&self) -> bool {
            self.version_str.is_some()
        }

        // Param is passed by value, moved
        pub fn set_version_str(&mut self, v: ::std::string::String) {
            self.version_str = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_version_str(&mut self) -> &mut ::std::string::String {
            if self.version_str.is_none() {
                self.version_str = ::std::option::Option::Some(::std::string::String::new());
            }
            self.version_str.as_mut().unwrap()
        }

        // Take field
        pub fn take_version_str(&mut self) -> ::std::string::String {
            self.version_str.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 version_strindex = 25;

        pub fn version_strindex(&self) -> u32 {
            self.version_strindex.unwrap_or(0)
        }

        pub fn clear_version_strindex(&mut self) {
            self.version_strindex = ::std::option::Option::None;
        }

        pub fn has_version_strindex(&self) -> bool {
            self.version_strindex.is_some()
        }

        // Param is passed by value, moved
        pub fn set_version_strindex(&mut self, v: u32) {
            self.version_strindex = ::std::option::Option::Some(v);
        }

        // optional string gametype_str = 26;

        pub fn gametype_str(&self) -> &str {
            match self.gametype_str.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_gametype_str(&mut self) {
            self.gametype_str = ::std::option::Option::None;
        }

        pub fn has_gametype_str(&self) -> bool {
            self.gametype_str.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gametype_str(&mut self, v: ::std::string::String) {
            self.gametype_str = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_gametype_str(&mut self) -> &mut ::std::string::String {
            if self.gametype_str.is_none() {
                self.gametype_str = ::std::option::Option::Some(::std::string::String::new());
            }
            self.gametype_str.as_mut().unwrap()
        }

        // Take field
        pub fn take_gametype_str(&mut self) -> ::std::string::String {
            self.gametype_str.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 gametype_strindex = 27;

        pub fn gametype_strindex(&self) -> u32 {
            self.gametype_strindex.unwrap_or(0)
        }

        pub fn clear_gametype_strindex(&mut self) {
            self.gametype_strindex = ::std::option::Option::None;
        }

        pub fn has_gametype_strindex(&self) -> bool {
            self.gametype_strindex.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gametype_strindex(&mut self, v: u32) {
            self.gametype_strindex = ::std::option::Option::Some(v);
        }

        // optional string spectator_name_str = 30;

        pub fn spectator_name_str(&self) -> &str {
            match self.spectator_name_str.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_spectator_name_str(&mut self) {
            self.spectator_name_str = ::std::option::Option::None;
        }

        pub fn has_spectator_name_str(&self) -> bool {
            self.spectator_name_str.is_some()
        }

        // Param is passed by value, moved
        pub fn set_spectator_name_str(&mut self, v: ::std::string::String) {
            self.spectator_name_str = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_spectator_name_str(&mut self) -> &mut ::std::string::String {
            if self.spectator_name_str.is_none() {
                self.spectator_name_str = ::std::option::Option::Some(::std::string::String::new());
            }
            self.spectator_name_str.as_mut().unwrap()
        }

        // Take field
        pub fn take_spectator_name_str(&mut self) -> ::std::string::String {
            self.spectator_name_str.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 spectator_name_strindex = 31;

        pub fn spectator_name_strindex(&self) -> u32 {
            self.spectator_name_strindex.unwrap_or(0)
        }

        pub fn clear_spectator_name_strindex(&mut self) {
            self.spectator_name_strindex = ::std::option::Option::None;
        }

        pub fn has_spectator_name_strindex(&self) -> bool {
            self.spectator_name_strindex.is_some()
        }

        // Param is passed by value, moved
        pub fn set_spectator_name_strindex(&mut self, v: u32) {
            self.spectator_name_strindex = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Server {
        const NAME: &'static str = "Server";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.deprecated_server_ip = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.query_port = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.auth_players = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    34 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.server_ip)?;
                    },
                    49 => {
                        self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    56 => {
                        self.revision = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.players = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    72 => {
                        self.game_port = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    85 => {
                        self.sdr_popid = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    258 => {
                        self.sdr_ping_location = ::std::option::Option::Some(is.read_string()?);
                    },
                    88 => {
                        self.flags = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    96 => {
                        self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    104 => {
                        self.max_players = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    112 => {
                        self.bots = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    120 => {
                        self.spectator_port = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    130 => {
                        self.gamedir_str = ::std::option::Option::Some(is.read_string()?);
                    },
                    136 => {
                        self.gamedir_strindex = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    146 => {
                        self.map_str = ::std::option::Option::Some(is.read_string()?);
                    },
                    152 => {
                        self.map_strindex = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    162 => {
                        self.name_str = ::std::option::Option::Some(is.read_string()?);
                    },
                    168 => {
                        self.name_strindex = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    178 => {
                        self.game_description_str = ::std::option::Option::Some(is.read_string()?);
                    },
                    184 => {
                        self.game_description_strindex = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    194 => {
                        self.version_str = ::std::option::Option::Some(is.read_string()?);
                    },
                    200 => {
                        self.version_strindex = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    210 => {
                        self.gametype_str = ::std::option::Option::Some(is.read_string()?);
                    },
                    216 => {
                        self.gametype_strindex = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    242 => {
                        self.spectator_name_str = ::std::option::Option::Some(is.read_string()?);
                    },
                    248 => {
                        self.spectator_name_strindex = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.deprecated_server_ip {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.query_port {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.auth_players {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.server_ip.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.steam_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.revision {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.players {
                my_size += ::protobuf::rt::uint32_size(8, v);
            }
            if let Some(v) = self.game_port {
                my_size += ::protobuf::rt::uint32_size(9, v);
            }
            if let Some(v) = self.sdr_popid {
                my_size += 1 + 4;
            }
            if let Some(v) = self.sdr_ping_location.as_ref() {
                my_size += ::protobuf::rt::string_size(32, &v);
            }
            if let Some(v) = self.flags {
                my_size += ::protobuf::rt::uint32_size(11, v);
            }
            if let Some(v) = self.app_id {
                my_size += ::protobuf::rt::uint32_size(12, v);
            }
            if let Some(v) = self.max_players {
                my_size += ::protobuf::rt::uint32_size(13, v);
            }
            if let Some(v) = self.bots {
                my_size += ::protobuf::rt::uint32_size(14, v);
            }
            if let Some(v) = self.spectator_port {
                my_size += ::protobuf::rt::uint32_size(15, v);
            }
            if let Some(v) = self.gamedir_str.as_ref() {
                my_size += ::protobuf::rt::string_size(16, &v);
            }
            if let Some(v) = self.gamedir_strindex {
                my_size += ::protobuf::rt::uint32_size(17, v);
            }
            if let Some(v) = self.map_str.as_ref() {
                my_size += ::protobuf::rt::string_size(18, &v);
            }
            if let Some(v) = self.map_strindex {
                my_size += ::protobuf::rt::uint32_size(19, v);
            }
            if let Some(v) = self.name_str.as_ref() {
                my_size += ::protobuf::rt::string_size(20, &v);
            }
            if let Some(v) = self.name_strindex {
                my_size += ::protobuf::rt::uint32_size(21, v);
            }
            if let Some(v) = self.game_description_str.as_ref() {
                my_size += ::protobuf::rt::string_size(22, &v);
            }
            if let Some(v) = self.game_description_strindex {
                my_size += ::protobuf::rt::uint32_size(23, v);
            }
            if let Some(v) = self.version_str.as_ref() {
                my_size += ::protobuf::rt::string_size(24, &v);
            }
            if let Some(v) = self.version_strindex {
                my_size += ::protobuf::rt::uint32_size(25, v);
            }
            if let Some(v) = self.gametype_str.as_ref() {
                my_size += ::protobuf::rt::string_size(26, &v);
            }
            if let Some(v) = self.gametype_strindex {
                my_size += ::protobuf::rt::uint32_size(27, v);
            }
            if let Some(v) = self.spectator_name_str.as_ref() {
                my_size += ::protobuf::rt::string_size(30, &v);
            }
            if let Some(v) = self.spectator_name_strindex {
                my_size += ::protobuf::rt::uint32_size(31, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.deprecated_server_ip {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.query_port {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.auth_players {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.server_ip.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            }
            if let Some(v) = self.steam_id {
                os.write_fixed64(6, v)?;
            }
            if let Some(v) = self.revision {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.players {
                os.write_uint32(8, v)?;
            }
            if let Some(v) = self.game_port {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.sdr_popid {
                os.write_fixed32(10, v)?;
            }
            if let Some(v) = self.sdr_ping_location.as_ref() {
                os.write_string(32, v)?;
            }
            if let Some(v) = self.flags {
                os.write_uint32(11, v)?;
            }
            if let Some(v) = self.app_id {
                os.write_uint32(12, v)?;
            }
            if let Some(v) = self.max_players {
                os.write_uint32(13, v)?;
            }
            if let Some(v) = self.bots {
                os.write_uint32(14, v)?;
            }
            if let Some(v) = self.spectator_port {
                os.write_uint32(15, v)?;
            }
            if let Some(v) = self.gamedir_str.as_ref() {
                os.write_string(16, v)?;
            }
            if let Some(v) = self.gamedir_strindex {
                os.write_uint32(17, v)?;
            }
            if let Some(v) = self.map_str.as_ref() {
                os.write_string(18, v)?;
            }
            if let Some(v) = self.map_strindex {
                os.write_uint32(19, v)?;
            }
            if let Some(v) = self.name_str.as_ref() {
                os.write_string(20, v)?;
            }
            if let Some(v) = self.name_strindex {
                os.write_uint32(21, v)?;
            }
            if let Some(v) = self.game_description_str.as_ref() {
                os.write_string(22, v)?;
            }
            if let Some(v) = self.game_description_strindex {
                os.write_uint32(23, v)?;
            }
            if let Some(v) = self.version_str.as_ref() {
                os.write_string(24, v)?;
            }
            if let Some(v) = self.version_strindex {
                os.write_uint32(25, v)?;
            }
            if let Some(v) = self.gametype_str.as_ref() {
                os.write_string(26, v)?;
            }
            if let Some(v) = self.gametype_strindex {
                os.write_uint32(27, v)?;
            }
            if let Some(v) = self.spectator_name_str.as_ref() {
                os.write_string(30, v)?;
            }
            if let Some(v) = self.spectator_name_strindex {
                os.write_uint32(31, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Server {
            Server::new()
        }

        fn clear(&mut self) {
            self.deprecated_server_ip = ::std::option::Option::None;
            self.query_port = ::std::option::Option::None;
            self.auth_players = ::std::option::Option::None;
            self.server_ip.clear();
            self.steam_id = ::std::option::Option::None;
            self.revision = ::std::option::Option::None;
            self.players = ::std::option::Option::None;
            self.game_port = ::std::option::Option::None;
            self.sdr_popid = ::std::option::Option::None;
            self.sdr_ping_location = ::std::option::Option::None;
            self.flags = ::std::option::Option::None;
            self.app_id = ::std::option::Option::None;
            self.max_players = ::std::option::Option::None;
            self.bots = ::std::option::Option::None;
            self.spectator_port = ::std::option::Option::None;
            self.gamedir_str = ::std::option::Option::None;
            self.gamedir_strindex = ::std::option::Option::None;
            self.map_str = ::std::option::Option::None;
            self.map_strindex = ::std::option::Option::None;
            self.name_str = ::std::option::Option::None;
            self.name_strindex = ::std::option::Option::None;
            self.game_description_str = ::std::option::Option::None;
            self.game_description_strindex = ::std::option::Option::None;
            self.version_str = ::std::option::Option::None;
            self.version_strindex = ::std::option::Option::None;
            self.gametype_str = ::std::option::Option::None;
            self.gametype_strindex = ::std::option::Option::None;
            self.spectator_name_str = ::std::option::Option::None;
            self.spectator_name_strindex = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Server {
            static instance: Server = Server {
                deprecated_server_ip: ::std::option::Option::None,
                query_port: ::std::option::Option::None,
                auth_players: ::std::option::Option::None,
                server_ip: ::protobuf::MessageField::none(),
                steam_id: ::std::option::Option::None,
                revision: ::std::option::Option::None,
                players: ::std::option::Option::None,
                game_port: ::std::option::Option::None,
                sdr_popid: ::std::option::Option::None,
                sdr_ping_location: ::std::option::Option::None,
                flags: ::std::option::Option::None,
                app_id: ::std::option::Option::None,
                max_players: ::std::option::Option::None,
                bots: ::std::option::Option::None,
                spectator_port: ::std::option::Option::None,
                gamedir_str: ::std::option::Option::None,
                gamedir_strindex: ::std::option::Option::None,
                map_str: ::std::option::Option::None,
                map_strindex: ::std::option::Option::None,
                name_str: ::std::option::Option::None,
                name_strindex: ::std::option::Option::None,
                game_description_str: ::std::option::Option::None,
                game_description_strindex: ::std::option::Option::None,
                version_str: ::std::option::Option::None,
                version_strindex: ::std::option::Option::None,
                gametype_str: ::std::option::Option::None,
                gametype_strindex: ::std::option::Option::None,
                spectator_name_str: ::std::option::Option::None,
                spectator_name_strindex: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgGMSClientServerQueryResponse.EFlags)
    pub enum EFlags {
        // @@protoc_insertion_point(enum_value:CMsgGMSClientServerQueryResponse.EFlags.k_EFlag_HasPassword)
        k_EFlag_HasPassword = 1,
        // @@protoc_insertion_point(enum_value:CMsgGMSClientServerQueryResponse.EFlags.k_EFlag_Secure)
        k_EFlag_Secure = 2,
    }

    impl ::protobuf::Enum for EFlags {
        const NAME: &'static str = "EFlags";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EFlags> {
            match value {
                1 => ::std::option::Option::Some(EFlags::k_EFlag_HasPassword),
                2 => ::std::option::Option::Some(EFlags::k_EFlag_Secure),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EFlags> {
            match str {
                "k_EFlag_HasPassword" => ::std::option::Option::Some(EFlags::k_EFlag_HasPassword),
                "k_EFlag_Secure" => ::std::option::Option::Some(EFlags::k_EFlag_Secure),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EFlags] = &[
            EFlags::k_EFlag_HasPassword,
            EFlags::k_EFlag_Secure,
        ];
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for EFlags {
        fn default() -> Self {
            EFlags::k_EFlag_HasPassword
        }
    }

}

// @@protoc_insertion_point(message:CMsgGameServerOutOfDate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameServerOutOfDate {
    // message fields
    // @@protoc_insertion_point(field:CMsgGameServerOutOfDate.steam_id_gs)
    pub steam_id_gs: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGameServerOutOfDate.reject)
    pub reject: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGameServerOutOfDate.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGameServerOutOfDate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameServerOutOfDate {
    fn default() -> &'a CMsgGameServerOutOfDate {
        <CMsgGameServerOutOfDate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameServerOutOfDate {
    pub fn new() -> CMsgGameServerOutOfDate {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id_gs = 1;

    pub fn steam_id_gs(&self) -> u64 {
        self.steam_id_gs.unwrap_or(0)
    }

    pub fn clear_steam_id_gs(&mut self) {
        self.steam_id_gs = ::std::option::Option::None;
    }

    pub fn has_steam_id_gs(&self) -> bool {
        self.steam_id_gs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_gs(&mut self, v: u64) {
        self.steam_id_gs = ::std::option::Option::Some(v);
    }

    // optional bool reject = 2;

    pub fn reject(&self) -> bool {
        self.reject.unwrap_or(false)
    }

    pub fn clear_reject(&mut self) {
        self.reject = ::std::option::Option::None;
    }

    pub fn has_reject(&self) -> bool {
        self.reject.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reject(&mut self, v: bool) {
        self.reject = ::std::option::Option::Some(v);
    }

    // optional string message = 3;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgGameServerOutOfDate {
    const NAME: &'static str = "CMsgGameServerOutOfDate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id_gs = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.reject = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_gs {
            my_size += 1 + 8;
        }
        if let Some(v) = self.reject {
            my_size += 1 + 1;
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steam_id_gs {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.reject {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameServerOutOfDate {
        CMsgGameServerOutOfDate::new()
    }

    fn clear(&mut self) {
        self.steam_id_gs = ::std::option::Option::None;
        self.reject = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameServerOutOfDate {
        static instance: CMsgGameServerOutOfDate = CMsgGameServerOutOfDate {
            steam_id_gs: ::std::option::Option::None,
            reject: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGSAssociateWithClan)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGSAssociateWithClan {
    // message fields
    // @@protoc_insertion_point(field:CMsgGSAssociateWithClan.steam_id_clan)
    pub steam_id_clan: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGSAssociateWithClan.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGSAssociateWithClan {
    fn default() -> &'a CMsgGSAssociateWithClan {
        <CMsgGSAssociateWithClan as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSAssociateWithClan {
    pub fn new() -> CMsgGSAssociateWithClan {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id_clan = 1;

    pub fn steam_id_clan(&self) -> u64 {
        self.steam_id_clan.unwrap_or(0)
    }

    pub fn clear_steam_id_clan(&mut self) {
        self.steam_id_clan = ::std::option::Option::None;
    }

    pub fn has_steam_id_clan(&self) -> bool {
        self.steam_id_clan.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_clan(&mut self, v: u64) {
        self.steam_id_clan = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGSAssociateWithClan {
    const NAME: &'static str = "CMsgGSAssociateWithClan";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id_clan = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_clan {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steam_id_clan {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGSAssociateWithClan {
        CMsgGSAssociateWithClan::new()
    }

    fn clear(&mut self) {
        self.steam_id_clan = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGSAssociateWithClan {
        static instance: CMsgGSAssociateWithClan = CMsgGSAssociateWithClan {
            steam_id_clan: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGSAssociateWithClanResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGSAssociateWithClanResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGSAssociateWithClanResponse.steam_id_clan)
    pub steam_id_clan: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGSAssociateWithClanResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGSAssociateWithClanResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGSAssociateWithClanResponse {
    fn default() -> &'a CMsgGSAssociateWithClanResponse {
        <CMsgGSAssociateWithClanResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSAssociateWithClanResponse {
    pub fn new() -> CMsgGSAssociateWithClanResponse {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id_clan = 1;

    pub fn steam_id_clan(&self) -> u64 {
        self.steam_id_clan.unwrap_or(0)
    }

    pub fn clear_steam_id_clan(&mut self) {
        self.steam_id_clan = ::std::option::Option::None;
    }

    pub fn has_steam_id_clan(&self) -> bool {
        self.steam_id_clan.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_clan(&mut self, v: u64) {
        self.steam_id_clan = ::std::option::Option::Some(v);
    }

    // optional uint32 eresult = 2;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGSAssociateWithClanResponse {
    const NAME: &'static str = "CMsgGSAssociateWithClanResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id_clan = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_clan {
            my_size += 1 + 8;
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steam_id_clan {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGSAssociateWithClanResponse {
        CMsgGSAssociateWithClanResponse::new()
    }

    fn clear(&mut self) {
        self.steam_id_clan = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGSAssociateWithClanResponse {
        static instance: CMsgGSAssociateWithClanResponse = CMsgGSAssociateWithClanResponse {
            steam_id_clan: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGSComputeNewPlayerCompatibility)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGSComputeNewPlayerCompatibility {
    // message fields
    // @@protoc_insertion_point(field:CMsgGSComputeNewPlayerCompatibility.steam_id_candidate)
    pub steam_id_candidate: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGSComputeNewPlayerCompatibility.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGSComputeNewPlayerCompatibility {
    fn default() -> &'a CMsgGSComputeNewPlayerCompatibility {
        <CMsgGSComputeNewPlayerCompatibility as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSComputeNewPlayerCompatibility {
    pub fn new() -> CMsgGSComputeNewPlayerCompatibility {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id_candidate = 1;

    pub fn steam_id_candidate(&self) -> u64 {
        self.steam_id_candidate.unwrap_or(0)
    }

    pub fn clear_steam_id_candidate(&mut self) {
        self.steam_id_candidate = ::std::option::Option::None;
    }

    pub fn has_steam_id_candidate(&self) -> bool {
        self.steam_id_candidate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_candidate(&mut self, v: u64) {
        self.steam_id_candidate = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGSComputeNewPlayerCompatibility {
    const NAME: &'static str = "CMsgGSComputeNewPlayerCompatibility";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id_candidate = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_candidate {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steam_id_candidate {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGSComputeNewPlayerCompatibility {
        CMsgGSComputeNewPlayerCompatibility::new()
    }

    fn clear(&mut self) {
        self.steam_id_candidate = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGSComputeNewPlayerCompatibility {
        static instance: CMsgGSComputeNewPlayerCompatibility = CMsgGSComputeNewPlayerCompatibility {
            steam_id_candidate: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGSComputeNewPlayerCompatibilityResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGSComputeNewPlayerCompatibilityResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGSComputeNewPlayerCompatibilityResponse.steam_id_candidate)
    pub steam_id_candidate: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGSComputeNewPlayerCompatibilityResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGSComputeNewPlayerCompatibilityResponse.is_clan_member)
    pub is_clan_member: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGSComputeNewPlayerCompatibilityResponse.ct_dont_like_you)
    pub ct_dont_like_you: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGSComputeNewPlayerCompatibilityResponse.ct_you_dont_like)
    pub ct_you_dont_like: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGSComputeNewPlayerCompatibilityResponse.ct_clanmembers_dont_like_you)
    pub ct_clanmembers_dont_like_you: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGSComputeNewPlayerCompatibilityResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGSComputeNewPlayerCompatibilityResponse {
    fn default() -> &'a CMsgGSComputeNewPlayerCompatibilityResponse {
        <CMsgGSComputeNewPlayerCompatibilityResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSComputeNewPlayerCompatibilityResponse {
    pub fn new() -> CMsgGSComputeNewPlayerCompatibilityResponse {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id_candidate = 1;

    pub fn steam_id_candidate(&self) -> u64 {
        self.steam_id_candidate.unwrap_or(0)
    }

    pub fn clear_steam_id_candidate(&mut self) {
        self.steam_id_candidate = ::std::option::Option::None;
    }

    pub fn has_steam_id_candidate(&self) -> bool {
        self.steam_id_candidate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_candidate(&mut self, v: u64) {
        self.steam_id_candidate = ::std::option::Option::Some(v);
    }

    // optional uint32 eresult = 2;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional bool is_clan_member = 3;

    pub fn is_clan_member(&self) -> bool {
        self.is_clan_member.unwrap_or(false)
    }

    pub fn clear_is_clan_member(&mut self) {
        self.is_clan_member = ::std::option::Option::None;
    }

    pub fn has_is_clan_member(&self) -> bool {
        self.is_clan_member.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_clan_member(&mut self, v: bool) {
        self.is_clan_member = ::std::option::Option::Some(v);
    }

    // optional int32 ct_dont_like_you = 4;

    pub fn ct_dont_like_you(&self) -> i32 {
        self.ct_dont_like_you.unwrap_or(0)
    }

    pub fn clear_ct_dont_like_you(&mut self) {
        self.ct_dont_like_you = ::std::option::Option::None;
    }

    pub fn has_ct_dont_like_you(&self) -> bool {
        self.ct_dont_like_you.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ct_dont_like_you(&mut self, v: i32) {
        self.ct_dont_like_you = ::std::option::Option::Some(v);
    }

    // optional int32 ct_you_dont_like = 5;

    pub fn ct_you_dont_like(&self) -> i32 {
        self.ct_you_dont_like.unwrap_or(0)
    }

    pub fn clear_ct_you_dont_like(&mut self) {
        self.ct_you_dont_like = ::std::option::Option::None;
    }

    pub fn has_ct_you_dont_like(&self) -> bool {
        self.ct_you_dont_like.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ct_you_dont_like(&mut self, v: i32) {
        self.ct_you_dont_like = ::std::option::Option::Some(v);
    }

    // optional int32 ct_clanmembers_dont_like_you = 6;

    pub fn ct_clanmembers_dont_like_you(&self) -> i32 {
        self.ct_clanmembers_dont_like_you.unwrap_or(0)
    }

    pub fn clear_ct_clanmembers_dont_like_you(&mut self) {
        self.ct_clanmembers_dont_like_you = ::std::option::Option::None;
    }

    pub fn has_ct_clanmembers_dont_like_you(&self) -> bool {
        self.ct_clanmembers_dont_like_you.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ct_clanmembers_dont_like_you(&mut self, v: i32) {
        self.ct_clanmembers_dont_like_you = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGSComputeNewPlayerCompatibilityResponse {
    const NAME: &'static str = "CMsgGSComputeNewPlayerCompatibilityResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id_candidate = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.is_clan_member = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.ct_dont_like_you = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.ct_you_dont_like = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.ct_clanmembers_dont_like_you = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_candidate {
            my_size += 1 + 8;
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.is_clan_member {
            my_size += 1 + 1;
        }
        if let Some(v) = self.ct_dont_like_you {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.ct_you_dont_like {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.ct_clanmembers_dont_like_you {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steam_id_candidate {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.is_clan_member {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.ct_dont_like_you {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.ct_you_dont_like {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.ct_clanmembers_dont_like_you {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGSComputeNewPlayerCompatibilityResponse {
        CMsgGSComputeNewPlayerCompatibilityResponse::new()
    }

    fn clear(&mut self) {
        self.steam_id_candidate = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.is_clan_member = ::std::option::Option::None;
        self.ct_dont_like_you = ::std::option::Option::None;
        self.ct_you_dont_like = ::std::option::Option::None;
        self.ct_clanmembers_dont_like_you = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGSComputeNewPlayerCompatibilityResponse {
        static instance: CMsgGSComputeNewPlayerCompatibilityResponse = CMsgGSComputeNewPlayerCompatibilityResponse {
            steam_id_candidate: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            is_clan_member: ::std::option::Option::None,
            ct_dont_like_you: ::std::option::Option::None,
            ct_you_dont_like: ::std::option::Option::None,
            ct_clanmembers_dont_like_you: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}
#[allow(unused_imports)]
use crate::steammessages_base::*;
impl crate::RpcMessage for CMsgGSServerType {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgGSServerType {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgGSServerType;
}
impl crate::RpcMessage for CMsgGSStatusReply {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgGSStatusReply {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgGSStatusReply;
}
impl crate::RpcMessage for CMsgGSPlayerList {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgGSPlayerList {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgGSPlayerList;
}
impl crate::RpcMessage for CMsgGSUserPlaying {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgGSUserPlaying {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgGSUserPlaying;
}
impl crate::RpcMessage for CMsgGSDisconnectNotice {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgGSDisconnectNotice {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgGSDisconnectNotice;
}
impl crate::RpcMessage for CMsgGameServerData {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgGameServerRemove {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgClientGMSServerQuery {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientGMSServerQuery {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientGMSServerQuery;
}
impl crate::RpcMessage for CMsgGMSClientServerQueryResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgGMSClientServerQueryResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgGMSClientServerQueryResponse;
}
impl crate::RpcMessage for CMsgGameServerOutOfDate {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgGameServerOutOfDate {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgGameServerOutOfDate;
}
impl crate::RpcMessage for CMsgGSAssociateWithClan {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgGSAssociateWithClan {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgGSAssociateWithClan;
}
impl crate::RpcMessage for CMsgGSAssociateWithClanResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgGSAssociateWithClanResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgGSAssociateWithClanResponse;
}
impl crate::RpcMessage for CMsgGSComputeNewPlayerCompatibility {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgGSComputeNewPlayerCompatibility {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgGSComputeNewPlayerCompatibility;
}
impl crate::RpcMessage for CMsgGSComputeNewPlayerCompatibilityResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgGSComputeNewPlayerCompatibilityResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgGSComputeNewPlayerCompatibilityResponse;
}
