// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `htmlmessages.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:CMsgKeyUp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgKeyUp {
    // message fields
    // @@protoc_insertion_point(field:CMsgKeyUp.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgKeyUp.keyCode)
    pub keyCode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgKeyUp.modifiers)
    pub modifiers: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgKeyUp.nativeKeyCode)
    pub nativeKeyCode: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgKeyUp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgKeyUp {
    fn default() -> &'a CMsgKeyUp {
        <CMsgKeyUp as ::protobuf::Message>::default_instance()
    }
}

impl CMsgKeyUp {
    pub fn new() -> CMsgKeyUp {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 keyCode = 2;

    pub fn keyCode(&self) -> u32 {
        self.keyCode.unwrap_or(0)
    }

    pub fn clear_keyCode(&mut self) {
        self.keyCode = ::std::option::Option::None;
    }

    pub fn has_keyCode(&self) -> bool {
        self.keyCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyCode(&mut self, v: u32) {
        self.keyCode = ::std::option::Option::Some(v);
    }

    // optional uint32 modifiers = 3;

    pub fn modifiers(&self) -> u32 {
        self.modifiers.unwrap_or(0)
    }

    pub fn clear_modifiers(&mut self) {
        self.modifiers = ::std::option::Option::None;
    }

    pub fn has_modifiers(&self) -> bool {
        self.modifiers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifiers(&mut self, v: u32) {
        self.modifiers = ::std::option::Option::Some(v);
    }

    // optional uint32 nativeKeyCode = 4;

    pub fn nativeKeyCode(&self) -> u32 {
        self.nativeKeyCode.unwrap_or(0)
    }

    pub fn clear_nativeKeyCode(&mut self) {
        self.nativeKeyCode = ::std::option::Option::None;
    }

    pub fn has_nativeKeyCode(&self) -> bool {
        self.nativeKeyCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nativeKeyCode(&mut self, v: u32) {
        self.nativeKeyCode = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgKeyUp {
    const NAME: &'static str = "CMsgKeyUp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.keyCode = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.modifiers = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.nativeKeyCode = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.keyCode {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.modifiers {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.nativeKeyCode {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.keyCode {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.modifiers {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.nativeKeyCode {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgKeyUp {
        CMsgKeyUp::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.keyCode = ::std::option::Option::None;
        self.modifiers = ::std::option::Option::None;
        self.nativeKeyCode = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgKeyUp {
        static instance: CMsgKeyUp = CMsgKeyUp {
            browser_handle: ::std::option::Option::None,
            keyCode: ::std::option::Option::None,
            modifiers: ::std::option::Option::None,
            nativeKeyCode: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgKeyDown)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgKeyDown {
    // message fields
    // @@protoc_insertion_point(field:CMsgKeyDown.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgKeyDown.keyCode)
    pub keyCode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgKeyDown.modifiers)
    pub modifiers: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgKeyDown.is_system_key)
    pub is_system_key: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgKeyDown.nativeKeyCode)
    pub nativeKeyCode: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgKeyDown.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgKeyDown {
    fn default() -> &'a CMsgKeyDown {
        <CMsgKeyDown as ::protobuf::Message>::default_instance()
    }
}

impl CMsgKeyDown {
    pub fn new() -> CMsgKeyDown {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 keyCode = 2;

    pub fn keyCode(&self) -> u32 {
        self.keyCode.unwrap_or(0)
    }

    pub fn clear_keyCode(&mut self) {
        self.keyCode = ::std::option::Option::None;
    }

    pub fn has_keyCode(&self) -> bool {
        self.keyCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyCode(&mut self, v: u32) {
        self.keyCode = ::std::option::Option::Some(v);
    }

    // optional uint32 modifiers = 3;

    pub fn modifiers(&self) -> u32 {
        self.modifiers.unwrap_or(0)
    }

    pub fn clear_modifiers(&mut self) {
        self.modifiers = ::std::option::Option::None;
    }

    pub fn has_modifiers(&self) -> bool {
        self.modifiers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifiers(&mut self, v: u32) {
        self.modifiers = ::std::option::Option::Some(v);
    }

    // optional bool is_system_key = 4;

    pub fn is_system_key(&self) -> bool {
        self.is_system_key.unwrap_or(false)
    }

    pub fn clear_is_system_key(&mut self) {
        self.is_system_key = ::std::option::Option::None;
    }

    pub fn has_is_system_key(&self) -> bool {
        self.is_system_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_system_key(&mut self, v: bool) {
        self.is_system_key = ::std::option::Option::Some(v);
    }

    // optional uint32 nativeKeyCode = 5;

    pub fn nativeKeyCode(&self) -> u32 {
        self.nativeKeyCode.unwrap_or(0)
    }

    pub fn clear_nativeKeyCode(&mut self) {
        self.nativeKeyCode = ::std::option::Option::None;
    }

    pub fn has_nativeKeyCode(&self) -> bool {
        self.nativeKeyCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nativeKeyCode(&mut self, v: u32) {
        self.nativeKeyCode = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgKeyDown {
    const NAME: &'static str = "CMsgKeyDown";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.keyCode = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.modifiers = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.is_system_key = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.nativeKeyCode = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.keyCode {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.modifiers {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.is_system_key {
            my_size += 1 + 1;
        }
        if let Some(v) = self.nativeKeyCode {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.keyCode {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.modifiers {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.is_system_key {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.nativeKeyCode {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgKeyDown {
        CMsgKeyDown::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.keyCode = ::std::option::Option::None;
        self.modifiers = ::std::option::Option::None;
        self.is_system_key = ::std::option::Option::None;
        self.nativeKeyCode = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgKeyDown {
        static instance: CMsgKeyDown = CMsgKeyDown {
            browser_handle: ::std::option::Option::None,
            keyCode: ::std::option::Option::None,
            modifiers: ::std::option::Option::None,
            is_system_key: ::std::option::Option::None,
            nativeKeyCode: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgKeyChar)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgKeyChar {
    // message fields
    // @@protoc_insertion_point(field:CMsgKeyChar.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgKeyChar.unichar)
    pub unichar: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgKeyChar.modifiers)
    pub modifiers: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgKeyChar.keyCode)
    pub keyCode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgKeyChar.nativeKeyCode)
    pub nativeKeyCode: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgKeyChar.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgKeyChar {
    fn default() -> &'a CMsgKeyChar {
        <CMsgKeyChar as ::protobuf::Message>::default_instance()
    }
}

impl CMsgKeyChar {
    pub fn new() -> CMsgKeyChar {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 unichar = 2;

    pub fn unichar(&self) -> u32 {
        self.unichar.unwrap_or(0)
    }

    pub fn clear_unichar(&mut self) {
        self.unichar = ::std::option::Option::None;
    }

    pub fn has_unichar(&self) -> bool {
        self.unichar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unichar(&mut self, v: u32) {
        self.unichar = ::std::option::Option::Some(v);
    }

    // optional uint32 modifiers = 3;

    pub fn modifiers(&self) -> u32 {
        self.modifiers.unwrap_or(0)
    }

    pub fn clear_modifiers(&mut self) {
        self.modifiers = ::std::option::Option::None;
    }

    pub fn has_modifiers(&self) -> bool {
        self.modifiers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifiers(&mut self, v: u32) {
        self.modifiers = ::std::option::Option::Some(v);
    }

    // optional uint32 keyCode = 4;

    pub fn keyCode(&self) -> u32 {
        self.keyCode.unwrap_or(0)
    }

    pub fn clear_keyCode(&mut self) {
        self.keyCode = ::std::option::Option::None;
    }

    pub fn has_keyCode(&self) -> bool {
        self.keyCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyCode(&mut self, v: u32) {
        self.keyCode = ::std::option::Option::Some(v);
    }

    // optional uint32 nativeKeyCode = 5;

    pub fn nativeKeyCode(&self) -> u32 {
        self.nativeKeyCode.unwrap_or(0)
    }

    pub fn clear_nativeKeyCode(&mut self) {
        self.nativeKeyCode = ::std::option::Option::None;
    }

    pub fn has_nativeKeyCode(&self) -> bool {
        self.nativeKeyCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nativeKeyCode(&mut self, v: u32) {
        self.nativeKeyCode = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgKeyChar {
    const NAME: &'static str = "CMsgKeyChar";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.unichar = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.modifiers = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.keyCode = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.nativeKeyCode = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.unichar {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.modifiers {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.keyCode {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.nativeKeyCode {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.unichar {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.modifiers {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.keyCode {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.nativeKeyCode {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgKeyChar {
        CMsgKeyChar::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unichar = ::std::option::Option::None;
        self.modifiers = ::std::option::Option::None;
        self.keyCode = ::std::option::Option::None;
        self.nativeKeyCode = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgKeyChar {
        static instance: CMsgKeyChar = CMsgKeyChar {
            browser_handle: ::std::option::Option::None,
            unichar: ::std::option::Option::None,
            modifiers: ::std::option::Option::None,
            keyCode: ::std::option::Option::None,
            nativeKeyCode: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgMouseDown)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMouseDown {
    // message fields
    // @@protoc_insertion_point(field:CMsgMouseDown.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMouseDown.mouse_button)
    pub mouse_button: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMouseDown.modifiers)
    pub modifiers: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMouseDown.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMouseDown {
    fn default() -> &'a CMsgMouseDown {
        <CMsgMouseDown as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMouseDown {
    pub fn new() -> CMsgMouseDown {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 mouse_button = 2;

    pub fn mouse_button(&self) -> u32 {
        self.mouse_button.unwrap_or(0)
    }

    pub fn clear_mouse_button(&mut self) {
        self.mouse_button = ::std::option::Option::None;
    }

    pub fn has_mouse_button(&self) -> bool {
        self.mouse_button.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mouse_button(&mut self, v: u32) {
        self.mouse_button = ::std::option::Option::Some(v);
    }

    // optional uint32 modifiers = 3;

    pub fn modifiers(&self) -> u32 {
        self.modifiers.unwrap_or(0)
    }

    pub fn clear_modifiers(&mut self) {
        self.modifiers = ::std::option::Option::None;
    }

    pub fn has_modifiers(&self) -> bool {
        self.modifiers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifiers(&mut self, v: u32) {
        self.modifiers = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgMouseDown {
    const NAME: &'static str = "CMsgMouseDown";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.mouse_button = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.modifiers = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.mouse_button {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.modifiers {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.mouse_button {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.modifiers {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMouseDown {
        CMsgMouseDown::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.mouse_button = ::std::option::Option::None;
        self.modifiers = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMouseDown {
        static instance: CMsgMouseDown = CMsgMouseDown {
            browser_handle: ::std::option::Option::None,
            mouse_button: ::std::option::Option::None,
            modifiers: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgMouseUp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMouseUp {
    // message fields
    // @@protoc_insertion_point(field:CMsgMouseUp.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMouseUp.mouse_button)
    pub mouse_button: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMouseUp.modifiers)
    pub modifiers: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMouseUp.is_off_panel)
    pub is_off_panel: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgMouseUp.x)
    pub x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgMouseUp.y)
    pub y: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMouseUp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMouseUp {
    fn default() -> &'a CMsgMouseUp {
        <CMsgMouseUp as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMouseUp {
    pub fn new() -> CMsgMouseUp {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 mouse_button = 2;

    pub fn mouse_button(&self) -> u32 {
        self.mouse_button.unwrap_or(0)
    }

    pub fn clear_mouse_button(&mut self) {
        self.mouse_button = ::std::option::Option::None;
    }

    pub fn has_mouse_button(&self) -> bool {
        self.mouse_button.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mouse_button(&mut self, v: u32) {
        self.mouse_button = ::std::option::Option::Some(v);
    }

    // optional uint32 modifiers = 3;

    pub fn modifiers(&self) -> u32 {
        self.modifiers.unwrap_or(0)
    }

    pub fn clear_modifiers(&mut self) {
        self.modifiers = ::std::option::Option::None;
    }

    pub fn has_modifiers(&self) -> bool {
        self.modifiers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifiers(&mut self, v: u32) {
        self.modifiers = ::std::option::Option::Some(v);
    }

    // optional bool is_off_panel = 4;

    pub fn is_off_panel(&self) -> bool {
        self.is_off_panel.unwrap_or(false)
    }

    pub fn clear_is_off_panel(&mut self) {
        self.is_off_panel = ::std::option::Option::None;
    }

    pub fn has_is_off_panel(&self) -> bool {
        self.is_off_panel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_off_panel(&mut self, v: bool) {
        self.is_off_panel = ::std::option::Option::Some(v);
    }

    // optional int32 x = 5;

    pub fn x(&self) -> i32 {
        self.x.unwrap_or(0)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: i32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional int32 y = 6;

    pub fn y(&self) -> i32 {
        self.y.unwrap_or(0)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: i32) {
        self.y = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgMouseUp {
    const NAME: &'static str = "CMsgMouseUp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.mouse_button = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.modifiers = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.is_off_panel = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.x = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.y = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.mouse_button {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.modifiers {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.is_off_panel {
            my_size += 1 + 1;
        }
        if let Some(v) = self.x {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.y {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.mouse_button {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.modifiers {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.is_off_panel {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.x {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.y {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMouseUp {
        CMsgMouseUp::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.mouse_button = ::std::option::Option::None;
        self.modifiers = ::std::option::Option::None;
        self.is_off_panel = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMouseUp {
        static instance: CMsgMouseUp = CMsgMouseUp {
            browser_handle: ::std::option::Option::None,
            mouse_button: ::std::option::Option::None,
            modifiers: ::std::option::Option::None,
            is_off_panel: ::std::option::Option::None,
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgMouseDblClick)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMouseDblClick {
    // message fields
    // @@protoc_insertion_point(field:CMsgMouseDblClick.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMouseDblClick.mouse_button)
    pub mouse_button: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMouseDblClick.modifiers)
    pub modifiers: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMouseDblClick.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMouseDblClick {
    fn default() -> &'a CMsgMouseDblClick {
        <CMsgMouseDblClick as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMouseDblClick {
    pub fn new() -> CMsgMouseDblClick {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 mouse_button = 2;

    pub fn mouse_button(&self) -> u32 {
        self.mouse_button.unwrap_or(0)
    }

    pub fn clear_mouse_button(&mut self) {
        self.mouse_button = ::std::option::Option::None;
    }

    pub fn has_mouse_button(&self) -> bool {
        self.mouse_button.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mouse_button(&mut self, v: u32) {
        self.mouse_button = ::std::option::Option::Some(v);
    }

    // optional uint32 modifiers = 3;

    pub fn modifiers(&self) -> u32 {
        self.modifiers.unwrap_or(0)
    }

    pub fn clear_modifiers(&mut self) {
        self.modifiers = ::std::option::Option::None;
    }

    pub fn has_modifiers(&self) -> bool {
        self.modifiers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifiers(&mut self, v: u32) {
        self.modifiers = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgMouseDblClick {
    const NAME: &'static str = "CMsgMouseDblClick";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.mouse_button = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.modifiers = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.mouse_button {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.modifiers {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.mouse_button {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.modifiers {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMouseDblClick {
        CMsgMouseDblClick::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.mouse_button = ::std::option::Option::None;
        self.modifiers = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMouseDblClick {
        static instance: CMsgMouseDblClick = CMsgMouseDblClick {
            browser_handle: ::std::option::Option::None,
            mouse_button: ::std::option::Option::None,
            modifiers: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgMouseWheel)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMouseWheel {
    // message fields
    // @@protoc_insertion_point(field:CMsgMouseWheel.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMouseWheel.deltax)
    pub deltax: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgMouseWheel.deltay)
    pub deltay: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgMouseWheel.modifiers)
    pub modifiers: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMouseWheel.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMouseWheel {
    fn default() -> &'a CMsgMouseWheel {
        <CMsgMouseWheel as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMouseWheel {
    pub fn new() -> CMsgMouseWheel {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional int32 deltax = 2;

    pub fn deltax(&self) -> i32 {
        self.deltax.unwrap_or(0)
    }

    pub fn clear_deltax(&mut self) {
        self.deltax = ::std::option::Option::None;
    }

    pub fn has_deltax(&self) -> bool {
        self.deltax.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deltax(&mut self, v: i32) {
        self.deltax = ::std::option::Option::Some(v);
    }

    // optional int32 deltay = 3;

    pub fn deltay(&self) -> i32 {
        self.deltay.unwrap_or(0)
    }

    pub fn clear_deltay(&mut self) {
        self.deltay = ::std::option::Option::None;
    }

    pub fn has_deltay(&self) -> bool {
        self.deltay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deltay(&mut self, v: i32) {
        self.deltay = ::std::option::Option::Some(v);
    }

    // optional uint32 modifiers = 4;

    pub fn modifiers(&self) -> u32 {
        self.modifiers.unwrap_or(0)
    }

    pub fn clear_modifiers(&mut self) {
        self.modifiers = ::std::option::Option::None;
    }

    pub fn has_modifiers(&self) -> bool {
        self.modifiers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifiers(&mut self, v: u32) {
        self.modifiers = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgMouseWheel {
    const NAME: &'static str = "CMsgMouseWheel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.deltax = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.deltay = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.modifiers = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.deltax {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.deltay {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.modifiers {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.deltax {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.deltay {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.modifiers {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMouseWheel {
        CMsgMouseWheel::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.deltax = ::std::option::Option::None;
        self.deltay = ::std::option::Option::None;
        self.modifiers = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMouseWheel {
        static instance: CMsgMouseWheel = CMsgMouseWheel {
            browser_handle: ::std::option::Option::None,
            deltax: ::std::option::Option::None,
            deltay: ::std::option::Option::None,
            modifiers: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgMouseMove)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMouseMove {
    // message fields
    // @@protoc_insertion_point(field:CMsgMouseMove.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMouseMove.x)
    pub x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgMouseMove.y)
    pub y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgMouseMove.modifiers)
    pub modifiers: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMouseMove.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMouseMove {
    fn default() -> &'a CMsgMouseMove {
        <CMsgMouseMove as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMouseMove {
    pub fn new() -> CMsgMouseMove {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional int32 x = 2;

    pub fn x(&self) -> i32 {
        self.x.unwrap_or(0)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: i32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional int32 y = 3;

    pub fn y(&self) -> i32 {
        self.y.unwrap_or(0)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: i32) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional uint32 modifiers = 4;

    pub fn modifiers(&self) -> u32 {
        self.modifiers.unwrap_or(0)
    }

    pub fn clear_modifiers(&mut self) {
        self.modifiers = ::std::option::Option::None;
    }

    pub fn has_modifiers(&self) -> bool {
        self.modifiers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifiers(&mut self, v: u32) {
        self.modifiers = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgMouseMove {
    const NAME: &'static str = "CMsgMouseMove";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.x = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.y = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.modifiers = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.x {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.y {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.modifiers {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.y {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.modifiers {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMouseMove {
        CMsgMouseMove::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.modifiers = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMouseMove {
        static instance: CMsgMouseMove = CMsgMouseMove {
            browser_handle: ::std::option::Option::None,
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            modifiers: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgMouseLeave)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMouseLeave {
    // message fields
    // @@protoc_insertion_point(field:CMsgMouseLeave.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMouseLeave.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMouseLeave {
    fn default() -> &'a CMsgMouseLeave {
        <CMsgMouseLeave as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMouseLeave {
    pub fn new() -> CMsgMouseLeave {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgMouseLeave {
    const NAME: &'static str = "CMsgMouseLeave";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMouseLeave {
        CMsgMouseLeave::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMouseLeave {
        static instance: CMsgMouseLeave = CMsgMouseLeave {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgBrowserCreate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBrowserCreate {
    // message fields
    // @@protoc_insertion_point(field:CMsgBrowserCreate.request_id)
    pub request_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.useragent)
    pub useragent: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.user_css)
    pub user_css: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.native_dropdowns)
    pub native_dropdowns: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.dpi_scaling)
    pub dpi_scaling: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.offscreen)
    pub offscreen: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.initial_width)
    pub initial_width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.initial_height)
    pub initial_height: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.window_icon)
    pub window_icon: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.borderless)
    pub borderless: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.vroverlay_key)
    pub vroverlay_key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.browser_type)
    pub browser_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.initial_top)
    pub initial_top: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.initial_left)
    pub initial_left: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.only_allow_trusted_popups)
    pub only_allow_trusted_popups: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.initial_url)
    pub initial_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.hwnd_parent)
    pub hwnd_parent: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.creation_flags)
    pub creation_flags: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBrowserCreate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBrowserCreate {
    fn default() -> &'a CMsgBrowserCreate {
        <CMsgBrowserCreate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBrowserCreate {
    pub fn new() -> CMsgBrowserCreate {
        ::std::default::Default::default()
    }

    // optional uint32 request_id = 1;

    pub fn request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional string useragent = 3;

    pub fn useragent(&self) -> &str {
        match self.useragent.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_useragent(&mut self) {
        self.useragent = ::std::option::Option::None;
    }

    pub fn has_useragent(&self) -> bool {
        self.useragent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_useragent(&mut self, v: ::std::string::String) {
        self.useragent = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_useragent(&mut self) -> &mut ::std::string::String {
        if self.useragent.is_none() {
            self.useragent = ::std::option::Option::Some(::std::string::String::new());
        }
        self.useragent.as_mut().unwrap()
    }

    // Take field
    pub fn take_useragent(&mut self) -> ::std::string::String {
        self.useragent.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string user_css = 5;

    pub fn user_css(&self) -> &str {
        match self.user_css.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_user_css(&mut self) {
        self.user_css = ::std::option::Option::None;
    }

    pub fn has_user_css(&self) -> bool {
        self.user_css.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_css(&mut self, v: ::std::string::String) {
        self.user_css = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_css(&mut self) -> &mut ::std::string::String {
        if self.user_css.is_none() {
            self.user_css = ::std::option::Option::Some(::std::string::String::new());
        }
        self.user_css.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_css(&mut self) -> ::std::string::String {
        self.user_css.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool native_dropdowns = 6;

    pub fn native_dropdowns(&self) -> bool {
        self.native_dropdowns.unwrap_or(false)
    }

    pub fn clear_native_dropdowns(&mut self) {
        self.native_dropdowns = ::std::option::Option::None;
    }

    pub fn has_native_dropdowns(&self) -> bool {
        self.native_dropdowns.is_some()
    }

    // Param is passed by value, moved
    pub fn set_native_dropdowns(&mut self, v: bool) {
        self.native_dropdowns = ::std::option::Option::Some(v);
    }

    // optional float dpi_scaling = 7;

    pub fn dpi_scaling(&self) -> f32 {
        self.dpi_scaling.unwrap_or(0.)
    }

    pub fn clear_dpi_scaling(&mut self) {
        self.dpi_scaling = ::std::option::Option::None;
    }

    pub fn has_dpi_scaling(&self) -> bool {
        self.dpi_scaling.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dpi_scaling(&mut self, v: f32) {
        self.dpi_scaling = ::std::option::Option::Some(v);
    }

    // optional bool offscreen = 8;

    pub fn offscreen(&self) -> bool {
        self.offscreen.unwrap_or(true)
    }

    pub fn clear_offscreen(&mut self) {
        self.offscreen = ::std::option::Option::None;
    }

    pub fn has_offscreen(&self) -> bool {
        self.offscreen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offscreen(&mut self, v: bool) {
        self.offscreen = ::std::option::Option::Some(v);
    }

    // optional uint32 initial_width = 9;

    pub fn initial_width(&self) -> u32 {
        self.initial_width.unwrap_or(0u32)
    }

    pub fn clear_initial_width(&mut self) {
        self.initial_width = ::std::option::Option::None;
    }

    pub fn has_initial_width(&self) -> bool {
        self.initial_width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_width(&mut self, v: u32) {
        self.initial_width = ::std::option::Option::Some(v);
    }

    // optional uint32 initial_height = 10;

    pub fn initial_height(&self) -> u32 {
        self.initial_height.unwrap_or(0u32)
    }

    pub fn clear_initial_height(&mut self) {
        self.initial_height = ::std::option::Option::None;
    }

    pub fn has_initial_height(&self) -> bool {
        self.initial_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_height(&mut self, v: u32) {
        self.initial_height = ::std::option::Option::Some(v);
    }

    // optional string window_icon = 11;

    pub fn window_icon(&self) -> &str {
        match self.window_icon.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_window_icon(&mut self) {
        self.window_icon = ::std::option::Option::None;
    }

    pub fn has_window_icon(&self) -> bool {
        self.window_icon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_window_icon(&mut self, v: ::std::string::String) {
        self.window_icon = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_window_icon(&mut self) -> &mut ::std::string::String {
        if self.window_icon.is_none() {
            self.window_icon = ::std::option::Option::Some(::std::string::String::new());
        }
        self.window_icon.as_mut().unwrap()
    }

    // Take field
    pub fn take_window_icon(&mut self) -> ::std::string::String {
        self.window_icon.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool borderless = 12;

    pub fn borderless(&self) -> bool {
        self.borderless.unwrap_or(false)
    }

    pub fn clear_borderless(&mut self) {
        self.borderless = ::std::option::Option::None;
    }

    pub fn has_borderless(&self) -> bool {
        self.borderless.is_some()
    }

    // Param is passed by value, moved
    pub fn set_borderless(&mut self, v: bool) {
        self.borderless = ::std::option::Option::Some(v);
    }

    // optional string vroverlay_key = 13;

    pub fn vroverlay_key(&self) -> &str {
        match self.vroverlay_key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_vroverlay_key(&mut self) {
        self.vroverlay_key = ::std::option::Option::None;
    }

    pub fn has_vroverlay_key(&self) -> bool {
        self.vroverlay_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vroverlay_key(&mut self, v: ::std::string::String) {
        self.vroverlay_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vroverlay_key(&mut self) -> &mut ::std::string::String {
        if self.vroverlay_key.is_none() {
            self.vroverlay_key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.vroverlay_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_vroverlay_key(&mut self) -> ::std::string::String {
        self.vroverlay_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 browser_type = 14;

    pub fn browser_type(&self) -> u32 {
        self.browser_type.unwrap_or(0u32)
    }

    pub fn clear_browser_type(&mut self) {
        self.browser_type = ::std::option::Option::None;
    }

    pub fn has_browser_type(&self) -> bool {
        self.browser_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_type(&mut self, v: u32) {
        self.browser_type = ::std::option::Option::Some(v);
    }

    // optional int32 initial_top = 15;

    pub fn initial_top(&self) -> i32 {
        self.initial_top.unwrap_or(-2147483648i32)
    }

    pub fn clear_initial_top(&mut self) {
        self.initial_top = ::std::option::Option::None;
    }

    pub fn has_initial_top(&self) -> bool {
        self.initial_top.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_top(&mut self, v: i32) {
        self.initial_top = ::std::option::Option::Some(v);
    }

    // optional int32 initial_left = 16;

    pub fn initial_left(&self) -> i32 {
        self.initial_left.unwrap_or(-2147483648i32)
    }

    pub fn clear_initial_left(&mut self) {
        self.initial_left = ::std::option::Option::None;
    }

    pub fn has_initial_left(&self) -> bool {
        self.initial_left.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_left(&mut self, v: i32) {
        self.initial_left = ::std::option::Option::Some(v);
    }

    // optional bool only_allow_trusted_popups = 17;

    pub fn only_allow_trusted_popups(&self) -> bool {
        self.only_allow_trusted_popups.unwrap_or(false)
    }

    pub fn clear_only_allow_trusted_popups(&mut self) {
        self.only_allow_trusted_popups = ::std::option::Option::None;
    }

    pub fn has_only_allow_trusted_popups(&self) -> bool {
        self.only_allow_trusted_popups.is_some()
    }

    // Param is passed by value, moved
    pub fn set_only_allow_trusted_popups(&mut self, v: bool) {
        self.only_allow_trusted_popups = ::std::option::Option::Some(v);
    }

    // optional string initial_url = 18;

    pub fn initial_url(&self) -> &str {
        match self.initial_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_initial_url(&mut self) {
        self.initial_url = ::std::option::Option::None;
    }

    pub fn has_initial_url(&self) -> bool {
        self.initial_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_url(&mut self, v: ::std::string::String) {
        self.initial_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_initial_url(&mut self) -> &mut ::std::string::String {
        if self.initial_url.is_none() {
            self.initial_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.initial_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_initial_url(&mut self) -> ::std::string::String {
        self.initial_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 hwnd_parent = 19;

    pub fn hwnd_parent(&self) -> u64 {
        self.hwnd_parent.unwrap_or(0)
    }

    pub fn clear_hwnd_parent(&mut self) {
        self.hwnd_parent = ::std::option::Option::None;
    }

    pub fn has_hwnd_parent(&self) -> bool {
        self.hwnd_parent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hwnd_parent(&mut self, v: u64) {
        self.hwnd_parent = ::std::option::Option::Some(v);
    }

    // optional uint32 creation_flags = 20;

    pub fn creation_flags(&self) -> u32 {
        self.creation_flags.unwrap_or(0u32)
    }

    pub fn clear_creation_flags(&mut self) {
        self.creation_flags = ::std::option::Option::None;
    }

    pub fn has_creation_flags(&self) -> bool {
        self.creation_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creation_flags(&mut self, v: u32) {
        self.creation_flags = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgBrowserCreate {
    const NAME: &'static str = "CMsgBrowserCreate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.request_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.useragent = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.user_css = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.native_dropdowns = ::std::option::Option::Some(is.read_bool()?);
                },
                61 => {
                    self.dpi_scaling = ::std::option::Option::Some(is.read_float()?);
                },
                64 => {
                    self.offscreen = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.initial_width = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.initial_height = ::std::option::Option::Some(is.read_uint32()?);
                },
                90 => {
                    self.window_icon = ::std::option::Option::Some(is.read_string()?);
                },
                96 => {
                    self.borderless = ::std::option::Option::Some(is.read_bool()?);
                },
                106 => {
                    self.vroverlay_key = ::std::option::Option::Some(is.read_string()?);
                },
                112 => {
                    self.browser_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.initial_top = ::std::option::Option::Some(is.read_int32()?);
                },
                128 => {
                    self.initial_left = ::std::option::Option::Some(is.read_int32()?);
                },
                136 => {
                    self.only_allow_trusted_popups = ::std::option::Option::Some(is.read_bool()?);
                },
                146 => {
                    self.initial_url = ::std::option::Option::Some(is.read_string()?);
                },
                153 => {
                    self.hwnd_parent = ::std::option::Option::Some(is.read_fixed64()?);
                },
                160 => {
                    self.creation_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.useragent.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.user_css.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.native_dropdowns {
            my_size += 1 + 1;
        }
        if let Some(v) = self.dpi_scaling {
            my_size += 1 + 4;
        }
        if let Some(v) = self.offscreen {
            my_size += 1 + 1;
        }
        if let Some(v) = self.initial_width {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.initial_height {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.window_icon.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.borderless {
            my_size += 1 + 1;
        }
        if let Some(v) = self.vroverlay_key.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.browser_type {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.initial_top {
            my_size += ::protobuf::rt::int32_size(15, v);
        }
        if let Some(v) = self.initial_left {
            my_size += ::protobuf::rt::int32_size(16, v);
        }
        if let Some(v) = self.only_allow_trusted_popups {
            my_size += 2 + 1;
        }
        if let Some(v) = self.initial_url.as_ref() {
            my_size += ::protobuf::rt::string_size(18, &v);
        }
        if let Some(v) = self.hwnd_parent {
            my_size += 2 + 8;
        }
        if let Some(v) = self.creation_flags {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.request_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.useragent.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.user_css.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.native_dropdowns {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.dpi_scaling {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.offscreen {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.initial_width {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.initial_height {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.window_icon.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.borderless {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.vroverlay_key.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.browser_type {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.initial_top {
            os.write_int32(15, v)?;
        }
        if let Some(v) = self.initial_left {
            os.write_int32(16, v)?;
        }
        if let Some(v) = self.only_allow_trusted_popups {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.initial_url.as_ref() {
            os.write_string(18, v)?;
        }
        if let Some(v) = self.hwnd_parent {
            os.write_fixed64(19, v)?;
        }
        if let Some(v) = self.creation_flags {
            os.write_uint32(20, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBrowserCreate {
        CMsgBrowserCreate::new()
    }

    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.useragent = ::std::option::Option::None;
        self.user_css = ::std::option::Option::None;
        self.native_dropdowns = ::std::option::Option::None;
        self.dpi_scaling = ::std::option::Option::None;
        self.offscreen = ::std::option::Option::None;
        self.initial_width = ::std::option::Option::None;
        self.initial_height = ::std::option::Option::None;
        self.window_icon = ::std::option::Option::None;
        self.borderless = ::std::option::Option::None;
        self.vroverlay_key = ::std::option::Option::None;
        self.browser_type = ::std::option::Option::None;
        self.initial_top = ::std::option::Option::None;
        self.initial_left = ::std::option::Option::None;
        self.only_allow_trusted_popups = ::std::option::Option::None;
        self.initial_url = ::std::option::Option::None;
        self.hwnd_parent = ::std::option::Option::None;
        self.creation_flags = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBrowserCreate {
        static instance: CMsgBrowserCreate = CMsgBrowserCreate {
            request_id: ::std::option::Option::None,
            useragent: ::std::option::Option::None,
            user_css: ::std::option::Option::None,
            native_dropdowns: ::std::option::Option::None,
            dpi_scaling: ::std::option::Option::None,
            offscreen: ::std::option::Option::None,
            initial_width: ::std::option::Option::None,
            initial_height: ::std::option::Option::None,
            window_icon: ::std::option::Option::None,
            borderless: ::std::option::Option::None,
            vroverlay_key: ::std::option::Option::None,
            browser_type: ::std::option::Option::None,
            initial_top: ::std::option::Option::None,
            initial_left: ::std::option::Option::None,
            only_allow_trusted_popups: ::std::option::Option::None,
            initial_url: ::std::option::Option::None,
            hwnd_parent: ::std::option::Option::None,
            creation_flags: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgBrowserCreateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBrowserCreateResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgBrowserCreateResponse.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBrowserCreateResponse.request_id)
    pub request_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBrowserCreateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBrowserCreateResponse {
    fn default() -> &'a CMsgBrowserCreateResponse {
        <CMsgBrowserCreateResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBrowserCreateResponse {
    pub fn new() -> CMsgBrowserCreateResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 request_id = 2;

    pub fn request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgBrowserCreateResponse {
    const NAME: &'static str = "CMsgBrowserCreateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.request_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.request_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBrowserCreateResponse {
        CMsgBrowserCreateResponse::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.request_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBrowserCreateResponse {
        static instance: CMsgBrowserCreateResponse = CMsgBrowserCreateResponse {
            browser_handle: ::std::option::Option::None,
            request_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgBrowserRemove)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBrowserRemove {
    // message fields
    // @@protoc_insertion_point(field:CMsgBrowserRemove.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBrowserRemove.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBrowserRemove {
    fn default() -> &'a CMsgBrowserRemove {
        <CMsgBrowserRemove as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBrowserRemove {
    pub fn new() -> CMsgBrowserRemove {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgBrowserRemove {
    const NAME: &'static str = "CMsgBrowserRemove";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBrowserRemove {
        CMsgBrowserRemove::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBrowserRemove {
        static instance: CMsgBrowserRemove = CMsgBrowserRemove {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSetLocalFileRequestMapping)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetLocalFileRequestMapping {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetLocalFileRequestMapping.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetLocalFileRequestMapping.request_url)
    pub request_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSetLocalFileRequestMapping.default_local_path)
    pub default_local_path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSetLocalFileRequestMapping.routes)
    pub routes: ::std::vec::Vec<cmsg_set_local_file_request_mapping::AdditionalRoute>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetLocalFileRequestMapping.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetLocalFileRequestMapping {
    fn default() -> &'a CMsgSetLocalFileRequestMapping {
        <CMsgSetLocalFileRequestMapping as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetLocalFileRequestMapping {
    pub fn new() -> CMsgSetLocalFileRequestMapping {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string request_url = 2;

    pub fn request_url(&self) -> &str {
        match self.request_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_request_url(&mut self) {
        self.request_url = ::std::option::Option::None;
    }

    pub fn has_request_url(&self) -> bool {
        self.request_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_url(&mut self, v: ::std::string::String) {
        self.request_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_request_url(&mut self) -> &mut ::std::string::String {
        if self.request_url.is_none() {
            self.request_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.request_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_request_url(&mut self) -> ::std::string::String {
        self.request_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string default_local_path = 3;

    pub fn default_local_path(&self) -> &str {
        match self.default_local_path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_default_local_path(&mut self) {
        self.default_local_path = ::std::option::Option::None;
    }

    pub fn has_default_local_path(&self) -> bool {
        self.default_local_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_local_path(&mut self, v: ::std::string::String) {
        self.default_local_path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_default_local_path(&mut self) -> &mut ::std::string::String {
        if self.default_local_path.is_none() {
            self.default_local_path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.default_local_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_default_local_path(&mut self) -> ::std::string::String {
        self.default_local_path.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgSetLocalFileRequestMapping {
    const NAME: &'static str = "CMsgSetLocalFileRequestMapping";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.request_url = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.default_local_path = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.routes.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.request_url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.default_local_path.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.routes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.request_url.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.default_local_path.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.routes {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetLocalFileRequestMapping {
        CMsgSetLocalFileRequestMapping::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.request_url = ::std::option::Option::None;
        self.default_local_path = ::std::option::Option::None;
        self.routes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetLocalFileRequestMapping {
        static instance: CMsgSetLocalFileRequestMapping = CMsgSetLocalFileRequestMapping {
            browser_handle: ::std::option::Option::None,
            request_url: ::std::option::Option::None,
            default_local_path: ::std::option::Option::None,
            routes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSetLocalFileRequestMapping`
pub mod cmsg_set_local_file_request_mapping {
    // @@protoc_insertion_point(message:CMsgSetLocalFileRequestMapping.AdditionalRoute)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AdditionalRoute {
        // message fields
        // @@protoc_insertion_point(field:CMsgSetLocalFileRequestMapping.AdditionalRoute.relative_url)
        pub relative_url: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgSetLocalFileRequestMapping.AdditionalRoute.local_path)
        pub local_path: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgSetLocalFileRequestMapping.AdditionalRoute.allowed_extensions)
        pub allowed_extensions: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgSetLocalFileRequestMapping.AdditionalRoute.url_rewrite)
        pub url_rewrite: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSetLocalFileRequestMapping.AdditionalRoute.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AdditionalRoute {
        fn default() -> &'a AdditionalRoute {
            <AdditionalRoute as ::protobuf::Message>::default_instance()
        }
    }

    impl AdditionalRoute {
        pub fn new() -> AdditionalRoute {
            ::std::default::Default::default()
        }

        // optional string relative_url = 1;

        pub fn relative_url(&self) -> &str {
            match self.relative_url.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_relative_url(&mut self) {
            self.relative_url = ::std::option::Option::None;
        }

        pub fn has_relative_url(&self) -> bool {
            self.relative_url.is_some()
        }

        // Param is passed by value, moved
        pub fn set_relative_url(&mut self, v: ::std::string::String) {
            self.relative_url = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_relative_url(&mut self) -> &mut ::std::string::String {
            if self.relative_url.is_none() {
                self.relative_url = ::std::option::Option::Some(::std::string::String::new());
            }
            self.relative_url.as_mut().unwrap()
        }

        // Take field
        pub fn take_relative_url(&mut self) -> ::std::string::String {
            self.relative_url.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string local_path = 2;

        pub fn local_path(&self) -> &str {
            match self.local_path.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_local_path(&mut self) {
            self.local_path = ::std::option::Option::None;
        }

        pub fn has_local_path(&self) -> bool {
            self.local_path.is_some()
        }

        // Param is passed by value, moved
        pub fn set_local_path(&mut self, v: ::std::string::String) {
            self.local_path = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_local_path(&mut self) -> &mut ::std::string::String {
            if self.local_path.is_none() {
                self.local_path = ::std::option::Option::Some(::std::string::String::new());
            }
            self.local_path.as_mut().unwrap()
        }

        // Take field
        pub fn take_local_path(&mut self) -> ::std::string::String {
            self.local_path.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string allowed_extensions = 3;

        pub fn allowed_extensions(&self) -> &str {
            match self.allowed_extensions.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_allowed_extensions(&mut self) {
            self.allowed_extensions = ::std::option::Option::None;
        }

        pub fn has_allowed_extensions(&self) -> bool {
            self.allowed_extensions.is_some()
        }

        // Param is passed by value, moved
        pub fn set_allowed_extensions(&mut self, v: ::std::string::String) {
            self.allowed_extensions = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_allowed_extensions(&mut self) -> &mut ::std::string::String {
            if self.allowed_extensions.is_none() {
                self.allowed_extensions = ::std::option::Option::Some(::std::string::String::new());
            }
            self.allowed_extensions.as_mut().unwrap()
        }

        // Take field
        pub fn take_allowed_extensions(&mut self) -> ::std::string::String {
            self.allowed_extensions.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool url_rewrite = 4;

        pub fn url_rewrite(&self) -> bool {
            self.url_rewrite.unwrap_or(false)
        }

        pub fn clear_url_rewrite(&mut self) {
            self.url_rewrite = ::std::option::Option::None;
        }

        pub fn has_url_rewrite(&self) -> bool {
            self.url_rewrite.is_some()
        }

        // Param is passed by value, moved
        pub fn set_url_rewrite(&mut self, v: bool) {
            self.url_rewrite = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for AdditionalRoute {
        const NAME: &'static str = "AdditionalRoute";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.relative_url = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.local_path = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.allowed_extensions = ::std::option::Option::Some(is.read_string()?);
                    },
                    32 => {
                        self.url_rewrite = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.relative_url.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.local_path.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.allowed_extensions.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.url_rewrite {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.relative_url.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.local_path.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.allowed_extensions.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.url_rewrite {
                os.write_bool(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AdditionalRoute {
            AdditionalRoute::new()
        }

        fn clear(&mut self) {
            self.relative_url = ::std::option::Option::None;
            self.local_path = ::std::option::Option::None;
            self.allowed_extensions = ::std::option::Option::None;
            self.url_rewrite = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AdditionalRoute {
            static instance: AdditionalRoute = AdditionalRoute {
                relative_url: ::std::option::Option::None,
                local_path: ::std::option::Option::None,
                allowed_extensions: ::std::option::Option::None,
                url_rewrite: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgBrowserErrorStrings)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBrowserErrorStrings {
    // message fields
    // @@protoc_insertion_point(field:CMsgBrowserErrorStrings.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBrowserErrorStrings.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgBrowserErrorStrings.header)
    pub header: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgBrowserErrorStrings.cache_miss)
    pub cache_miss: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgBrowserErrorStrings.bad_url)
    pub bad_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgBrowserErrorStrings.connection_problem)
    pub connection_problem: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgBrowserErrorStrings.proxy_problem)
    pub proxy_problem: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgBrowserErrorStrings.unknown)
    pub unknown: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBrowserErrorStrings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBrowserErrorStrings {
    fn default() -> &'a CMsgBrowserErrorStrings {
        <CMsgBrowserErrorStrings as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBrowserErrorStrings {
    pub fn new() -> CMsgBrowserErrorStrings {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string title = 2;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string header = 3;

    pub fn header(&self) -> &str {
        match self.header.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_header(&mut self) {
        self.header = ::std::option::Option::None;
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ::std::string::String) {
        self.header = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ::std::string::String {
        if self.header.is_none() {
            self.header = ::std::option::Option::Some(::std::string::String::new());
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ::std::string::String {
        self.header.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string cache_miss = 4;

    pub fn cache_miss(&self) -> &str {
        match self.cache_miss.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_cache_miss(&mut self) {
        self.cache_miss = ::std::option::Option::None;
    }

    pub fn has_cache_miss(&self) -> bool {
        self.cache_miss.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cache_miss(&mut self, v: ::std::string::String) {
        self.cache_miss = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cache_miss(&mut self) -> &mut ::std::string::String {
        if self.cache_miss.is_none() {
            self.cache_miss = ::std::option::Option::Some(::std::string::String::new());
        }
        self.cache_miss.as_mut().unwrap()
    }

    // Take field
    pub fn take_cache_miss(&mut self) -> ::std::string::String {
        self.cache_miss.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string bad_url = 5;

    pub fn bad_url(&self) -> &str {
        match self.bad_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_bad_url(&mut self) {
        self.bad_url = ::std::option::Option::None;
    }

    pub fn has_bad_url(&self) -> bool {
        self.bad_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bad_url(&mut self, v: ::std::string::String) {
        self.bad_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bad_url(&mut self) -> &mut ::std::string::String {
        if self.bad_url.is_none() {
            self.bad_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.bad_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_bad_url(&mut self) -> ::std::string::String {
        self.bad_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string connection_problem = 6;

    pub fn connection_problem(&self) -> &str {
        match self.connection_problem.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_connection_problem(&mut self) {
        self.connection_problem = ::std::option::Option::None;
    }

    pub fn has_connection_problem(&self) -> bool {
        self.connection_problem.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_problem(&mut self, v: ::std::string::String) {
        self.connection_problem = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connection_problem(&mut self) -> &mut ::std::string::String {
        if self.connection_problem.is_none() {
            self.connection_problem = ::std::option::Option::Some(::std::string::String::new());
        }
        self.connection_problem.as_mut().unwrap()
    }

    // Take field
    pub fn take_connection_problem(&mut self) -> ::std::string::String {
        self.connection_problem.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string proxy_problem = 7;

    pub fn proxy_problem(&self) -> &str {
        match self.proxy_problem.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_proxy_problem(&mut self) {
        self.proxy_problem = ::std::option::Option::None;
    }

    pub fn has_proxy_problem(&self) -> bool {
        self.proxy_problem.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proxy_problem(&mut self, v: ::std::string::String) {
        self.proxy_problem = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proxy_problem(&mut self) -> &mut ::std::string::String {
        if self.proxy_problem.is_none() {
            self.proxy_problem = ::std::option::Option::Some(::std::string::String::new());
        }
        self.proxy_problem.as_mut().unwrap()
    }

    // Take field
    pub fn take_proxy_problem(&mut self) -> ::std::string::String {
        self.proxy_problem.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string unknown = 8;

    pub fn unknown(&self) -> &str {
        match self.unknown.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_unknown(&mut self) {
        self.unknown = ::std::option::Option::None;
    }

    pub fn has_unknown(&self) -> bool {
        self.unknown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unknown(&mut self, v: ::std::string::String) {
        self.unknown = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unknown(&mut self) -> &mut ::std::string::String {
        if self.unknown.is_none() {
            self.unknown = ::std::option::Option::Some(::std::string::String::new());
        }
        self.unknown.as_mut().unwrap()
    }

    // Take field
    pub fn take_unknown(&mut self) -> ::std::string::String {
        self.unknown.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgBrowserErrorStrings {
    const NAME: &'static str = "CMsgBrowserErrorStrings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.header = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.cache_miss = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.bad_url = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.connection_problem = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.proxy_problem = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.unknown = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.header.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.cache_miss.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.bad_url.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.connection_problem.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.proxy_problem.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.unknown.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.header.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.cache_miss.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.bad_url.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.connection_problem.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.proxy_problem.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.unknown.as_ref() {
            os.write_string(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBrowserErrorStrings {
        CMsgBrowserErrorStrings::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.header = ::std::option::Option::None;
        self.cache_miss = ::std::option::Option::None;
        self.bad_url = ::std::option::Option::None;
        self.connection_problem = ::std::option::Option::None;
        self.proxy_problem = ::std::option::Option::None;
        self.unknown = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBrowserErrorStrings {
        static instance: CMsgBrowserErrorStrings = CMsgBrowserErrorStrings {
            browser_handle: ::std::option::Option::None,
            title: ::std::option::Option::None,
            header: ::std::option::Option::None,
            cache_miss: ::std::option::Option::None,
            bad_url: ::std::option::Option::None,
            connection_problem: ::std::option::Option::None,
            proxy_problem: ::std::option::Option::None,
            unknown: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgBrowserSetName)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBrowserSetName {
    // message fields
    // @@protoc_insertion_point(field:CMsgBrowserSetName.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBrowserSetName.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBrowserSetName.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBrowserSetName {
    fn default() -> &'a CMsgBrowserSetName {
        <CMsgBrowserSetName as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBrowserSetName {
    pub fn new() -> CMsgBrowserSetName {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgBrowserSetName {
    const NAME: &'static str = "CMsgBrowserSetName";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBrowserSetName {
        CMsgBrowserSetName::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBrowserSetName {
        static instance: CMsgBrowserSetName = CMsgBrowserSetName {
            browser_handle: ::std::option::Option::None,
            name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgBrowserSize)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBrowserSize {
    // message fields
    // @@protoc_insertion_point(field:CMsgBrowserSize.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBrowserSize.width)
    pub width: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgBrowserSize.height)
    pub height: ::std::option::Option<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBrowserSize.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBrowserSize {
    fn default() -> &'a CMsgBrowserSize {
        <CMsgBrowserSize as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBrowserSize {
    pub fn new() -> CMsgBrowserSize {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional double width = 2;

    pub fn width(&self) -> f64 {
        self.width.unwrap_or(0.)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: f64) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional double height = 3;

    pub fn height(&self) -> f64 {
        self.height.unwrap_or(0.)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: f64) {
        self.height = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgBrowserSize {
    const NAME: &'static str = "CMsgBrowserSize";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.width = ::std::option::Option::Some(is.read_double()?);
                },
                25 => {
                    self.height = ::std::option::Option::Some(is.read_double()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.width {
            my_size += 1 + 8;
        }
        if let Some(v) = self.height {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.width {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.height {
            os.write_double(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBrowserSize {
        CMsgBrowserSize::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBrowserSize {
        static instance: CMsgBrowserSize = CMsgBrowserSize {
            browser_handle: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgBrowserSetMinSize)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBrowserSetMinSize {
    // message fields
    // @@protoc_insertion_point(field:CMsgBrowserSetMinSize.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBrowserSetMinSize.width)
    pub width: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgBrowserSetMinSize.height)
    pub height: ::std::option::Option<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBrowserSetMinSize.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBrowserSetMinSize {
    fn default() -> &'a CMsgBrowserSetMinSize {
        <CMsgBrowserSetMinSize as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBrowserSetMinSize {
    pub fn new() -> CMsgBrowserSetMinSize {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional double width = 2;

    pub fn width(&self) -> f64 {
        self.width.unwrap_or(0.)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: f64) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional double height = 3;

    pub fn height(&self) -> f64 {
        self.height.unwrap_or(0.)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: f64) {
        self.height = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgBrowserSetMinSize {
    const NAME: &'static str = "CMsgBrowserSetMinSize";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.width = ::std::option::Option::Some(is.read_double()?);
                },
                25 => {
                    self.height = ::std::option::Option::Some(is.read_double()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.width {
            my_size += 1 + 8;
        }
        if let Some(v) = self.height {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.width {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.height {
            os.write_double(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBrowserSetMinSize {
        CMsgBrowserSetMinSize::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBrowserSetMinSize {
        static instance: CMsgBrowserSetMinSize = CMsgBrowserSetMinSize {
            browser_handle: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgBrowserPosition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBrowserPosition {
    // message fields
    // @@protoc_insertion_point(field:CMsgBrowserPosition.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBrowserPosition.x)
    pub x: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgBrowserPosition.y)
    pub y: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgBrowserPosition.x_local)
    pub x_local: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgBrowserPosition.y_local)
    pub y_local: ::std::option::Option<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBrowserPosition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBrowserPosition {
    fn default() -> &'a CMsgBrowserPosition {
        <CMsgBrowserPosition as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBrowserPosition {
    pub fn new() -> CMsgBrowserPosition {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional double x = 2;

    pub fn x(&self) -> f64 {
        self.x.unwrap_or(0.)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f64) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional double y = 3;

    pub fn y(&self) -> f64 {
        self.y.unwrap_or(0.)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f64) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional double x_local = 4;

    pub fn x_local(&self) -> f64 {
        self.x_local.unwrap_or(0.)
    }

    pub fn clear_x_local(&mut self) {
        self.x_local = ::std::option::Option::None;
    }

    pub fn has_x_local(&self) -> bool {
        self.x_local.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x_local(&mut self, v: f64) {
        self.x_local = ::std::option::Option::Some(v);
    }

    // optional double y_local = 5;

    pub fn y_local(&self) -> f64 {
        self.y_local.unwrap_or(0.)
    }

    pub fn clear_y_local(&mut self) {
        self.y_local = ::std::option::Option::None;
    }

    pub fn has_y_local(&self) -> bool {
        self.y_local.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y_local(&mut self, v: f64) {
        self.y_local = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgBrowserPosition {
    const NAME: &'static str = "CMsgBrowserPosition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.x = ::std::option::Option::Some(is.read_double()?);
                },
                25 => {
                    self.y = ::std::option::Option::Some(is.read_double()?);
                },
                33 => {
                    self.x_local = ::std::option::Option::Some(is.read_double()?);
                },
                41 => {
                    self.y_local = ::std::option::Option::Some(is.read_double()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.x {
            my_size += 1 + 8;
        }
        if let Some(v) = self.y {
            my_size += 1 + 8;
        }
        if let Some(v) = self.x_local {
            my_size += 1 + 8;
        }
        if let Some(v) = self.y_local {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.y {
            os.write_double(3, v)?;
        }
        if let Some(v) = self.x_local {
            os.write_double(4, v)?;
        }
        if let Some(v) = self.y_local {
            os.write_double(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBrowserPosition {
        CMsgBrowserPosition::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.x_local = ::std::option::Option::None;
        self.y_local = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBrowserPosition {
        static instance: CMsgBrowserPosition = CMsgBrowserPosition {
            browser_handle: ::std::option::Option::None,
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            x_local: ::std::option::Option::None,
            y_local: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgBrowserResized)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBrowserResized {
    // message fields
    // @@protoc_insertion_point(field:CMsgBrowserResized.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBrowserResized.x)
    pub x: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgBrowserResized.y)
    pub y: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgBrowserResized.width)
    pub width: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgBrowserResized.height)
    pub height: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgBrowserResized.dpi_horizontal)
    pub dpi_horizontal: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgBrowserResized.dpi_vertical)
    pub dpi_vertical: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgBrowserResized.display_name)
    pub display_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBrowserResized.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBrowserResized {
    fn default() -> &'a CMsgBrowserResized {
        <CMsgBrowserResized as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBrowserResized {
    pub fn new() -> CMsgBrowserResized {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional double x = 2;

    pub fn x(&self) -> f64 {
        self.x.unwrap_or(0.)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f64) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional double y = 3;

    pub fn y(&self) -> f64 {
        self.y.unwrap_or(0.)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f64) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional double width = 4;

    pub fn width(&self) -> f64 {
        self.width.unwrap_or(0.)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: f64) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional double height = 5;

    pub fn height(&self) -> f64 {
        self.height.unwrap_or(0.)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: f64) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional double dpi_horizontal = 6;

    pub fn dpi_horizontal(&self) -> f64 {
        self.dpi_horizontal.unwrap_or(0.)
    }

    pub fn clear_dpi_horizontal(&mut self) {
        self.dpi_horizontal = ::std::option::Option::None;
    }

    pub fn has_dpi_horizontal(&self) -> bool {
        self.dpi_horizontal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dpi_horizontal(&mut self, v: f64) {
        self.dpi_horizontal = ::std::option::Option::Some(v);
    }

    // optional double dpi_vertical = 7;

    pub fn dpi_vertical(&self) -> f64 {
        self.dpi_vertical.unwrap_or(0.)
    }

    pub fn clear_dpi_vertical(&mut self) {
        self.dpi_vertical = ::std::option::Option::None;
    }

    pub fn has_dpi_vertical(&self) -> bool {
        self.dpi_vertical.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dpi_vertical(&mut self, v: f64) {
        self.dpi_vertical = ::std::option::Option::Some(v);
    }

    // optional string display_name = 8;

    pub fn display_name(&self) -> &str {
        match self.display_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_display_name(&mut self) {
        self.display_name = ::std::option::Option::None;
    }

    pub fn has_display_name(&self) -> bool {
        self.display_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_name(&mut self, v: ::std::string::String) {
        self.display_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display_name(&mut self) -> &mut ::std::string::String {
        if self.display_name.is_none() {
            self.display_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.display_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_display_name(&mut self) -> ::std::string::String {
        self.display_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgBrowserResized {
    const NAME: &'static str = "CMsgBrowserResized";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.x = ::std::option::Option::Some(is.read_double()?);
                },
                25 => {
                    self.y = ::std::option::Option::Some(is.read_double()?);
                },
                33 => {
                    self.width = ::std::option::Option::Some(is.read_double()?);
                },
                41 => {
                    self.height = ::std::option::Option::Some(is.read_double()?);
                },
                49 => {
                    self.dpi_horizontal = ::std::option::Option::Some(is.read_double()?);
                },
                57 => {
                    self.dpi_vertical = ::std::option::Option::Some(is.read_double()?);
                },
                66 => {
                    self.display_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.x {
            my_size += 1 + 8;
        }
        if let Some(v) = self.y {
            my_size += 1 + 8;
        }
        if let Some(v) = self.width {
            my_size += 1 + 8;
        }
        if let Some(v) = self.height {
            my_size += 1 + 8;
        }
        if let Some(v) = self.dpi_horizontal {
            my_size += 1 + 8;
        }
        if let Some(v) = self.dpi_vertical {
            my_size += 1 + 8;
        }
        if let Some(v) = self.display_name.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.y {
            os.write_double(3, v)?;
        }
        if let Some(v) = self.width {
            os.write_double(4, v)?;
        }
        if let Some(v) = self.height {
            os.write_double(5, v)?;
        }
        if let Some(v) = self.dpi_horizontal {
            os.write_double(6, v)?;
        }
        if let Some(v) = self.dpi_vertical {
            os.write_double(7, v)?;
        }
        if let Some(v) = self.display_name.as_ref() {
            os.write_string(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBrowserResized {
        CMsgBrowserResized::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.dpi_horizontal = ::std::option::Option::None;
        self.dpi_vertical = ::std::option::Option::None;
        self.display_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBrowserResized {
        static instance: CMsgBrowserResized = CMsgBrowserResized {
            browser_handle: ::std::option::Option::None,
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            dpi_horizontal: ::std::option::Option::None,
            dpi_vertical: ::std::option::Option::None,
            display_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPostURL)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPostURL {
    // message fields
    // @@protoc_insertion_point(field:CMsgPostURL.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPostURL.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgPostURL.post)
    pub post: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgPostURL.pageserial)
    pub pageserial: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPostURL.replace_entry)
    pub replace_entry: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPostURL.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPostURL {
    fn default() -> &'a CMsgPostURL {
        <CMsgPostURL as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPostURL {
    pub fn new() -> CMsgPostURL {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string post = 3;

    pub fn post(&self) -> &str {
        match self.post.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_post(&mut self) {
        self.post = ::std::option::Option::None;
    }

    pub fn has_post(&self) -> bool {
        self.post.is_some()
    }

    // Param is passed by value, moved
    pub fn set_post(&mut self, v: ::std::string::String) {
        self.post = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_post(&mut self) -> &mut ::std::string::String {
        if self.post.is_none() {
            self.post = ::std::option::Option::Some(::std::string::String::new());
        }
        self.post.as_mut().unwrap()
    }

    // Take field
    pub fn take_post(&mut self) -> ::std::string::String {
        self.post.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 pageserial = 4;

    pub fn pageserial(&self) -> u32 {
        self.pageserial.unwrap_or(0)
    }

    pub fn clear_pageserial(&mut self) {
        self.pageserial = ::std::option::Option::None;
    }

    pub fn has_pageserial(&self) -> bool {
        self.pageserial.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pageserial(&mut self, v: u32) {
        self.pageserial = ::std::option::Option::Some(v);
    }

    // optional bool replace_entry = 5;

    pub fn replace_entry(&self) -> bool {
        self.replace_entry.unwrap_or(false)
    }

    pub fn clear_replace_entry(&mut self) {
        self.replace_entry = ::std::option::Option::None;
    }

    pub fn has_replace_entry(&self) -> bool {
        self.replace_entry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replace_entry(&mut self, v: bool) {
        self.replace_entry = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgPostURL {
    const NAME: &'static str = "CMsgPostURL";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.post = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.pageserial = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.replace_entry = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.post.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.pageserial {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.replace_entry {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.post.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.pageserial {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.replace_entry {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPostURL {
        CMsgPostURL::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.post = ::std::option::Option::None;
        self.pageserial = ::std::option::Option::None;
        self.replace_entry = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPostURL {
        static instance: CMsgPostURL = CMsgPostURL {
            browser_handle: ::std::option::Option::None,
            url: ::std::option::Option::None,
            post: ::std::option::Option::None,
            pageserial: ::std::option::Option::None,
            replace_entry: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgAddHeader)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAddHeader {
    // message fields
    // @@protoc_insertion_point(field:CMsgAddHeader.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgAddHeader.key)
    pub key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgAddHeader.value)
    pub value: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAddHeader.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAddHeader {
    fn default() -> &'a CMsgAddHeader {
        <CMsgAddHeader as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAddHeader {
    pub fn new() -> CMsgAddHeader {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string key = 2;

    pub fn key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 3;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgAddHeader {
    const NAME: &'static str = "CMsgAddHeader";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.key = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.key.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAddHeader {
        CMsgAddHeader::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.key = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAddHeader {
        static instance: CMsgAddHeader = CMsgAddHeader {
            browser_handle: ::std::option::Option::None,
            key: ::std::option::Option::None,
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgStopLoad)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgStopLoad {
    // message fields
    // @@protoc_insertion_point(field:CMsgStopLoad.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgStopLoad.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgStopLoad {
    fn default() -> &'a CMsgStopLoad {
        <CMsgStopLoad as ::protobuf::Message>::default_instance()
    }
}

impl CMsgStopLoad {
    pub fn new() -> CMsgStopLoad {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgStopLoad {
    const NAME: &'static str = "CMsgStopLoad";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgStopLoad {
        CMsgStopLoad::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgStopLoad {
        static instance: CMsgStopLoad = CMsgStopLoad {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgReload)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgReload {
    // message fields
    // @@protoc_insertion_point(field:CMsgReload.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgReload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgReload {
    fn default() -> &'a CMsgReload {
        <CMsgReload as ::protobuf::Message>::default_instance()
    }
}

impl CMsgReload {
    pub fn new() -> CMsgReload {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgReload {
    const NAME: &'static str = "CMsgReload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgReload {
        CMsgReload::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgReload {
        static instance: CMsgReload = CMsgReload {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGoForward)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGoForward {
    // message fields
    // @@protoc_insertion_point(field:CMsgGoForward.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGoForward.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGoForward {
    fn default() -> &'a CMsgGoForward {
        <CMsgGoForward as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGoForward {
    pub fn new() -> CMsgGoForward {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGoForward {
    const NAME: &'static str = "CMsgGoForward";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGoForward {
        CMsgGoForward::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGoForward {
        static instance: CMsgGoForward = CMsgGoForward {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGoBack)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGoBack {
    // message fields
    // @@protoc_insertion_point(field:CMsgGoBack.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGoBack.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGoBack {
    fn default() -> &'a CMsgGoBack {
        <CMsgGoBack as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGoBack {
    pub fn new() -> CMsgGoBack {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGoBack {
    const NAME: &'static str = "CMsgGoBack";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGoBack {
        CMsgGoBack::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGoBack {
        static instance: CMsgGoBack = CMsgGoBack {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgWasHidden)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgWasHidden {
    // message fields
    // @@protoc_insertion_point(field:CMsgWasHidden.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgWasHidden.hidden)
    pub hidden: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgWasHidden.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgWasHidden {
    fn default() -> &'a CMsgWasHidden {
        <CMsgWasHidden as ::protobuf::Message>::default_instance()
    }
}

impl CMsgWasHidden {
    pub fn new() -> CMsgWasHidden {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional bool hidden = 2;

    pub fn hidden(&self) -> bool {
        self.hidden.unwrap_or(false)
    }

    pub fn clear_hidden(&mut self) {
        self.hidden = ::std::option::Option::None;
    }

    pub fn has_hidden(&self) -> bool {
        self.hidden.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hidden(&mut self, v: bool) {
        self.hidden = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgWasHidden {
    const NAME: &'static str = "CMsgWasHidden";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.hidden = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.hidden {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.hidden {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgWasHidden {
        CMsgWasHidden::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.hidden = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgWasHidden {
        static instance: CMsgWasHidden = CMsgWasHidden {
            browser_handle: ::std::option::Option::None,
            hidden: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSetWindowVisibility)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetWindowVisibility {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetWindowVisibility.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetWindowVisibility.visible)
    pub visible: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetWindowVisibility.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetWindowVisibility {
    fn default() -> &'a CMsgSetWindowVisibility {
        <CMsgSetWindowVisibility as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetWindowVisibility {
    pub fn new() -> CMsgSetWindowVisibility {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional bool visible = 2;

    pub fn visible(&self) -> bool {
        self.visible.unwrap_or(false)
    }

    pub fn clear_visible(&mut self) {
        self.visible = ::std::option::Option::None;
    }

    pub fn has_visible(&self) -> bool {
        self.visible.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visible(&mut self, v: bool) {
        self.visible = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSetWindowVisibility {
    const NAME: &'static str = "CMsgSetWindowVisibility";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.visible = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.visible {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.visible {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetWindowVisibility {
        CMsgSetWindowVisibility::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.visible = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetWindowVisibility {
        static instance: CMsgSetWindowVisibility = CMsgSetWindowVisibility {
            browser_handle: ::std::option::Option::None,
            visible: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClearHistory)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClearHistory {
    // message fields
    // @@protoc_insertion_point(field:CMsgClearHistory.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClearHistory.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClearHistory {
    fn default() -> &'a CMsgClearHistory {
        <CMsgClearHistory as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClearHistory {
    pub fn new() -> CMsgClearHistory {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClearHistory {
    const NAME: &'static str = "CMsgClearHistory";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClearHistory {
        CMsgClearHistory::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClearHistory {
        static instance: CMsgClearHistory = CMsgClearHistory {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClearAllBrowsingData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClearAllBrowsingData {
    // message fields
    // @@protoc_insertion_point(field:CMsgClearAllBrowsingData.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClearAllBrowsingData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClearAllBrowsingData {
    fn default() -> &'a CMsgClearAllBrowsingData {
        <CMsgClearAllBrowsingData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClearAllBrowsingData {
    pub fn new() -> CMsgClearAllBrowsingData {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClearAllBrowsingData {
    const NAME: &'static str = "CMsgClearAllBrowsingData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClearAllBrowsingData {
        CMsgClearAllBrowsingData::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClearAllBrowsingData {
        static instance: CMsgClearAllBrowsingData = CMsgClearAllBrowsingData {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgCopy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCopy {
    // message fields
    // @@protoc_insertion_point(field:CMsgCopy.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCopy.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCopy {
    fn default() -> &'a CMsgCopy {
        <CMsgCopy as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCopy {
    pub fn new() -> CMsgCopy {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgCopy {
    const NAME: &'static str = "CMsgCopy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCopy {
        CMsgCopy::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCopy {
        static instance: CMsgCopy = CMsgCopy {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPaste)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPaste {
    // message fields
    // @@protoc_insertion_point(field:CMsgPaste.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPaste.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPaste {
    fn default() -> &'a CMsgPaste {
        <CMsgPaste as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPaste {
    pub fn new() -> CMsgPaste {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgPaste {
    const NAME: &'static str = "CMsgPaste";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPaste {
        CMsgPaste::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPaste {
        static instance: CMsgPaste = CMsgPaste {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgExecuteJavaScript)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgExecuteJavaScript {
    // message fields
    // @@protoc_insertion_point(field:CMsgExecuteJavaScript.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgExecuteJavaScript.script)
    pub script: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgExecuteJavaScript.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgExecuteJavaScript {
    fn default() -> &'a CMsgExecuteJavaScript {
        <CMsgExecuteJavaScript as ::protobuf::Message>::default_instance()
    }
}

impl CMsgExecuteJavaScript {
    pub fn new() -> CMsgExecuteJavaScript {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string script = 2;

    pub fn script(&self) -> &str {
        match self.script.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_script(&mut self) {
        self.script = ::std::option::Option::None;
    }

    pub fn has_script(&self) -> bool {
        self.script.is_some()
    }

    // Param is passed by value, moved
    pub fn set_script(&mut self, v: ::std::string::String) {
        self.script = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_script(&mut self) -> &mut ::std::string::String {
        if self.script.is_none() {
            self.script = ::std::option::Option::Some(::std::string::String::new());
        }
        self.script.as_mut().unwrap()
    }

    // Take field
    pub fn take_script(&mut self) -> ::std::string::String {
        self.script.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgExecuteJavaScript {
    const NAME: &'static str = "CMsgExecuteJavaScript";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.script = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.script.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.script.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgExecuteJavaScript {
        CMsgExecuteJavaScript::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.script = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgExecuteJavaScript {
        static instance: CMsgExecuteJavaScript = CMsgExecuteJavaScript {
            browser_handle: ::std::option::Option::None,
            script: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSetFocus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetFocus {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetFocus.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetFocus.focus)
    pub focus: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetFocus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetFocus {
    fn default() -> &'a CMsgSetFocus {
        <CMsgSetFocus as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetFocus {
    pub fn new() -> CMsgSetFocus {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional bool focus = 2;

    pub fn focus(&self) -> bool {
        self.focus.unwrap_or(false)
    }

    pub fn clear_focus(&mut self) {
        self.focus = ::std::option::Option::None;
    }

    pub fn has_focus(&self) -> bool {
        self.focus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_focus(&mut self, v: bool) {
        self.focus = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSetFocus {
    const NAME: &'static str = "CMsgSetFocus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.focus = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.focus {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.focus {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetFocus {
        CMsgSetFocus::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.focus = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetFocus {
        static instance: CMsgSetFocus = CMsgSetFocus {
            browser_handle: ::std::option::Option::None,
            focus: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgHorizontalScrollBarSize)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgHorizontalScrollBarSize {
    // message fields
    // @@protoc_insertion_point(field:CMsgHorizontalScrollBarSize.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgHorizontalScrollBarSize.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgHorizontalScrollBarSize {
    fn default() -> &'a CMsgHorizontalScrollBarSize {
        <CMsgHorizontalScrollBarSize as ::protobuf::Message>::default_instance()
    }
}

impl CMsgHorizontalScrollBarSize {
    pub fn new() -> CMsgHorizontalScrollBarSize {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgHorizontalScrollBarSize {
    const NAME: &'static str = "CMsgHorizontalScrollBarSize";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgHorizontalScrollBarSize {
        CMsgHorizontalScrollBarSize::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgHorizontalScrollBarSize {
        static instance: CMsgHorizontalScrollBarSize = CMsgHorizontalScrollBarSize {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgHorizontalScrollBarSizeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgHorizontalScrollBarSizeResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgHorizontalScrollBarSizeResponse.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHorizontalScrollBarSizeResponse.scroll_max)
    pub scroll_max: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHorizontalScrollBarSizeResponse.scroll)
    pub scroll: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHorizontalScrollBarSizeResponse.zoom)
    pub zoom: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgHorizontalScrollBarSizeResponse.visible)
    pub visible: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgHorizontalScrollBarSizeResponse.page_size)
    pub page_size: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgHorizontalScrollBarSizeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgHorizontalScrollBarSizeResponse {
    fn default() -> &'a CMsgHorizontalScrollBarSizeResponse {
        <CMsgHorizontalScrollBarSizeResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgHorizontalScrollBarSizeResponse {
    pub fn new() -> CMsgHorizontalScrollBarSizeResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 scroll_max = 6;

    pub fn scroll_max(&self) -> u32 {
        self.scroll_max.unwrap_or(0)
    }

    pub fn clear_scroll_max(&mut self) {
        self.scroll_max = ::std::option::Option::None;
    }

    pub fn has_scroll_max(&self) -> bool {
        self.scroll_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scroll_max(&mut self, v: u32) {
        self.scroll_max = ::std::option::Option::Some(v);
    }

    // optional uint32 scroll = 7;

    pub fn scroll(&self) -> u32 {
        self.scroll.unwrap_or(0)
    }

    pub fn clear_scroll(&mut self) {
        self.scroll = ::std::option::Option::None;
    }

    pub fn has_scroll(&self) -> bool {
        self.scroll.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scroll(&mut self, v: u32) {
        self.scroll = ::std::option::Option::Some(v);
    }

    // optional float zoom = 8;

    pub fn zoom(&self) -> f32 {
        self.zoom.unwrap_or(0.)
    }

    pub fn clear_zoom(&mut self) {
        self.zoom = ::std::option::Option::None;
    }

    pub fn has_zoom(&self) -> bool {
        self.zoom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_zoom(&mut self, v: f32) {
        self.zoom = ::std::option::Option::Some(v);
    }

    // optional bool visible = 9;

    pub fn visible(&self) -> bool {
        self.visible.unwrap_or(false)
    }

    pub fn clear_visible(&mut self) {
        self.visible = ::std::option::Option::None;
    }

    pub fn has_visible(&self) -> bool {
        self.visible.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visible(&mut self, v: bool) {
        self.visible = ::std::option::Option::Some(v);
    }

    // optional uint32 page_size = 10;

    pub fn page_size(&self) -> u32 {
        self.page_size.unwrap_or(0)
    }

    pub fn clear_page_size(&mut self) {
        self.page_size = ::std::option::Option::None;
    }

    pub fn has_page_size(&self) -> bool {
        self.page_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: u32) {
        self.page_size = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgHorizontalScrollBarSizeResponse {
    const NAME: &'static str = "CMsgHorizontalScrollBarSizeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.scroll_max = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.scroll = ::std::option::Option::Some(is.read_uint32()?);
                },
                69 => {
                    self.zoom = ::std::option::Option::Some(is.read_float()?);
                },
                72 => {
                    self.visible = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.page_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.scroll_max {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.scroll {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.zoom {
            my_size += 1 + 4;
        }
        if let Some(v) = self.visible {
            my_size += 1 + 1;
        }
        if let Some(v) = self.page_size {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.scroll_max {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.scroll {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.zoom {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.visible {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.page_size {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgHorizontalScrollBarSizeResponse {
        CMsgHorizontalScrollBarSizeResponse::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.scroll_max = ::std::option::Option::None;
        self.scroll = ::std::option::Option::None;
        self.zoom = ::std::option::Option::None;
        self.visible = ::std::option::Option::None;
        self.page_size = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgHorizontalScrollBarSizeResponse {
        static instance: CMsgHorizontalScrollBarSizeResponse = CMsgHorizontalScrollBarSizeResponse {
            browser_handle: ::std::option::Option::None,
            scroll_max: ::std::option::Option::None,
            scroll: ::std::option::Option::None,
            zoom: ::std::option::Option::None,
            visible: ::std::option::Option::None,
            page_size: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgVerticalScrollBarSize)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgVerticalScrollBarSize {
    // message fields
    // @@protoc_insertion_point(field:CMsgVerticalScrollBarSize.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgVerticalScrollBarSize.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgVerticalScrollBarSize {
    fn default() -> &'a CMsgVerticalScrollBarSize {
        <CMsgVerticalScrollBarSize as ::protobuf::Message>::default_instance()
    }
}

impl CMsgVerticalScrollBarSize {
    pub fn new() -> CMsgVerticalScrollBarSize {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgVerticalScrollBarSize {
    const NAME: &'static str = "CMsgVerticalScrollBarSize";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgVerticalScrollBarSize {
        CMsgVerticalScrollBarSize::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgVerticalScrollBarSize {
        static instance: CMsgVerticalScrollBarSize = CMsgVerticalScrollBarSize {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgVerticalScrollBarSizeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgVerticalScrollBarSizeResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgVerticalScrollBarSizeResponse.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgVerticalScrollBarSizeResponse.scroll_max)
    pub scroll_max: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgVerticalScrollBarSizeResponse.scroll)
    pub scroll: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgVerticalScrollBarSizeResponse.zoom)
    pub zoom: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgVerticalScrollBarSizeResponse.visible)
    pub visible: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgVerticalScrollBarSizeResponse.page_size)
    pub page_size: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgVerticalScrollBarSizeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgVerticalScrollBarSizeResponse {
    fn default() -> &'a CMsgVerticalScrollBarSizeResponse {
        <CMsgVerticalScrollBarSizeResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgVerticalScrollBarSizeResponse {
    pub fn new() -> CMsgVerticalScrollBarSizeResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 scroll_max = 6;

    pub fn scroll_max(&self) -> u32 {
        self.scroll_max.unwrap_or(0)
    }

    pub fn clear_scroll_max(&mut self) {
        self.scroll_max = ::std::option::Option::None;
    }

    pub fn has_scroll_max(&self) -> bool {
        self.scroll_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scroll_max(&mut self, v: u32) {
        self.scroll_max = ::std::option::Option::Some(v);
    }

    // optional uint32 scroll = 7;

    pub fn scroll(&self) -> u32 {
        self.scroll.unwrap_or(0)
    }

    pub fn clear_scroll(&mut self) {
        self.scroll = ::std::option::Option::None;
    }

    pub fn has_scroll(&self) -> bool {
        self.scroll.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scroll(&mut self, v: u32) {
        self.scroll = ::std::option::Option::Some(v);
    }

    // optional float zoom = 8;

    pub fn zoom(&self) -> f32 {
        self.zoom.unwrap_or(0.)
    }

    pub fn clear_zoom(&mut self) {
        self.zoom = ::std::option::Option::None;
    }

    pub fn has_zoom(&self) -> bool {
        self.zoom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_zoom(&mut self, v: f32) {
        self.zoom = ::std::option::Option::Some(v);
    }

    // optional bool visible = 9;

    pub fn visible(&self) -> bool {
        self.visible.unwrap_or(false)
    }

    pub fn clear_visible(&mut self) {
        self.visible = ::std::option::Option::None;
    }

    pub fn has_visible(&self) -> bool {
        self.visible.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visible(&mut self, v: bool) {
        self.visible = ::std::option::Option::Some(v);
    }

    // optional uint32 page_size = 10;

    pub fn page_size(&self) -> u32 {
        self.page_size.unwrap_or(0)
    }

    pub fn clear_page_size(&mut self) {
        self.page_size = ::std::option::Option::None;
    }

    pub fn has_page_size(&self) -> bool {
        self.page_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: u32) {
        self.page_size = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgVerticalScrollBarSizeResponse {
    const NAME: &'static str = "CMsgVerticalScrollBarSizeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.scroll_max = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.scroll = ::std::option::Option::Some(is.read_uint32()?);
                },
                69 => {
                    self.zoom = ::std::option::Option::Some(is.read_float()?);
                },
                72 => {
                    self.visible = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.page_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.scroll_max {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.scroll {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.zoom {
            my_size += 1 + 4;
        }
        if let Some(v) = self.visible {
            my_size += 1 + 1;
        }
        if let Some(v) = self.page_size {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.scroll_max {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.scroll {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.zoom {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.visible {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.page_size {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgVerticalScrollBarSizeResponse {
        CMsgVerticalScrollBarSizeResponse::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.scroll_max = ::std::option::Option::None;
        self.scroll = ::std::option::Option::None;
        self.zoom = ::std::option::Option::None;
        self.visible = ::std::option::Option::None;
        self.page_size = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgVerticalScrollBarSizeResponse {
        static instance: CMsgVerticalScrollBarSizeResponse = CMsgVerticalScrollBarSizeResponse {
            browser_handle: ::std::option::Option::None,
            scroll_max: ::std::option::Option::None,
            scroll: ::std::option::Option::None,
            zoom: ::std::option::Option::None,
            visible: ::std::option::Option::None,
            page_size: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgFind)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFind {
    // message fields
    // @@protoc_insertion_point(field:CMsgFind.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgFind.find)
    pub find: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgFind.infind)
    pub infind: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgFind.reverse)
    pub reverse: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFind.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFind {
    fn default() -> &'a CMsgFind {
        <CMsgFind as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFind {
    pub fn new() -> CMsgFind {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string find = 2;

    pub fn find(&self) -> &str {
        match self.find.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_find(&mut self) {
        self.find = ::std::option::Option::None;
    }

    pub fn has_find(&self) -> bool {
        self.find.is_some()
    }

    // Param is passed by value, moved
    pub fn set_find(&mut self, v: ::std::string::String) {
        self.find = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_find(&mut self) -> &mut ::std::string::String {
        if self.find.is_none() {
            self.find = ::std::option::Option::Some(::std::string::String::new());
        }
        self.find.as_mut().unwrap()
    }

    // Take field
    pub fn take_find(&mut self) -> ::std::string::String {
        self.find.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool infind = 3;

    pub fn infind(&self) -> bool {
        self.infind.unwrap_or(false)
    }

    pub fn clear_infind(&mut self) {
        self.infind = ::std::option::Option::None;
    }

    pub fn has_infind(&self) -> bool {
        self.infind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_infind(&mut self, v: bool) {
        self.infind = ::std::option::Option::Some(v);
    }

    // optional bool reverse = 4;

    pub fn reverse(&self) -> bool {
        self.reverse.unwrap_or(false)
    }

    pub fn clear_reverse(&mut self) {
        self.reverse = ::std::option::Option::None;
    }

    pub fn has_reverse(&self) -> bool {
        self.reverse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reverse(&mut self, v: bool) {
        self.reverse = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgFind {
    const NAME: &'static str = "CMsgFind";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.find = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.infind = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.reverse = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.find.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.infind {
            my_size += 1 + 1;
        }
        if let Some(v) = self.reverse {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.find.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.infind {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.reverse {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFind {
        CMsgFind::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.find = ::std::option::Option::None;
        self.infind = ::std::option::Option::None;
        self.reverse = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFind {
        static instance: CMsgFind = CMsgFind {
            browser_handle: ::std::option::Option::None,
            find: ::std::option::Option::None,
            infind: ::std::option::Option::None,
            reverse: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgStopFind)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgStopFind {
    // message fields
    // @@protoc_insertion_point(field:CMsgStopFind.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgStopFind.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgStopFind {
    fn default() -> &'a CMsgStopFind {
        <CMsgStopFind as ::protobuf::Message>::default_instance()
    }
}

impl CMsgStopFind {
    pub fn new() -> CMsgStopFind {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgStopFind {
    const NAME: &'static str = "CMsgStopFind";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgStopFind {
        CMsgStopFind::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgStopFind {
        static instance: CMsgStopFind = CMsgStopFind {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSetHorizontalScroll)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetHorizontalScroll {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetHorizontalScroll.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetHorizontalScroll.scroll)
    pub scroll: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetHorizontalScroll.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetHorizontalScroll {
    fn default() -> &'a CMsgSetHorizontalScroll {
        <CMsgSetHorizontalScroll as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetHorizontalScroll {
    pub fn new() -> CMsgSetHorizontalScroll {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 scroll = 2;

    pub fn scroll(&self) -> u32 {
        self.scroll.unwrap_or(0)
    }

    pub fn clear_scroll(&mut self) {
        self.scroll = ::std::option::Option::None;
    }

    pub fn has_scroll(&self) -> bool {
        self.scroll.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scroll(&mut self, v: u32) {
        self.scroll = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSetHorizontalScroll {
    const NAME: &'static str = "CMsgSetHorizontalScroll";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.scroll = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.scroll {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.scroll {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetHorizontalScroll {
        CMsgSetHorizontalScroll::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.scroll = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetHorizontalScroll {
        static instance: CMsgSetHorizontalScroll = CMsgSetHorizontalScroll {
            browser_handle: ::std::option::Option::None,
            scroll: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSetVerticalScroll)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetVerticalScroll {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetVerticalScroll.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetVerticalScroll.scroll)
    pub scroll: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetVerticalScroll.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetVerticalScroll {
    fn default() -> &'a CMsgSetVerticalScroll {
        <CMsgSetVerticalScroll as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetVerticalScroll {
    pub fn new() -> CMsgSetVerticalScroll {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 scroll = 2;

    pub fn scroll(&self) -> u32 {
        self.scroll.unwrap_or(0)
    }

    pub fn clear_scroll(&mut self) {
        self.scroll = ::std::option::Option::None;
    }

    pub fn has_scroll(&self) -> bool {
        self.scroll.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scroll(&mut self, v: u32) {
        self.scroll = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSetVerticalScroll {
    const NAME: &'static str = "CMsgSetVerticalScroll";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.scroll = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.scroll {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.scroll {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetVerticalScroll {
        CMsgSetVerticalScroll::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.scroll = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetVerticalScroll {
        static instance: CMsgSetVerticalScroll = CMsgSetVerticalScroll {
            browser_handle: ::std::option::Option::None,
            scroll: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSetZoomLevel)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetZoomLevel {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetZoomLevel.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetZoomLevel.zoom)
    pub zoom: ::std::option::Option<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetZoomLevel.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetZoomLevel {
    fn default() -> &'a CMsgSetZoomLevel {
        <CMsgSetZoomLevel as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetZoomLevel {
    pub fn new() -> CMsgSetZoomLevel {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional double zoom = 2;

    pub fn zoom(&self) -> f64 {
        self.zoom.unwrap_or(0.)
    }

    pub fn clear_zoom(&mut self) {
        self.zoom = ::std::option::Option::None;
    }

    pub fn has_zoom(&self) -> bool {
        self.zoom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_zoom(&mut self, v: f64) {
        self.zoom = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSetZoomLevel {
    const NAME: &'static str = "CMsgSetZoomLevel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.zoom = ::std::option::Option::Some(is.read_double()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.zoom {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.zoom {
            os.write_double(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetZoomLevel {
        CMsgSetZoomLevel::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.zoom = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetZoomLevel {
        static instance: CMsgSetZoomLevel = CMsgSetZoomLevel {
            browser_handle: ::std::option::Option::None,
            zoom: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgViewSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgViewSource {
    // message fields
    // @@protoc_insertion_point(field:CMsgViewSource.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgViewSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgViewSource {
    fn default() -> &'a CMsgViewSource {
        <CMsgViewSource as ::protobuf::Message>::default_instance()
    }
}

impl CMsgViewSource {
    pub fn new() -> CMsgViewSource {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgViewSource {
    const NAME: &'static str = "CMsgViewSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgViewSource {
        CMsgViewSource::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgViewSource {
        static instance: CMsgViewSource = CMsgViewSource {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgBrowserReady)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBrowserReady {
    // message fields
    // @@protoc_insertion_point(field:CMsgBrowserReady.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBrowserReady.vr_overlay_key)
    pub vr_overlay_key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgBrowserReady.hwnd_browser)
    pub hwnd_browser: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBrowserReady.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBrowserReady {
    fn default() -> &'a CMsgBrowserReady {
        <CMsgBrowserReady as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBrowserReady {
    pub fn new() -> CMsgBrowserReady {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string vr_overlay_key = 2;

    pub fn vr_overlay_key(&self) -> &str {
        match self.vr_overlay_key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_vr_overlay_key(&mut self) {
        self.vr_overlay_key = ::std::option::Option::None;
    }

    pub fn has_vr_overlay_key(&self) -> bool {
        self.vr_overlay_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vr_overlay_key(&mut self, v: ::std::string::String) {
        self.vr_overlay_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vr_overlay_key(&mut self) -> &mut ::std::string::String {
        if self.vr_overlay_key.is_none() {
            self.vr_overlay_key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.vr_overlay_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_vr_overlay_key(&mut self) -> ::std::string::String {
        self.vr_overlay_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 hwnd_browser = 3;

    pub fn hwnd_browser(&self) -> u64 {
        self.hwnd_browser.unwrap_or(0)
    }

    pub fn clear_hwnd_browser(&mut self) {
        self.hwnd_browser = ::std::option::Option::None;
    }

    pub fn has_hwnd_browser(&self) -> bool {
        self.hwnd_browser.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hwnd_browser(&mut self, v: u64) {
        self.hwnd_browser = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgBrowserReady {
    const NAME: &'static str = "CMsgBrowserReady";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.vr_overlay_key = ::std::option::Option::Some(is.read_string()?);
                },
                25 => {
                    self.hwnd_browser = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.vr_overlay_key.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.hwnd_browser {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.vr_overlay_key.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.hwnd_browser {
            os.write_fixed64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBrowserReady {
        CMsgBrowserReady::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.vr_overlay_key = ::std::option::Option::None;
        self.hwnd_browser = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBrowserReady {
        static instance: CMsgBrowserReady = CMsgBrowserReady {
            browser_handle: ::std::option::Option::None,
            vr_overlay_key: ::std::option::Option::None,
            hwnd_browser: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgURLChanged)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgURLChanged {
    // message fields
    // @@protoc_insertion_point(field:CMsgURLChanged.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgURLChanged.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgURLChanged.postData)
    pub postData: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgURLChanged.bIsRedirect)
    pub bIsRedirect: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgURLChanged.pagetitle)
    pub pagetitle: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgURLChanged.bNewNavigation)
    pub bNewNavigation: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgURLChanged.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgURLChanged {
    fn default() -> &'a CMsgURLChanged {
        <CMsgURLChanged as ::protobuf::Message>::default_instance()
    }
}

impl CMsgURLChanged {
    pub fn new() -> CMsgURLChanged {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string postData = 3;

    pub fn postData(&self) -> &str {
        match self.postData.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_postData(&mut self) {
        self.postData = ::std::option::Option::None;
    }

    pub fn has_postData(&self) -> bool {
        self.postData.is_some()
    }

    // Param is passed by value, moved
    pub fn set_postData(&mut self, v: ::std::string::String) {
        self.postData = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_postData(&mut self) -> &mut ::std::string::String {
        if self.postData.is_none() {
            self.postData = ::std::option::Option::Some(::std::string::String::new());
        }
        self.postData.as_mut().unwrap()
    }

    // Take field
    pub fn take_postData(&mut self) -> ::std::string::String {
        self.postData.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool bIsRedirect = 4;

    pub fn bIsRedirect(&self) -> bool {
        self.bIsRedirect.unwrap_or(false)
    }

    pub fn clear_bIsRedirect(&mut self) {
        self.bIsRedirect = ::std::option::Option::None;
    }

    pub fn has_bIsRedirect(&self) -> bool {
        self.bIsRedirect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bIsRedirect(&mut self, v: bool) {
        self.bIsRedirect = ::std::option::Option::Some(v);
    }

    // optional string pagetitle = 5;

    pub fn pagetitle(&self) -> &str {
        match self.pagetitle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pagetitle(&mut self) {
        self.pagetitle = ::std::option::Option::None;
    }

    pub fn has_pagetitle(&self) -> bool {
        self.pagetitle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagetitle(&mut self, v: ::std::string::String) {
        self.pagetitle = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pagetitle(&mut self) -> &mut ::std::string::String {
        if self.pagetitle.is_none() {
            self.pagetitle = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pagetitle.as_mut().unwrap()
    }

    // Take field
    pub fn take_pagetitle(&mut self) -> ::std::string::String {
        self.pagetitle.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool bNewNavigation = 6;

    pub fn bNewNavigation(&self) -> bool {
        self.bNewNavigation.unwrap_or(false)
    }

    pub fn clear_bNewNavigation(&mut self) {
        self.bNewNavigation = ::std::option::Option::None;
    }

    pub fn has_bNewNavigation(&self) -> bool {
        self.bNewNavigation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bNewNavigation(&mut self, v: bool) {
        self.bNewNavigation = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgURLChanged {
    const NAME: &'static str = "CMsgURLChanged";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.postData = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.bIsRedirect = ::std::option::Option::Some(is.read_bool()?);
                },
                42 => {
                    self.pagetitle = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.bNewNavigation = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.postData.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.bIsRedirect {
            my_size += 1 + 1;
        }
        if let Some(v) = self.pagetitle.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.bNewNavigation {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.postData.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.bIsRedirect {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.pagetitle.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.bNewNavigation {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgURLChanged {
        CMsgURLChanged::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.postData = ::std::option::Option::None;
        self.bIsRedirect = ::std::option::Option::None;
        self.pagetitle = ::std::option::Option::None;
        self.bNewNavigation = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgURLChanged {
        static instance: CMsgURLChanged = CMsgURLChanged {
            browser_handle: ::std::option::Option::None,
            url: ::std::option::Option::None,
            postData: ::std::option::Option::None,
            bIsRedirect: ::std::option::Option::None,
            pagetitle: ::std::option::Option::None,
            bNewNavigation: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CHistoryEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CHistoryEntry {
    // message fields
    // @@protoc_insertion_point(field:CHistoryEntry.url)
    pub url: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CHistoryEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CHistoryEntry {
    fn default() -> &'a CHistoryEntry {
        <CHistoryEntry as ::protobuf::Message>::default_instance()
    }
}

impl CHistoryEntry {
    pub fn new() -> CHistoryEntry {
        ::std::default::Default::default()
    }

    // optional string url = 1;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CHistoryEntry {
    const NAME: &'static str = "CHistoryEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.url.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CHistoryEntry {
        CHistoryEntry::new()
    }

    fn clear(&mut self) {
        self.url = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CHistoryEntry {
        static instance: CHistoryEntry = CHistoryEntry {
            url: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgHistoryChanged)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgHistoryChanged {
    // message fields
    // @@protoc_insertion_point(field:CMsgHistoryChanged.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHistoryChanged.index)
    pub index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHistoryChanged.entries)
    pub entries: ::std::vec::Vec<CHistoryEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgHistoryChanged.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgHistoryChanged {
    fn default() -> &'a CMsgHistoryChanged {
        <CMsgHistoryChanged as ::protobuf::Message>::default_instance()
    }
}

impl CMsgHistoryChanged {
    pub fn new() -> CMsgHistoryChanged {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 index = 2;

    pub fn index(&self) -> u32 {
        self.index.unwrap_or(0)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: u32) {
        self.index = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgHistoryChanged {
    const NAME: &'static str = "CMsgHistoryChanged";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.index = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.entries.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.index {
            os.write_uint32(2, v)?;
        }
        for v in &self.entries {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgHistoryChanged {
        CMsgHistoryChanged::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.index = ::std::option::Option::None;
        self.entries.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgHistoryChanged {
        static instance: CMsgHistoryChanged = CMsgHistoryChanged {
            browser_handle: ::std::option::Option::None,
            index: ::std::option::Option::None,
            entries: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgLoadError)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLoadError {
    // message fields
    // @@protoc_insertion_point(field:CMsgLoadError.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLoadError.error_code)
    pub error_code: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgLoadError.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgLoadError.error_description)
    pub error_description: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLoadError.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLoadError {
    fn default() -> &'a CMsgLoadError {
        <CMsgLoadError as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLoadError {
    pub fn new() -> CMsgLoadError {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional int32 error_code = 2;

    pub fn error_code(&self) -> i32 {
        self.error_code.unwrap_or(0)
    }

    pub fn clear_error_code(&mut self) {
        self.error_code = ::std::option::Option::None;
    }

    pub fn has_error_code(&self) -> bool {
        self.error_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_code(&mut self, v: i32) {
        self.error_code = ::std::option::Option::Some(v);
    }

    // optional string url = 3;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string error_description = 4;

    pub fn error_description(&self) -> &str {
        match self.error_description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error_description(&mut self) {
        self.error_description = ::std::option::Option::None;
    }

    pub fn has_error_description(&self) -> bool {
        self.error_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_description(&mut self, v: ::std::string::String) {
        self.error_description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_description(&mut self) -> &mut ::std::string::String {
        if self.error_description.is_none() {
            self.error_description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_description(&mut self) -> ::std::string::String {
        self.error_description.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgLoadError {
    const NAME: &'static str = "CMsgLoadError";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.error_code = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.error_description = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.error_code {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.error_description.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.error_code {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.error_description.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLoadError {
        CMsgLoadError::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.error_code = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.error_description = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLoadError {
        static instance: CMsgLoadError = CMsgLoadError {
            browser_handle: ::std::option::Option::None,
            error_code: ::std::option::Option::None,
            url: ::std::option::Option::None,
            error_description: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CHTMLHeader)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CHTMLHeader {
    // message fields
    // @@protoc_insertion_point(field:CHTMLHeader.key)
    pub key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CHTMLHeader.value)
    pub value: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CHTMLHeader.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CHTMLHeader {
    fn default() -> &'a CHTMLHeader {
        <CHTMLHeader as ::protobuf::Message>::default_instance()
    }
}

impl CHTMLHeader {
    pub fn new() -> CHTMLHeader {
        ::std::default::Default::default()
    }

    // optional string key = 1;

    pub fn key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 2;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CHTMLHeader {
    const NAME: &'static str = "CHTMLHeader";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CHTMLHeader {
        CHTMLHeader::new()
    }

    fn clear(&mut self) {
        self.key = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CHTMLHeader {
        static instance: CHTMLHeader = CHTMLHeader {
            key: ::std::option::Option::None,
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CHTMLPageSecurityInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CHTMLPageSecurityInfo {
    // message fields
    // @@protoc_insertion_point(field:CHTMLPageSecurityInfo.bIsSecure)
    pub bIsSecure: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CHTMLPageSecurityInfo.bHasCertError)
    pub bHasCertError: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CHTMLPageSecurityInfo.issuerName)
    pub issuerName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CHTMLPageSecurityInfo.certName)
    pub certName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CHTMLPageSecurityInfo.certExpiry)
    pub certExpiry: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CHTMLPageSecurityInfo.nCertBits)
    pub nCertBits: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CHTMLPageSecurityInfo.bIsEVCert)
    pub bIsEVCert: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CHTMLPageSecurityInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CHTMLPageSecurityInfo {
    fn default() -> &'a CHTMLPageSecurityInfo {
        <CHTMLPageSecurityInfo as ::protobuf::Message>::default_instance()
    }
}

impl CHTMLPageSecurityInfo {
    pub fn new() -> CHTMLPageSecurityInfo {
        ::std::default::Default::default()
    }

    // optional bool bIsSecure = 1;

    pub fn bIsSecure(&self) -> bool {
        self.bIsSecure.unwrap_or(false)
    }

    pub fn clear_bIsSecure(&mut self) {
        self.bIsSecure = ::std::option::Option::None;
    }

    pub fn has_bIsSecure(&self) -> bool {
        self.bIsSecure.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bIsSecure(&mut self, v: bool) {
        self.bIsSecure = ::std::option::Option::Some(v);
    }

    // optional bool bHasCertError = 2;

    pub fn bHasCertError(&self) -> bool {
        self.bHasCertError.unwrap_or(false)
    }

    pub fn clear_bHasCertError(&mut self) {
        self.bHasCertError = ::std::option::Option::None;
    }

    pub fn has_bHasCertError(&self) -> bool {
        self.bHasCertError.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bHasCertError(&mut self, v: bool) {
        self.bHasCertError = ::std::option::Option::Some(v);
    }

    // optional string issuerName = 3;

    pub fn issuerName(&self) -> &str {
        match self.issuerName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_issuerName(&mut self) {
        self.issuerName = ::std::option::Option::None;
    }

    pub fn has_issuerName(&self) -> bool {
        self.issuerName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_issuerName(&mut self, v: ::std::string::String) {
        self.issuerName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_issuerName(&mut self) -> &mut ::std::string::String {
        if self.issuerName.is_none() {
            self.issuerName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.issuerName.as_mut().unwrap()
    }

    // Take field
    pub fn take_issuerName(&mut self) -> ::std::string::String {
        self.issuerName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string certName = 4;

    pub fn certName(&self) -> &str {
        match self.certName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_certName(&mut self) {
        self.certName = ::std::option::Option::None;
    }

    pub fn has_certName(&self) -> bool {
        self.certName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_certName(&mut self, v: ::std::string::String) {
        self.certName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_certName(&mut self) -> &mut ::std::string::String {
        if self.certName.is_none() {
            self.certName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.certName.as_mut().unwrap()
    }

    // Take field
    pub fn take_certName(&mut self) -> ::std::string::String {
        self.certName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 certExpiry = 5;

    pub fn certExpiry(&self) -> i32 {
        self.certExpiry.unwrap_or(0i32)
    }

    pub fn clear_certExpiry(&mut self) {
        self.certExpiry = ::std::option::Option::None;
    }

    pub fn has_certExpiry(&self) -> bool {
        self.certExpiry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_certExpiry(&mut self, v: i32) {
        self.certExpiry = ::std::option::Option::Some(v);
    }

    // optional int32 nCertBits = 6;

    pub fn nCertBits(&self) -> i32 {
        self.nCertBits.unwrap_or(0i32)
    }

    pub fn clear_nCertBits(&mut self) {
        self.nCertBits = ::std::option::Option::None;
    }

    pub fn has_nCertBits(&self) -> bool {
        self.nCertBits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nCertBits(&mut self, v: i32) {
        self.nCertBits = ::std::option::Option::Some(v);
    }

    // optional bool bIsEVCert = 7;

    pub fn bIsEVCert(&self) -> bool {
        self.bIsEVCert.unwrap_or(false)
    }

    pub fn clear_bIsEVCert(&mut self) {
        self.bIsEVCert = ::std::option::Option::None;
    }

    pub fn has_bIsEVCert(&self) -> bool {
        self.bIsEVCert.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bIsEVCert(&mut self, v: bool) {
        self.bIsEVCert = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CHTMLPageSecurityInfo {
    const NAME: &'static str = "CHTMLPageSecurityInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.bIsSecure = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.bHasCertError = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.issuerName = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.certName = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.certExpiry = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.nCertBits = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.bIsEVCert = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.bIsSecure {
            my_size += 1 + 1;
        }
        if let Some(v) = self.bHasCertError {
            my_size += 1 + 1;
        }
        if let Some(v) = self.issuerName.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.certName.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.certExpiry {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.nCertBits {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.bIsEVCert {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.bIsSecure {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.bHasCertError {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.issuerName.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.certName.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.certExpiry {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.nCertBits {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.bIsEVCert {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CHTMLPageSecurityInfo {
        CHTMLPageSecurityInfo::new()
    }

    fn clear(&mut self) {
        self.bIsSecure = ::std::option::Option::None;
        self.bHasCertError = ::std::option::Option::None;
        self.issuerName = ::std::option::Option::None;
        self.certName = ::std::option::Option::None;
        self.certExpiry = ::std::option::Option::None;
        self.nCertBits = ::std::option::Option::None;
        self.bIsEVCert = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CHTMLPageSecurityInfo {
        static instance: CHTMLPageSecurityInfo = CHTMLPageSecurityInfo {
            bIsSecure: ::std::option::Option::None,
            bHasCertError: ::std::option::Option::None,
            issuerName: ::std::option::Option::None,
            certName: ::std::option::Option::None,
            certExpiry: ::std::option::Option::None,
            nCertBits: ::std::option::Option::None,
            bIsEVCert: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgFinishedRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFinishedRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgFinishedRequest.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgFinishedRequest.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgFinishedRequest.pageTitle)
    pub pageTitle: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFinishedRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFinishedRequest {
    fn default() -> &'a CMsgFinishedRequest {
        <CMsgFinishedRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFinishedRequest {
    pub fn new() -> CMsgFinishedRequest {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string pageTitle = 3;

    pub fn pageTitle(&self) -> &str {
        match self.pageTitle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pageTitle(&mut self) {
        self.pageTitle = ::std::option::Option::None;
    }

    pub fn has_pageTitle(&self) -> bool {
        self.pageTitle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pageTitle(&mut self, v: ::std::string::String) {
        self.pageTitle = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pageTitle(&mut self) -> &mut ::std::string::String {
        if self.pageTitle.is_none() {
            self.pageTitle = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pageTitle.as_mut().unwrap()
    }

    // Take field
    pub fn take_pageTitle(&mut self) -> ::std::string::String {
        self.pageTitle.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgFinishedRequest {
    const NAME: &'static str = "CMsgFinishedRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.pageTitle = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.pageTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.pageTitle.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFinishedRequest {
        CMsgFinishedRequest::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.pageTitle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFinishedRequest {
        static instance: CMsgFinishedRequest = CMsgFinishedRequest {
            browser_handle: ::std::option::Option::None,
            url: ::std::option::Option::None,
            pageTitle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgLoadedRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLoadedRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgLoadedRequest.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLoadedRequest.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgLoadedRequest.pageTitle)
    pub pageTitle: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgLoadedRequest.headers)
    pub headers: ::std::vec::Vec<CHTMLHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLoadedRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLoadedRequest {
    fn default() -> &'a CMsgLoadedRequest {
        <CMsgLoadedRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLoadedRequest {
    pub fn new() -> CMsgLoadedRequest {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string pageTitle = 3;

    pub fn pageTitle(&self) -> &str {
        match self.pageTitle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pageTitle(&mut self) {
        self.pageTitle = ::std::option::Option::None;
    }

    pub fn has_pageTitle(&self) -> bool {
        self.pageTitle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pageTitle(&mut self, v: ::std::string::String) {
        self.pageTitle = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pageTitle(&mut self) -> &mut ::std::string::String {
        if self.pageTitle.is_none() {
            self.pageTitle = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pageTitle.as_mut().unwrap()
    }

    // Take field
    pub fn take_pageTitle(&mut self) -> ::std::string::String {
        self.pageTitle.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgLoadedRequest {
    const NAME: &'static str = "CMsgLoadedRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.pageTitle = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.headers.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.pageTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.headers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.pageTitle.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.headers {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLoadedRequest {
        CMsgLoadedRequest::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.pageTitle = ::std::option::Option::None;
        self.headers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLoadedRequest {
        static instance: CMsgLoadedRequest = CMsgLoadedRequest {
            browser_handle: ::std::option::Option::None,
            url: ::std::option::Option::None,
            pageTitle: ::std::option::Option::None,
            headers: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgFavIconURLChanged)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFavIconURLChanged {
    // message fields
    // @@protoc_insertion_point(field:CMsgFavIconURLChanged.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgFavIconURLChanged.urls)
    pub urls: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFavIconURLChanged.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFavIconURLChanged {
    fn default() -> &'a CMsgFavIconURLChanged {
        <CMsgFavIconURLChanged as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFavIconURLChanged {
    pub fn new() -> CMsgFavIconURLChanged {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgFavIconURLChanged {
    const NAME: &'static str = "CMsgFavIconURLChanged";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.urls.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.urls {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        for v in &self.urls {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFavIconURLChanged {
        CMsgFavIconURLChanged::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.urls.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFavIconURLChanged {
        static instance: CMsgFavIconURLChanged = CMsgFavIconURLChanged {
            browser_handle: ::std::option::Option::None,
            urls: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPageSecurity)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPageSecurity {
    // message fields
    // @@protoc_insertion_point(field:CMsgPageSecurity.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPageSecurity.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgPageSecurity.security_info)
    pub security_info: ::protobuf::MessageField<CHTMLPageSecurityInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPageSecurity.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPageSecurity {
    fn default() -> &'a CMsgPageSecurity {
        <CMsgPageSecurity as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPageSecurity {
    pub fn new() -> CMsgPageSecurity {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgPageSecurity {
    const NAME: &'static str = "CMsgPageSecurity";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.security_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.security_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.security_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPageSecurity {
        CMsgPageSecurity::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.security_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPageSecurity {
        static instance: CMsgPageSecurity = CMsgPageSecurity {
            browser_handle: ::std::option::Option::None,
            url: ::std::option::Option::None,
            security_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgStartRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgStartRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgStartRequest.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgStartRequest.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgStartRequest.target)
    pub target: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgStartRequest.postData)
    pub postData: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgStartRequest.bIsRedirect)
    pub bIsRedirect: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgStartRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgStartRequest {
    fn default() -> &'a CMsgStartRequest {
        <CMsgStartRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgStartRequest {
    pub fn new() -> CMsgStartRequest {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string target = 3;

    pub fn target(&self) -> &str {
        match self.target.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_target(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_target(&self) -> bool {
        self.target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target(&mut self, v: ::std::string::String) {
        self.target = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target(&mut self) -> &mut ::std::string::String {
        if self.target.is_none() {
            self.target = ::std::option::Option::Some(::std::string::String::new());
        }
        self.target.as_mut().unwrap()
    }

    // Take field
    pub fn take_target(&mut self) -> ::std::string::String {
        self.target.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string postData = 4;

    pub fn postData(&self) -> &str {
        match self.postData.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_postData(&mut self) {
        self.postData = ::std::option::Option::None;
    }

    pub fn has_postData(&self) -> bool {
        self.postData.is_some()
    }

    // Param is passed by value, moved
    pub fn set_postData(&mut self, v: ::std::string::String) {
        self.postData = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_postData(&mut self) -> &mut ::std::string::String {
        if self.postData.is_none() {
            self.postData = ::std::option::Option::Some(::std::string::String::new());
        }
        self.postData.as_mut().unwrap()
    }

    // Take field
    pub fn take_postData(&mut self) -> ::std::string::String {
        self.postData.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool bIsRedirect = 5;

    pub fn bIsRedirect(&self) -> bool {
        self.bIsRedirect.unwrap_or(false)
    }

    pub fn clear_bIsRedirect(&mut self) {
        self.bIsRedirect = ::std::option::Option::None;
    }

    pub fn has_bIsRedirect(&self) -> bool {
        self.bIsRedirect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bIsRedirect(&mut self, v: bool) {
        self.bIsRedirect = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgStartRequest {
    const NAME: &'static str = "CMsgStartRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.target = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.postData = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.bIsRedirect = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.target.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.postData.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.bIsRedirect {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.target.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.postData.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.bIsRedirect {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgStartRequest {
        CMsgStartRequest::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.target = ::std::option::Option::None;
        self.postData = ::std::option::Option::None;
        self.bIsRedirect = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgStartRequest {
        static instance: CMsgStartRequest = CMsgStartRequest {
            browser_handle: ::std::option::Option::None,
            url: ::std::option::Option::None,
            target: ::std::option::Option::None,
            postData: ::std::option::Option::None,
            bIsRedirect: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgStartRequestResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgStartRequestResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgStartRequestResponse.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgStartRequestResponse.bAllow)
    pub bAllow: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgStartRequestResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgStartRequestResponse {
    fn default() -> &'a CMsgStartRequestResponse {
        <CMsgStartRequestResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgStartRequestResponse {
    pub fn new() -> CMsgStartRequestResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional bool bAllow = 2;

    pub fn bAllow(&self) -> bool {
        self.bAllow.unwrap_or(false)
    }

    pub fn clear_bAllow(&mut self) {
        self.bAllow = ::std::option::Option::None;
    }

    pub fn has_bAllow(&self) -> bool {
        self.bAllow.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bAllow(&mut self, v: bool) {
        self.bAllow = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgStartRequestResponse {
    const NAME: &'static str = "CMsgStartRequestResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.bAllow = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.bAllow {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.bAllow {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgStartRequestResponse {
        CMsgStartRequestResponse::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.bAllow = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgStartRequestResponse {
        static instance: CMsgStartRequestResponse = CMsgStartRequestResponse {
            browser_handle: ::std::option::Option::None,
            bAllow: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgShowPopup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgShowPopup {
    // message fields
    // @@protoc_insertion_point(field:CMsgShowPopup.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgShowPopup.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgShowPopup {
    fn default() -> &'a CMsgShowPopup {
        <CMsgShowPopup as ::protobuf::Message>::default_instance()
    }
}

impl CMsgShowPopup {
    pub fn new() -> CMsgShowPopup {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgShowPopup {
    const NAME: &'static str = "CMsgShowPopup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgShowPopup {
        CMsgShowPopup::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgShowPopup {
        static instance: CMsgShowPopup = CMsgShowPopup {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgHidePopup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgHidePopup {
    // message fields
    // @@protoc_insertion_point(field:CMsgHidePopup.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgHidePopup.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgHidePopup {
    fn default() -> &'a CMsgHidePopup {
        <CMsgHidePopup as ::protobuf::Message>::default_instance()
    }
}

impl CMsgHidePopup {
    pub fn new() -> CMsgHidePopup {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgHidePopup {
    const NAME: &'static str = "CMsgHidePopup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgHidePopup {
        CMsgHidePopup::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgHidePopup {
        static instance: CMsgHidePopup = CMsgHidePopup {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSizePopup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSizePopup {
    // message fields
    // @@protoc_insertion_point(field:CMsgSizePopup.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSizePopup.x)
    pub x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSizePopup.y)
    pub y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSizePopup.wide)
    pub wide: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSizePopup.tall)
    pub tall: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSizePopup.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSizePopup {
    fn default() -> &'a CMsgSizePopup {
        <CMsgSizePopup as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSizePopup {
    pub fn new() -> CMsgSizePopup {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional int32 x = 2;

    pub fn x(&self) -> i32 {
        self.x.unwrap_or(0)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: i32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional int32 y = 3;

    pub fn y(&self) -> i32 {
        self.y.unwrap_or(0)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: i32) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional uint32 wide = 4;

    pub fn wide(&self) -> u32 {
        self.wide.unwrap_or(0)
    }

    pub fn clear_wide(&mut self) {
        self.wide = ::std::option::Option::None;
    }

    pub fn has_wide(&self) -> bool {
        self.wide.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wide(&mut self, v: u32) {
        self.wide = ::std::option::Option::Some(v);
    }

    // optional uint32 tall = 5;

    pub fn tall(&self) -> u32 {
        self.tall.unwrap_or(0)
    }

    pub fn clear_tall(&mut self) {
        self.tall = ::std::option::Option::None;
    }

    pub fn has_tall(&self) -> bool {
        self.tall.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tall(&mut self, v: u32) {
        self.tall = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSizePopup {
    const NAME: &'static str = "CMsgSizePopup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.x = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.y = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.wide = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.tall = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.x {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.y {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.wide {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.tall {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.y {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.wide {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.tall {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSizePopup {
        CMsgSizePopup::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.wide = ::std::option::Option::None;
        self.tall = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSizePopup {
        static instance: CMsgSizePopup = CMsgSizePopup {
            browser_handle: ::std::option::Option::None,
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            wide: ::std::option::Option::None,
            tall: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgOpenNewTab)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgOpenNewTab {
    // message fields
    // @@protoc_insertion_point(field:CMsgOpenNewTab.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgOpenNewTab.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgOpenNewTab.bForeground)
    pub bForeground: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgOpenNewTab.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgOpenNewTab {
    fn default() -> &'a CMsgOpenNewTab {
        <CMsgOpenNewTab as ::protobuf::Message>::default_instance()
    }
}

impl CMsgOpenNewTab {
    pub fn new() -> CMsgOpenNewTab {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool bForeground = 3;

    pub fn bForeground(&self) -> bool {
        self.bForeground.unwrap_or(false)
    }

    pub fn clear_bForeground(&mut self) {
        self.bForeground = ::std::option::Option::None;
    }

    pub fn has_bForeground(&self) -> bool {
        self.bForeground.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bForeground(&mut self, v: bool) {
        self.bForeground = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgOpenNewTab {
    const NAME: &'static str = "CMsgOpenNewTab";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.bForeground = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.bForeground {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.bForeground {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgOpenNewTab {
        CMsgOpenNewTab::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.bForeground = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgOpenNewTab {
        static instance: CMsgOpenNewTab = CMsgOpenNewTab {
            browser_handle: ::std::option::Option::None,
            url: ::std::option::Option::None,
            bForeground: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPopupHTMLWindow)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPopupHTMLWindow {
    // message fields
    // @@protoc_insertion_point(field:CMsgPopupHTMLWindow.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPopupHTMLWindow.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgPopupHTMLWindow.x)
    pub x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgPopupHTMLWindow.y)
    pub y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgPopupHTMLWindow.wide)
    pub wide: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPopupHTMLWindow.tall)
    pub tall: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPopupHTMLWindow.popup_index)
    pub popup_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPopupHTMLWindow.trusted_creator)
    pub trusted_creator: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgPopupHTMLWindow.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgPopupHTMLWindow.hwnd)
    pub hwnd: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPopupHTMLWindow.parent_popup_index)
    pub parent_popup_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPopupHTMLWindow.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPopupHTMLWindow {
    fn default() -> &'a CMsgPopupHTMLWindow {
        <CMsgPopupHTMLWindow as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPopupHTMLWindow {
    pub fn new() -> CMsgPopupHTMLWindow {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 x = 3;

    pub fn x(&self) -> i32 {
        self.x.unwrap_or(-2147483648i32)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: i32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional int32 y = 4;

    pub fn y(&self) -> i32 {
        self.y.unwrap_or(-2147483648i32)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: i32) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional uint32 wide = 5;

    pub fn wide(&self) -> u32 {
        self.wide.unwrap_or(0)
    }

    pub fn clear_wide(&mut self) {
        self.wide = ::std::option::Option::None;
    }

    pub fn has_wide(&self) -> bool {
        self.wide.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wide(&mut self, v: u32) {
        self.wide = ::std::option::Option::Some(v);
    }

    // optional uint32 tall = 6;

    pub fn tall(&self) -> u32 {
        self.tall.unwrap_or(0)
    }

    pub fn clear_tall(&mut self) {
        self.tall = ::std::option::Option::None;
    }

    pub fn has_tall(&self) -> bool {
        self.tall.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tall(&mut self, v: u32) {
        self.tall = ::std::option::Option::Some(v);
    }

    // optional uint32 popup_index = 7;

    pub fn popup_index(&self) -> u32 {
        self.popup_index.unwrap_or(0)
    }

    pub fn clear_popup_index(&mut self) {
        self.popup_index = ::std::option::Option::None;
    }

    pub fn has_popup_index(&self) -> bool {
        self.popup_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_popup_index(&mut self, v: u32) {
        self.popup_index = ::std::option::Option::Some(v);
    }

    // optional bool trusted_creator = 8;

    pub fn trusted_creator(&self) -> bool {
        self.trusted_creator.unwrap_or(false)
    }

    pub fn clear_trusted_creator(&mut self) {
        self.trusted_creator = ::std::option::Option::None;
    }

    pub fn has_trusted_creator(&self) -> bool {
        self.trusted_creator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trusted_creator(&mut self, v: bool) {
        self.trusted_creator = ::std::option::Option::Some(v);
    }

    // optional string name = 9;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 hwnd = 10;

    pub fn hwnd(&self) -> u64 {
        self.hwnd.unwrap_or(0)
    }

    pub fn clear_hwnd(&mut self) {
        self.hwnd = ::std::option::Option::None;
    }

    pub fn has_hwnd(&self) -> bool {
        self.hwnd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hwnd(&mut self, v: u64) {
        self.hwnd = ::std::option::Option::Some(v);
    }

    // optional uint32 parent_popup_index = 11;

    pub fn parent_popup_index(&self) -> u32 {
        self.parent_popup_index.unwrap_or(0)
    }

    pub fn clear_parent_popup_index(&mut self) {
        self.parent_popup_index = ::std::option::Option::None;
    }

    pub fn has_parent_popup_index(&self) -> bool {
        self.parent_popup_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent_popup_index(&mut self, v: u32) {
        self.parent_popup_index = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgPopupHTMLWindow {
    const NAME: &'static str = "CMsgPopupHTMLWindow";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.x = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.y = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.wide = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.tall = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.popup_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.trusted_creator = ::std::option::Option::Some(is.read_bool()?);
                },
                74 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                80 => {
                    self.hwnd = ::std::option::Option::Some(is.read_uint64()?);
                },
                88 => {
                    self.parent_popup_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.x {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.y {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.wide {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.tall {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.popup_index {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.trusted_creator {
            my_size += 1 + 1;
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.hwnd {
            my_size += ::protobuf::rt::uint64_size(10, v);
        }
        if let Some(v) = self.parent_popup_index {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.x {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.y {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.wide {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.tall {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.popup_index {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.trusted_creator {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.hwnd {
            os.write_uint64(10, v)?;
        }
        if let Some(v) = self.parent_popup_index {
            os.write_uint32(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPopupHTMLWindow {
        CMsgPopupHTMLWindow::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.wide = ::std::option::Option::None;
        self.tall = ::std::option::Option::None;
        self.popup_index = ::std::option::Option::None;
        self.trusted_creator = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.hwnd = ::std::option::Option::None;
        self.parent_popup_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPopupHTMLWindow {
        static instance: CMsgPopupHTMLWindow = CMsgPopupHTMLWindow {
            browser_handle: ::std::option::Option::None,
            url: ::std::option::Option::None,
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            wide: ::std::option::Option::None,
            tall: ::std::option::Option::None,
            popup_index: ::std::option::Option::None,
            trusted_creator: ::std::option::Option::None,
            name: ::std::option::Option::None,
            hwnd: ::std::option::Option::None,
            parent_popup_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPopupHTMLWindowResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPopupHTMLWindowResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgPopupHTMLWindowResponse.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPopupHTMLWindowResponse.bAllow)
    pub bAllow: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPopupHTMLWindowResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPopupHTMLWindowResponse {
    fn default() -> &'a CMsgPopupHTMLWindowResponse {
        <CMsgPopupHTMLWindowResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPopupHTMLWindowResponse {
    pub fn new() -> CMsgPopupHTMLWindowResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional bool bAllow = 2;

    pub fn bAllow(&self) -> bool {
        self.bAllow.unwrap_or(false)
    }

    pub fn clear_bAllow(&mut self) {
        self.bAllow = ::std::option::Option::None;
    }

    pub fn has_bAllow(&self) -> bool {
        self.bAllow.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bAllow(&mut self, v: bool) {
        self.bAllow = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgPopupHTMLWindowResponse {
    const NAME: &'static str = "CMsgPopupHTMLWindowResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.bAllow = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.bAllow {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.bAllow {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPopupHTMLWindowResponse {
        CMsgPopupHTMLWindowResponse::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.bAllow = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPopupHTMLWindowResponse {
        static instance: CMsgPopupHTMLWindowResponse = CMsgPopupHTMLWindowResponse {
            browser_handle: ::std::option::Option::None,
            bAllow: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSetHTMLTitle)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetHTMLTitle {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetHTMLTitle.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetHTMLTitle.title)
    pub title: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetHTMLTitle.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetHTMLTitle {
    fn default() -> &'a CMsgSetHTMLTitle {
        <CMsgSetHTMLTitle as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetHTMLTitle {
    pub fn new() -> CMsgSetHTMLTitle {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string title = 2;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgSetHTMLTitle {
    const NAME: &'static str = "CMsgSetHTMLTitle";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetHTMLTitle {
        CMsgSetHTMLTitle::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetHTMLTitle {
        static instance: CMsgSetHTMLTitle = CMsgSetHTMLTitle {
            browser_handle: ::std::option::Option::None,
            title: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgLoadingResource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLoadingResource {
    // message fields
    // @@protoc_insertion_point(field:CMsgLoadingResource.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLoadingResource.url)
    pub url: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLoadingResource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLoadingResource {
    fn default() -> &'a CMsgLoadingResource {
        <CMsgLoadingResource as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLoadingResource {
    pub fn new() -> CMsgLoadingResource {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgLoadingResource {
    const NAME: &'static str = "CMsgLoadingResource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLoadingResource {
        CMsgLoadingResource::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLoadingResource {
        static instance: CMsgLoadingResource = CMsgLoadingResource {
            browser_handle: ::std::option::Option::None,
            url: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgStatusText)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgStatusText {
    // message fields
    // @@protoc_insertion_point(field:CMsgStatusText.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgStatusText.text)
    pub text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgStatusText.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgStatusText {
    fn default() -> &'a CMsgStatusText {
        <CMsgStatusText as ::protobuf::Message>::default_instance()
    }
}

impl CMsgStatusText {
    pub fn new() -> CMsgStatusText {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string text = 2;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgStatusText {
    const NAME: &'static str = "CMsgStatusText";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgStatusText {
        CMsgStatusText::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgStatusText {
        static instance: CMsgStatusText = CMsgStatusText {
            browser_handle: ::std::option::Option::None,
            text: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSetCursor)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetCursor {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetCursor.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetCursor.cursor)
    pub cursor: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetCursor.custom_data)
    pub custom_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgSetCursor.wide)
    pub wide: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetCursor.tall)
    pub tall: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetCursor.xhotspot)
    pub xhotspot: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetCursor.yhotspot)
    pub yhotspot: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetCursor.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetCursor {
    fn default() -> &'a CMsgSetCursor {
        <CMsgSetCursor as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetCursor {
    pub fn new() -> CMsgSetCursor {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 cursor = 2;

    pub fn cursor(&self) -> u32 {
        self.cursor.unwrap_or(0)
    }

    pub fn clear_cursor(&mut self) {
        self.cursor = ::std::option::Option::None;
    }

    pub fn has_cursor(&self) -> bool {
        self.cursor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cursor(&mut self, v: u32) {
        self.cursor = ::std::option::Option::Some(v);
    }

    // optional bytes custom_data = 3;

    pub fn custom_data(&self) -> &[u8] {
        match self.custom_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_custom_data(&mut self) {
        self.custom_data = ::std::option::Option::None;
    }

    pub fn has_custom_data(&self) -> bool {
        self.custom_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.custom_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.custom_data.is_none() {
            self.custom_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.custom_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_custom_data(&mut self) -> ::std::vec::Vec<u8> {
        self.custom_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 wide = 4;

    pub fn wide(&self) -> u32 {
        self.wide.unwrap_or(0)
    }

    pub fn clear_wide(&mut self) {
        self.wide = ::std::option::Option::None;
    }

    pub fn has_wide(&self) -> bool {
        self.wide.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wide(&mut self, v: u32) {
        self.wide = ::std::option::Option::Some(v);
    }

    // optional uint32 tall = 5;

    pub fn tall(&self) -> u32 {
        self.tall.unwrap_or(0)
    }

    pub fn clear_tall(&mut self) {
        self.tall = ::std::option::Option::None;
    }

    pub fn has_tall(&self) -> bool {
        self.tall.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tall(&mut self, v: u32) {
        self.tall = ::std::option::Option::Some(v);
    }

    // optional uint32 xhotspot = 6;

    pub fn xhotspot(&self) -> u32 {
        self.xhotspot.unwrap_or(0)
    }

    pub fn clear_xhotspot(&mut self) {
        self.xhotspot = ::std::option::Option::None;
    }

    pub fn has_xhotspot(&self) -> bool {
        self.xhotspot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xhotspot(&mut self, v: u32) {
        self.xhotspot = ::std::option::Option::Some(v);
    }

    // optional uint32 yhotspot = 7;

    pub fn yhotspot(&self) -> u32 {
        self.yhotspot.unwrap_or(0)
    }

    pub fn clear_yhotspot(&mut self) {
        self.yhotspot = ::std::option::Option::None;
    }

    pub fn has_yhotspot(&self) -> bool {
        self.yhotspot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_yhotspot(&mut self, v: u32) {
        self.yhotspot = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSetCursor {
    const NAME: &'static str = "CMsgSetCursor";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.cursor = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.custom_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                32 => {
                    self.wide = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.tall = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.xhotspot = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.yhotspot = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.cursor {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.custom_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.wide {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.tall {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.xhotspot {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.yhotspot {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.cursor {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.custom_data.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.wide {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.tall {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.xhotspot {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.yhotspot {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetCursor {
        CMsgSetCursor::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.cursor = ::std::option::Option::None;
        self.custom_data = ::std::option::Option::None;
        self.wide = ::std::option::Option::None;
        self.tall = ::std::option::Option::None;
        self.xhotspot = ::std::option::Option::None;
        self.yhotspot = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetCursor {
        static instance: CMsgSetCursor = CMsgSetCursor {
            browser_handle: ::std::option::Option::None,
            cursor: ::std::option::Option::None,
            custom_data: ::std::option::Option::None,
            wide: ::std::option::Option::None,
            tall: ::std::option::Option::None,
            xhotspot: ::std::option::Option::None,
            yhotspot: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgFileLoadDialog)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFileLoadDialog {
    // message fields
    // @@protoc_insertion_point(field:CMsgFileLoadDialog.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgFileLoadDialog.owning_browser_handle)
    pub owning_browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgFileLoadDialog.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgFileLoadDialog.initialFile)
    pub initialFile: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgFileLoadDialog.accept_types)
    pub accept_types: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgFileLoadDialog.is_save)
    pub is_save: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgFileLoadDialog.choose_directory)
    pub choose_directory: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgFileLoadDialog.filters)
    pub filters: ::std::vec::Vec<cmsg_file_load_dialog::Filter>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFileLoadDialog.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFileLoadDialog {
    fn default() -> &'a CMsgFileLoadDialog {
        <CMsgFileLoadDialog as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFileLoadDialog {
    pub fn new() -> CMsgFileLoadDialog {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 owning_browser_handle = 2;

    pub fn owning_browser_handle(&self) -> u32 {
        self.owning_browser_handle.unwrap_or(0)
    }

    pub fn clear_owning_browser_handle(&mut self) {
        self.owning_browser_handle = ::std::option::Option::None;
    }

    pub fn has_owning_browser_handle(&self) -> bool {
        self.owning_browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owning_browser_handle(&mut self, v: u32) {
        self.owning_browser_handle = ::std::option::Option::Some(v);
    }

    // optional string title = 3;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string initialFile = 4;

    pub fn initialFile(&self) -> &str {
        match self.initialFile.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_initialFile(&mut self) {
        self.initialFile = ::std::option::Option::None;
    }

    pub fn has_initialFile(&self) -> bool {
        self.initialFile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initialFile(&mut self, v: ::std::string::String) {
        self.initialFile = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_initialFile(&mut self) -> &mut ::std::string::String {
        if self.initialFile.is_none() {
            self.initialFile = ::std::option::Option::Some(::std::string::String::new());
        }
        self.initialFile.as_mut().unwrap()
    }

    // Take field
    pub fn take_initialFile(&mut self) -> ::std::string::String {
        self.initialFile.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_save = 6;

    pub fn is_save(&self) -> bool {
        self.is_save.unwrap_or(false)
    }

    pub fn clear_is_save(&mut self) {
        self.is_save = ::std::option::Option::None;
    }

    pub fn has_is_save(&self) -> bool {
        self.is_save.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_save(&mut self, v: bool) {
        self.is_save = ::std::option::Option::Some(v);
    }

    // optional bool choose_directory = 7;

    pub fn choose_directory(&self) -> bool {
        self.choose_directory.unwrap_or(false)
    }

    pub fn clear_choose_directory(&mut self) {
        self.choose_directory = ::std::option::Option::None;
    }

    pub fn has_choose_directory(&self) -> bool {
        self.choose_directory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_choose_directory(&mut self, v: bool) {
        self.choose_directory = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgFileLoadDialog {
    const NAME: &'static str = "CMsgFileLoadDialog";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.owning_browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.initialFile = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.accept_types.push(is.read_string()?);
                },
                48 => {
                    self.is_save = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.choose_directory = ::std::option::Option::Some(is.read_bool()?);
                },
                66 => {
                    self.filters.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.owning_browser_handle {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.initialFile.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.accept_types {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if let Some(v) = self.is_save {
            my_size += 1 + 1;
        }
        if let Some(v) = self.choose_directory {
            my_size += 1 + 1;
        }
        for value in &self.filters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.owning_browser_handle {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.initialFile.as_ref() {
            os.write_string(4, v)?;
        }
        for v in &self.accept_types {
            os.write_string(5, &v)?;
        };
        if let Some(v) = self.is_save {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.choose_directory {
            os.write_bool(7, v)?;
        }
        for v in &self.filters {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFileLoadDialog {
        CMsgFileLoadDialog::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.owning_browser_handle = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.initialFile = ::std::option::Option::None;
        self.accept_types.clear();
        self.is_save = ::std::option::Option::None;
        self.choose_directory = ::std::option::Option::None;
        self.filters.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFileLoadDialog {
        static instance: CMsgFileLoadDialog = CMsgFileLoadDialog {
            browser_handle: ::std::option::Option::None,
            owning_browser_handle: ::std::option::Option::None,
            title: ::std::option::Option::None,
            initialFile: ::std::option::Option::None,
            accept_types: ::std::vec::Vec::new(),
            is_save: ::std::option::Option::None,
            choose_directory: ::std::option::Option::None,
            filters: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgFileLoadDialog`
pub mod cmsg_file_load_dialog {
    // @@protoc_insertion_point(message:CMsgFileLoadDialog.Filter)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Filter {
        // message fields
        // @@protoc_insertion_point(field:CMsgFileLoadDialog.Filter.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgFileLoadDialog.Filter.patterns)
        pub patterns: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgFileLoadDialog.Filter.is_default)
        pub is_default: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgFileLoadDialog.Filter.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Filter {
        fn default() -> &'a Filter {
            <Filter as ::protobuf::Message>::default_instance()
        }
    }

    impl Filter {
        pub fn new() -> Filter {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool is_default = 3;

        pub fn is_default(&self) -> bool {
            self.is_default.unwrap_or(false)
        }

        pub fn clear_is_default(&mut self) {
            self.is_default = ::std::option::Option::None;
        }

        pub fn has_is_default(&self) -> bool {
            self.is_default.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_default(&mut self, v: bool) {
            self.is_default = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Filter {
        const NAME: &'static str = "Filter";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.patterns.push(is.read_string()?);
                    },
                    24 => {
                        self.is_default = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            for value in &self.patterns {
                my_size += ::protobuf::rt::string_size(2, &value);
            };
            if let Some(v) = self.is_default {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            for v in &self.patterns {
                os.write_string(2, &v)?;
            };
            if let Some(v) = self.is_default {
                os.write_bool(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Filter {
            Filter::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.patterns.clear();
            self.is_default = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Filter {
            static instance: Filter = Filter {
                name: ::std::option::Option::None,
                patterns: ::std::vec::Vec::new(),
                is_default: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgFileLoadDialogResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFileLoadDialogResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgFileLoadDialogResponse.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgFileLoadDialogResponse.owning_browser_handle)
    pub owning_browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgFileLoadDialogResponse.bsuccess)
    pub bsuccess: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgFileLoadDialogResponse.files)
    pub files: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFileLoadDialogResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFileLoadDialogResponse {
    fn default() -> &'a CMsgFileLoadDialogResponse {
        <CMsgFileLoadDialogResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFileLoadDialogResponse {
    pub fn new() -> CMsgFileLoadDialogResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 owning_browser_handle = 2;

    pub fn owning_browser_handle(&self) -> u32 {
        self.owning_browser_handle.unwrap_or(0)
    }

    pub fn clear_owning_browser_handle(&mut self) {
        self.owning_browser_handle = ::std::option::Option::None;
    }

    pub fn has_owning_browser_handle(&self) -> bool {
        self.owning_browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owning_browser_handle(&mut self, v: u32) {
        self.owning_browser_handle = ::std::option::Option::Some(v);
    }

    // optional bool bsuccess = 3;

    pub fn bsuccess(&self) -> bool {
        self.bsuccess.unwrap_or(false)
    }

    pub fn clear_bsuccess(&mut self) {
        self.bsuccess = ::std::option::Option::None;
    }

    pub fn has_bsuccess(&self) -> bool {
        self.bsuccess.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bsuccess(&mut self, v: bool) {
        self.bsuccess = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgFileLoadDialogResponse {
    const NAME: &'static str = "CMsgFileLoadDialogResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.owning_browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.bsuccess = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    self.files.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.owning_browser_handle {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.bsuccess {
            my_size += 1 + 1;
        }
        for value in &self.files {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.owning_browser_handle {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.bsuccess {
            os.write_bool(3, v)?;
        }
        for v in &self.files {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFileLoadDialogResponse {
        CMsgFileLoadDialogResponse::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.owning_browser_handle = ::std::option::Option::None;
        self.bsuccess = ::std::option::Option::None;
        self.files.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFileLoadDialogResponse {
        static instance: CMsgFileLoadDialogResponse = CMsgFileLoadDialogResponse {
            browser_handle: ::std::option::Option::None,
            owning_browser_handle: ::std::option::Option::None,
            bsuccess: ::std::option::Option::None,
            files: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgShowToolTip)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgShowToolTip {
    // message fields
    // @@protoc_insertion_point(field:CMsgShowToolTip.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgShowToolTip.text)
    pub text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgShowToolTip.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgShowToolTip {
    fn default() -> &'a CMsgShowToolTip {
        <CMsgShowToolTip as ::protobuf::Message>::default_instance()
    }
}

impl CMsgShowToolTip {
    pub fn new() -> CMsgShowToolTip {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string text = 2;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgShowToolTip {
    const NAME: &'static str = "CMsgShowToolTip";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgShowToolTip {
        CMsgShowToolTip::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgShowToolTip {
        static instance: CMsgShowToolTip = CMsgShowToolTip {
            browser_handle: ::std::option::Option::None,
            text: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgUpdateToolTip)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgUpdateToolTip {
    // message fields
    // @@protoc_insertion_point(field:CMsgUpdateToolTip.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgUpdateToolTip.text)
    pub text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgUpdateToolTip.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgUpdateToolTip {
    fn default() -> &'a CMsgUpdateToolTip {
        <CMsgUpdateToolTip as ::protobuf::Message>::default_instance()
    }
}

impl CMsgUpdateToolTip {
    pub fn new() -> CMsgUpdateToolTip {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string text = 2;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgUpdateToolTip {
    const NAME: &'static str = "CMsgUpdateToolTip";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgUpdateToolTip {
        CMsgUpdateToolTip::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgUpdateToolTip {
        static instance: CMsgUpdateToolTip = CMsgUpdateToolTip {
            browser_handle: ::std::option::Option::None,
            text: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgHideToolTip)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgHideToolTip {
    // message fields
    // @@protoc_insertion_point(field:CMsgHideToolTip.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgHideToolTip.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgHideToolTip {
    fn default() -> &'a CMsgHideToolTip {
        <CMsgHideToolTip as ::protobuf::Message>::default_instance()
    }
}

impl CMsgHideToolTip {
    pub fn new() -> CMsgHideToolTip {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgHideToolTip {
    const NAME: &'static str = "CMsgHideToolTip";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgHideToolTip {
        CMsgHideToolTip::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgHideToolTip {
        static instance: CMsgHideToolTip = CMsgHideToolTip {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSearchResults)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSearchResults {
    // message fields
    // @@protoc_insertion_point(field:CMsgSearchResults.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSearchResults.activeMatch)
    pub activeMatch: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSearchResults.results)
    pub results: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSearchResults.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSearchResults {
    fn default() -> &'a CMsgSearchResults {
        <CMsgSearchResults as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSearchResults {
    pub fn new() -> CMsgSearchResults {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional int32 activeMatch = 2;

    pub fn activeMatch(&self) -> i32 {
        self.activeMatch.unwrap_or(0)
    }

    pub fn clear_activeMatch(&mut self) {
        self.activeMatch = ::std::option::Option::None;
    }

    pub fn has_activeMatch(&self) -> bool {
        self.activeMatch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_activeMatch(&mut self, v: i32) {
        self.activeMatch = ::std::option::Option::Some(v);
    }

    // optional int32 results = 3;

    pub fn results(&self) -> i32 {
        self.results.unwrap_or(0)
    }

    pub fn clear_results(&mut self) {
        self.results = ::std::option::Option::None;
    }

    pub fn has_results(&self) -> bool {
        self.results.is_some()
    }

    // Param is passed by value, moved
    pub fn set_results(&mut self, v: i32) {
        self.results = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSearchResults {
    const NAME: &'static str = "CMsgSearchResults";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.activeMatch = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.results = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.activeMatch {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.results {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.activeMatch {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.results {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSearchResults {
        CMsgSearchResults::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.activeMatch = ::std::option::Option::None;
        self.results = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSearchResults {
        static instance: CMsgSearchResults = CMsgSearchResults {
            browser_handle: ::std::option::Option::None,
            activeMatch: ::std::option::Option::None,
            results: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClose)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClose {
    // message fields
    // @@protoc_insertion_point(field:CMsgClose.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClose.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClose {
    fn default() -> &'a CMsgClose {
        <CMsgClose as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClose {
    pub fn new() -> CMsgClose {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClose {
    const NAME: &'static str = "CMsgClose";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClose {
        CMsgClose::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClose {
        static instance: CMsgClose = CMsgClose {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSetSharedPaintBuffers)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetSharedPaintBuffers {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetSharedPaintBuffers.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetSharedPaintBuffers.wide)
    pub wide: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetSharedPaintBuffers.tall)
    pub tall: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetSharedPaintBuffers.source_pid)
    pub source_pid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSetSharedPaintBuffers.source_handle)
    pub source_handle: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSetSharedPaintBuffers.handle)
    pub handle: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetSharedPaintBuffers.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetSharedPaintBuffers {
    fn default() -> &'a CMsgSetSharedPaintBuffers {
        <CMsgSetSharedPaintBuffers as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetSharedPaintBuffers {
    pub fn new() -> CMsgSetSharedPaintBuffers {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 wide = 2;

    pub fn wide(&self) -> u32 {
        self.wide.unwrap_or(0)
    }

    pub fn clear_wide(&mut self) {
        self.wide = ::std::option::Option::None;
    }

    pub fn has_wide(&self) -> bool {
        self.wide.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wide(&mut self, v: u32) {
        self.wide = ::std::option::Option::Some(v);
    }

    // optional uint32 tall = 3;

    pub fn tall(&self) -> u32 {
        self.tall.unwrap_or(0)
    }

    pub fn clear_tall(&mut self) {
        self.tall = ::std::option::Option::None;
    }

    pub fn has_tall(&self) -> bool {
        self.tall.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tall(&mut self, v: u32) {
        self.tall = ::std::option::Option::Some(v);
    }

    // optional uint64 source_pid = 4;

    pub fn source_pid(&self) -> u64 {
        self.source_pid.unwrap_or(0)
    }

    pub fn clear_source_pid(&mut self) {
        self.source_pid = ::std::option::Option::None;
    }

    pub fn has_source_pid(&self) -> bool {
        self.source_pid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_pid(&mut self, v: u64) {
        self.source_pid = ::std::option::Option::Some(v);
    }

    // optional uint64 source_handle = 5;

    pub fn source_handle(&self) -> u64 {
        self.source_handle.unwrap_or(0)
    }

    pub fn clear_source_handle(&mut self) {
        self.source_handle = ::std::option::Option::None;
    }

    pub fn has_source_handle(&self) -> bool {
        self.source_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_handle(&mut self, v: u64) {
        self.source_handle = ::std::option::Option::Some(v);
    }

    // optional uint64 handle = 6;

    pub fn handle(&self) -> u64 {
        self.handle.unwrap_or(0)
    }

    pub fn clear_handle(&mut self) {
        self.handle = ::std::option::Option::None;
    }

    pub fn has_handle(&self) -> bool {
        self.handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_handle(&mut self, v: u64) {
        self.handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSetSharedPaintBuffers {
    const NAME: &'static str = "CMsgSetSharedPaintBuffers";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.wide = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.tall = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.source_pid = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.source_handle = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.handle = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.wide {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.tall {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.source_pid {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.source_handle {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.handle {
            my_size += ::protobuf::rt::uint64_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.wide {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.tall {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.source_pid {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.source_handle {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.handle {
            os.write_uint64(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetSharedPaintBuffers {
        CMsgSetSharedPaintBuffers::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.wide = ::std::option::Option::None;
        self.tall = ::std::option::Option::None;
        self.source_pid = ::std::option::Option::None;
        self.source_handle = ::std::option::Option::None;
        self.handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetSharedPaintBuffers {
        static instance: CMsgSetSharedPaintBuffers = CMsgSetSharedPaintBuffers {
            browser_handle: ::std::option::Option::None,
            wide: ::std::option::Option::None,
            tall: ::std::option::Option::None,
            source_pid: ::std::option::Option::None,
            source_handle: ::std::option::Option::None,
            handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgAckSharedPaintBuffers)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAckSharedPaintBuffers {
    // message fields
    // @@protoc_insertion_point(field:CMsgAckSharedPaintBuffers.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAckSharedPaintBuffers.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAckSharedPaintBuffers {
    fn default() -> &'a CMsgAckSharedPaintBuffers {
        <CMsgAckSharedPaintBuffers as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAckSharedPaintBuffers {
    pub fn new() -> CMsgAckSharedPaintBuffers {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgAckSharedPaintBuffers {
    const NAME: &'static str = "CMsgAckSharedPaintBuffers";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAckSharedPaintBuffers {
        CMsgAckSharedPaintBuffers::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAckSharedPaintBuffers {
        static instance: CMsgAckSharedPaintBuffers = CMsgAckSharedPaintBuffers {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgNeedsPaint)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgNeedsPaint {
    // message fields
    // @@protoc_insertion_point(field:CMsgNeedsPaint.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgNeedsPaint.scrollx)
    pub scrollx: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgNeedsPaint.scrolly)
    pub scrolly: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgNeedsPaint.pagescale)
    pub pagescale: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgNeedsPaint.pageserial)
    pub pageserial: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgNeedsPaint.avg_frame_ms)
    pub avg_frame_ms: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgNeedsPaint.stddev_sum_frame_ms)
    pub stddev_sum_frame_ms: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgNeedsPaint.long_frame_ms)
    pub long_frame_ms: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgNeedsPaint.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgNeedsPaint {
    fn default() -> &'a CMsgNeedsPaint {
        <CMsgNeedsPaint as ::protobuf::Message>::default_instance()
    }
}

impl CMsgNeedsPaint {
    pub fn new() -> CMsgNeedsPaint {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 scrollx = 10;

    pub fn scrollx(&self) -> u32 {
        self.scrollx.unwrap_or(0)
    }

    pub fn clear_scrollx(&mut self) {
        self.scrollx = ::std::option::Option::None;
    }

    pub fn has_scrollx(&self) -> bool {
        self.scrollx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scrollx(&mut self, v: u32) {
        self.scrollx = ::std::option::Option::Some(v);
    }

    // optional uint32 scrolly = 11;

    pub fn scrolly(&self) -> u32 {
        self.scrolly.unwrap_or(0)
    }

    pub fn clear_scrolly(&mut self) {
        self.scrolly = ::std::option::Option::None;
    }

    pub fn has_scrolly(&self) -> bool {
        self.scrolly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scrolly(&mut self, v: u32) {
        self.scrolly = ::std::option::Option::Some(v);
    }

    // optional float pagescale = 12;

    pub fn pagescale(&self) -> f32 {
        self.pagescale.unwrap_or(0.)
    }

    pub fn clear_pagescale(&mut self) {
        self.pagescale = ::std::option::Option::None;
    }

    pub fn has_pagescale(&self) -> bool {
        self.pagescale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagescale(&mut self, v: f32) {
        self.pagescale = ::std::option::Option::Some(v);
    }

    // optional uint32 pageserial = 15;

    pub fn pageserial(&self) -> u32 {
        self.pageserial.unwrap_or(0)
    }

    pub fn clear_pageserial(&mut self) {
        self.pageserial = ::std::option::Option::None;
    }

    pub fn has_pageserial(&self) -> bool {
        self.pageserial.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pageserial(&mut self, v: u32) {
        self.pageserial = ::std::option::Option::Some(v);
    }

    // optional uint32 avg_frame_ms = 20;

    pub fn avg_frame_ms(&self) -> u32 {
        self.avg_frame_ms.unwrap_or(0)
    }

    pub fn clear_avg_frame_ms(&mut self) {
        self.avg_frame_ms = ::std::option::Option::None;
    }

    pub fn has_avg_frame_ms(&self) -> bool {
        self.avg_frame_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_frame_ms(&mut self, v: u32) {
        self.avg_frame_ms = ::std::option::Option::Some(v);
    }

    // optional float stddev_sum_frame_ms = 21;

    pub fn stddev_sum_frame_ms(&self) -> f32 {
        self.stddev_sum_frame_ms.unwrap_or(0.)
    }

    pub fn clear_stddev_sum_frame_ms(&mut self) {
        self.stddev_sum_frame_ms = ::std::option::Option::None;
    }

    pub fn has_stddev_sum_frame_ms(&self) -> bool {
        self.stddev_sum_frame_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stddev_sum_frame_ms(&mut self, v: f32) {
        self.stddev_sum_frame_ms = ::std::option::Option::Some(v);
    }

    // optional uint32 long_frame_ms = 22;

    pub fn long_frame_ms(&self) -> u32 {
        self.long_frame_ms.unwrap_or(0)
    }

    pub fn clear_long_frame_ms(&mut self) {
        self.long_frame_ms = ::std::option::Option::None;
    }

    pub fn has_long_frame_ms(&self) -> bool {
        self.long_frame_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_long_frame_ms(&mut self, v: u32) {
        self.long_frame_ms = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgNeedsPaint {
    const NAME: &'static str = "CMsgNeedsPaint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.scrollx = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.scrolly = ::std::option::Option::Some(is.read_uint32()?);
                },
                101 => {
                    self.pagescale = ::std::option::Option::Some(is.read_float()?);
                },
                120 => {
                    self.pageserial = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.avg_frame_ms = ::std::option::Option::Some(is.read_uint32()?);
                },
                173 => {
                    self.stddev_sum_frame_ms = ::std::option::Option::Some(is.read_float()?);
                },
                176 => {
                    self.long_frame_ms = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.scrollx {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.scrolly {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.pagescale {
            my_size += 1 + 4;
        }
        if let Some(v) = self.pageserial {
            my_size += ::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.avg_frame_ms {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.stddev_sum_frame_ms {
            my_size += 2 + 4;
        }
        if let Some(v) = self.long_frame_ms {
            my_size += ::protobuf::rt::uint32_size(22, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.scrollx {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.scrolly {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.pagescale {
            os.write_float(12, v)?;
        }
        if let Some(v) = self.pageserial {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.avg_frame_ms {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.stddev_sum_frame_ms {
            os.write_float(21, v)?;
        }
        if let Some(v) = self.long_frame_ms {
            os.write_uint32(22, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgNeedsPaint {
        CMsgNeedsPaint::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.scrollx = ::std::option::Option::None;
        self.scrolly = ::std::option::Option::None;
        self.pagescale = ::std::option::Option::None;
        self.pageserial = ::std::option::Option::None;
        self.avg_frame_ms = ::std::option::Option::None;
        self.stddev_sum_frame_ms = ::std::option::Option::None;
        self.long_frame_ms = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgNeedsPaint {
        static instance: CMsgNeedsPaint = CMsgNeedsPaint {
            browser_handle: ::std::option::Option::None,
            scrollx: ::std::option::Option::None,
            scrolly: ::std::option::Option::None,
            pagescale: ::std::option::Option::None,
            pageserial: ::std::option::Option::None,
            avg_frame_ms: ::std::option::Option::None,
            stddev_sum_frame_ms: ::std::option::Option::None,
            long_frame_ms: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgComboNeedsPaint)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgComboNeedsPaint {
    // message fields
    // @@protoc_insertion_point(field:CMsgComboNeedsPaint.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgComboNeedsPaint.rgba)
    pub rgba: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgComboNeedsPaint.combobox_wide)
    pub combobox_wide: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgComboNeedsPaint.combobox_tall)
    pub combobox_tall: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgComboNeedsPaint.shared_memory_handle)
    pub shared_memory_handle: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgComboNeedsPaint.shared_memory_size)
    pub shared_memory_size: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgComboNeedsPaint.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgComboNeedsPaint {
    fn default() -> &'a CMsgComboNeedsPaint {
        <CMsgComboNeedsPaint as ::protobuf::Message>::default_instance()
    }
}

impl CMsgComboNeedsPaint {
    pub fn new() -> CMsgComboNeedsPaint {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint64 rgba = 2;

    pub fn rgba(&self) -> u64 {
        self.rgba.unwrap_or(0)
    }

    pub fn clear_rgba(&mut self) {
        self.rgba = ::std::option::Option::None;
    }

    pub fn has_rgba(&self) -> bool {
        self.rgba.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rgba(&mut self, v: u64) {
        self.rgba = ::std::option::Option::Some(v);
    }

    // optional uint32 combobox_wide = 3;

    pub fn combobox_wide(&self) -> u32 {
        self.combobox_wide.unwrap_or(0u32)
    }

    pub fn clear_combobox_wide(&mut self) {
        self.combobox_wide = ::std::option::Option::None;
    }

    pub fn has_combobox_wide(&self) -> bool {
        self.combobox_wide.is_some()
    }

    // Param is passed by value, moved
    pub fn set_combobox_wide(&mut self, v: u32) {
        self.combobox_wide = ::std::option::Option::Some(v);
    }

    // optional uint32 combobox_tall = 4;

    pub fn combobox_tall(&self) -> u32 {
        self.combobox_tall.unwrap_or(0u32)
    }

    pub fn clear_combobox_tall(&mut self) {
        self.combobox_tall = ::std::option::Option::None;
    }

    pub fn has_combobox_tall(&self) -> bool {
        self.combobox_tall.is_some()
    }

    // Param is passed by value, moved
    pub fn set_combobox_tall(&mut self, v: u32) {
        self.combobox_tall = ::std::option::Option::Some(v);
    }

    // optional uint64 shared_memory_handle = 5;

    pub fn shared_memory_handle(&self) -> u64 {
        self.shared_memory_handle.unwrap_or(0u64)
    }

    pub fn clear_shared_memory_handle(&mut self) {
        self.shared_memory_handle = ::std::option::Option::None;
    }

    pub fn has_shared_memory_handle(&self) -> bool {
        self.shared_memory_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shared_memory_handle(&mut self, v: u64) {
        self.shared_memory_handle = ::std::option::Option::Some(v);
    }

    // optional uint64 shared_memory_size = 7;

    pub fn shared_memory_size(&self) -> u64 {
        self.shared_memory_size.unwrap_or(0u64)
    }

    pub fn clear_shared_memory_size(&mut self) {
        self.shared_memory_size = ::std::option::Option::None;
    }

    pub fn has_shared_memory_size(&self) -> bool {
        self.shared_memory_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shared_memory_size(&mut self, v: u64) {
        self.shared_memory_size = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgComboNeedsPaint {
    const NAME: &'static str = "CMsgComboNeedsPaint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.rgba = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.combobox_wide = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.combobox_tall = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.shared_memory_handle = ::std::option::Option::Some(is.read_uint64()?);
                },
                56 => {
                    self.shared_memory_size = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.rgba {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.combobox_wide {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.combobox_tall {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.shared_memory_handle {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.shared_memory_size {
            my_size += ::protobuf::rt::uint64_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.rgba {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.combobox_wide {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.combobox_tall {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.shared_memory_handle {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.shared_memory_size {
            os.write_uint64(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgComboNeedsPaint {
        CMsgComboNeedsPaint::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.rgba = ::std::option::Option::None;
        self.combobox_wide = ::std::option::Option::None;
        self.combobox_tall = ::std::option::Option::None;
        self.shared_memory_handle = ::std::option::Option::None;
        self.shared_memory_size = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgComboNeedsPaint {
        static instance: CMsgComboNeedsPaint = CMsgComboNeedsPaint {
            browser_handle: ::std::option::Option::None,
            rgba: ::std::option::Option::None,
            combobox_wide: ::std::option::Option::None,
            combobox_tall: ::std::option::Option::None,
            shared_memory_handle: ::std::option::Option::None,
            shared_memory_size: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgNeedsSharedTexturePaint)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgNeedsSharedTexturePaint {
    // message fields
    // @@protoc_insertion_point(field:CMsgNeedsSharedTexturePaint.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgNeedsSharedTexturePaint.share_handle)
    pub share_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgNeedsSharedTexturePaint.width)
    pub width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgNeedsSharedTexturePaint.height)
    pub height: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgNeedsSharedTexturePaint.scrollx)
    pub scrollx: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgNeedsSharedTexturePaint.scrolly)
    pub scrolly: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgNeedsSharedTexturePaint.pagescale)
    pub pagescale: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgNeedsSharedTexturePaint.pageserial)
    pub pageserial: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgNeedsSharedTexturePaint.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgNeedsSharedTexturePaint {
    fn default() -> &'a CMsgNeedsSharedTexturePaint {
        <CMsgNeedsSharedTexturePaint as ::protobuf::Message>::default_instance()
    }
}

impl CMsgNeedsSharedTexturePaint {
    pub fn new() -> CMsgNeedsSharedTexturePaint {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 share_handle = 2;

    pub fn share_handle(&self) -> u32 {
        self.share_handle.unwrap_or(0)
    }

    pub fn clear_share_handle(&mut self) {
        self.share_handle = ::std::option::Option::None;
    }

    pub fn has_share_handle(&self) -> bool {
        self.share_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_share_handle(&mut self, v: u32) {
        self.share_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 width = 3;

    pub fn width(&self) -> u32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional uint32 height = 4;

    pub fn height(&self) -> u32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional uint32 scrollx = 5;

    pub fn scrollx(&self) -> u32 {
        self.scrollx.unwrap_or(0)
    }

    pub fn clear_scrollx(&mut self) {
        self.scrollx = ::std::option::Option::None;
    }

    pub fn has_scrollx(&self) -> bool {
        self.scrollx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scrollx(&mut self, v: u32) {
        self.scrollx = ::std::option::Option::Some(v);
    }

    // optional uint32 scrolly = 6;

    pub fn scrolly(&self) -> u32 {
        self.scrolly.unwrap_or(0)
    }

    pub fn clear_scrolly(&mut self) {
        self.scrolly = ::std::option::Option::None;
    }

    pub fn has_scrolly(&self) -> bool {
        self.scrolly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scrolly(&mut self, v: u32) {
        self.scrolly = ::std::option::Option::Some(v);
    }

    // optional float pagescale = 7;

    pub fn pagescale(&self) -> f32 {
        self.pagescale.unwrap_or(0.)
    }

    pub fn clear_pagescale(&mut self) {
        self.pagescale = ::std::option::Option::None;
    }

    pub fn has_pagescale(&self) -> bool {
        self.pagescale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagescale(&mut self, v: f32) {
        self.pagescale = ::std::option::Option::Some(v);
    }

    // optional uint32 pageserial = 8;

    pub fn pageserial(&self) -> u32 {
        self.pageserial.unwrap_or(0)
    }

    pub fn clear_pageserial(&mut self) {
        self.pageserial = ::std::option::Option::None;
    }

    pub fn has_pageserial(&self) -> bool {
        self.pageserial.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pageserial(&mut self, v: u32) {
        self.pageserial = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgNeedsSharedTexturePaint {
    const NAME: &'static str = "CMsgNeedsSharedTexturePaint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.share_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.width = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.height = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.scrollx = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.scrolly = ::std::option::Option::Some(is.read_uint32()?);
                },
                61 => {
                    self.pagescale = ::std::option::Option::Some(is.read_float()?);
                },
                64 => {
                    self.pageserial = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.share_handle {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.scrollx {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.scrolly {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.pagescale {
            my_size += 1 + 4;
        }
        if let Some(v) = self.pageserial {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.share_handle {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.width {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.scrollx {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.scrolly {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.pagescale {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.pageserial {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgNeedsSharedTexturePaint {
        CMsgNeedsSharedTexturePaint::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.share_handle = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.scrollx = ::std::option::Option::None;
        self.scrolly = ::std::option::Option::None;
        self.pagescale = ::std::option::Option::None;
        self.pageserial = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgNeedsSharedTexturePaint {
        static instance: CMsgNeedsSharedTexturePaint = CMsgNeedsSharedTexturePaint {
            browser_handle: ::std::option::Option::None,
            share_handle: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            scrollx: ::std::option::Option::None,
            scrolly: ::std::option::Option::None,
            pagescale: ::std::option::Option::None,
            pageserial: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGameOverlayTexturePaint)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameOverlayTexturePaint {
    // message fields
    // @@protoc_insertion_point(field:CMsgGameOverlayTexturePaint.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameOverlayTexturePaint.width)
    pub width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameOverlayTexturePaint.height)
    pub height: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameOverlayTexturePaint.scrollx)
    pub scrollx: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameOverlayTexturePaint.scrolly)
    pub scrolly: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameOverlayTexturePaint.pagescale)
    pub pagescale: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgGameOverlayTexturePaint.pageserial)
    pub pageserial: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGameOverlayTexturePaint.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameOverlayTexturePaint {
    fn default() -> &'a CMsgGameOverlayTexturePaint {
        <CMsgGameOverlayTexturePaint as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameOverlayTexturePaint {
    pub fn new() -> CMsgGameOverlayTexturePaint {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 width = 3;

    pub fn width(&self) -> u32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional uint32 height = 4;

    pub fn height(&self) -> u32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional uint32 scrollx = 5;

    pub fn scrollx(&self) -> u32 {
        self.scrollx.unwrap_or(0)
    }

    pub fn clear_scrollx(&mut self) {
        self.scrollx = ::std::option::Option::None;
    }

    pub fn has_scrollx(&self) -> bool {
        self.scrollx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scrollx(&mut self, v: u32) {
        self.scrollx = ::std::option::Option::Some(v);
    }

    // optional uint32 scrolly = 6;

    pub fn scrolly(&self) -> u32 {
        self.scrolly.unwrap_or(0)
    }

    pub fn clear_scrolly(&mut self) {
        self.scrolly = ::std::option::Option::None;
    }

    pub fn has_scrolly(&self) -> bool {
        self.scrolly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scrolly(&mut self, v: u32) {
        self.scrolly = ::std::option::Option::Some(v);
    }

    // optional float pagescale = 7;

    pub fn pagescale(&self) -> f32 {
        self.pagescale.unwrap_or(0.)
    }

    pub fn clear_pagescale(&mut self) {
        self.pagescale = ::std::option::Option::None;
    }

    pub fn has_pagescale(&self) -> bool {
        self.pagescale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagescale(&mut self, v: f32) {
        self.pagescale = ::std::option::Option::Some(v);
    }

    // optional uint32 pageserial = 8;

    pub fn pageserial(&self) -> u32 {
        self.pageserial.unwrap_or(0)
    }

    pub fn clear_pageserial(&mut self) {
        self.pageserial = ::std::option::Option::None;
    }

    pub fn has_pageserial(&self) -> bool {
        self.pageserial.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pageserial(&mut self, v: u32) {
        self.pageserial = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGameOverlayTexturePaint {
    const NAME: &'static str = "CMsgGameOverlayTexturePaint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.width = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.height = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.scrollx = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.scrolly = ::std::option::Option::Some(is.read_uint32()?);
                },
                61 => {
                    self.pagescale = ::std::option::Option::Some(is.read_float()?);
                },
                64 => {
                    self.pageserial = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.scrollx {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.scrolly {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.pagescale {
            my_size += 1 + 4;
        }
        if let Some(v) = self.pageserial {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.width {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.scrollx {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.scrolly {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.pagescale {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.pageserial {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameOverlayTexturePaint {
        CMsgGameOverlayTexturePaint::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.scrollx = ::std::option::Option::None;
        self.scrolly = ::std::option::Option::None;
        self.pagescale = ::std::option::Option::None;
        self.pageserial = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameOverlayTexturePaint {
        static instance: CMsgGameOverlayTexturePaint = CMsgGameOverlayTexturePaint {
            browser_handle: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            scrollx: ::std::option::Option::None,
            scrolly: ::std::option::Option::None,
            pagescale: ::std::option::Option::None,
            pageserial: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGetZoom)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGetZoom {
    // message fields
    // @@protoc_insertion_point(field:CMsgGetZoom.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGetZoom.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGetZoom {
    fn default() -> &'a CMsgGetZoom {
        <CMsgGetZoom as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGetZoom {
    pub fn new() -> CMsgGetZoom {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGetZoom {
    const NAME: &'static str = "CMsgGetZoom";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGetZoom {
        CMsgGetZoom::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGetZoom {
        static instance: CMsgGetZoom = CMsgGetZoom {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGetZoomResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGetZoomResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGetZoomResponse.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGetZoomResponse.zoom)
    pub zoom: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGetZoomResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGetZoomResponse {
    fn default() -> &'a CMsgGetZoomResponse {
        <CMsgGetZoomResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGetZoomResponse {
    pub fn new() -> CMsgGetZoomResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional float zoom = 2;

    pub fn zoom(&self) -> f32 {
        self.zoom.unwrap_or(0.)
    }

    pub fn clear_zoom(&mut self) {
        self.zoom = ::std::option::Option::None;
    }

    pub fn has_zoom(&self) -> bool {
        self.zoom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_zoom(&mut self, v: f32) {
        self.zoom = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGetZoomResponse {
    const NAME: &'static str = "CMsgGetZoomResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.zoom = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.zoom {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.zoom {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGetZoomResponse {
        CMsgGetZoomResponse::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.zoom = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGetZoomResponse {
        static instance: CMsgGetZoomResponse = CMsgGetZoomResponse {
            browser_handle: ::std::option::Option::None,
            zoom: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgLinkAtPosition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLinkAtPosition {
    // message fields
    // @@protoc_insertion_point(field:CMsgLinkAtPosition.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLinkAtPosition.x)
    pub x: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLinkAtPosition.y)
    pub y: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLinkAtPosition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLinkAtPosition {
    fn default() -> &'a CMsgLinkAtPosition {
        <CMsgLinkAtPosition as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLinkAtPosition {
    pub fn new() -> CMsgLinkAtPosition {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 x = 2;

    pub fn x(&self) -> u32 {
        self.x.unwrap_or(0)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: u32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional uint32 y = 3;

    pub fn y(&self) -> u32 {
        self.y.unwrap_or(0)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: u32) {
        self.y = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgLinkAtPosition {
    const NAME: &'static str = "CMsgLinkAtPosition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.x = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.y = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.x {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.y {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.y {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLinkAtPosition {
        CMsgLinkAtPosition::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLinkAtPosition {
        static instance: CMsgLinkAtPosition = CMsgLinkAtPosition {
            browser_handle: ::std::option::Option::None,
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgLinkAtPositionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLinkAtPositionResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgLinkAtPositionResponse.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLinkAtPositionResponse.x)
    pub x: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLinkAtPositionResponse.y)
    pub y: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLinkAtPositionResponse.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgLinkAtPositionResponse.blivelink)
    pub blivelink: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgLinkAtPositionResponse.binput)
    pub binput: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLinkAtPositionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLinkAtPositionResponse {
    fn default() -> &'a CMsgLinkAtPositionResponse {
        <CMsgLinkAtPositionResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLinkAtPositionResponse {
    pub fn new() -> CMsgLinkAtPositionResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 x = 2;

    pub fn x(&self) -> u32 {
        self.x.unwrap_or(0)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: u32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional uint32 y = 3;

    pub fn y(&self) -> u32 {
        self.y.unwrap_or(0)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: u32) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional string url = 4;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool blivelink = 5;

    pub fn blivelink(&self) -> bool {
        self.blivelink.unwrap_or(false)
    }

    pub fn clear_blivelink(&mut self) {
        self.blivelink = ::std::option::Option::None;
    }

    pub fn has_blivelink(&self) -> bool {
        self.blivelink.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blivelink(&mut self, v: bool) {
        self.blivelink = ::std::option::Option::Some(v);
    }

    // optional bool binput = 6;

    pub fn binput(&self) -> bool {
        self.binput.unwrap_or(false)
    }

    pub fn clear_binput(&mut self) {
        self.binput = ::std::option::Option::None;
    }

    pub fn has_binput(&self) -> bool {
        self.binput.is_some()
    }

    // Param is passed by value, moved
    pub fn set_binput(&mut self, v: bool) {
        self.binput = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgLinkAtPositionResponse {
    const NAME: &'static str = "CMsgLinkAtPositionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.x = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.y = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.blivelink = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.binput = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.x {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.y {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.blivelink {
            my_size += 1 + 1;
        }
        if let Some(v) = self.binput {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.y {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.blivelink {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.binput {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLinkAtPositionResponse {
        CMsgLinkAtPositionResponse::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.blivelink = ::std::option::Option::None;
        self.binput = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLinkAtPositionResponse {
        static instance: CMsgLinkAtPositionResponse = CMsgLinkAtPositionResponse {
            browser_handle: ::std::option::Option::None,
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            url: ::std::option::Option::None,
            blivelink: ::std::option::Option::None,
            binput: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgZoomToElementAtPosition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgZoomToElementAtPosition {
    // message fields
    // @@protoc_insertion_point(field:CMsgZoomToElementAtPosition.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgZoomToElementAtPosition.x)
    pub x: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgZoomToElementAtPosition.y)
    pub y: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgZoomToElementAtPosition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgZoomToElementAtPosition {
    fn default() -> &'a CMsgZoomToElementAtPosition {
        <CMsgZoomToElementAtPosition as ::protobuf::Message>::default_instance()
    }
}

impl CMsgZoomToElementAtPosition {
    pub fn new() -> CMsgZoomToElementAtPosition {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 x = 2;

    pub fn x(&self) -> u32 {
        self.x.unwrap_or(0)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: u32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional uint32 y = 3;

    pub fn y(&self) -> u32 {
        self.y.unwrap_or(0)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: u32) {
        self.y = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgZoomToElementAtPosition {
    const NAME: &'static str = "CMsgZoomToElementAtPosition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.x = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.y = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.x {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.y {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.y {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgZoomToElementAtPosition {
        CMsgZoomToElementAtPosition::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgZoomToElementAtPosition {
        static instance: CMsgZoomToElementAtPosition = CMsgZoomToElementAtPosition {
            browser_handle: ::std::option::Option::None,
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgZoomToElementAtPositionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgZoomToElementAtPositionResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgZoomToElementAtPositionResponse.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgZoomToElementAtPositionResponse.scale)
    pub scale: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgZoomToElementAtPositionResponse.duration)
    pub duration: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgZoomToElementAtPositionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgZoomToElementAtPositionResponse {
    fn default() -> &'a CMsgZoomToElementAtPositionResponse {
        <CMsgZoomToElementAtPositionResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgZoomToElementAtPositionResponse {
    pub fn new() -> CMsgZoomToElementAtPositionResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional float scale = 2;

    pub fn scale(&self) -> f32 {
        self.scale.unwrap_or(0.)
    }

    pub fn clear_scale(&mut self) {
        self.scale = ::std::option::Option::None;
    }

    pub fn has_scale(&self) -> bool {
        self.scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scale(&mut self, v: f32) {
        self.scale = ::std::option::Option::Some(v);
    }

    // optional float duration = 3;

    pub fn duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgZoomToElementAtPositionResponse {
    const NAME: &'static str = "CMsgZoomToElementAtPositionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.scale = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.duration = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.scale {
            my_size += 1 + 4;
        }
        if let Some(v) = self.duration {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.scale {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.duration {
            os.write_float(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgZoomToElementAtPositionResponse {
        CMsgZoomToElementAtPositionResponse::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.scale = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgZoomToElementAtPositionResponse {
        static instance: CMsgZoomToElementAtPositionResponse = CMsgZoomToElementAtPositionResponse {
            browser_handle: ::std::option::Option::None,
            scale: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgScalePageToValue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgScalePageToValue {
    // message fields
    // @@protoc_insertion_point(field:CMsgScalePageToValue.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgScalePageToValue.scale)
    pub scale: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgScalePageToValue.x)
    pub x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgScalePageToValue.y)
    pub y: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgScalePageToValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgScalePageToValue {
    fn default() -> &'a CMsgScalePageToValue {
        <CMsgScalePageToValue as ::protobuf::Message>::default_instance()
    }
}

impl CMsgScalePageToValue {
    pub fn new() -> CMsgScalePageToValue {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional float scale = 2;

    pub fn scale(&self) -> f32 {
        self.scale.unwrap_or(0.)
    }

    pub fn clear_scale(&mut self) {
        self.scale = ::std::option::Option::None;
    }

    pub fn has_scale(&self) -> bool {
        self.scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scale(&mut self, v: f32) {
        self.scale = ::std::option::Option::Some(v);
    }

    // optional float x = 3;

    pub fn x(&self) -> f32 {
        self.x.unwrap_or(0.)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional float y = 4;

    pub fn y(&self) -> f32 {
        self.y.unwrap_or(0.)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f32) {
        self.y = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgScalePageToValue {
    const NAME: &'static str = "CMsgScalePageToValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.scale = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.x = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.y = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.scale {
            my_size += 1 + 4;
        }
        if let Some(v) = self.x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.y {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.scale {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.x {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.y {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgScalePageToValue {
        CMsgScalePageToValue::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.scale = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgScalePageToValue {
        static instance: CMsgScalePageToValue = CMsgScalePageToValue {
            browser_handle: ::std::option::Option::None,
            scale: ::std::option::Option::None,
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgForcePopupsToDirectHWND)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgForcePopupsToDirectHWND {
    // message fields
    // @@protoc_insertion_point(field:CMsgForcePopupsToDirectHWND.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgForcePopupsToDirectHWND.force_direct_hwnd_popups)
    pub force_direct_hwnd_popups: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgForcePopupsToDirectHWND.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgForcePopupsToDirectHWND {
    fn default() -> &'a CMsgForcePopupsToDirectHWND {
        <CMsgForcePopupsToDirectHWND as ::protobuf::Message>::default_instance()
    }
}

impl CMsgForcePopupsToDirectHWND {
    pub fn new() -> CMsgForcePopupsToDirectHWND {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional bool force_direct_hwnd_popups = 2;

    pub fn force_direct_hwnd_popups(&self) -> bool {
        self.force_direct_hwnd_popups.unwrap_or(false)
    }

    pub fn clear_force_direct_hwnd_popups(&mut self) {
        self.force_direct_hwnd_popups = ::std::option::Option::None;
    }

    pub fn has_force_direct_hwnd_popups(&self) -> bool {
        self.force_direct_hwnd_popups.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force_direct_hwnd_popups(&mut self, v: bool) {
        self.force_direct_hwnd_popups = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgForcePopupsToDirectHWND {
    const NAME: &'static str = "CMsgForcePopupsToDirectHWND";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.force_direct_hwnd_popups = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.force_direct_hwnd_popups {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.force_direct_hwnd_popups {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgForcePopupsToDirectHWND {
        CMsgForcePopupsToDirectHWND::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.force_direct_hwnd_popups = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgForcePopupsToDirectHWND {
        static instance: CMsgForcePopupsToDirectHWND = CMsgForcePopupsToDirectHWND {
            browser_handle: ::std::option::Option::None,
            force_direct_hwnd_popups: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgScalePageToValueResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgScalePageToValueResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgScalePageToValueResponse.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgScalePageToValueResponse.zoom)
    pub zoom: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgScalePageToValueResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgScalePageToValueResponse {
    fn default() -> &'a CMsgScalePageToValueResponse {
        <CMsgScalePageToValueResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgScalePageToValueResponse {
    pub fn new() -> CMsgScalePageToValueResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional float zoom = 2;

    pub fn zoom(&self) -> f32 {
        self.zoom.unwrap_or(0.)
    }

    pub fn clear_zoom(&mut self) {
        self.zoom = ::std::option::Option::None;
    }

    pub fn has_zoom(&self) -> bool {
        self.zoom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_zoom(&mut self, v: f32) {
        self.zoom = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgScalePageToValueResponse {
    const NAME: &'static str = "CMsgScalePageToValueResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.zoom = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.zoom {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.zoom {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgScalePageToValueResponse {
        CMsgScalePageToValueResponse::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.zoom = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgScalePageToValueResponse {
        static instance: CMsgScalePageToValueResponse = CMsgScalePageToValueResponse {
            browser_handle: ::std::option::Option::None,
            zoom: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSavePageToJPEG)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSavePageToJPEG {
    // message fields
    // @@protoc_insertion_point(field:CMsgSavePageToJPEG.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSavePageToJPEG.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSavePageToJPEG.filename)
    pub filename: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSavePageToJPEG.width)
    pub width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSavePageToJPEG.height)
    pub height: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSavePageToJPEG.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSavePageToJPEG {
    fn default() -> &'a CMsgSavePageToJPEG {
        <CMsgSavePageToJPEG as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSavePageToJPEG {
    pub fn new() -> CMsgSavePageToJPEG {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string filename = 3;

    pub fn filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename(&mut self) {
        self.filename = ::std::option::Option::None;
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 width = 4;

    pub fn width(&self) -> u32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional uint32 height = 5;

    pub fn height(&self) -> u32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSavePageToJPEG {
    const NAME: &'static str = "CMsgSavePageToJPEG";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.filename = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.width = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.height = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.filename.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.width {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSavePageToJPEG {
        CMsgSavePageToJPEG::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.filename = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSavePageToJPEG {
        static instance: CMsgSavePageToJPEG = CMsgSavePageToJPEG {
            browser_handle: ::std::option::Option::None,
            url: ::std::option::Option::None,
            filename: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSavePageToJPEGResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSavePageToJPEGResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgSavePageToJPEGResponse.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSavePageToJPEGResponse.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSavePageToJPEGResponse.filename)
    pub filename: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSavePageToJPEGResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSavePageToJPEGResponse {
    fn default() -> &'a CMsgSavePageToJPEGResponse {
        <CMsgSavePageToJPEGResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSavePageToJPEGResponse {
    pub fn new() -> CMsgSavePageToJPEGResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string filename = 3;

    pub fn filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename(&mut self) {
        self.filename = ::std::option::Option::None;
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgSavePageToJPEGResponse {
    const NAME: &'static str = "CMsgSavePageToJPEGResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.filename = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.filename.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSavePageToJPEGResponse {
        CMsgSavePageToJPEGResponse::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.filename = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSavePageToJPEGResponse {
        static instance: CMsgSavePageToJPEGResponse = CMsgSavePageToJPEGResponse {
            browser_handle: ::std::option::Option::None,
            url: ::std::option::Option::None,
            filename: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgJSAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgJSAlert {
    // message fields
    // @@protoc_insertion_point(field:CMsgJSAlert.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgJSAlert.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgJSAlert.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgJSAlert {
    fn default() -> &'a CMsgJSAlert {
        <CMsgJSAlert as ::protobuf::Message>::default_instance()
    }
}

impl CMsgJSAlert {
    pub fn new() -> CMsgJSAlert {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string message = 2;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgJSAlert {
    const NAME: &'static str = "CMsgJSAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgJSAlert {
        CMsgJSAlert::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgJSAlert {
        static instance: CMsgJSAlert = CMsgJSAlert {
            browser_handle: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgJSConfirm)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgJSConfirm {
    // message fields
    // @@protoc_insertion_point(field:CMsgJSConfirm.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgJSConfirm.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgJSConfirm.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgJSConfirm {
    fn default() -> &'a CMsgJSConfirm {
        <CMsgJSConfirm as ::protobuf::Message>::default_instance()
    }
}

impl CMsgJSConfirm {
    pub fn new() -> CMsgJSConfirm {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string message = 2;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgJSConfirm {
    const NAME: &'static str = "CMsgJSConfirm";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgJSConfirm {
        CMsgJSConfirm::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgJSConfirm {
        static instance: CMsgJSConfirm = CMsgJSConfirm {
            browser_handle: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgJSDialogResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgJSDialogResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgJSDialogResponse.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgJSDialogResponse.result)
    pub result: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgJSDialogResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgJSDialogResponse {
    fn default() -> &'a CMsgJSDialogResponse {
        <CMsgJSDialogResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgJSDialogResponse {
    pub fn new() -> CMsgJSDialogResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional bool result = 2;

    pub fn result(&self) -> bool {
        self.result.unwrap_or(false)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgJSDialogResponse {
    const NAME: &'static str = "CMsgJSDialogResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.result = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.result {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.result {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgJSDialogResponse {
        CMsgJSDialogResponse::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgJSDialogResponse {
        static instance: CMsgJSDialogResponse = CMsgJSDialogResponse {
            browser_handle: ::std::option::Option::None,
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgCanGoBackAndForward)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCanGoBackAndForward {
    // message fields
    // @@protoc_insertion_point(field:CMsgCanGoBackAndForward.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgCanGoBackAndForward.bgoback)
    pub bgoback: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgCanGoBackAndForward.bgoforward)
    pub bgoforward: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCanGoBackAndForward.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCanGoBackAndForward {
    fn default() -> &'a CMsgCanGoBackAndForward {
        <CMsgCanGoBackAndForward as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCanGoBackAndForward {
    pub fn new() -> CMsgCanGoBackAndForward {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional bool bgoback = 2;

    pub fn bgoback(&self) -> bool {
        self.bgoback.unwrap_or(false)
    }

    pub fn clear_bgoback(&mut self) {
        self.bgoback = ::std::option::Option::None;
    }

    pub fn has_bgoback(&self) -> bool {
        self.bgoback.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bgoback(&mut self, v: bool) {
        self.bgoback = ::std::option::Option::Some(v);
    }

    // optional bool bgoforward = 3;

    pub fn bgoforward(&self) -> bool {
        self.bgoforward.unwrap_or(false)
    }

    pub fn clear_bgoforward(&mut self) {
        self.bgoforward = ::std::option::Option::None;
    }

    pub fn has_bgoforward(&self) -> bool {
        self.bgoforward.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bgoforward(&mut self, v: bool) {
        self.bgoforward = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgCanGoBackAndForward {
    const NAME: &'static str = "CMsgCanGoBackAndForward";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.bgoback = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.bgoforward = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.bgoback {
            my_size += 1 + 1;
        }
        if let Some(v) = self.bgoforward {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.bgoback {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.bgoforward {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCanGoBackAndForward {
        CMsgCanGoBackAndForward::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.bgoback = ::std::option::Option::None;
        self.bgoforward = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCanGoBackAndForward {
        static instance: CMsgCanGoBackAndForward = CMsgCanGoBackAndForward {
            browser_handle: ::std::option::Option::None,
            bgoback: ::std::option::Option::None,
            bgoforward: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgOpenSteamURL)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgOpenSteamURL {
    // message fields
    // @@protoc_insertion_point(field:CMsgOpenSteamURL.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgOpenSteamURL.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgOpenSteamURL.referrer)
    pub referrer: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgOpenSteamURL.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgOpenSteamURL {
    fn default() -> &'a CMsgOpenSteamURL {
        <CMsgOpenSteamURL as ::protobuf::Message>::default_instance()
    }
}

impl CMsgOpenSteamURL {
    pub fn new() -> CMsgOpenSteamURL {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string referrer = 3;

    pub fn referrer(&self) -> &str {
        match self.referrer.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_referrer(&mut self) {
        self.referrer = ::std::option::Option::None;
    }

    pub fn has_referrer(&self) -> bool {
        self.referrer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_referrer(&mut self, v: ::std::string::String) {
        self.referrer = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_referrer(&mut self) -> &mut ::std::string::String {
        if self.referrer.is_none() {
            self.referrer = ::std::option::Option::Some(::std::string::String::new());
        }
        self.referrer.as_mut().unwrap()
    }

    // Take field
    pub fn take_referrer(&mut self) -> ::std::string::String {
        self.referrer.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgOpenSteamURL {
    const NAME: &'static str = "CMsgOpenSteamURL";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.referrer = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.referrer.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.referrer.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgOpenSteamURL {
        CMsgOpenSteamURL::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.referrer = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgOpenSteamURL {
        static instance: CMsgOpenSteamURL = CMsgOpenSteamURL {
            browser_handle: ::std::option::Option::None,
            url: ::std::option::Option::None,
            referrer: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSetCookie)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetCookie {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetCookie.key)
    pub key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSetCookie.value)
    pub value: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSetCookie.path)
    pub path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSetCookie.host)
    pub host: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSetCookie.expires)
    pub expires: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetCookie.secure)
    pub secure: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSetCookie.httponly)
    pub httponly: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetCookie.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetCookie {
    fn default() -> &'a CMsgSetCookie {
        <CMsgSetCookie as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetCookie {
    pub fn new() -> CMsgSetCookie {
        ::std::default::Default::default()
    }

    // optional string key = 1;

    pub fn key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 2;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string path = 3;

    pub fn path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_path(&mut self) {
        self.path = ::std::option::Option::None;
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string host = 4;

    pub fn host(&self) -> &str {
        match self.host.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_host(&mut self) {
        self.host = ::std::option::Option::None;
    }

    pub fn has_host(&self) -> bool {
        self.host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host(&mut self, v: ::std::string::String) {
        self.host = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host(&mut self) -> &mut ::std::string::String {
        if self.host.is_none() {
            self.host = ::std::option::Option::Some(::std::string::String::new());
        }
        self.host.as_mut().unwrap()
    }

    // Take field
    pub fn take_host(&mut self) -> ::std::string::String {
        self.host.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 expires = 5;

    pub fn expires(&self) -> u32 {
        self.expires.unwrap_or(0)
    }

    pub fn clear_expires(&mut self) {
        self.expires = ::std::option::Option::None;
    }

    pub fn has_expires(&self) -> bool {
        self.expires.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expires(&mut self, v: u32) {
        self.expires = ::std::option::Option::Some(v);
    }

    // optional bool secure = 6;

    pub fn secure(&self) -> bool {
        self.secure.unwrap_or(false)
    }

    pub fn clear_secure(&mut self) {
        self.secure = ::std::option::Option::None;
    }

    pub fn has_secure(&self) -> bool {
        self.secure.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secure(&mut self, v: bool) {
        self.secure = ::std::option::Option::Some(v);
    }

    // optional bool httponly = 7;

    pub fn httponly(&self) -> bool {
        self.httponly.unwrap_or(false)
    }

    pub fn clear_httponly(&mut self) {
        self.httponly = ::std::option::Option::None;
    }

    pub fn has_httponly(&self) -> bool {
        self.httponly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_httponly(&mut self, v: bool) {
        self.httponly = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSetCookie {
    const NAME: &'static str = "CMsgSetCookie";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.path = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.host = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.expires = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.secure = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.httponly = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.host.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.expires {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.secure {
            my_size += 1 + 1;
        }
        if let Some(v) = self.httponly {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.path.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.host.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.expires {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.secure {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.httponly {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetCookie {
        CMsgSetCookie::new()
    }

    fn clear(&mut self) {
        self.key = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.path = ::std::option::Option::None;
        self.host = ::std::option::Option::None;
        self.expires = ::std::option::Option::None;
        self.secure = ::std::option::Option::None;
        self.httponly = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetCookie {
        static instance: CMsgSetCookie = CMsgSetCookie {
            key: ::std::option::Option::None,
            value: ::std::option::Option::None,
            path: ::std::option::Option::None,
            host: ::std::option::Option::None,
            expires: ::std::option::Option::None,
            secure: ::std::option::Option::None,
            httponly: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSetTargetFrameRate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetTargetFrameRate {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetTargetFrameRate.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetTargetFrameRate.nTargetFrameRate)
    pub nTargetFrameRate: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetTargetFrameRate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetTargetFrameRate {
    fn default() -> &'a CMsgSetTargetFrameRate {
        <CMsgSetTargetFrameRate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetTargetFrameRate {
    pub fn new() -> CMsgSetTargetFrameRate {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 nTargetFrameRate = 2;

    pub fn nTargetFrameRate(&self) -> u32 {
        self.nTargetFrameRate.unwrap_or(0)
    }

    pub fn clear_nTargetFrameRate(&mut self) {
        self.nTargetFrameRate = ::std::option::Option::None;
    }

    pub fn has_nTargetFrameRate(&self) -> bool {
        self.nTargetFrameRate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nTargetFrameRate(&mut self, v: u32) {
        self.nTargetFrameRate = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSetTargetFrameRate {
    const NAME: &'static str = "CMsgSetTargetFrameRate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.nTargetFrameRate = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.nTargetFrameRate {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.nTargetFrameRate {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetTargetFrameRate {
        CMsgSetTargetFrameRate::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.nTargetFrameRate = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetTargetFrameRate {
        static instance: CMsgSetTargetFrameRate = CMsgSetTargetFrameRate {
            browser_handle: ::std::option::Option::None,
            nTargetFrameRate: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPauseRepaint)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPauseRepaint {
    // message fields
    // @@protoc_insertion_point(field:CMsgPauseRepaint.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPauseRepaint.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPauseRepaint {
    fn default() -> &'a CMsgPauseRepaint {
        <CMsgPauseRepaint as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPauseRepaint {
    pub fn new() -> CMsgPauseRepaint {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgPauseRepaint {
    const NAME: &'static str = "CMsgPauseRepaint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPauseRepaint {
        CMsgPauseRepaint::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPauseRepaint {
        static instance: CMsgPauseRepaint = CMsgPauseRepaint {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgFullRepaint)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFullRepaint {
    // message fields
    // @@protoc_insertion_point(field:CMsgFullRepaint.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFullRepaint.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFullRepaint {
    fn default() -> &'a CMsgFullRepaint {
        <CMsgFullRepaint as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFullRepaint {
    pub fn new() -> CMsgFullRepaint {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgFullRepaint {
    const NAME: &'static str = "CMsgFullRepaint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFullRepaint {
        CMsgFullRepaint::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFullRepaint {
        static instance: CMsgFullRepaint = CMsgFullRepaint {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgRequestFullScreen)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRequestFullScreen {
    // message fields
    // @@protoc_insertion_point(field:CMsgRequestFullScreen.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRequestFullScreen.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRequestFullScreen {
    fn default() -> &'a CMsgRequestFullScreen {
        <CMsgRequestFullScreen as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRequestFullScreen {
    pub fn new() -> CMsgRequestFullScreen {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgRequestFullScreen {
    const NAME: &'static str = "CMsgRequestFullScreen";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRequestFullScreen {
        CMsgRequestFullScreen::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRequestFullScreen {
        static instance: CMsgRequestFullScreen = CMsgRequestFullScreen {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgExitFullScreen)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgExitFullScreen {
    // message fields
    // @@protoc_insertion_point(field:CMsgExitFullScreen.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgExitFullScreen.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgExitFullScreen {
    fn default() -> &'a CMsgExitFullScreen {
        <CMsgExitFullScreen as ::protobuf::Message>::default_instance()
    }
}

impl CMsgExitFullScreen {
    pub fn new() -> CMsgExitFullScreen {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgExitFullScreen {
    const NAME: &'static str = "CMsgExitFullScreen";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgExitFullScreen {
        CMsgExitFullScreen::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgExitFullScreen {
        static instance: CMsgExitFullScreen = CMsgExitFullScreen {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgToggleFindInPageDialog)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgToggleFindInPageDialog {
    // message fields
    // @@protoc_insertion_point(field:CMsgToggleFindInPageDialog.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgToggleFindInPageDialog.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgToggleFindInPageDialog {
    fn default() -> &'a CMsgToggleFindInPageDialog {
        <CMsgToggleFindInPageDialog as ::protobuf::Message>::default_instance()
    }
}

impl CMsgToggleFindInPageDialog {
    pub fn new() -> CMsgToggleFindInPageDialog {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgToggleFindInPageDialog {
    const NAME: &'static str = "CMsgToggleFindInPageDialog";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgToggleFindInPageDialog {
        CMsgToggleFindInPageDialog::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgToggleFindInPageDialog {
        static instance: CMsgToggleFindInPageDialog = CMsgToggleFindInPageDialog {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSetPIDShuttingDown)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetPIDShuttingDown {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetPIDShuttingDown.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetPIDShuttingDown.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetPIDShuttingDown {
    fn default() -> &'a CMsgSetPIDShuttingDown {
        <CMsgSetPIDShuttingDown as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetPIDShuttingDown {
    pub fn new() -> CMsgSetPIDShuttingDown {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSetPIDShuttingDown {
    const NAME: &'static str = "CMsgSetPIDShuttingDown";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetPIDShuttingDown {
        CMsgSetPIDShuttingDown::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetPIDShuttingDown {
        static instance: CMsgSetPIDShuttingDown = CMsgSetPIDShuttingDown {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDisableBackgroundThrottling)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDisableBackgroundThrottling {
    // message fields
    // @@protoc_insertion_point(field:CMsgDisableBackgroundThrottling.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDisableBackgroundThrottling.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDisableBackgroundThrottling {
    fn default() -> &'a CMsgDisableBackgroundThrottling {
        <CMsgDisableBackgroundThrottling as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDisableBackgroundThrottling {
    pub fn new() -> CMsgDisableBackgroundThrottling {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgDisableBackgroundThrottling {
    const NAME: &'static str = "CMsgDisableBackgroundThrottling";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDisableBackgroundThrottling {
        CMsgDisableBackgroundThrottling::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDisableBackgroundThrottling {
        static instance: CMsgDisableBackgroundThrottling = CMsgDisableBackgroundThrottling {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgAckPIDShuttingDown)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAckPIDShuttingDown {
    // message fields
    // @@protoc_insertion_point(field:CMsgAckPIDShuttingDown.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAckPIDShuttingDown.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAckPIDShuttingDown {
    fn default() -> &'a CMsgAckPIDShuttingDown {
        <CMsgAckPIDShuttingDown as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAckPIDShuttingDown {
    pub fn new() -> CMsgAckPIDShuttingDown {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgAckPIDShuttingDown {
    const NAME: &'static str = "CMsgAckPIDShuttingDown";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAckPIDShuttingDown {
        CMsgAckPIDShuttingDown::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAckPIDShuttingDown {
        static instance: CMsgAckPIDShuttingDown = CMsgAckPIDShuttingDown {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGetCookiesForURL)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGetCookiesForURL {
    // message fields
    // @@protoc_insertion_point(field:CMsgGetCookiesForURL.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGetCookiesForURL.url)
    pub url: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGetCookiesForURL.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGetCookiesForURL {
    fn default() -> &'a CMsgGetCookiesForURL {
        <CMsgGetCookiesForURL as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGetCookiesForURL {
    pub fn new() -> CMsgGetCookiesForURL {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgGetCookiesForURL {
    const NAME: &'static str = "CMsgGetCookiesForURL";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGetCookiesForURL {
        CMsgGetCookiesForURL::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGetCookiesForURL {
        static instance: CMsgGetCookiesForURL = CMsgGetCookiesForURL {
            browser_handle: ::std::option::Option::None,
            url: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCookie)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCookie {
    // message fields
    // @@protoc_insertion_point(field:CCookie.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCookie.value)
    pub value: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCookie.domain)
    pub domain: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCookie.path)
    pub path: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CCookie.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCookie {
    fn default() -> &'a CCookie {
        <CCookie as ::protobuf::Message>::default_instance()
    }
}

impl CCookie {
    pub fn new() -> CCookie {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 2;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string domain = 3;

    pub fn domain(&self) -> &str {
        match self.domain.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_domain(&mut self) {
        self.domain = ::std::option::Option::None;
    }

    pub fn has_domain(&self) -> bool {
        self.domain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_domain(&mut self, v: ::std::string::String) {
        self.domain = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_domain(&mut self) -> &mut ::std::string::String {
        if self.domain.is_none() {
            self.domain = ::std::option::Option::Some(::std::string::String::new());
        }
        self.domain.as_mut().unwrap()
    }

    // Take field
    pub fn take_domain(&mut self) -> ::std::string::String {
        self.domain.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string path = 4;

    pub fn path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_path(&mut self) {
        self.path = ::std::option::Option::None;
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CCookie {
    const NAME: &'static str = "CCookie";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.domain = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.path = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.domain.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.domain.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.path.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCookie {
        CCookie::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.domain = ::std::option::Option::None;
        self.path = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCookie {
        static instance: CCookie = CCookie {
            name: ::std::option::Option::None,
            value: ::std::option::Option::None,
            domain: ::std::option::Option::None,
            path: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGetCookiesForURLResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGetCookiesForURLResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGetCookiesForURLResponse.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGetCookiesForURLResponse.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGetCookiesForURLResponse.cookies)
    pub cookies: ::std::vec::Vec<CCookie>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGetCookiesForURLResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGetCookiesForURLResponse {
    fn default() -> &'a CMsgGetCookiesForURLResponse {
        <CMsgGetCookiesForURLResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGetCookiesForURLResponse {
    pub fn new() -> CMsgGetCookiesForURLResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgGetCookiesForURLResponse {
    const NAME: &'static str = "CMsgGetCookiesForURLResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.cookies.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.cookies {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.cookies {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGetCookiesForURLResponse {
        CMsgGetCookiesForURLResponse::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.cookies.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGetCookiesForURLResponse {
        static instance: CMsgGetCookiesForURLResponse = CMsgGetCookiesForURLResponse {
            browser_handle: ::std::option::Option::None,
            url: ::std::option::Option::None,
            cookies: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgNodeHasFocus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgNodeHasFocus {
    // message fields
    // @@protoc_insertion_point(field:CMsgNodeHasFocus.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgNodeHasFocus.bInput)
    pub bInput: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgNodeHasFocus.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgNodeHasFocus.elementtagname)
    pub elementtagname: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgNodeHasFocus.searchbuttontext)
    pub searchbuttontext: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgNodeHasFocus.bHasMultipleInputs)
    pub bHasMultipleInputs: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgNodeHasFocus.input_type)
    pub input_type: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgNodeHasFocus.bIsMainFrame)
    pub bIsMainFrame: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgNodeHasFocus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgNodeHasFocus {
    fn default() -> &'a CMsgNodeHasFocus {
        <CMsgNodeHasFocus as ::protobuf::Message>::default_instance()
    }
}

impl CMsgNodeHasFocus {
    pub fn new() -> CMsgNodeHasFocus {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional bool bInput = 2;

    pub fn bInput(&self) -> bool {
        self.bInput.unwrap_or(false)
    }

    pub fn clear_bInput(&mut self) {
        self.bInput = ::std::option::Option::None;
    }

    pub fn has_bInput(&self) -> bool {
        self.bInput.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bInput(&mut self, v: bool) {
        self.bInput = ::std::option::Option::Some(v);
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string elementtagname = 4;

    pub fn elementtagname(&self) -> &str {
        match self.elementtagname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_elementtagname(&mut self) {
        self.elementtagname = ::std::option::Option::None;
    }

    pub fn has_elementtagname(&self) -> bool {
        self.elementtagname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_elementtagname(&mut self, v: ::std::string::String) {
        self.elementtagname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_elementtagname(&mut self) -> &mut ::std::string::String {
        if self.elementtagname.is_none() {
            self.elementtagname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.elementtagname.as_mut().unwrap()
    }

    // Take field
    pub fn take_elementtagname(&mut self) -> ::std::string::String {
        self.elementtagname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string searchbuttontext = 5;

    pub fn searchbuttontext(&self) -> &str {
        match self.searchbuttontext.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_searchbuttontext(&mut self) {
        self.searchbuttontext = ::std::option::Option::None;
    }

    pub fn has_searchbuttontext(&self) -> bool {
        self.searchbuttontext.is_some()
    }

    // Param is passed by value, moved
    pub fn set_searchbuttontext(&mut self, v: ::std::string::String) {
        self.searchbuttontext = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_searchbuttontext(&mut self) -> &mut ::std::string::String {
        if self.searchbuttontext.is_none() {
            self.searchbuttontext = ::std::option::Option::Some(::std::string::String::new());
        }
        self.searchbuttontext.as_mut().unwrap()
    }

    // Take field
    pub fn take_searchbuttontext(&mut self) -> ::std::string::String {
        self.searchbuttontext.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool bHasMultipleInputs = 6;

    pub fn bHasMultipleInputs(&self) -> bool {
        self.bHasMultipleInputs.unwrap_or(false)
    }

    pub fn clear_bHasMultipleInputs(&mut self) {
        self.bHasMultipleInputs = ::std::option::Option::None;
    }

    pub fn has_bHasMultipleInputs(&self) -> bool {
        self.bHasMultipleInputs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bHasMultipleInputs(&mut self, v: bool) {
        self.bHasMultipleInputs = ::std::option::Option::Some(v);
    }

    // optional string input_type = 7;

    pub fn input_type(&self) -> &str {
        match self.input_type.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_input_type(&mut self) {
        self.input_type = ::std::option::Option::None;
    }

    pub fn has_input_type(&self) -> bool {
        self.input_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_type(&mut self, v: ::std::string::String) {
        self.input_type = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_input_type(&mut self) -> &mut ::std::string::String {
        if self.input_type.is_none() {
            self.input_type = ::std::option::Option::Some(::std::string::String::new());
        }
        self.input_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_input_type(&mut self) -> ::std::string::String {
        self.input_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool bIsMainFrame = 8;

    pub fn bIsMainFrame(&self) -> bool {
        self.bIsMainFrame.unwrap_or(false)
    }

    pub fn clear_bIsMainFrame(&mut self) {
        self.bIsMainFrame = ::std::option::Option::None;
    }

    pub fn has_bIsMainFrame(&self) -> bool {
        self.bIsMainFrame.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bIsMainFrame(&mut self, v: bool) {
        self.bIsMainFrame = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgNodeHasFocus {
    const NAME: &'static str = "CMsgNodeHasFocus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.bInput = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.elementtagname = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.searchbuttontext = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.bHasMultipleInputs = ::std::option::Option::Some(is.read_bool()?);
                },
                58 => {
                    self.input_type = ::std::option::Option::Some(is.read_string()?);
                },
                64 => {
                    self.bIsMainFrame = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.bInput {
            my_size += 1 + 1;
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.elementtagname.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.searchbuttontext.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.bHasMultipleInputs {
            my_size += 1 + 1;
        }
        if let Some(v) = self.input_type.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.bIsMainFrame {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.bInput {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.elementtagname.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.searchbuttontext.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.bHasMultipleInputs {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.input_type.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.bIsMainFrame {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgNodeHasFocus {
        CMsgNodeHasFocus::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.bInput = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.elementtagname = ::std::option::Option::None;
        self.searchbuttontext = ::std::option::Option::None;
        self.bHasMultipleInputs = ::std::option::Option::None;
        self.input_type = ::std::option::Option::None;
        self.bIsMainFrame = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgNodeHasFocus {
        static instance: CMsgNodeHasFocus = CMsgNodeHasFocus {
            browser_handle: ::std::option::Option::None,
            bInput: ::std::option::Option::None,
            name: ::std::option::Option::None,
            elementtagname: ::std::option::Option::None,
            searchbuttontext: ::std::option::Option::None,
            bHasMultipleInputs: ::std::option::Option::None,
            input_type: ::std::option::Option::None,
            bIsMainFrame: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgZoomToFocusedElement)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgZoomToFocusedElement {
    // message fields
    // @@protoc_insertion_point(field:CMsgZoomToFocusedElement.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgZoomToFocusedElement.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgZoomToFocusedElement {
    fn default() -> &'a CMsgZoomToFocusedElement {
        <CMsgZoomToFocusedElement as ::protobuf::Message>::default_instance()
    }
}

impl CMsgZoomToFocusedElement {
    pub fn new() -> CMsgZoomToFocusedElement {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgZoomToFocusedElement {
    const NAME: &'static str = "CMsgZoomToFocusedElement";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgZoomToFocusedElement {
        CMsgZoomToFocusedElement::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgZoomToFocusedElement {
        static instance: CMsgZoomToFocusedElement = CMsgZoomToFocusedElement {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgCloseFullScreenFlashIfOpen)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCloseFullScreenFlashIfOpen {
    // message fields
    // @@protoc_insertion_point(field:CMsgCloseFullScreenFlashIfOpen.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCloseFullScreenFlashIfOpen.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCloseFullScreenFlashIfOpen {
    fn default() -> &'a CMsgCloseFullScreenFlashIfOpen {
        <CMsgCloseFullScreenFlashIfOpen as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCloseFullScreenFlashIfOpen {
    pub fn new() -> CMsgCloseFullScreenFlashIfOpen {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgCloseFullScreenFlashIfOpen {
    const NAME: &'static str = "CMsgCloseFullScreenFlashIfOpen";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCloseFullScreenFlashIfOpen {
        CMsgCloseFullScreenFlashIfOpen::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCloseFullScreenFlashIfOpen {
        static instance: CMsgCloseFullScreenFlashIfOpen = CMsgCloseFullScreenFlashIfOpen {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPauseFullScreenFlashMovieIfOpen)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPauseFullScreenFlashMovieIfOpen {
    // message fields
    // @@protoc_insertion_point(field:CMsgPauseFullScreenFlashMovieIfOpen.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPauseFullScreenFlashMovieIfOpen.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPauseFullScreenFlashMovieIfOpen {
    fn default() -> &'a CMsgPauseFullScreenFlashMovieIfOpen {
        <CMsgPauseFullScreenFlashMovieIfOpen as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPauseFullScreenFlashMovieIfOpen {
    pub fn new() -> CMsgPauseFullScreenFlashMovieIfOpen {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgPauseFullScreenFlashMovieIfOpen {
    const NAME: &'static str = "CMsgPauseFullScreenFlashMovieIfOpen";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPauseFullScreenFlashMovieIfOpen {
        CMsgPauseFullScreenFlashMovieIfOpen::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPauseFullScreenFlashMovieIfOpen {
        static instance: CMsgPauseFullScreenFlashMovieIfOpen = CMsgPauseFullScreenFlashMovieIfOpen {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgFocusedNodeText)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFocusedNodeText {
    // message fields
    // @@protoc_insertion_point(field:CMsgFocusedNodeText.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFocusedNodeText.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFocusedNodeText {
    fn default() -> &'a CMsgFocusedNodeText {
        <CMsgFocusedNodeText as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFocusedNodeText {
    pub fn new() -> CMsgFocusedNodeText {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgFocusedNodeText {
    const NAME: &'static str = "CMsgFocusedNodeText";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFocusedNodeText {
        CMsgFocusedNodeText::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFocusedNodeText {
        static instance: CMsgFocusedNodeText = CMsgFocusedNodeText {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgFocusedNodeTextResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFocusedNodeTextResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgFocusedNodeTextResponse.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgFocusedNodeTextResponse.value)
    pub value: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFocusedNodeTextResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFocusedNodeTextResponse {
    fn default() -> &'a CMsgFocusedNodeTextResponse {
        <CMsgFocusedNodeTextResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFocusedNodeTextResponse {
    pub fn new() -> CMsgFocusedNodeTextResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string value = 2;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgFocusedNodeTextResponse {
    const NAME: &'static str = "CMsgFocusedNodeTextResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFocusedNodeTextResponse {
        CMsgFocusedNodeTextResponse::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFocusedNodeTextResponse {
        static instance: CMsgFocusedNodeTextResponse = CMsgFocusedNodeTextResponse {
            browser_handle: ::std::option::Option::None,
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgBuildID)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBuildID {
    // message fields
    // @@protoc_insertion_point(field:CMsgBuildID.build_id)
    pub build_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBuildID.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBuildID {
    fn default() -> &'a CMsgBuildID {
        <CMsgBuildID as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBuildID {
    pub fn new() -> CMsgBuildID {
        ::std::default::Default::default()
    }

    // optional uint64 build_id = 1;

    pub fn build_id(&self) -> u64 {
        self.build_id.unwrap_or(0)
    }

    pub fn clear_build_id(&mut self) {
        self.build_id = ::std::option::Option::None;
    }

    pub fn has_build_id(&self) -> bool {
        self.build_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_build_id(&mut self, v: u64) {
        self.build_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgBuildID {
    const NAME: &'static str = "CMsgBuildID";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.build_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.build_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.build_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBuildID {
        CMsgBuildID::new()
    }

    fn clear(&mut self) {
        self.build_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBuildID {
        static instance: CMsgBuildID = CMsgBuildID {
            build_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgOpenDevTools)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgOpenDevTools {
    // message fields
    // @@protoc_insertion_point(field:CMsgOpenDevTools.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgOpenDevTools.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgOpenDevTools {
    fn default() -> &'a CMsgOpenDevTools {
        <CMsgOpenDevTools as ::protobuf::Message>::default_instance()
    }
}

impl CMsgOpenDevTools {
    pub fn new() -> CMsgOpenDevTools {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgOpenDevTools {
    const NAME: &'static str = "CMsgOpenDevTools";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgOpenDevTools {
        CMsgOpenDevTools::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgOpenDevTools {
        static instance: CMsgOpenDevTools = CMsgOpenDevTools {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgCloseDevTools)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCloseDevTools {
    // message fields
    // @@protoc_insertion_point(field:CMsgCloseDevTools.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCloseDevTools.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCloseDevTools {
    fn default() -> &'a CMsgCloseDevTools {
        <CMsgCloseDevTools as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCloseDevTools {
    pub fn new() -> CMsgCloseDevTools {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgCloseDevTools {
    const NAME: &'static str = "CMsgCloseDevTools";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCloseDevTools {
        CMsgCloseDevTools::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCloseDevTools {
        static instance: CMsgCloseDevTools = CMsgCloseDevTools {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgUnlockH264)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgUnlockH264 {
    // message fields
    // @@protoc_insertion_point(field:CMsgUnlockH264.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgUnlockH264.unlock_code)
    pub unlock_code: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgUnlockH264.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgUnlockH264 {
    fn default() -> &'a CMsgUnlockH264 {
        <CMsgUnlockH264 as ::protobuf::Message>::default_instance()
    }
}

impl CMsgUnlockH264 {
    pub fn new() -> CMsgUnlockH264 {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string unlock_code = 2;

    pub fn unlock_code(&self) -> &str {
        match self.unlock_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_unlock_code(&mut self) {
        self.unlock_code = ::std::option::Option::None;
    }

    pub fn has_unlock_code(&self) -> bool {
        self.unlock_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unlock_code(&mut self, v: ::std::string::String) {
        self.unlock_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unlock_code(&mut self) -> &mut ::std::string::String {
        if self.unlock_code.is_none() {
            self.unlock_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.unlock_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_unlock_code(&mut self) -> ::std::string::String {
        self.unlock_code.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgUnlockH264 {
    const NAME: &'static str = "CMsgUnlockH264";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.unlock_code = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.unlock_code.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.unlock_code.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgUnlockH264 {
        CMsgUnlockH264::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unlock_code = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgUnlockH264 {
        static instance: CMsgUnlockH264 = CMsgUnlockH264 {
            browser_handle: ::std::option::Option::None,
            unlock_code: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgScreenInformationChanged)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgScreenInformationChanged {
    // message fields
    // @@protoc_insertion_point(field:CMsgScreenInformationChanged.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgScreenInformationChanged.override_width)
    pub override_width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgScreenInformationChanged.override_height)
    pub override_height: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgScreenInformationChanged.monitor_left)
    pub monitor_left: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgScreenInformationChanged.monitor_top)
    pub monitor_top: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgScreenInformationChanged.monitor_right)
    pub monitor_right: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgScreenInformationChanged.monitor_bottom)
    pub monitor_bottom: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgScreenInformationChanged.usable_left)
    pub usable_left: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgScreenInformationChanged.usable_top)
    pub usable_top: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgScreenInformationChanged.usable_right)
    pub usable_right: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgScreenInformationChanged.usable_bottom)
    pub usable_bottom: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgScreenInformationChanged.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgScreenInformationChanged {
    fn default() -> &'a CMsgScreenInformationChanged {
        <CMsgScreenInformationChanged as ::protobuf::Message>::default_instance()
    }
}

impl CMsgScreenInformationChanged {
    pub fn new() -> CMsgScreenInformationChanged {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 override_width = 2;

    pub fn override_width(&self) -> u32 {
        self.override_width.unwrap_or(0)
    }

    pub fn clear_override_width(&mut self) {
        self.override_width = ::std::option::Option::None;
    }

    pub fn has_override_width(&self) -> bool {
        self.override_width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_override_width(&mut self, v: u32) {
        self.override_width = ::std::option::Option::Some(v);
    }

    // optional uint32 override_height = 3;

    pub fn override_height(&self) -> u32 {
        self.override_height.unwrap_or(0)
    }

    pub fn clear_override_height(&mut self) {
        self.override_height = ::std::option::Option::None;
    }

    pub fn has_override_height(&self) -> bool {
        self.override_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_override_height(&mut self, v: u32) {
        self.override_height = ::std::option::Option::Some(v);
    }

    // optional uint32 monitor_left = 4;

    pub fn monitor_left(&self) -> u32 {
        self.monitor_left.unwrap_or(0)
    }

    pub fn clear_monitor_left(&mut self) {
        self.monitor_left = ::std::option::Option::None;
    }

    pub fn has_monitor_left(&self) -> bool {
        self.monitor_left.is_some()
    }

    // Param is passed by value, moved
    pub fn set_monitor_left(&mut self, v: u32) {
        self.monitor_left = ::std::option::Option::Some(v);
    }

    // optional uint32 monitor_top = 5;

    pub fn monitor_top(&self) -> u32 {
        self.monitor_top.unwrap_or(0)
    }

    pub fn clear_monitor_top(&mut self) {
        self.monitor_top = ::std::option::Option::None;
    }

    pub fn has_monitor_top(&self) -> bool {
        self.monitor_top.is_some()
    }

    // Param is passed by value, moved
    pub fn set_monitor_top(&mut self, v: u32) {
        self.monitor_top = ::std::option::Option::Some(v);
    }

    // optional uint32 monitor_right = 6;

    pub fn monitor_right(&self) -> u32 {
        self.monitor_right.unwrap_or(0)
    }

    pub fn clear_monitor_right(&mut self) {
        self.monitor_right = ::std::option::Option::None;
    }

    pub fn has_monitor_right(&self) -> bool {
        self.monitor_right.is_some()
    }

    // Param is passed by value, moved
    pub fn set_monitor_right(&mut self, v: u32) {
        self.monitor_right = ::std::option::Option::Some(v);
    }

    // optional uint32 monitor_bottom = 7;

    pub fn monitor_bottom(&self) -> u32 {
        self.monitor_bottom.unwrap_or(0)
    }

    pub fn clear_monitor_bottom(&mut self) {
        self.monitor_bottom = ::std::option::Option::None;
    }

    pub fn has_monitor_bottom(&self) -> bool {
        self.monitor_bottom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_monitor_bottom(&mut self, v: u32) {
        self.monitor_bottom = ::std::option::Option::Some(v);
    }

    // optional uint32 usable_left = 8;

    pub fn usable_left(&self) -> u32 {
        self.usable_left.unwrap_or(0)
    }

    pub fn clear_usable_left(&mut self) {
        self.usable_left = ::std::option::Option::None;
    }

    pub fn has_usable_left(&self) -> bool {
        self.usable_left.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usable_left(&mut self, v: u32) {
        self.usable_left = ::std::option::Option::Some(v);
    }

    // optional uint32 usable_top = 9;

    pub fn usable_top(&self) -> u32 {
        self.usable_top.unwrap_or(0)
    }

    pub fn clear_usable_top(&mut self) {
        self.usable_top = ::std::option::Option::None;
    }

    pub fn has_usable_top(&self) -> bool {
        self.usable_top.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usable_top(&mut self, v: u32) {
        self.usable_top = ::std::option::Option::Some(v);
    }

    // optional uint32 usable_right = 10;

    pub fn usable_right(&self) -> u32 {
        self.usable_right.unwrap_or(0)
    }

    pub fn clear_usable_right(&mut self) {
        self.usable_right = ::std::option::Option::None;
    }

    pub fn has_usable_right(&self) -> bool {
        self.usable_right.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usable_right(&mut self, v: u32) {
        self.usable_right = ::std::option::Option::Some(v);
    }

    // optional uint32 usable_bottom = 11;

    pub fn usable_bottom(&self) -> u32 {
        self.usable_bottom.unwrap_or(0)
    }

    pub fn clear_usable_bottom(&mut self) {
        self.usable_bottom = ::std::option::Option::None;
    }

    pub fn has_usable_bottom(&self) -> bool {
        self.usable_bottom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usable_bottom(&mut self, v: u32) {
        self.usable_bottom = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgScreenInformationChanged {
    const NAME: &'static str = "CMsgScreenInformationChanged";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.override_width = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.override_height = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.monitor_left = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.monitor_top = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.monitor_right = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.monitor_bottom = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.usable_left = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.usable_top = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.usable_right = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.usable_bottom = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.override_width {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.override_height {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.monitor_left {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.monitor_top {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.monitor_right {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.monitor_bottom {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.usable_left {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.usable_top {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.usable_right {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.usable_bottom {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.override_width {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.override_height {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.monitor_left {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.monitor_top {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.monitor_right {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.monitor_bottom {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.usable_left {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.usable_top {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.usable_right {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.usable_bottom {
            os.write_uint32(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgScreenInformationChanged {
        CMsgScreenInformationChanged::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.override_width = ::std::option::Option::None;
        self.override_height = ::std::option::Option::None;
        self.monitor_left = ::std::option::Option::None;
        self.monitor_top = ::std::option::Option::None;
        self.monitor_right = ::std::option::Option::None;
        self.monitor_bottom = ::std::option::Option::None;
        self.usable_left = ::std::option::Option::None;
        self.usable_top = ::std::option::Option::None;
        self.usable_right = ::std::option::Option::None;
        self.usable_bottom = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgScreenInformationChanged {
        static instance: CMsgScreenInformationChanged = CMsgScreenInformationChanged {
            browser_handle: ::std::option::Option::None,
            override_width: ::std::option::Option::None,
            override_height: ::std::option::Option::None,
            monitor_left: ::std::option::Option::None,
            monitor_top: ::std::option::Option::None,
            monitor_right: ::std::option::Option::None,
            monitor_bottom: ::std::option::Option::None,
            usable_left: ::std::option::Option::None,
            usable_top: ::std::option::Option::None,
            usable_right: ::std::option::Option::None,
            usable_bottom: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClearAllCookies)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClearAllCookies {
    // message fields
    // @@protoc_insertion_point(field:CMsgClearAllCookies.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClearAllCookies.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClearAllCookies {
    fn default() -> &'a CMsgClearAllCookies {
        <CMsgClearAllCookies as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClearAllCookies {
    pub fn new() -> CMsgClearAllCookies {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClearAllCookies {
    const NAME: &'static str = "CMsgClearAllCookies";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClearAllCookies {
        CMsgClearAllCookies::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClearAllCookies {
        static instance: CMsgClearAllCookies = CMsgClearAllCookies {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgScreenDPI)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgScreenDPI {
    // message fields
    // @@protoc_insertion_point(field:CMsgScreenDPI.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgScreenDPI.dpi_scaling)
    pub dpi_scaling: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgScreenDPI.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgScreenDPI {
    fn default() -> &'a CMsgScreenDPI {
        <CMsgScreenDPI as ::protobuf::Message>::default_instance()
    }
}

impl CMsgScreenDPI {
    pub fn new() -> CMsgScreenDPI {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional float dpi_scaling = 2;

    pub fn dpi_scaling(&self) -> f32 {
        self.dpi_scaling.unwrap_or(0.)
    }

    pub fn clear_dpi_scaling(&mut self) {
        self.dpi_scaling = ::std::option::Option::None;
    }

    pub fn has_dpi_scaling(&self) -> bool {
        self.dpi_scaling.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dpi_scaling(&mut self, v: f32) {
        self.dpi_scaling = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgScreenDPI {
    const NAME: &'static str = "CMsgScreenDPI";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.dpi_scaling = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.dpi_scaling {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.dpi_scaling {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgScreenDPI {
        CMsgScreenDPI::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.dpi_scaling = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgScreenDPI {
        static instance: CMsgScreenDPI = CMsgScreenDPI {
            browser_handle: ::std::option::Option::None,
            dpi_scaling: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgAckScreenDPI)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAckScreenDPI {
    // message fields
    // @@protoc_insertion_point(field:CMsgAckScreenDPI.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAckScreenDPI.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAckScreenDPI {
    fn default() -> &'a CMsgAckScreenDPI {
        <CMsgAckScreenDPI as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAckScreenDPI {
    pub fn new() -> CMsgAckScreenDPI {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgAckScreenDPI {
    const NAME: &'static str = "CMsgAckScreenDPI";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAckScreenDPI {
        CMsgAckScreenDPI::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAckScreenDPI {
        static instance: CMsgAckScreenDPI = CMsgAckScreenDPI {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgAuthedSteamDomains)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAuthedSteamDomains {
    // message fields
    // @@protoc_insertion_point(field:CMsgAuthedSteamDomains.domains)
    pub domains: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAuthedSteamDomains.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAuthedSteamDomains {
    fn default() -> &'a CMsgAuthedSteamDomains {
        <CMsgAuthedSteamDomains as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAuthedSteamDomains {
    pub fn new() -> CMsgAuthedSteamDomains {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgAuthedSteamDomains {
    const NAME: &'static str = "CMsgAuthedSteamDomains";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.domains.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.domains {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.domains {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAuthedSteamDomains {
        CMsgAuthedSteamDomains::new()
    }

    fn clear(&mut self) {
        self.domains.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAuthedSteamDomains {
        static instance: CMsgAuthedSteamDomains = CMsgAuthedSteamDomains {
            domains: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSteamAuthNeeded)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamAuthNeeded {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamAuthNeeded.filler)
    pub filler: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamAuthNeeded.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamAuthNeeded {
    fn default() -> &'a CMsgSteamAuthNeeded {
        <CMsgSteamAuthNeeded as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamAuthNeeded {
    pub fn new() -> CMsgSteamAuthNeeded {
        ::std::default::Default::default()
    }

    // optional bool filler = 1;

    pub fn filler(&self) -> bool {
        self.filler.unwrap_or(false)
    }

    pub fn clear_filler(&mut self) {
        self.filler = ::std::option::Option::None;
    }

    pub fn has_filler(&self) -> bool {
        self.filler.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filler(&mut self, v: bool) {
        self.filler = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamAuthNeeded {
    const NAME: &'static str = "CMsgSteamAuthNeeded";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.filler = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.filler {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.filler {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamAuthNeeded {
        CMsgSteamAuthNeeded::new()
    }

    fn clear(&mut self) {
        self.filler = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamAuthNeeded {
        static instance: CMsgSteamAuthNeeded = CMsgSteamAuthNeeded {
            filler: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSteamAuthCookiesSet)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamAuthCookiesSet {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamAuthCookiesSet.success)
    pub success: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamAuthCookiesSet.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamAuthCookiesSet {
    fn default() -> &'a CMsgSteamAuthCookiesSet {
        <CMsgSteamAuthCookiesSet as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamAuthCookiesSet {
    pub fn new() -> CMsgSteamAuthCookiesSet {
        ::std::default::Default::default()
    }

    // optional bool success = 1;

    pub fn success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamAuthCookiesSet {
    const NAME: &'static str = "CMsgSteamAuthCookiesSet";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamAuthCookiesSet {
        CMsgSteamAuthCookiesSet::new()
    }

    fn clear(&mut self) {
        self.success = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamAuthCookiesSet {
        static instance: CMsgSteamAuthCookiesSet = CMsgSteamAuthCookiesSet {
            success: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgJSRegisterMethod)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgJSRegisterMethod {
    // message fields
    // @@protoc_insertion_point(field:CMsgJSRegisterMethod.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgJSRegisterMethod.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgJSRegisterMethod.method_type)
    pub method_type: ::std::option::Option<::protobuf::EnumOrUnknown<EJSRegisterMethodType>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgJSRegisterMethod.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgJSRegisterMethod {
    fn default() -> &'a CMsgJSRegisterMethod {
        <CMsgJSRegisterMethod as ::protobuf::Message>::default_instance()
    }
}

impl CMsgJSRegisterMethod {
    pub fn new() -> CMsgJSRegisterMethod {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .EJSRegisterMethodType method_type = 3;

    pub fn method_type(&self) -> EJSRegisterMethodType {
        match self.method_type {
            Some(e) => e.enum_value_or(EJSRegisterMethodType::k_EJSRegisterMethodType_Invalid),
            None => EJSRegisterMethodType::k_EJSRegisterMethodType_Invalid,
        }
    }

    pub fn clear_method_type(&mut self) {
        self.method_type = ::std::option::Option::None;
    }

    pub fn has_method_type(&self) -> bool {
        self.method_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_method_type(&mut self, v: EJSRegisterMethodType) {
        self.method_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::protobuf::Message for CMsgJSRegisterMethod {
    const NAME: &'static str = "CMsgJSRegisterMethod";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.method_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.method_type {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.method_type {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgJSRegisterMethod {
        CMsgJSRegisterMethod::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.method_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgJSRegisterMethod {
        static instance: CMsgJSRegisterMethod = CMsgJSRegisterMethod {
            browser_handle: ::std::option::Option::None,
            name: ::std::option::Option::None,
            method_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgJSValue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgJSValue {
    // message fields
    // @@protoc_insertion_point(field:CMsgJSValue.bool_value)
    pub bool_value: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgJSValue.int_value)
    pub int_value: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgJSValue.uint_value)
    pub uint_value: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgJSValue.double_value)
    pub double_value: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgJSValue.string_value)
    pub string_value: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgJSValue.function_handle)
    pub function_handle: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgJSValue.bytes_value)
    pub bytes_value: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgJSValue.is_array)
    pub is_array: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgJSValue.array_values)
    pub array_values: ::std::vec::Vec<CMsgJSValue>,
    // @@protoc_insertion_point(field:CMsgJSValue.is_object)
    pub is_object: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgJSValue.object_properties)
    pub object_properties: ::std::vec::Vec<cmsg_jsvalue::JSObjectProperty>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgJSValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgJSValue {
    fn default() -> &'a CMsgJSValue {
        <CMsgJSValue as ::protobuf::Message>::default_instance()
    }
}

impl CMsgJSValue {
    pub fn new() -> CMsgJSValue {
        ::std::default::Default::default()
    }

    // optional bool bool_value = 1;

    pub fn bool_value(&self) -> bool {
        self.bool_value.unwrap_or(false)
    }

    pub fn clear_bool_value(&mut self) {
        self.bool_value = ::std::option::Option::None;
    }

    pub fn has_bool_value(&self) -> bool {
        self.bool_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bool_value(&mut self, v: bool) {
        self.bool_value = ::std::option::Option::Some(v);
    }

    // optional int32 int_value = 2;

    pub fn int_value(&self) -> i32 {
        self.int_value.unwrap_or(0)
    }

    pub fn clear_int_value(&mut self) {
        self.int_value = ::std::option::Option::None;
    }

    pub fn has_int_value(&self) -> bool {
        self.int_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_int_value(&mut self, v: i32) {
        self.int_value = ::std::option::Option::Some(v);
    }

    // optional uint32 uint_value = 3;

    pub fn uint_value(&self) -> u32 {
        self.uint_value.unwrap_or(0)
    }

    pub fn clear_uint_value(&mut self) {
        self.uint_value = ::std::option::Option::None;
    }

    pub fn has_uint_value(&self) -> bool {
        self.uint_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uint_value(&mut self, v: u32) {
        self.uint_value = ::std::option::Option::Some(v);
    }

    // optional double double_value = 4;

    pub fn double_value(&self) -> f64 {
        self.double_value.unwrap_or(0.)
    }

    pub fn clear_double_value(&mut self) {
        self.double_value = ::std::option::Option::None;
    }

    pub fn has_double_value(&self) -> bool {
        self.double_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_double_value(&mut self, v: f64) {
        self.double_value = ::std::option::Option::Some(v);
    }

    // optional string string_value = 5;

    pub fn string_value(&self) -> &str {
        match self.string_value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_string_value(&mut self) {
        self.string_value = ::std::option::Option::None;
    }

    pub fn has_string_value(&self) -> bool {
        self.string_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_value(&mut self, v: ::std::string::String) {
        self.string_value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_value(&mut self) -> &mut ::std::string::String {
        if self.string_value.is_none() {
            self.string_value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.string_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_string_value(&mut self) -> ::std::string::String {
        self.string_value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 function_handle = 6;

    pub fn function_handle(&self) -> u64 {
        self.function_handle.unwrap_or(0)
    }

    pub fn clear_function_handle(&mut self) {
        self.function_handle = ::std::option::Option::None;
    }

    pub fn has_function_handle(&self) -> bool {
        self.function_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_function_handle(&mut self, v: u64) {
        self.function_handle = ::std::option::Option::Some(v);
    }

    // optional bytes bytes_value = 12;

    pub fn bytes_value(&self) -> &[u8] {
        match self.bytes_value.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_bytes_value(&mut self) {
        self.bytes_value = ::std::option::Option::None;
    }

    pub fn has_bytes_value(&self) -> bool {
        self.bytes_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.bytes_value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bytes_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.bytes_value.is_none() {
            self.bytes_value = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.bytes_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_bytes_value(&mut self) -> ::std::vec::Vec<u8> {
        self.bytes_value.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool is_array = 8;

    pub fn is_array(&self) -> bool {
        self.is_array.unwrap_or(false)
    }

    pub fn clear_is_array(&mut self) {
        self.is_array = ::std::option::Option::None;
    }

    pub fn has_is_array(&self) -> bool {
        self.is_array.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_array(&mut self, v: bool) {
        self.is_array = ::std::option::Option::Some(v);
    }

    // optional bool is_object = 10;

    pub fn is_object(&self) -> bool {
        self.is_object.unwrap_or(false)
    }

    pub fn clear_is_object(&mut self) {
        self.is_object = ::std::option::Option::None;
    }

    pub fn has_is_object(&self) -> bool {
        self.is_object.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_object(&mut self, v: bool) {
        self.is_object = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgJSValue {
    const NAME: &'static str = "CMsgJSValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.bool_value = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.int_value = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.uint_value = ::std::option::Option::Some(is.read_uint32()?);
                },
                33 => {
                    self.double_value = ::std::option::Option::Some(is.read_double()?);
                },
                42 => {
                    self.string_value = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.function_handle = ::std::option::Option::Some(is.read_uint64()?);
                },
                98 => {
                    self.bytes_value = ::std::option::Option::Some(is.read_bytes()?);
                },
                64 => {
                    self.is_array = ::std::option::Option::Some(is.read_bool()?);
                },
                74 => {
                    self.array_values.push(is.read_message()?);
                },
                80 => {
                    self.is_object = ::std::option::Option::Some(is.read_bool()?);
                },
                90 => {
                    self.object_properties.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.bool_value {
            my_size += 1 + 1;
        }
        if let Some(v) = self.int_value {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.uint_value {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.double_value {
            my_size += 1 + 8;
        }
        if let Some(v) = self.string_value.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.function_handle {
            my_size += ::protobuf::rt::uint64_size(6, v);
        }
        if let Some(v) = self.bytes_value.as_ref() {
            my_size += ::protobuf::rt::bytes_size(12, &v);
        }
        if let Some(v) = self.is_array {
            my_size += 1 + 1;
        }
        for value in &self.array_values {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.is_object {
            my_size += 1 + 1;
        }
        for value in &self.object_properties {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.bool_value {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.int_value {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.uint_value {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.double_value {
            os.write_double(4, v)?;
        }
        if let Some(v) = self.string_value.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.function_handle {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.bytes_value.as_ref() {
            os.write_bytes(12, v)?;
        }
        if let Some(v) = self.is_array {
            os.write_bool(8, v)?;
        }
        for v in &self.array_values {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        if let Some(v) = self.is_object {
            os.write_bool(10, v)?;
        }
        for v in &self.object_properties {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgJSValue {
        CMsgJSValue::new()
    }

    fn clear(&mut self) {
        self.bool_value = ::std::option::Option::None;
        self.int_value = ::std::option::Option::None;
        self.uint_value = ::std::option::Option::None;
        self.double_value = ::std::option::Option::None;
        self.string_value = ::std::option::Option::None;
        self.function_handle = ::std::option::Option::None;
        self.bytes_value = ::std::option::Option::None;
        self.is_array = ::std::option::Option::None;
        self.array_values.clear();
        self.is_object = ::std::option::Option::None;
        self.object_properties.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgJSValue {
        static instance: CMsgJSValue = CMsgJSValue {
            bool_value: ::std::option::Option::None,
            int_value: ::std::option::Option::None,
            uint_value: ::std::option::Option::None,
            double_value: ::std::option::Option::None,
            string_value: ::std::option::Option::None,
            function_handle: ::std::option::Option::None,
            bytes_value: ::std::option::Option::None,
            is_array: ::std::option::Option::None,
            array_values: ::std::vec::Vec::new(),
            is_object: ::std::option::Option::None,
            object_properties: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgJSValue`
pub mod cmsg_jsvalue {
    // @@protoc_insertion_point(message:CMsgJSValue.JSObjectProperty)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct JSObjectProperty {
        // message fields
        // @@protoc_insertion_point(field:CMsgJSValue.JSObjectProperty.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgJSValue.JSObjectProperty.value)
        pub value: ::protobuf::MessageField<super::CMsgJSValue>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgJSValue.JSObjectProperty.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a JSObjectProperty {
        fn default() -> &'a JSObjectProperty {
            <JSObjectProperty as ::protobuf::Message>::default_instance()
        }
    }

    impl JSObjectProperty {
        pub fn new() -> JSObjectProperty {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::protobuf::Message for JSObjectProperty {
        const NAME: &'static str = "JSObjectProperty";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.value)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.value.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.value.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> JSObjectProperty {
            JSObjectProperty::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.value.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static JSObjectProperty {
            static instance: JSObjectProperty = JSObjectProperty {
                name: ::std::option::Option::None,
                value: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgJSMethodCall)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgJSMethodCall {
    // message fields
    // @@protoc_insertion_point(field:CMsgJSMethodCall.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgJSMethodCall.owning_browser_handle)
    pub owning_browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgJSMethodCall.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgJSMethodCall.arguments)
    pub arguments: ::std::vec::Vec<CMsgJSValue>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgJSMethodCall.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgJSMethodCall {
    fn default() -> &'a CMsgJSMethodCall {
        <CMsgJSMethodCall as ::protobuf::Message>::default_instance()
    }
}

impl CMsgJSMethodCall {
    pub fn new() -> CMsgJSMethodCall {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 owning_browser_handle = 2;

    pub fn owning_browser_handle(&self) -> u32 {
        self.owning_browser_handle.unwrap_or(0)
    }

    pub fn clear_owning_browser_handle(&mut self) {
        self.owning_browser_handle = ::std::option::Option::None;
    }

    pub fn has_owning_browser_handle(&self) -> bool {
        self.owning_browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owning_browser_handle(&mut self, v: u32) {
        self.owning_browser_handle = ::std::option::Option::Some(v);
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgJSMethodCall {
    const NAME: &'static str = "CMsgJSMethodCall";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.owning_browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.arguments.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.owning_browser_handle {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.arguments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.owning_browser_handle {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.arguments {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgJSMethodCall {
        CMsgJSMethodCall::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.owning_browser_handle = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.arguments.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgJSMethodCall {
        static instance: CMsgJSMethodCall = CMsgJSMethodCall {
            browser_handle: ::std::option::Option::None,
            owning_browser_handle: ::std::option::Option::None,
            name: ::std::option::Option::None,
            arguments: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgJSExecuteCallback)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgJSExecuteCallback {
    // message fields
    // @@protoc_insertion_point(field:CMsgJSExecuteCallback.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgJSExecuteCallback.owning_browser_handle)
    pub owning_browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgJSExecuteCallback.function_handle)
    pub function_handle: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgJSExecuteCallback.arguments)
    pub arguments: ::std::vec::Vec<CMsgJSValue>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgJSExecuteCallback.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgJSExecuteCallback {
    fn default() -> &'a CMsgJSExecuteCallback {
        <CMsgJSExecuteCallback as ::protobuf::Message>::default_instance()
    }
}

impl CMsgJSExecuteCallback {
    pub fn new() -> CMsgJSExecuteCallback {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 owning_browser_handle = 2;

    pub fn owning_browser_handle(&self) -> u32 {
        self.owning_browser_handle.unwrap_or(0)
    }

    pub fn clear_owning_browser_handle(&mut self) {
        self.owning_browser_handle = ::std::option::Option::None;
    }

    pub fn has_owning_browser_handle(&self) -> bool {
        self.owning_browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owning_browser_handle(&mut self, v: u32) {
        self.owning_browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint64 function_handle = 3;

    pub fn function_handle(&self) -> u64 {
        self.function_handle.unwrap_or(0)
    }

    pub fn clear_function_handle(&mut self) {
        self.function_handle = ::std::option::Option::None;
    }

    pub fn has_function_handle(&self) -> bool {
        self.function_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_function_handle(&mut self, v: u64) {
        self.function_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgJSExecuteCallback {
    const NAME: &'static str = "CMsgJSExecuteCallback";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.owning_browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.function_handle = ::std::option::Option::Some(is.read_uint64()?);
                },
                34 => {
                    self.arguments.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.owning_browser_handle {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.function_handle {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        for value in &self.arguments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.owning_browser_handle {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.function_handle {
            os.write_uint64(3, v)?;
        }
        for v in &self.arguments {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgJSExecuteCallback {
        CMsgJSExecuteCallback::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.owning_browser_handle = ::std::option::Option::None;
        self.function_handle = ::std::option::Option::None;
        self.arguments.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgJSExecuteCallback {
        static instance: CMsgJSExecuteCallback = CMsgJSExecuteCallback {
            browser_handle: ::std::option::Option::None,
            owning_browser_handle: ::std::option::Option::None,
            function_handle: ::std::option::Option::None,
            arguments: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgJSReleaseCallback)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgJSReleaseCallback {
    // message fields
    // @@protoc_insertion_point(field:CMsgJSReleaseCallback.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgJSReleaseCallback.owning_browser_handle)
    pub owning_browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgJSReleaseCallback.function_handle)
    pub function_handle: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgJSReleaseCallback.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgJSReleaseCallback {
    fn default() -> &'a CMsgJSReleaseCallback {
        <CMsgJSReleaseCallback as ::protobuf::Message>::default_instance()
    }
}

impl CMsgJSReleaseCallback {
    pub fn new() -> CMsgJSReleaseCallback {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 owning_browser_handle = 2;

    pub fn owning_browser_handle(&self) -> u32 {
        self.owning_browser_handle.unwrap_or(0)
    }

    pub fn clear_owning_browser_handle(&mut self) {
        self.owning_browser_handle = ::std::option::Option::None;
    }

    pub fn has_owning_browser_handle(&self) -> bool {
        self.owning_browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owning_browser_handle(&mut self, v: u32) {
        self.owning_browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint64 function_handle = 3;

    pub fn function_handle(&self) -> u64 {
        self.function_handle.unwrap_or(0)
    }

    pub fn clear_function_handle(&mut self) {
        self.function_handle = ::std::option::Option::None;
    }

    pub fn has_function_handle(&self) -> bool {
        self.function_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_function_handle(&mut self, v: u64) {
        self.function_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgJSReleaseCallback {
    const NAME: &'static str = "CMsgJSReleaseCallback";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.owning_browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.function_handle = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.owning_browser_handle {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.function_handle {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.owning_browser_handle {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.function_handle {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgJSReleaseCallback {
        CMsgJSReleaseCallback::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.owning_browser_handle = ::std::option::Option::None;
        self.function_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgJSReleaseCallback {
        static instance: CMsgJSReleaseCallback = CMsgJSReleaseCallback {
            browser_handle: ::std::option::Option::None,
            owning_browser_handle: ::std::option::Option::None,
            function_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgJSRaiseException)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgJSRaiseException {
    // message fields
    // @@protoc_insertion_point(field:CMsgJSRaiseException.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgJSRaiseException.owning_browser_handle)
    pub owning_browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgJSRaiseException.exception)
    pub exception: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgJSRaiseException.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgJSRaiseException {
    fn default() -> &'a CMsgJSRaiseException {
        <CMsgJSRaiseException as ::protobuf::Message>::default_instance()
    }
}

impl CMsgJSRaiseException {
    pub fn new() -> CMsgJSRaiseException {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 owning_browser_handle = 2;

    pub fn owning_browser_handle(&self) -> u32 {
        self.owning_browser_handle.unwrap_or(0)
    }

    pub fn clear_owning_browser_handle(&mut self) {
        self.owning_browser_handle = ::std::option::Option::None;
    }

    pub fn has_owning_browser_handle(&self) -> bool {
        self.owning_browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owning_browser_handle(&mut self, v: u32) {
        self.owning_browser_handle = ::std::option::Option::Some(v);
    }

    // optional string exception = 3;

    pub fn exception(&self) -> &str {
        match self.exception.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_exception(&mut self) {
        self.exception = ::std::option::Option::None;
    }

    pub fn has_exception(&self) -> bool {
        self.exception.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exception(&mut self, v: ::std::string::String) {
        self.exception = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exception(&mut self) -> &mut ::std::string::String {
        if self.exception.is_none() {
            self.exception = ::std::option::Option::Some(::std::string::String::new());
        }
        self.exception.as_mut().unwrap()
    }

    // Take field
    pub fn take_exception(&mut self) -> ::std::string::String {
        self.exception.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgJSRaiseException {
    const NAME: &'static str = "CMsgJSRaiseException";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.owning_browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.exception = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.owning_browser_handle {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.exception.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.owning_browser_handle {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.exception.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgJSRaiseException {
        CMsgJSRaiseException::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.owning_browser_handle = ::std::option::Option::None;
        self.exception = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgJSRaiseException {
        static instance: CMsgJSRaiseException = CMsgJSRaiseException {
            browser_handle: ::std::option::Option::None,
            owning_browser_handle: ::std::option::Option::None,
            exception: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgLoadLocalization)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLoadLocalization {
    // message fields
    // @@protoc_insertion_point(field:CMsgLoadLocalization.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLoadLocalization.localization_path)
    pub localization_path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgLoadLocalization.language)
    pub language: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLoadLocalization.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLoadLocalization {
    fn default() -> &'a CMsgLoadLocalization {
        <CMsgLoadLocalization as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLoadLocalization {
    pub fn new() -> CMsgLoadLocalization {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string localization_path = 2;

    pub fn localization_path(&self) -> &str {
        match self.localization_path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_localization_path(&mut self) {
        self.localization_path = ::std::option::Option::None;
    }

    pub fn has_localization_path(&self) -> bool {
        self.localization_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_localization_path(&mut self, v: ::std::string::String) {
        self.localization_path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_localization_path(&mut self) -> &mut ::std::string::String {
        if self.localization_path.is_none() {
            self.localization_path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.localization_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_localization_path(&mut self) -> ::std::string::String {
        self.localization_path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string language = 3;

    pub fn language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language = ::std::option::Option::Some(::std::string::String::new());
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgLoadLocalization {
    const NAME: &'static str = "CMsgLoadLocalization";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.localization_path = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.language = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.localization_path.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.language.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.localization_path.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.language.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLoadLocalization {
        CMsgLoadLocalization::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.localization_path = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLoadLocalization {
        static instance: CMsgLoadLocalization = CMsgLoadLocalization {
            browser_handle: ::std::option::Option::None,
            localization_path: ::std::option::Option::None,
            language: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgNotifyUserActivation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgNotifyUserActivation {
    // message fields
    // @@protoc_insertion_point(field:CMsgNotifyUserActivation.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgNotifyUserActivation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgNotifyUserActivation {
    fn default() -> &'a CMsgNotifyUserActivation {
        <CMsgNotifyUserActivation as ::protobuf::Message>::default_instance()
    }
}

impl CMsgNotifyUserActivation {
    pub fn new() -> CMsgNotifyUserActivation {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgNotifyUserActivation {
    const NAME: &'static str = "CMsgNotifyUserActivation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgNotifyUserActivation {
        CMsgNotifyUserActivation::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgNotifyUserActivation {
        static instance: CMsgNotifyUserActivation = CMsgNotifyUserActivation {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSetNetFakeLocalSystemState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetNetFakeLocalSystemState {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetNetFakeLocalSystemState.state)
    pub state: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetNetFakeLocalSystemState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetNetFakeLocalSystemState {
    fn default() -> &'a CMsgSetNetFakeLocalSystemState {
        <CMsgSetNetFakeLocalSystemState as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetNetFakeLocalSystemState {
    pub fn new() -> CMsgSetNetFakeLocalSystemState {
        ::std::default::Default::default()
    }

    // optional uint32 state = 1;

    pub fn state(&self) -> u32 {
        self.state.unwrap_or(0)
    }

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: u32) {
        self.state = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSetNetFakeLocalSystemState {
    const NAME: &'static str = "CMsgSetNetFakeLocalSystemState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.state = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.state {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.state {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetNetFakeLocalSystemState {
        CMsgSetNetFakeLocalSystemState::new()
    }

    fn clear(&mut self) {
        self.state = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetNetFakeLocalSystemState {
        static instance: CMsgSetNetFakeLocalSystemState = CMsgSetNetFakeLocalSystemState {
            state: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSetGameOverlayTargetPIDs)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetGameOverlayTargetPIDs {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetGameOverlayTargetPIDs.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetGameOverlayTargetPIDs.target_pid)
    pub target_pid: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetGameOverlayTargetPIDs.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetGameOverlayTargetPIDs {
    fn default() -> &'a CMsgSetGameOverlayTargetPIDs {
        <CMsgSetGameOverlayTargetPIDs as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetGameOverlayTargetPIDs {
    pub fn new() -> CMsgSetGameOverlayTargetPIDs {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSetGameOverlayTargetPIDs {
    const NAME: &'static str = "CMsgSetGameOverlayTargetPIDs";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.target_pid)?;
                },
                16 => {
                    self.target_pid.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.target_pid {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        for v in &self.target_pid {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetGameOverlayTargetPIDs {
        CMsgSetGameOverlayTargetPIDs::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.target_pid.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetGameOverlayTargetPIDs {
        static instance: CMsgSetGameOverlayTargetPIDs = CMsgSetGameOverlayTargetPIDs {
            browser_handle: ::std::option::Option::None,
            target_pid: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGameOverlayTargetTextureID)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameOverlayTargetTextureID {
    // message fields
    // @@protoc_insertion_point(field:CMsgGameOverlayTargetTextureID.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameOverlayTargetTextureID.target_pid)
    pub target_pid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameOverlayTargetTextureID.texture_handle)
    pub texture_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGameOverlayTargetTextureID.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameOverlayTargetTextureID {
    fn default() -> &'a CMsgGameOverlayTargetTextureID {
        <CMsgGameOverlayTargetTextureID as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameOverlayTargetTextureID {
    pub fn new() -> CMsgGameOverlayTargetTextureID {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 target_pid = 2;

    pub fn target_pid(&self) -> u32 {
        self.target_pid.unwrap_or(0)
    }

    pub fn clear_target_pid(&mut self) {
        self.target_pid = ::std::option::Option::None;
    }

    pub fn has_target_pid(&self) -> bool {
        self.target_pid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_pid(&mut self, v: u32) {
        self.target_pid = ::std::option::Option::Some(v);
    }

    // optional uint32 texture_handle = 3;

    pub fn texture_handle(&self) -> u32 {
        self.texture_handle.unwrap_or(0)
    }

    pub fn clear_texture_handle(&mut self) {
        self.texture_handle = ::std::option::Option::None;
    }

    pub fn has_texture_handle(&self) -> bool {
        self.texture_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_texture_handle(&mut self, v: u32) {
        self.texture_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGameOverlayTargetTextureID {
    const NAME: &'static str = "CMsgGameOverlayTargetTextureID";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.target_pid = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.texture_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.target_pid {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.texture_handle {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.target_pid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.texture_handle {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameOverlayTargetTextureID {
        CMsgGameOverlayTargetTextureID::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.target_pid = ::std::option::Option::None;
        self.texture_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameOverlayTargetTextureID {
        static instance: CMsgGameOverlayTargetTextureID = CMsgGameOverlayTargetTextureID {
            browser_handle: ::std::option::Option::None,
            target_pid: ::std::option::Option::None,
            texture_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDraggableRegionsChanged)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDraggableRegionsChanged {
    // message fields
    // @@protoc_insertion_point(field:CMsgDraggableRegionsChanged.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDraggableRegionsChanged.rects)
    pub rects: ::std::vec::Vec<cmsg_draggable_regions_changed::DraggableRects>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDraggableRegionsChanged.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDraggableRegionsChanged {
    fn default() -> &'a CMsgDraggableRegionsChanged {
        <CMsgDraggableRegionsChanged as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDraggableRegionsChanged {
    pub fn new() -> CMsgDraggableRegionsChanged {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgDraggableRegionsChanged {
    const NAME: &'static str = "CMsgDraggableRegionsChanged";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.rects.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.rects {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        for v in &self.rects {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDraggableRegionsChanged {
        CMsgDraggableRegionsChanged::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.rects.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDraggableRegionsChanged {
        static instance: CMsgDraggableRegionsChanged = CMsgDraggableRegionsChanged {
            browser_handle: ::std::option::Option::None,
            rects: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgDraggableRegionsChanged`
pub mod cmsg_draggable_regions_changed {
    // @@protoc_insertion_point(message:CMsgDraggableRegionsChanged.DraggableRects)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DraggableRects {
        // message fields
        // @@protoc_insertion_point(field:CMsgDraggableRegionsChanged.DraggableRects.x)
        pub x: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDraggableRegionsChanged.DraggableRects.y)
        pub y: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDraggableRegionsChanged.DraggableRects.width)
        pub width: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDraggableRegionsChanged.DraggableRects.height)
        pub height: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDraggableRegionsChanged.DraggableRects.draggable)
        pub draggable: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDraggableRegionsChanged.DraggableRects.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DraggableRects {
        fn default() -> &'a DraggableRects {
            <DraggableRects as ::protobuf::Message>::default_instance()
        }
    }

    impl DraggableRects {
        pub fn new() -> DraggableRects {
            ::std::default::Default::default()
        }

        // optional int32 x = 1;

        pub fn x(&self) -> i32 {
            self.x.unwrap_or(0)
        }

        pub fn clear_x(&mut self) {
            self.x = ::std::option::Option::None;
        }

        pub fn has_x(&self) -> bool {
            self.x.is_some()
        }

        // Param is passed by value, moved
        pub fn set_x(&mut self, v: i32) {
            self.x = ::std::option::Option::Some(v);
        }

        // optional int32 y = 2;

        pub fn y(&self) -> i32 {
            self.y.unwrap_or(0)
        }

        pub fn clear_y(&mut self) {
            self.y = ::std::option::Option::None;
        }

        pub fn has_y(&self) -> bool {
            self.y.is_some()
        }

        // Param is passed by value, moved
        pub fn set_y(&mut self, v: i32) {
            self.y = ::std::option::Option::Some(v);
        }

        // optional int32 width = 3;

        pub fn width(&self) -> i32 {
            self.width.unwrap_or(0)
        }

        pub fn clear_width(&mut self) {
            self.width = ::std::option::Option::None;
        }

        pub fn has_width(&self) -> bool {
            self.width.is_some()
        }

        // Param is passed by value, moved
        pub fn set_width(&mut self, v: i32) {
            self.width = ::std::option::Option::Some(v);
        }

        // optional int32 height = 4;

        pub fn height(&self) -> i32 {
            self.height.unwrap_or(0)
        }

        pub fn clear_height(&mut self) {
            self.height = ::std::option::Option::None;
        }

        pub fn has_height(&self) -> bool {
            self.height.is_some()
        }

        // Param is passed by value, moved
        pub fn set_height(&mut self, v: i32) {
            self.height = ::std::option::Option::Some(v);
        }

        // optional bool draggable = 5;

        pub fn draggable(&self) -> bool {
            self.draggable.unwrap_or(false)
        }

        pub fn clear_draggable(&mut self) {
            self.draggable = ::std::option::Option::None;
        }

        pub fn has_draggable(&self) -> bool {
            self.draggable.is_some()
        }

        // Param is passed by value, moved
        pub fn set_draggable(&mut self, v: bool) {
            self.draggable = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for DraggableRects {
        const NAME: &'static str = "DraggableRects";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.x = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.y = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.width = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.height = ::std::option::Option::Some(is.read_int32()?);
                    },
                    40 => {
                        self.draggable = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.x {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.y {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.width {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.height {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.draggable {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.x {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.y {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.width {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.height {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.draggable {
                os.write_bool(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DraggableRects {
            DraggableRects::new()
        }

        fn clear(&mut self) {
            self.x = ::std::option::Option::None;
            self.y = ::std::option::Option::None;
            self.width = ::std::option::Option::None;
            self.height = ::std::option::Option::None;
            self.draggable = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DraggableRects {
            static instance: DraggableRects = DraggableRects {
                x: ::std::option::Option::None,
                y: ::std::option::Option::None,
                width: ::std::option::Option::None,
                height: ::std::option::Option::None,
                draggable: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgResizeGripChanged)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgResizeGripChanged {
    // message fields
    // @@protoc_insertion_point(field:CMsgResizeGripChanged.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgResizeGripChanged.width)
    pub width: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgResizeGripChanged.height)
    pub height: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgResizeGripChanged.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgResizeGripChanged {
    fn default() -> &'a CMsgResizeGripChanged {
        <CMsgResizeGripChanged as ::protobuf::Message>::default_instance()
    }
}

impl CMsgResizeGripChanged {
    pub fn new() -> CMsgResizeGripChanged {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional int32 width = 2;

    pub fn width(&self) -> i32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: i32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional int32 height = 3;

    pub fn height(&self) -> i32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgResizeGripChanged {
    const NAME: &'static str = "CMsgResizeGripChanged";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.width = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.height = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.width {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.height {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgResizeGripChanged {
        CMsgResizeGripChanged::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgResizeGripChanged {
        static instance: CMsgResizeGripChanged = CMsgResizeGripChanged {
            browser_handle: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSetWindowPosition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetWindowPosition {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetWindowPosition.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetWindowPosition.x)
    pub x: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgSetWindowPosition.y)
    pub y: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgSetWindowPosition.width)
    pub width: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgSetWindowPosition.height)
    pub height: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgSetWindowPosition.min_width)
    pub min_width: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgSetWindowPosition.min_height)
    pub min_height: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgSetWindowPosition.max_width)
    pub max_width: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgSetWindowPosition.max_height)
    pub max_height: ::std::option::Option<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetWindowPosition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetWindowPosition {
    fn default() -> &'a CMsgSetWindowPosition {
        <CMsgSetWindowPosition as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetWindowPosition {
    pub fn new() -> CMsgSetWindowPosition {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional double x = 2;

    pub fn x(&self) -> f64 {
        self.x.unwrap_or(0.)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f64) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional double y = 3;

    pub fn y(&self) -> f64 {
        self.y.unwrap_or(0.)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f64) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional double width = 4;

    pub fn width(&self) -> f64 {
        self.width.unwrap_or(0.)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: f64) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional double height = 5;

    pub fn height(&self) -> f64 {
        self.height.unwrap_or(0.)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: f64) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional double min_width = 6;

    pub fn min_width(&self) -> f64 {
        self.min_width.unwrap_or(0.)
    }

    pub fn clear_min_width(&mut self) {
        self.min_width = ::std::option::Option::None;
    }

    pub fn has_min_width(&self) -> bool {
        self.min_width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_width(&mut self, v: f64) {
        self.min_width = ::std::option::Option::Some(v);
    }

    // optional double min_height = 7;

    pub fn min_height(&self) -> f64 {
        self.min_height.unwrap_or(0.)
    }

    pub fn clear_min_height(&mut self) {
        self.min_height = ::std::option::Option::None;
    }

    pub fn has_min_height(&self) -> bool {
        self.min_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_height(&mut self, v: f64) {
        self.min_height = ::std::option::Option::Some(v);
    }

    // optional double max_width = 8;

    pub fn max_width(&self) -> f64 {
        self.max_width.unwrap_or(0.)
    }

    pub fn clear_max_width(&mut self) {
        self.max_width = ::std::option::Option::None;
    }

    pub fn has_max_width(&self) -> bool {
        self.max_width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_width(&mut self, v: f64) {
        self.max_width = ::std::option::Option::Some(v);
    }

    // optional double max_height = 9;

    pub fn max_height(&self) -> f64 {
        self.max_height.unwrap_or(0.)
    }

    pub fn clear_max_height(&mut self) {
        self.max_height = ::std::option::Option::None;
    }

    pub fn has_max_height(&self) -> bool {
        self.max_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_height(&mut self, v: f64) {
        self.max_height = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSetWindowPosition {
    const NAME: &'static str = "CMsgSetWindowPosition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.x = ::std::option::Option::Some(is.read_double()?);
                },
                25 => {
                    self.y = ::std::option::Option::Some(is.read_double()?);
                },
                33 => {
                    self.width = ::std::option::Option::Some(is.read_double()?);
                },
                41 => {
                    self.height = ::std::option::Option::Some(is.read_double()?);
                },
                49 => {
                    self.min_width = ::std::option::Option::Some(is.read_double()?);
                },
                57 => {
                    self.min_height = ::std::option::Option::Some(is.read_double()?);
                },
                65 => {
                    self.max_width = ::std::option::Option::Some(is.read_double()?);
                },
                73 => {
                    self.max_height = ::std::option::Option::Some(is.read_double()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.x {
            my_size += 1 + 8;
        }
        if let Some(v) = self.y {
            my_size += 1 + 8;
        }
        if let Some(v) = self.width {
            my_size += 1 + 8;
        }
        if let Some(v) = self.height {
            my_size += 1 + 8;
        }
        if let Some(v) = self.min_width {
            my_size += 1 + 8;
        }
        if let Some(v) = self.min_height {
            my_size += 1 + 8;
        }
        if let Some(v) = self.max_width {
            my_size += 1 + 8;
        }
        if let Some(v) = self.max_height {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.y {
            os.write_double(3, v)?;
        }
        if let Some(v) = self.width {
            os.write_double(4, v)?;
        }
        if let Some(v) = self.height {
            os.write_double(5, v)?;
        }
        if let Some(v) = self.min_width {
            os.write_double(6, v)?;
        }
        if let Some(v) = self.min_height {
            os.write_double(7, v)?;
        }
        if let Some(v) = self.max_width {
            os.write_double(8, v)?;
        }
        if let Some(v) = self.max_height {
            os.write_double(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetWindowPosition {
        CMsgSetWindowPosition::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.min_width = ::std::option::Option::None;
        self.min_height = ::std::option::Option::None;
        self.max_width = ::std::option::Option::None;
        self.max_height = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetWindowPosition {
        static instance: CMsgSetWindowPosition = CMsgSetWindowPosition {
            browser_handle: ::std::option::Option::None,
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            min_width: ::std::option::Option::None,
            min_height: ::std::option::Option::None,
            max_width: ::std::option::Option::None,
            max_height: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgShowWindow)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgShowWindow {
    // message fields
    // @@protoc_insertion_point(field:CMsgShowWindow.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgShowWindow.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgShowWindow {
    fn default() -> &'a CMsgShowWindow {
        <CMsgShowWindow as ::protobuf::Message>::default_instance()
    }
}

impl CMsgShowWindow {
    pub fn new() -> CMsgShowWindow {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgShowWindow {
    const NAME: &'static str = "CMsgShowWindow";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgShowWindow {
        CMsgShowWindow::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgShowWindow {
        static instance: CMsgShowWindow = CMsgShowWindow {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgHideWindow)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgHideWindow {
    // message fields
    // @@protoc_insertion_point(field:CMsgHideWindow.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgHideWindow.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgHideWindow {
    fn default() -> &'a CMsgHideWindow {
        <CMsgHideWindow as ::protobuf::Message>::default_instance()
    }
}

impl CMsgHideWindow {
    pub fn new() -> CMsgHideWindow {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgHideWindow {
    const NAME: &'static str = "CMsgHideWindow";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgHideWindow {
        CMsgHideWindow::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgHideWindow {
        static instance: CMsgHideWindow = CMsgHideWindow {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgBringWindowToFront)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBringWindowToFront {
    // message fields
    // @@protoc_insertion_point(field:CMsgBringWindowToFront.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBringWindowToFront.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBringWindowToFront {
    fn default() -> &'a CMsgBringWindowToFront {
        <CMsgBringWindowToFront as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBringWindowToFront {
    pub fn new() -> CMsgBringWindowToFront {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgBringWindowToFront {
    const NAME: &'static str = "CMsgBringWindowToFront";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBringWindowToFront {
        CMsgBringWindowToFront::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBringWindowToFront {
        static instance: CMsgBringWindowToFront = CMsgBringWindowToFront {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSetForegroundWindow)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetForegroundWindow {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetForegroundWindow.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetForegroundWindow.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetForegroundWindow {
    fn default() -> &'a CMsgSetForegroundWindow {
        <CMsgSetForegroundWindow as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetForegroundWindow {
    pub fn new() -> CMsgSetForegroundWindow {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSetForegroundWindow {
    const NAME: &'static str = "CMsgSetForegroundWindow";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetForegroundWindow {
        CMsgSetForegroundWindow::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetForegroundWindow {
        static instance: CMsgSetForegroundWindow = CMsgSetForegroundWindow {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgMaximizeRestoreWindow)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMaximizeRestoreWindow {
    // message fields
    // @@protoc_insertion_point(field:CMsgMaximizeRestoreWindow.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMaximizeRestoreWindow.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMaximizeRestoreWindow {
    fn default() -> &'a CMsgMaximizeRestoreWindow {
        <CMsgMaximizeRestoreWindow as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMaximizeRestoreWindow {
    pub fn new() -> CMsgMaximizeRestoreWindow {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgMaximizeRestoreWindow {
    const NAME: &'static str = "CMsgMaximizeRestoreWindow";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMaximizeRestoreWindow {
        CMsgMaximizeRestoreWindow::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMaximizeRestoreWindow {
        static instance: CMsgMaximizeRestoreWindow = CMsgMaximizeRestoreWindow {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgMinimizeWindow)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMinimizeWindow {
    // message fields
    // @@protoc_insertion_point(field:CMsgMinimizeWindow.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMinimizeWindow.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMinimizeWindow {
    fn default() -> &'a CMsgMinimizeWindow {
        <CMsgMinimizeWindow as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMinimizeWindow {
    pub fn new() -> CMsgMinimizeWindow {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgMinimizeWindow {
    const NAME: &'static str = "CMsgMinimizeWindow";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMinimizeWindow {
        CMsgMinimizeWindow::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMinimizeWindow {
        static instance: CMsgMinimizeWindow = CMsgMinimizeWindow {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgShowBrowserContextMenu)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgShowBrowserContextMenu {
    // message fields
    // @@protoc_insertion_point(field:CMsgShowBrowserContextMenu.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgShowBrowserContextMenu.custom_commands)
    pub custom_commands: ::std::vec::Vec<cmsg_show_browser_context_menu::ContextCommand>,
    // @@protoc_insertion_point(field:CMsgShowBrowserContextMenu.type_flags)
    pub type_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgShowBrowserContextMenu.page_url)
    pub page_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgShowBrowserContextMenu.coord_x)
    pub coord_x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgShowBrowserContextMenu.coord_y)
    pub coord_y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgShowBrowserContextMenu.link_url)
    pub link_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgShowBrowserContextMenu.unfiltered_link_url)
    pub unfiltered_link_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgShowBrowserContextMenu.selection_text)
    pub selection_text: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgShowBrowserContextMenu.misspelled_word)
    pub misspelled_word: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgShowBrowserContextMenu.edit_state_flags)
    pub edit_state_flags: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgShowBrowserContextMenu.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgShowBrowserContextMenu {
    fn default() -> &'a CMsgShowBrowserContextMenu {
        <CMsgShowBrowserContextMenu as ::protobuf::Message>::default_instance()
    }
}

impl CMsgShowBrowserContextMenu {
    pub fn new() -> CMsgShowBrowserContextMenu {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 type_flags = 3;

    pub fn type_flags(&self) -> u32 {
        self.type_flags.unwrap_or(0)
    }

    pub fn clear_type_flags(&mut self) {
        self.type_flags = ::std::option::Option::None;
    }

    pub fn has_type_flags(&self) -> bool {
        self.type_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type_flags(&mut self, v: u32) {
        self.type_flags = ::std::option::Option::Some(v);
    }

    // optional string page_url = 4;

    pub fn page_url(&self) -> &str {
        match self.page_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_page_url(&mut self) {
        self.page_url = ::std::option::Option::None;
    }

    pub fn has_page_url(&self) -> bool {
        self.page_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_page_url(&mut self, v: ::std::string::String) {
        self.page_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_url(&mut self) -> &mut ::std::string::String {
        if self.page_url.is_none() {
            self.page_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.page_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_page_url(&mut self) -> ::std::string::String {
        self.page_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 coord_x = 5;

    pub fn coord_x(&self) -> i32 {
        self.coord_x.unwrap_or(0)
    }

    pub fn clear_coord_x(&mut self) {
        self.coord_x = ::std::option::Option::None;
    }

    pub fn has_coord_x(&self) -> bool {
        self.coord_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coord_x(&mut self, v: i32) {
        self.coord_x = ::std::option::Option::Some(v);
    }

    // optional int32 coord_y = 6;

    pub fn coord_y(&self) -> i32 {
        self.coord_y.unwrap_or(0)
    }

    pub fn clear_coord_y(&mut self) {
        self.coord_y = ::std::option::Option::None;
    }

    pub fn has_coord_y(&self) -> bool {
        self.coord_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coord_y(&mut self, v: i32) {
        self.coord_y = ::std::option::Option::Some(v);
    }

    // optional string link_url = 7;

    pub fn link_url(&self) -> &str {
        match self.link_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_link_url(&mut self) {
        self.link_url = ::std::option::Option::None;
    }

    pub fn has_link_url(&self) -> bool {
        self.link_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_link_url(&mut self, v: ::std::string::String) {
        self.link_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_link_url(&mut self) -> &mut ::std::string::String {
        if self.link_url.is_none() {
            self.link_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.link_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_link_url(&mut self) -> ::std::string::String {
        self.link_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string unfiltered_link_url = 8;

    pub fn unfiltered_link_url(&self) -> &str {
        match self.unfiltered_link_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_unfiltered_link_url(&mut self) {
        self.unfiltered_link_url = ::std::option::Option::None;
    }

    pub fn has_unfiltered_link_url(&self) -> bool {
        self.unfiltered_link_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unfiltered_link_url(&mut self, v: ::std::string::String) {
        self.unfiltered_link_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unfiltered_link_url(&mut self) -> &mut ::std::string::String {
        if self.unfiltered_link_url.is_none() {
            self.unfiltered_link_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.unfiltered_link_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_unfiltered_link_url(&mut self) -> ::std::string::String {
        self.unfiltered_link_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string selection_text = 9;

    pub fn selection_text(&self) -> &str {
        match self.selection_text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_selection_text(&mut self) {
        self.selection_text = ::std::option::Option::None;
    }

    pub fn has_selection_text(&self) -> bool {
        self.selection_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selection_text(&mut self, v: ::std::string::String) {
        self.selection_text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selection_text(&mut self) -> &mut ::std::string::String {
        if self.selection_text.is_none() {
            self.selection_text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.selection_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_selection_text(&mut self) -> ::std::string::String {
        self.selection_text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string misspelled_word = 10;

    pub fn misspelled_word(&self) -> &str {
        match self.misspelled_word.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_misspelled_word(&mut self) {
        self.misspelled_word = ::std::option::Option::None;
    }

    pub fn has_misspelled_word(&self) -> bool {
        self.misspelled_word.is_some()
    }

    // Param is passed by value, moved
    pub fn set_misspelled_word(&mut self, v: ::std::string::String) {
        self.misspelled_word = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_misspelled_word(&mut self) -> &mut ::std::string::String {
        if self.misspelled_word.is_none() {
            self.misspelled_word = ::std::option::Option::Some(::std::string::String::new());
        }
        self.misspelled_word.as_mut().unwrap()
    }

    // Take field
    pub fn take_misspelled_word(&mut self) -> ::std::string::String {
        self.misspelled_word.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 edit_state_flags = 11;

    pub fn edit_state_flags(&self) -> u32 {
        self.edit_state_flags.unwrap_or(0)
    }

    pub fn clear_edit_state_flags(&mut self) {
        self.edit_state_flags = ::std::option::Option::None;
    }

    pub fn has_edit_state_flags(&self) -> bool {
        self.edit_state_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_edit_state_flags(&mut self, v: u32) {
        self.edit_state_flags = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgShowBrowserContextMenu {
    const NAME: &'static str = "CMsgShowBrowserContextMenu";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.custom_commands.push(is.read_message()?);
                },
                24 => {
                    self.type_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.page_url = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.coord_x = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.coord_y = ::std::option::Option::Some(is.read_int32()?);
                },
                58 => {
                    self.link_url = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.unfiltered_link_url = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.selection_text = ::std::option::Option::Some(is.read_string()?);
                },
                82 => {
                    self.misspelled_word = ::std::option::Option::Some(is.read_string()?);
                },
                88 => {
                    self.edit_state_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.custom_commands {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.type_flags {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.page_url.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.coord_x {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.coord_y {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.link_url.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.unfiltered_link_url.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.selection_text.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.misspelled_word.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.edit_state_flags {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        for v in &self.custom_commands {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.type_flags {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.page_url.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.coord_x {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.coord_y {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.link_url.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.unfiltered_link_url.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.selection_text.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.misspelled_word.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.edit_state_flags {
            os.write_uint32(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgShowBrowserContextMenu {
        CMsgShowBrowserContextMenu::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.custom_commands.clear();
        self.type_flags = ::std::option::Option::None;
        self.page_url = ::std::option::Option::None;
        self.coord_x = ::std::option::Option::None;
        self.coord_y = ::std::option::Option::None;
        self.link_url = ::std::option::Option::None;
        self.unfiltered_link_url = ::std::option::Option::None;
        self.selection_text = ::std::option::Option::None;
        self.misspelled_word = ::std::option::Option::None;
        self.edit_state_flags = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgShowBrowserContextMenu {
        static instance: CMsgShowBrowserContextMenu = CMsgShowBrowserContextMenu {
            browser_handle: ::std::option::Option::None,
            custom_commands: ::std::vec::Vec::new(),
            type_flags: ::std::option::Option::None,
            page_url: ::std::option::Option::None,
            coord_x: ::std::option::Option::None,
            coord_y: ::std::option::Option::None,
            link_url: ::std::option::Option::None,
            unfiltered_link_url: ::std::option::Option::None,
            selection_text: ::std::option::Option::None,
            misspelled_word: ::std::option::Option::None,
            edit_state_flags: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgShowBrowserContextMenu`
pub mod cmsg_show_browser_context_menu {
    // @@protoc_insertion_point(message:CMsgShowBrowserContextMenu.ContextCommand)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ContextCommand {
        // message fields
        // @@protoc_insertion_point(field:CMsgShowBrowserContextMenu.ContextCommand.id)
        pub id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgShowBrowserContextMenu.ContextCommand.label)
        pub label: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgShowBrowserContextMenu.ContextCommand.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ContextCommand {
        fn default() -> &'a ContextCommand {
            <ContextCommand as ::protobuf::Message>::default_instance()
        }
    }

    impl ContextCommand {
        pub fn new() -> ContextCommand {
            ::std::default::Default::default()
        }

        // optional int32 id = 1;

        pub fn id(&self) -> i32 {
            self.id.unwrap_or(0)
        }

        pub fn clear_id(&mut self) {
            self.id = ::std::option::Option::None;
        }

        pub fn has_id(&self) -> bool {
            self.id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_id(&mut self, v: i32) {
            self.id = ::std::option::Option::Some(v);
        }

        // optional string label = 2;

        pub fn label(&self) -> &str {
            match self.label.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_label(&mut self) {
            self.label = ::std::option::Option::None;
        }

        pub fn has_label(&self) -> bool {
            self.label.is_some()
        }

        // Param is passed by value, moved
        pub fn set_label(&mut self, v: ::std::string::String) {
            self.label = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_label(&mut self) -> &mut ::std::string::String {
            if self.label.is_none() {
                self.label = ::std::option::Option::Some(::std::string::String::new());
            }
            self.label.as_mut().unwrap()
        }

        // Take field
        pub fn take_label(&mut self) -> ::std::string::String {
            self.label.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::protobuf::Message for ContextCommand {
        const NAME: &'static str = "ContextCommand";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.label = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.id {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.label.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.label.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ContextCommand {
            ContextCommand::new()
        }

        fn clear(&mut self) {
            self.id = ::std::option::Option::None;
            self.label = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ContextCommand {
            static instance: ContextCommand = ContextCommand {
                id: ::std::option::Option::None,
                label: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgHandleContextMenuCommand)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgHandleContextMenuCommand {
    // message fields
    // @@protoc_insertion_point(field:CMsgHandleContextMenuCommand.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHandleContextMenuCommand.command_id)
    pub command_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgHandleContextMenuCommand.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgHandleContextMenuCommand {
    fn default() -> &'a CMsgHandleContextMenuCommand {
        <CMsgHandleContextMenuCommand as ::protobuf::Message>::default_instance()
    }
}

impl CMsgHandleContextMenuCommand {
    pub fn new() -> CMsgHandleContextMenuCommand {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional int32 command_id = 2;

    pub fn command_id(&self) -> i32 {
        self.command_id.unwrap_or(0)
    }

    pub fn clear_command_id(&mut self) {
        self.command_id = ::std::option::Option::None;
    }

    pub fn has_command_id(&self) -> bool {
        self.command_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_command_id(&mut self, v: i32) {
        self.command_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgHandleContextMenuCommand {
    const NAME: &'static str = "CMsgHandleContextMenuCommand";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.command_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.command_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.command_id {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgHandleContextMenuCommand {
        CMsgHandleContextMenuCommand::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.command_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgHandleContextMenuCommand {
        static instance: CMsgHandleContextMenuCommand = CMsgHandleContextMenuCommand {
            browser_handle: ::std::option::Option::None,
            command_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTouchGesture)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTouchGesture {
    // message fields
    // @@protoc_insertion_point(field:CMsgTouchGesture.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTouchGesture.id)
    pub id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgTouchGesture.gesture)
    pub gesture: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTouchGesture.x)
    pub x: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgTouchGesture.y)
    pub y: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgTouchGesture.width)
    pub width: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgTouchGesture.height)
    pub height: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgTouchGesture.tap_count)
    pub tap_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTouchGesture.pinch_scale)
    pub pinch_scale: ::std::option::Option<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTouchGesture.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTouchGesture {
    fn default() -> &'a CMsgTouchGesture {
        <CMsgTouchGesture as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTouchGesture {
    pub fn new() -> CMsgTouchGesture {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional int32 id = 2;

    pub fn id(&self) -> i32 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional uint32 gesture = 3;

    pub fn gesture(&self) -> u32 {
        self.gesture.unwrap_or(0)
    }

    pub fn clear_gesture(&mut self) {
        self.gesture = ::std::option::Option::None;
    }

    pub fn has_gesture(&self) -> bool {
        self.gesture.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gesture(&mut self, v: u32) {
        self.gesture = ::std::option::Option::Some(v);
    }

    // optional double x = 4;

    pub fn x(&self) -> f64 {
        self.x.unwrap_or(0.)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f64) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional double y = 5;

    pub fn y(&self) -> f64 {
        self.y.unwrap_or(0.)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f64) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional double width = 6;

    pub fn width(&self) -> f64 {
        self.width.unwrap_or(0.)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: f64) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional double height = 7;

    pub fn height(&self) -> f64 {
        self.height.unwrap_or(0.)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: f64) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional uint32 tap_count = 8;

    pub fn tap_count(&self) -> u32 {
        self.tap_count.unwrap_or(0)
    }

    pub fn clear_tap_count(&mut self) {
        self.tap_count = ::std::option::Option::None;
    }

    pub fn has_tap_count(&self) -> bool {
        self.tap_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tap_count(&mut self, v: u32) {
        self.tap_count = ::std::option::Option::Some(v);
    }

    // optional double pinch_scale = 9;

    pub fn pinch_scale(&self) -> f64 {
        self.pinch_scale.unwrap_or(0.)
    }

    pub fn clear_pinch_scale(&mut self) {
        self.pinch_scale = ::std::option::Option::None;
    }

    pub fn has_pinch_scale(&self) -> bool {
        self.pinch_scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pinch_scale(&mut self, v: f64) {
        self.pinch_scale = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgTouchGesture {
    const NAME: &'static str = "CMsgTouchGesture";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.gesture = ::std::option::Option::Some(is.read_uint32()?);
                },
                33 => {
                    self.x = ::std::option::Option::Some(is.read_double()?);
                },
                41 => {
                    self.y = ::std::option::Option::Some(is.read_double()?);
                },
                49 => {
                    self.width = ::std::option::Option::Some(is.read_double()?);
                },
                57 => {
                    self.height = ::std::option::Option::Some(is.read_double()?);
                },
                64 => {
                    self.tap_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                73 => {
                    self.pinch_scale = ::std::option::Option::Some(is.read_double()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.gesture {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.x {
            my_size += 1 + 8;
        }
        if let Some(v) = self.y {
            my_size += 1 + 8;
        }
        if let Some(v) = self.width {
            my_size += 1 + 8;
        }
        if let Some(v) = self.height {
            my_size += 1 + 8;
        }
        if let Some(v) = self.tap_count {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.pinch_scale {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.gesture {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.x {
            os.write_double(4, v)?;
        }
        if let Some(v) = self.y {
            os.write_double(5, v)?;
        }
        if let Some(v) = self.width {
            os.write_double(6, v)?;
        }
        if let Some(v) = self.height {
            os.write_double(7, v)?;
        }
        if let Some(v) = self.tap_count {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.pinch_scale {
            os.write_double(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTouchGesture {
        CMsgTouchGesture::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.id = ::std::option::Option::None;
        self.gesture = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.tap_count = ::std::option::Option::None;
        self.pinch_scale = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTouchGesture {
        static instance: CMsgTouchGesture = CMsgTouchGesture {
            browser_handle: ::std::option::Option::None,
            id: ::std::option::Option::None,
            gesture: ::std::option::Option::None,
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            tap_count: ::std::option::Option::None,
            pinch_scale: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSetTouchGesturesToCancel)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetTouchGesturesToCancel {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetTouchGesturesToCancel.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetTouchGesturesToCancel.gestures)
    pub gestures: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetTouchGesturesToCancel.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetTouchGesturesToCancel {
    fn default() -> &'a CMsgSetTouchGesturesToCancel {
        <CMsgSetTouchGesturesToCancel as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetTouchGesturesToCancel {
    pub fn new() -> CMsgSetTouchGesturesToCancel {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSetTouchGesturesToCancel {
    const NAME: &'static str = "CMsgSetTouchGesturesToCancel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.gestures)?;
                },
                16 => {
                    self.gestures.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.gestures {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        for v in &self.gestures {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetTouchGesturesToCancel {
        CMsgSetTouchGesturesToCancel::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.gestures.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetTouchGesturesToCancel {
        static instance: CMsgSetTouchGesturesToCancel = CMsgSetTouchGesturesToCancel {
            browser_handle: ::std::option::Option::None,
            gestures: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgImeSetComposition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgImeSetComposition {
    // message fields
    // @@protoc_insertion_point(field:CMsgImeSetComposition.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgImeSetComposition.text)
    pub text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgImeSetComposition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgImeSetComposition {
    fn default() -> &'a CMsgImeSetComposition {
        <CMsgImeSetComposition as ::protobuf::Message>::default_instance()
    }
}

impl CMsgImeSetComposition {
    pub fn new() -> CMsgImeSetComposition {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string text = 2;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgImeSetComposition {
    const NAME: &'static str = "CMsgImeSetComposition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgImeSetComposition {
        CMsgImeSetComposition::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgImeSetComposition {
        static instance: CMsgImeSetComposition = CMsgImeSetComposition {
            browser_handle: ::std::option::Option::None,
            text: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgImeCommitText)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgImeCommitText {
    // message fields
    // @@protoc_insertion_point(field:CMsgImeCommitText.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgImeCommitText.text)
    pub text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgImeCommitText.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgImeCommitText {
    fn default() -> &'a CMsgImeCommitText {
        <CMsgImeCommitText as ::protobuf::Message>::default_instance()
    }
}

impl CMsgImeCommitText {
    pub fn new() -> CMsgImeCommitText {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string text = 2;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgImeCommitText {
    const NAME: &'static str = "CMsgImeCommitText";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgImeCommitText {
        CMsgImeCommitText::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgImeCommitText {
        static instance: CMsgImeCommitText = CMsgImeCommitText {
            browser_handle: ::std::option::Option::None,
            text: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgImeCancelComposition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgImeCancelComposition {
    // message fields
    // @@protoc_insertion_point(field:CMsgImeCancelComposition.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgImeCancelComposition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgImeCancelComposition {
    fn default() -> &'a CMsgImeCancelComposition {
        <CMsgImeCancelComposition as ::protobuf::Message>::default_instance()
    }
}

impl CMsgImeCancelComposition {
    pub fn new() -> CMsgImeCancelComposition {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgImeCancelComposition {
    const NAME: &'static str = "CMsgImeCancelComposition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgImeCancelComposition {
        CMsgImeCancelComposition::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgImeCancelComposition {
        static instance: CMsgImeCancelComposition = CMsgImeCancelComposition {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgImeCompositionRangeChanged)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgImeCompositionRangeChanged {
    // message fields
    // @@protoc_insertion_point(field:CMsgImeCompositionRangeChanged.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgImeCompositionRangeChanged.x)
    pub x: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgImeCompositionRangeChanged.y)
    pub y: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgImeCompositionRangeChanged.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgImeCompositionRangeChanged {
    fn default() -> &'a CMsgImeCompositionRangeChanged {
        <CMsgImeCompositionRangeChanged as ::protobuf::Message>::default_instance()
    }
}

impl CMsgImeCompositionRangeChanged {
    pub fn new() -> CMsgImeCompositionRangeChanged {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 x = 2;

    pub fn x(&self) -> u32 {
        self.x.unwrap_or(0)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: u32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional uint32 y = 3;

    pub fn y(&self) -> u32 {
        self.y.unwrap_or(0)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: u32) {
        self.y = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgImeCompositionRangeChanged {
    const NAME: &'static str = "CMsgImeCompositionRangeChanged";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.x = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.y = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.x {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.y {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.y {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgImeCompositionRangeChanged {
        CMsgImeCompositionRangeChanged::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgImeCompositionRangeChanged {
        static instance: CMsgImeCompositionRangeChanged = CMsgImeCompositionRangeChanged {
            browser_handle: ::std::option::Option::None,
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgInspectElement)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgInspectElement {
    // message fields
    // @@protoc_insertion_point(field:CMsgInspectElement.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgInspectElement.x)
    pub x: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgInspectElement.y)
    pub y: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgInspectElement.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgInspectElement {
    fn default() -> &'a CMsgInspectElement {
        <CMsgInspectElement as ::protobuf::Message>::default_instance()
    }
}

impl CMsgInspectElement {
    pub fn new() -> CMsgInspectElement {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 x = 2;

    pub fn x(&self) -> u32 {
        self.x.unwrap_or(0)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: u32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional uint32 y = 3;

    pub fn y(&self) -> u32 {
        self.y.unwrap_or(0)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: u32) {
        self.y = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgInspectElement {
    const NAME: &'static str = "CMsgInspectElement";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.x = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.y = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.x {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.y {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.y {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgInspectElement {
        CMsgInspectElement::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgInspectElement {
        static instance: CMsgInspectElement = CMsgInspectElement {
            browser_handle: ::std::option::Option::None,
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDisableF5)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDisableF5 {
    // message fields
    // @@protoc_insertion_point(field:CMsgDisableF5.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDisableF5.disable)
    pub disable: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDisableF5.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDisableF5 {
    fn default() -> &'a CMsgDisableF5 {
        <CMsgDisableF5 as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDisableF5 {
    pub fn new() -> CMsgDisableF5 {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional bool disable = 2;

    pub fn disable(&self) -> bool {
        self.disable.unwrap_or(false)
    }

    pub fn clear_disable(&mut self) {
        self.disable = ::std::option::Option::None;
    }

    pub fn has_disable(&self) -> bool {
        self.disable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable(&mut self, v: bool) {
        self.disable = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgDisableF5 {
    const NAME: &'static str = "CMsgDisableF5";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.disable = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.disable {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.disable {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDisableF5 {
        CMsgDisableF5::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.disable = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDisableF5 {
        static instance: CMsgDisableF5 = CMsgDisableF5 {
            browser_handle: ::std::option::Option::None,
            disable: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgStartDownload)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgStartDownload {
    // message fields
    // @@protoc_insertion_point(field:CMsgStartDownload.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgStartDownload.url)
    pub url: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgStartDownload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgStartDownload {
    fn default() -> &'a CMsgStartDownload {
        <CMsgStartDownload as ::protobuf::Message>::default_instance()
    }
}

impl CMsgStartDownload {
    pub fn new() -> CMsgStartDownload {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgStartDownload {
    const NAME: &'static str = "CMsgStartDownload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgStartDownload {
        CMsgStartDownload::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgStartDownload {
        static instance: CMsgStartDownload = CMsgStartDownload {
            browser_handle: ::std::option::Option::None,
            url: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSetTopWindow)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetTopWindow {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetTopWindow.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetTopWindow.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetTopWindow {
    fn default() -> &'a CMsgSetTopWindow {
        <CMsgSetTopWindow as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetTopWindow {
    pub fn new() -> CMsgSetTopWindow {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSetTopWindow {
    const NAME: &'static str = "CMsgSetTopWindow";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetTopWindow {
        CMsgSetTopWindow::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetTopWindow {
        static instance: CMsgSetTopWindow = CMsgSetTopWindow {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgBrowserViewPostMessageToParentRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBrowserViewPostMessageToParentRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgBrowserViewPostMessageToParentRequest.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBrowserViewPostMessageToParentRequest.message)
    pub message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgBrowserViewPostMessageToParentRequest.args)
    pub args: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgBrowserViewPostMessageToParentRequest.requesting_url)
    pub requesting_url: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBrowserViewPostMessageToParentRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBrowserViewPostMessageToParentRequest {
    fn default() -> &'a CMsgBrowserViewPostMessageToParentRequest {
        <CMsgBrowserViewPostMessageToParentRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBrowserViewPostMessageToParentRequest {
    pub fn new() -> CMsgBrowserViewPostMessageToParentRequest {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string message = 2;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string args = 3;

    pub fn args(&self) -> &str {
        match self.args.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_args(&mut self) {
        self.args = ::std::option::Option::None;
    }

    pub fn has_args(&self) -> bool {
        self.args.is_some()
    }

    // Param is passed by value, moved
    pub fn set_args(&mut self, v: ::std::string::String) {
        self.args = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_args(&mut self) -> &mut ::std::string::String {
        if self.args.is_none() {
            self.args = ::std::option::Option::Some(::std::string::String::new());
        }
        self.args.as_mut().unwrap()
    }

    // Take field
    pub fn take_args(&mut self) -> ::std::string::String {
        self.args.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string requesting_url = 4;

    pub fn requesting_url(&self) -> &str {
        match self.requesting_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_requesting_url(&mut self) {
        self.requesting_url = ::std::option::Option::None;
    }

    pub fn has_requesting_url(&self) -> bool {
        self.requesting_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requesting_url(&mut self, v: ::std::string::String) {
        self.requesting_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_requesting_url(&mut self) -> &mut ::std::string::String {
        if self.requesting_url.is_none() {
            self.requesting_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.requesting_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_requesting_url(&mut self) -> ::std::string::String {
        self.requesting_url.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgBrowserViewPostMessageToParentRequest {
    const NAME: &'static str = "CMsgBrowserViewPostMessageToParentRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.args = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.requesting_url = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.args.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.requesting_url.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.args.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.requesting_url.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBrowserViewPostMessageToParentRequest {
        CMsgBrowserViewPostMessageToParentRequest::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.args = ::std::option::Option::None;
        self.requesting_url = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBrowserViewPostMessageToParentRequest {
        static instance: CMsgBrowserViewPostMessageToParentRequest = CMsgBrowserViewPostMessageToParentRequest {
            browser_handle: ::std::option::Option::None,
            message: ::std::option::Option::None,
            args: ::std::option::Option::None,
            requesting_url: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgBlockedRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBlockedRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgBlockedRequest.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBlockedRequest.url)
    pub url: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBlockedRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBlockedRequest {
    fn default() -> &'a CMsgBlockedRequest {
        <CMsgBlockedRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBlockedRequest {
    pub fn new() -> CMsgBlockedRequest {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgBlockedRequest {
    const NAME: &'static str = "CMsgBlockedRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBlockedRequest {
        CMsgBlockedRequest::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBlockedRequest {
        static instance: CMsgBlockedRequest = CMsgBlockedRequest {
            browser_handle: ::std::option::Option::None,
            url: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgBrowserFocusChanged)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBrowserFocusChanged {
    // message fields
    // @@protoc_insertion_point(field:CMsgBrowserFocusChanged.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBrowserFocusChanged.focused)
    pub focused: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBrowserFocusChanged.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBrowserFocusChanged {
    fn default() -> &'a CMsgBrowserFocusChanged {
        <CMsgBrowserFocusChanged as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBrowserFocusChanged {
    pub fn new() -> CMsgBrowserFocusChanged {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional bool focused = 2;

    pub fn focused(&self) -> bool {
        self.focused.unwrap_or(false)
    }

    pub fn clear_focused(&mut self) {
        self.focused = ::std::option::Option::None;
    }

    pub fn has_focused(&self) -> bool {
        self.focused.is_some()
    }

    // Param is passed by value, moved
    pub fn set_focused(&mut self, v: bool) {
        self.focused = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgBrowserFocusChanged {
    const NAME: &'static str = "CMsgBrowserFocusChanged";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.focused = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.focused {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.focused {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBrowserFocusChanged {
        CMsgBrowserFocusChanged::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.focused = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBrowserFocusChanged {
        static instance: CMsgBrowserFocusChanged = CMsgBrowserFocusChanged {
            browser_handle: ::std::option::Option::None,
            focused: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSetProtocolBlockList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetProtocolBlockList {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetProtocolBlockList.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetProtocolBlockList.list)
    pub list: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetProtocolBlockList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetProtocolBlockList {
    fn default() -> &'a CMsgSetProtocolBlockList {
        <CMsgSetProtocolBlockList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetProtocolBlockList {
    pub fn new() -> CMsgSetProtocolBlockList {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string list = 2;

    pub fn list(&self) -> &str {
        match self.list.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_list(&mut self) {
        self.list = ::std::option::Option::None;
    }

    pub fn has_list(&self) -> bool {
        self.list.is_some()
    }

    // Param is passed by value, moved
    pub fn set_list(&mut self, v: ::std::string::String) {
        self.list = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_list(&mut self) -> &mut ::std::string::String {
        if self.list.is_none() {
            self.list = ::std::option::Option::Some(::std::string::String::new());
        }
        self.list.as_mut().unwrap()
    }

    // Take field
    pub fn take_list(&mut self) -> ::std::string::String {
        self.list.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgSetProtocolBlockList {
    const NAME: &'static str = "CMsgSetProtocolBlockList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.list = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.list.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.list.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetProtocolBlockList {
        CMsgSetProtocolBlockList::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.list = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetProtocolBlockList {
        static instance: CMsgSetProtocolBlockList = CMsgSetProtocolBlockList {
            browser_handle: ::std::option::Option::None,
            list: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSetForceDeviceScaleFactors)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetForceDeviceScaleFactors {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetForceDeviceScaleFactors.dpi_scale)
    pub dpi_scale: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgSetForceDeviceScaleFactors.browser_scale)
    pub browser_scale: ::std::option::Option<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetForceDeviceScaleFactors.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetForceDeviceScaleFactors {
    fn default() -> &'a CMsgSetForceDeviceScaleFactors {
        <CMsgSetForceDeviceScaleFactors as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetForceDeviceScaleFactors {
    pub fn new() -> CMsgSetForceDeviceScaleFactors {
        ::std::default::Default::default()
    }

    // optional double dpi_scale = 1;

    pub fn dpi_scale(&self) -> f64 {
        self.dpi_scale.unwrap_or(0.)
    }

    pub fn clear_dpi_scale(&mut self) {
        self.dpi_scale = ::std::option::Option::None;
    }

    pub fn has_dpi_scale(&self) -> bool {
        self.dpi_scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dpi_scale(&mut self, v: f64) {
        self.dpi_scale = ::std::option::Option::Some(v);
    }

    // optional double browser_scale = 2;

    pub fn browser_scale(&self) -> f64 {
        self.browser_scale.unwrap_or(0.)
    }

    pub fn clear_browser_scale(&mut self) {
        self.browser_scale = ::std::option::Option::None;
    }

    pub fn has_browser_scale(&self) -> bool {
        self.browser_scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_scale(&mut self, v: f64) {
        self.browser_scale = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSetForceDeviceScaleFactors {
    const NAME: &'static str = "CMsgSetForceDeviceScaleFactors";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.dpi_scale = ::std::option::Option::Some(is.read_double()?);
                },
                17 => {
                    self.browser_scale = ::std::option::Option::Some(is.read_double()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dpi_scale {
            my_size += 1 + 8;
        }
        if let Some(v) = self.browser_scale {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.dpi_scale {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.browser_scale {
            os.write_double(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetForceDeviceScaleFactors {
        CMsgSetForceDeviceScaleFactors::new()
    }

    fn clear(&mut self) {
        self.dpi_scale = ::std::option::Option::None;
        self.browser_scale = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetForceDeviceScaleFactors {
        static instance: CMsgSetForceDeviceScaleFactors = CMsgSetForceDeviceScaleFactors {
            dpi_scale: ::std::option::Option::None,
            browser_scale: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSetUIMode)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetUIMode {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetUIMode.ui_mode)
    pub ui_mode: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetUIMode.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetUIMode {
    fn default() -> &'a CMsgSetUIMode {
        <CMsgSetUIMode as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetUIMode {
    pub fn new() -> CMsgSetUIMode {
        ::std::default::Default::default()
    }

    // optional int32 ui_mode = 1;

    pub fn ui_mode(&self) -> i32 {
        self.ui_mode.unwrap_or(0)
    }

    pub fn clear_ui_mode(&mut self) {
        self.ui_mode = ::std::option::Option::None;
    }

    pub fn has_ui_mode(&self) -> bool {
        self.ui_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ui_mode(&mut self, v: i32) {
        self.ui_mode = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSetUIMode {
    const NAME: &'static str = "CMsgSetUIMode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ui_mode = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ui_mode {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ui_mode {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetUIMode {
        CMsgSetUIMode::new()
    }

    fn clear(&mut self) {
        self.ui_mode = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetUIMode {
        static instance: CMsgSetUIMode = CMsgSetUIMode {
            ui_mode: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPopupCreated)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPopupCreated {
    // message fields
    // @@protoc_insertion_point(field:CMsgPopupCreated.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPopupCreated.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPopupCreated {
    fn default() -> &'a CMsgPopupCreated {
        <CMsgPopupCreated as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPopupCreated {
    pub fn new() -> CMsgPopupCreated {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgPopupCreated {
    const NAME: &'static str = "CMsgPopupCreated";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPopupCreated {
        CMsgPopupCreated::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPopupCreated {
        static instance: CMsgPopupCreated = CMsgPopupCreated {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSetVRKeyboardVisibility)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetVRKeyboardVisibility {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetVRKeyboardVisibility.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetVRKeyboardVisibility.visible)
    pub visible: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetVRKeyboardVisibility.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetVRKeyboardVisibility {
    fn default() -> &'a CMsgSetVRKeyboardVisibility {
        <CMsgSetVRKeyboardVisibility as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetVRKeyboardVisibility {
    pub fn new() -> CMsgSetVRKeyboardVisibility {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional bool visible = 2;

    pub fn visible(&self) -> bool {
        self.visible.unwrap_or(false)
    }

    pub fn clear_visible(&mut self) {
        self.visible = ::std::option::Option::None;
    }

    pub fn has_visible(&self) -> bool {
        self.visible.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visible(&mut self, v: bool) {
        self.visible = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSetVRKeyboardVisibility {
    const NAME: &'static str = "CMsgSetVRKeyboardVisibility";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.visible = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.visible {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.visible {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetVRKeyboardVisibility {
        CMsgSetVRKeyboardVisibility::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.visible = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetVRKeyboardVisibility {
        static instance: CMsgSetVRKeyboardVisibility = CMsgSetVRKeyboardVisibility {
            browser_handle: ::std::option::Option::None,
            visible: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EJSRegisterMethodType)
pub enum EJSRegisterMethodType {
    // @@protoc_insertion_point(enum_value:EJSRegisterMethodType.k_EJSRegisterMethodType_Invalid)
    k_EJSRegisterMethodType_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EJSRegisterMethodType.k_EJSRegisterMethodType_Function)
    k_EJSRegisterMethodType_Function = 1,
    // @@protoc_insertion_point(enum_value:EJSRegisterMethodType.k_EJSRegisterMethodType_Callback)
    k_EJSRegisterMethodType_Callback = 2,
    // @@protoc_insertion_point(enum_value:EJSRegisterMethodType.k_EJSRegisterMethodType_Promise)
    k_EJSRegisterMethodType_Promise = 3,
}

impl ::protobuf::Enum for EJSRegisterMethodType {
    const NAME: &'static str = "EJSRegisterMethodType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EJSRegisterMethodType> {
        match value {
            0 => ::std::option::Option::Some(EJSRegisterMethodType::k_EJSRegisterMethodType_Invalid),
            1 => ::std::option::Option::Some(EJSRegisterMethodType::k_EJSRegisterMethodType_Function),
            2 => ::std::option::Option::Some(EJSRegisterMethodType::k_EJSRegisterMethodType_Callback),
            3 => ::std::option::Option::Some(EJSRegisterMethodType::k_EJSRegisterMethodType_Promise),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EJSRegisterMethodType> {
        match str {
            "k_EJSRegisterMethodType_Invalid" => ::std::option::Option::Some(EJSRegisterMethodType::k_EJSRegisterMethodType_Invalid),
            "k_EJSRegisterMethodType_Function" => ::std::option::Option::Some(EJSRegisterMethodType::k_EJSRegisterMethodType_Function),
            "k_EJSRegisterMethodType_Callback" => ::std::option::Option::Some(EJSRegisterMethodType::k_EJSRegisterMethodType_Callback),
            "k_EJSRegisterMethodType_Promise" => ::std::option::Option::Some(EJSRegisterMethodType::k_EJSRegisterMethodType_Promise),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EJSRegisterMethodType] = &[
        EJSRegisterMethodType::k_EJSRegisterMethodType_Invalid,
        EJSRegisterMethodType::k_EJSRegisterMethodType_Function,
        EJSRegisterMethodType::k_EJSRegisterMethodType_Callback,
        EJSRegisterMethodType::k_EJSRegisterMethodType_Promise,
    ];
}

impl ::std::default::Default for EJSRegisterMethodType {
    fn default() -> Self {
        EJSRegisterMethodType::k_EJSRegisterMethodType_Invalid
    }
}

impl crate::RpcMessage for CMsgKeyUp {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgKeyDown {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgKeyChar {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgMouseDown {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgMouseUp {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgMouseDblClick {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgMouseWheel {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgMouseMove {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgMouseLeave {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgBrowserCreate {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgBrowserCreateResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgBrowserRemove {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSetLocalFileRequestMapping {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgBrowserErrorStrings {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgBrowserSetName {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgBrowserSize {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgBrowserSetMinSize {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgBrowserPosition {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgBrowserResized {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgPostURL {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgAddHeader {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgStopLoad {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgReload {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgGoForward {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgGoBack {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgWasHidden {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSetWindowVisibility {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgClearHistory {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgClearAllBrowsingData {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgCopy {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgPaste {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgExecuteJavaScript {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSetFocus {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgHorizontalScrollBarSize {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgHorizontalScrollBarSizeResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgVerticalScrollBarSize {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgVerticalScrollBarSizeResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgFind {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgStopFind {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSetHorizontalScroll {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSetVerticalScroll {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSetZoomLevel {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgViewSource {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgBrowserReady {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgURLChanged {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CHistoryEntry {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgHistoryChanged {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgLoadError {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CHTMLHeader {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CHTMLPageSecurityInfo {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgFinishedRequest {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgLoadedRequest {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgFavIconURLChanged {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgPageSecurity {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgStartRequest {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgStartRequestResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgShowPopup {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgHidePopup {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSizePopup {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgOpenNewTab {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgPopupHTMLWindow {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgPopupHTMLWindowResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSetHTMLTitle {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgLoadingResource {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgStatusText {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSetCursor {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgFileLoadDialog {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgFileLoadDialogResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgShowToolTip {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgUpdateToolTip {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgHideToolTip {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSearchResults {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgClose {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSetSharedPaintBuffers {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgAckSharedPaintBuffers {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgNeedsPaint {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgComboNeedsPaint {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgNeedsSharedTexturePaint {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgGameOverlayTexturePaint {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgGetZoom {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgGetZoomResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgLinkAtPosition {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgLinkAtPositionResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgZoomToElementAtPosition {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgZoomToElementAtPositionResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgScalePageToValue {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgForcePopupsToDirectHWND {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgScalePageToValueResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSavePageToJPEG {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSavePageToJPEGResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgJSAlert {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgJSConfirm {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgJSDialogResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgCanGoBackAndForward {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgOpenSteamURL {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSetCookie {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSetTargetFrameRate {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgPauseRepaint {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgFullRepaint {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgRequestFullScreen {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgExitFullScreen {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgToggleFindInPageDialog {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSetPIDShuttingDown {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgDisableBackgroundThrottling {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgAckPIDShuttingDown {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgGetCookiesForURL {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CCookie {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgGetCookiesForURLResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgNodeHasFocus {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgZoomToFocusedElement {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgCloseFullScreenFlashIfOpen {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgPauseFullScreenFlashMovieIfOpen {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgFocusedNodeText {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgFocusedNodeTextResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgBuildID {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgOpenDevTools {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgCloseDevTools {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgUnlockH264 {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgScreenInformationChanged {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgClearAllCookies {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgScreenDPI {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgAckScreenDPI {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgAuthedSteamDomains {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSteamAuthNeeded {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSteamAuthCookiesSet {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgJSRegisterMethod {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgJSValue {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgJSMethodCall {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgJSExecuteCallback {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgJSReleaseCallback {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgJSRaiseException {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgLoadLocalization {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgNotifyUserActivation {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSetNetFakeLocalSystemState {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSetGameOverlayTargetPIDs {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgGameOverlayTargetTextureID {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgDraggableRegionsChanged {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgResizeGripChanged {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSetWindowPosition {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgShowWindow {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgHideWindow {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgBringWindowToFront {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSetForegroundWindow {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgMaximizeRestoreWindow {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgMinimizeWindow {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgShowBrowserContextMenu {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgHandleContextMenuCommand {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgTouchGesture {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSetTouchGesturesToCancel {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgImeSetComposition {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgImeCommitText {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgImeCancelComposition {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgImeCompositionRangeChanged {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgInspectElement {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgDisableF5 {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgStartDownload {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSetTopWindow {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgBrowserViewPostMessageToParentRequest {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgBlockedRequest {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgBrowserFocusChanged {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSetProtocolBlockList {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSetForceDeviceScaleFactors {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSetUIMode {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgPopupCreated {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSetVRKeyboardVisibility {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
