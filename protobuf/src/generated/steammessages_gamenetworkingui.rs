// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_gamenetworkingui.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:CGameNetworkingUI_GlobalState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameNetworkingUI_GlobalState {
    // special fields
    // @@protoc_insertion_point(special_field:CGameNetworkingUI_GlobalState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameNetworkingUI_GlobalState {
    fn default() -> &'a CGameNetworkingUI_GlobalState {
        <CGameNetworkingUI_GlobalState as ::protobuf::Message>::default_instance()
    }
}

impl CGameNetworkingUI_GlobalState {
    pub fn new() -> CGameNetworkingUI_GlobalState {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CGameNetworkingUI_GlobalState {
    const NAME: &'static str = "CGameNetworkingUI_GlobalState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameNetworkingUI_GlobalState {
        CGameNetworkingUI_GlobalState::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameNetworkingUI_GlobalState {
        static instance: CGameNetworkingUI_GlobalState = CGameNetworkingUI_GlobalState {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameNetworkingUI_ConnectionState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameNetworkingUI_ConnectionState {
    // message fields
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.connection_key)
    pub connection_key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.connection_id_local)
    pub connection_id_local: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.identity_local)
    pub identity_local: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.identity_remote)
    pub identity_remote: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.connection_state)
    pub connection_state: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.start_time)
    pub start_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.close_time)
    pub close_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.close_reason)
    pub close_reason: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.close_message)
    pub close_message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.status_loc_token)
    pub status_loc_token: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.transport_kind)
    pub transport_kind: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.sdrpopid_local)
    pub sdrpopid_local: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.sdrpopid_remote)
    pub sdrpopid_remote: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.address_remote)
    pub address_remote: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.p2p_routing)
    pub p2p_routing: ::protobuf::MessageField<super::steamdatagram_messages_sdr::CMsgSteamDatagramP2PRoutingSummary>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.ping_interior)
    pub ping_interior: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.ping_remote_front)
    pub ping_remote_front: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.ping_default_internet_route)
    pub ping_default_internet_route: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.e2e_quality_local)
    pub e2e_quality_local: ::protobuf::MessageField<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.e2e_quality_remote)
    pub e2e_quality_remote: ::protobuf::MessageField<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.e2e_quality_remote_instantaneous_time)
    pub e2e_quality_remote_instantaneous_time: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.e2e_quality_remote_lifetime_time)
    pub e2e_quality_remote_lifetime_time: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.front_quality_local)
    pub front_quality_local: ::protobuf::MessageField<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.front_quality_remote)
    pub front_quality_remote: ::protobuf::MessageField<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.front_quality_remote_instantaneous_time)
    pub front_quality_remote_instantaneous_time: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.front_quality_remote_lifetime_time)
    pub front_quality_remote_lifetime_time: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameNetworkingUI_ConnectionState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameNetworkingUI_ConnectionState {
    fn default() -> &'a CGameNetworkingUI_ConnectionState {
        <CGameNetworkingUI_ConnectionState as ::protobuf::Message>::default_instance()
    }
}

impl CGameNetworkingUI_ConnectionState {
    pub fn new() -> CGameNetworkingUI_ConnectionState {
        ::std::default::Default::default()
    }

    // optional string connection_key = 1;

    pub fn connection_key(&self) -> &str {
        match self.connection_key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_connection_key(&mut self) {
        self.connection_key = ::std::option::Option::None;
    }

    pub fn has_connection_key(&self) -> bool {
        self.connection_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_key(&mut self, v: ::std::string::String) {
        self.connection_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connection_key(&mut self) -> &mut ::std::string::String {
        if self.connection_key.is_none() {
            self.connection_key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.connection_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_connection_key(&mut self) -> ::std::string::String {
        self.connection_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 appid = 2;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional fixed32 connection_id_local = 3;

    pub fn connection_id_local(&self) -> u32 {
        self.connection_id_local.unwrap_or(0)
    }

    pub fn clear_connection_id_local(&mut self) {
        self.connection_id_local = ::std::option::Option::None;
    }

    pub fn has_connection_id_local(&self) -> bool {
        self.connection_id_local.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id_local(&mut self, v: u32) {
        self.connection_id_local = ::std::option::Option::Some(v);
    }

    // optional string identity_local = 4;

    pub fn identity_local(&self) -> &str {
        match self.identity_local.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_identity_local(&mut self) {
        self.identity_local = ::std::option::Option::None;
    }

    pub fn has_identity_local(&self) -> bool {
        self.identity_local.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identity_local(&mut self, v: ::std::string::String) {
        self.identity_local = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identity_local(&mut self) -> &mut ::std::string::String {
        if self.identity_local.is_none() {
            self.identity_local = ::std::option::Option::Some(::std::string::String::new());
        }
        self.identity_local.as_mut().unwrap()
    }

    // Take field
    pub fn take_identity_local(&mut self) -> ::std::string::String {
        self.identity_local.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string identity_remote = 5;

    pub fn identity_remote(&self) -> &str {
        match self.identity_remote.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_identity_remote(&mut self) {
        self.identity_remote = ::std::option::Option::None;
    }

    pub fn has_identity_remote(&self) -> bool {
        self.identity_remote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identity_remote(&mut self, v: ::std::string::String) {
        self.identity_remote = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identity_remote(&mut self) -> &mut ::std::string::String {
        if self.identity_remote.is_none() {
            self.identity_remote = ::std::option::Option::Some(::std::string::String::new());
        }
        self.identity_remote.as_mut().unwrap()
    }

    // Take field
    pub fn take_identity_remote(&mut self) -> ::std::string::String {
        self.identity_remote.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 connection_state = 10;

    pub fn connection_state(&self) -> u32 {
        self.connection_state.unwrap_or(0)
    }

    pub fn clear_connection_state(&mut self) {
        self.connection_state = ::std::option::Option::None;
    }

    pub fn has_connection_state(&self) -> bool {
        self.connection_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_state(&mut self, v: u32) {
        self.connection_state = ::std::option::Option::Some(v);
    }

    // optional uint32 start_time = 12;

    pub fn start_time(&self) -> u32 {
        self.start_time.unwrap_or(0)
    }

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: u32) {
        self.start_time = ::std::option::Option::Some(v);
    }

    // optional uint32 close_time = 13;

    pub fn close_time(&self) -> u32 {
        self.close_time.unwrap_or(0)
    }

    pub fn clear_close_time(&mut self) {
        self.close_time = ::std::option::Option::None;
    }

    pub fn has_close_time(&self) -> bool {
        self.close_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_close_time(&mut self, v: u32) {
        self.close_time = ::std::option::Option::Some(v);
    }

    // optional uint32 close_reason = 14;

    pub fn close_reason(&self) -> u32 {
        self.close_reason.unwrap_or(0)
    }

    pub fn clear_close_reason(&mut self) {
        self.close_reason = ::std::option::Option::None;
    }

    pub fn has_close_reason(&self) -> bool {
        self.close_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_close_reason(&mut self, v: u32) {
        self.close_reason = ::std::option::Option::Some(v);
    }

    // optional string close_message = 15;

    pub fn close_message(&self) -> &str {
        match self.close_message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_close_message(&mut self) {
        self.close_message = ::std::option::Option::None;
    }

    pub fn has_close_message(&self) -> bool {
        self.close_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_close_message(&mut self, v: ::std::string::String) {
        self.close_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_close_message(&mut self) -> &mut ::std::string::String {
        if self.close_message.is_none() {
            self.close_message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.close_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_close_message(&mut self) -> ::std::string::String {
        self.close_message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string status_loc_token = 16;

    pub fn status_loc_token(&self) -> &str {
        match self.status_loc_token.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_status_loc_token(&mut self) {
        self.status_loc_token = ::std::option::Option::None;
    }

    pub fn has_status_loc_token(&self) -> bool {
        self.status_loc_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status_loc_token(&mut self, v: ::std::string::String) {
        self.status_loc_token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status_loc_token(&mut self) -> &mut ::std::string::String {
        if self.status_loc_token.is_none() {
            self.status_loc_token = ::std::option::Option::Some(::std::string::String::new());
        }
        self.status_loc_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_status_loc_token(&mut self) -> ::std::string::String {
        self.status_loc_token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 transport_kind = 20;

    pub fn transport_kind(&self) -> u32 {
        self.transport_kind.unwrap_or(0)
    }

    pub fn clear_transport_kind(&mut self) {
        self.transport_kind = ::std::option::Option::None;
    }

    pub fn has_transport_kind(&self) -> bool {
        self.transport_kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transport_kind(&mut self, v: u32) {
        self.transport_kind = ::std::option::Option::Some(v);
    }

    // optional string sdrpopid_local = 21;

    pub fn sdrpopid_local(&self) -> &str {
        match self.sdrpopid_local.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_sdrpopid_local(&mut self) {
        self.sdrpopid_local = ::std::option::Option::None;
    }

    pub fn has_sdrpopid_local(&self) -> bool {
        self.sdrpopid_local.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sdrpopid_local(&mut self, v: ::std::string::String) {
        self.sdrpopid_local = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sdrpopid_local(&mut self) -> &mut ::std::string::String {
        if self.sdrpopid_local.is_none() {
            self.sdrpopid_local = ::std::option::Option::Some(::std::string::String::new());
        }
        self.sdrpopid_local.as_mut().unwrap()
    }

    // Take field
    pub fn take_sdrpopid_local(&mut self) -> ::std::string::String {
        self.sdrpopid_local.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string sdrpopid_remote = 22;

    pub fn sdrpopid_remote(&self) -> &str {
        match self.sdrpopid_remote.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_sdrpopid_remote(&mut self) {
        self.sdrpopid_remote = ::std::option::Option::None;
    }

    pub fn has_sdrpopid_remote(&self) -> bool {
        self.sdrpopid_remote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sdrpopid_remote(&mut self, v: ::std::string::String) {
        self.sdrpopid_remote = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sdrpopid_remote(&mut self) -> &mut ::std::string::String {
        if self.sdrpopid_remote.is_none() {
            self.sdrpopid_remote = ::std::option::Option::Some(::std::string::String::new());
        }
        self.sdrpopid_remote.as_mut().unwrap()
    }

    // Take field
    pub fn take_sdrpopid_remote(&mut self) -> ::std::string::String {
        self.sdrpopid_remote.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string address_remote = 23;

    pub fn address_remote(&self) -> &str {
        match self.address_remote.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_address_remote(&mut self) {
        self.address_remote = ::std::option::Option::None;
    }

    pub fn has_address_remote(&self) -> bool {
        self.address_remote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address_remote(&mut self, v: ::std::string::String) {
        self.address_remote = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address_remote(&mut self) -> &mut ::std::string::String {
        if self.address_remote.is_none() {
            self.address_remote = ::std::option::Option::Some(::std::string::String::new());
        }
        self.address_remote.as_mut().unwrap()
    }

    // Take field
    pub fn take_address_remote(&mut self) -> ::std::string::String {
        self.address_remote.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 ping_interior = 25;

    pub fn ping_interior(&self) -> u32 {
        self.ping_interior.unwrap_or(0)
    }

    pub fn clear_ping_interior(&mut self) {
        self.ping_interior = ::std::option::Option::None;
    }

    pub fn has_ping_interior(&self) -> bool {
        self.ping_interior.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_interior(&mut self, v: u32) {
        self.ping_interior = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_remote_front = 26;

    pub fn ping_remote_front(&self) -> u32 {
        self.ping_remote_front.unwrap_or(0)
    }

    pub fn clear_ping_remote_front(&mut self) {
        self.ping_remote_front = ::std::option::Option::None;
    }

    pub fn has_ping_remote_front(&self) -> bool {
        self.ping_remote_front.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_remote_front(&mut self, v: u32) {
        self.ping_remote_front = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_default_internet_route = 27;

    pub fn ping_default_internet_route(&self) -> u32 {
        self.ping_default_internet_route.unwrap_or(0)
    }

    pub fn clear_ping_default_internet_route(&mut self) {
        self.ping_default_internet_route = ::std::option::Option::None;
    }

    pub fn has_ping_default_internet_route(&self) -> bool {
        self.ping_default_internet_route.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_default_internet_route(&mut self, v: u32) {
        self.ping_default_internet_route = ::std::option::Option::Some(v);
    }

    // optional uint64 e2e_quality_remote_instantaneous_time = 32;

    pub fn e2e_quality_remote_instantaneous_time(&self) -> u64 {
        self.e2e_quality_remote_instantaneous_time.unwrap_or(0)
    }

    pub fn clear_e2e_quality_remote_instantaneous_time(&mut self) {
        self.e2e_quality_remote_instantaneous_time = ::std::option::Option::None;
    }

    pub fn has_e2e_quality_remote_instantaneous_time(&self) -> bool {
        self.e2e_quality_remote_instantaneous_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_e2e_quality_remote_instantaneous_time(&mut self, v: u64) {
        self.e2e_quality_remote_instantaneous_time = ::std::option::Option::Some(v);
    }

    // optional uint64 e2e_quality_remote_lifetime_time = 33;

    pub fn e2e_quality_remote_lifetime_time(&self) -> u64 {
        self.e2e_quality_remote_lifetime_time.unwrap_or(0)
    }

    pub fn clear_e2e_quality_remote_lifetime_time(&mut self) {
        self.e2e_quality_remote_lifetime_time = ::std::option::Option::None;
    }

    pub fn has_e2e_quality_remote_lifetime_time(&self) -> bool {
        self.e2e_quality_remote_lifetime_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_e2e_quality_remote_lifetime_time(&mut self, v: u64) {
        self.e2e_quality_remote_lifetime_time = ::std::option::Option::Some(v);
    }

    // optional uint64 front_quality_remote_instantaneous_time = 42;

    pub fn front_quality_remote_instantaneous_time(&self) -> u64 {
        self.front_quality_remote_instantaneous_time.unwrap_or(0)
    }

    pub fn clear_front_quality_remote_instantaneous_time(&mut self) {
        self.front_quality_remote_instantaneous_time = ::std::option::Option::None;
    }

    pub fn has_front_quality_remote_instantaneous_time(&self) -> bool {
        self.front_quality_remote_instantaneous_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_front_quality_remote_instantaneous_time(&mut self, v: u64) {
        self.front_quality_remote_instantaneous_time = ::std::option::Option::Some(v);
    }

    // optional uint64 front_quality_remote_lifetime_time = 43;

    pub fn front_quality_remote_lifetime_time(&self) -> u64 {
        self.front_quality_remote_lifetime_time.unwrap_or(0)
    }

    pub fn clear_front_quality_remote_lifetime_time(&mut self) {
        self.front_quality_remote_lifetime_time = ::std::option::Option::None;
    }

    pub fn has_front_quality_remote_lifetime_time(&self) -> bool {
        self.front_quality_remote_lifetime_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_front_quality_remote_lifetime_time(&mut self, v: u64) {
        self.front_quality_remote_lifetime_time = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CGameNetworkingUI_ConnectionState {
    const NAME: &'static str = "CGameNetworkingUI_ConnectionState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.connection_key = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                29 => {
                    self.connection_id_local = ::std::option::Option::Some(is.read_fixed32()?);
                },
                34 => {
                    self.identity_local = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.identity_remote = ::std::option::Option::Some(is.read_string()?);
                },
                80 => {
                    self.connection_state = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.start_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.close_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.close_reason = ::std::option::Option::Some(is.read_uint32()?);
                },
                122 => {
                    self.close_message = ::std::option::Option::Some(is.read_string()?);
                },
                130 => {
                    self.status_loc_token = ::std::option::Option::Some(is.read_string()?);
                },
                160 => {
                    self.transport_kind = ::std::option::Option::Some(is.read_uint32()?);
                },
                170 => {
                    self.sdrpopid_local = ::std::option::Option::Some(is.read_string()?);
                },
                178 => {
                    self.sdrpopid_remote = ::std::option::Option::Some(is.read_string()?);
                },
                186 => {
                    self.address_remote = ::std::option::Option::Some(is.read_string()?);
                },
                194 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.p2p_routing)?;
                },
                200 => {
                    self.ping_interior = ::std::option::Option::Some(is.read_uint32()?);
                },
                208 => {
                    self.ping_remote_front = ::std::option::Option::Some(is.read_uint32()?);
                },
                216 => {
                    self.ping_default_internet_route = ::std::option::Option::Some(is.read_uint32()?);
                },
                242 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.e2e_quality_local)?;
                },
                250 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.e2e_quality_remote)?;
                },
                256 => {
                    self.e2e_quality_remote_instantaneous_time = ::std::option::Option::Some(is.read_uint64()?);
                },
                264 => {
                    self.e2e_quality_remote_lifetime_time = ::std::option::Option::Some(is.read_uint64()?);
                },
                322 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.front_quality_local)?;
                },
                330 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.front_quality_remote)?;
                },
                336 => {
                    self.front_quality_remote_instantaneous_time = ::std::option::Option::Some(is.read_uint64()?);
                },
                344 => {
                    self.front_quality_remote_lifetime_time = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.connection_key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.connection_id_local {
            my_size += 1 + 4;
        }
        if let Some(v) = self.identity_local.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.identity_remote.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.connection_state {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.start_time {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.close_time {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.close_reason {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.close_message.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.status_loc_token.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        if let Some(v) = self.transport_kind {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.sdrpopid_local.as_ref() {
            my_size += ::protobuf::rt::string_size(21, &v);
        }
        if let Some(v) = self.sdrpopid_remote.as_ref() {
            my_size += ::protobuf::rt::string_size(22, &v);
        }
        if let Some(v) = self.address_remote.as_ref() {
            my_size += ::protobuf::rt::string_size(23, &v);
        }
        if let Some(v) = self.p2p_routing.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ping_interior {
            my_size += ::protobuf::rt::uint32_size(25, v);
        }
        if let Some(v) = self.ping_remote_front {
            my_size += ::protobuf::rt::uint32_size(26, v);
        }
        if let Some(v) = self.ping_default_internet_route {
            my_size += ::protobuf::rt::uint32_size(27, v);
        }
        if let Some(v) = self.e2e_quality_local.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.e2e_quality_remote.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.e2e_quality_remote_instantaneous_time {
            my_size += ::protobuf::rt::uint64_size(32, v);
        }
        if let Some(v) = self.e2e_quality_remote_lifetime_time {
            my_size += ::protobuf::rt::uint64_size(33, v);
        }
        if let Some(v) = self.front_quality_local.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.front_quality_remote.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.front_quality_remote_instantaneous_time {
            my_size += ::protobuf::rt::uint64_size(42, v);
        }
        if let Some(v) = self.front_quality_remote_lifetime_time {
            my_size += ::protobuf::rt::uint64_size(43, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.connection_key.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.connection_id_local {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.identity_local.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.identity_remote.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.connection_state {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.start_time {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.close_time {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.close_reason {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.close_message.as_ref() {
            os.write_string(15, v)?;
        }
        if let Some(v) = self.status_loc_token.as_ref() {
            os.write_string(16, v)?;
        }
        if let Some(v) = self.transport_kind {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.sdrpopid_local.as_ref() {
            os.write_string(21, v)?;
        }
        if let Some(v) = self.sdrpopid_remote.as_ref() {
            os.write_string(22, v)?;
        }
        if let Some(v) = self.address_remote.as_ref() {
            os.write_string(23, v)?;
        }
        if let Some(v) = self.p2p_routing.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        }
        if let Some(v) = self.ping_interior {
            os.write_uint32(25, v)?;
        }
        if let Some(v) = self.ping_remote_front {
            os.write_uint32(26, v)?;
        }
        if let Some(v) = self.ping_default_internet_route {
            os.write_uint32(27, v)?;
        }
        if let Some(v) = self.e2e_quality_local.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(30, v, os)?;
        }
        if let Some(v) = self.e2e_quality_remote.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(31, v, os)?;
        }
        if let Some(v) = self.e2e_quality_remote_instantaneous_time {
            os.write_uint64(32, v)?;
        }
        if let Some(v) = self.e2e_quality_remote_lifetime_time {
            os.write_uint64(33, v)?;
        }
        if let Some(v) = self.front_quality_local.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(40, v, os)?;
        }
        if let Some(v) = self.front_quality_remote.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(41, v, os)?;
        }
        if let Some(v) = self.front_quality_remote_instantaneous_time {
            os.write_uint64(42, v)?;
        }
        if let Some(v) = self.front_quality_remote_lifetime_time {
            os.write_uint64(43, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameNetworkingUI_ConnectionState {
        CGameNetworkingUI_ConnectionState::new()
    }

    fn clear(&mut self) {
        self.connection_key = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.connection_id_local = ::std::option::Option::None;
        self.identity_local = ::std::option::Option::None;
        self.identity_remote = ::std::option::Option::None;
        self.connection_state = ::std::option::Option::None;
        self.start_time = ::std::option::Option::None;
        self.close_time = ::std::option::Option::None;
        self.close_reason = ::std::option::Option::None;
        self.close_message = ::std::option::Option::None;
        self.status_loc_token = ::std::option::Option::None;
        self.transport_kind = ::std::option::Option::None;
        self.sdrpopid_local = ::std::option::Option::None;
        self.sdrpopid_remote = ::std::option::Option::None;
        self.address_remote = ::std::option::Option::None;
        self.p2p_routing.clear();
        self.ping_interior = ::std::option::Option::None;
        self.ping_remote_front = ::std::option::Option::None;
        self.ping_default_internet_route = ::std::option::Option::None;
        self.e2e_quality_local.clear();
        self.e2e_quality_remote.clear();
        self.e2e_quality_remote_instantaneous_time = ::std::option::Option::None;
        self.e2e_quality_remote_lifetime_time = ::std::option::Option::None;
        self.front_quality_local.clear();
        self.front_quality_remote.clear();
        self.front_quality_remote_instantaneous_time = ::std::option::Option::None;
        self.front_quality_remote_lifetime_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameNetworkingUI_ConnectionState {
        static instance: CGameNetworkingUI_ConnectionState = CGameNetworkingUI_ConnectionState {
            connection_key: ::std::option::Option::None,
            appid: ::std::option::Option::None,
            connection_id_local: ::std::option::Option::None,
            identity_local: ::std::option::Option::None,
            identity_remote: ::std::option::Option::None,
            connection_state: ::std::option::Option::None,
            start_time: ::std::option::Option::None,
            close_time: ::std::option::Option::None,
            close_reason: ::std::option::Option::None,
            close_message: ::std::option::Option::None,
            status_loc_token: ::std::option::Option::None,
            transport_kind: ::std::option::Option::None,
            sdrpopid_local: ::std::option::Option::None,
            sdrpopid_remote: ::std::option::Option::None,
            address_remote: ::std::option::Option::None,
            p2p_routing: ::protobuf::MessageField::none(),
            ping_interior: ::std::option::Option::None,
            ping_remote_front: ::std::option::Option::None,
            ping_default_internet_route: ::std::option::Option::None,
            e2e_quality_local: ::protobuf::MessageField::none(),
            e2e_quality_remote: ::protobuf::MessageField::none(),
            e2e_quality_remote_instantaneous_time: ::std::option::Option::None,
            e2e_quality_remote_lifetime_time: ::std::option::Option::None,
            front_quality_local: ::protobuf::MessageField::none(),
            front_quality_remote: ::protobuf::MessageField::none(),
            front_quality_remote_instantaneous_time: ::std::option::Option::None,
            front_quality_remote_lifetime_time: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameNetworkingUI_Message)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameNetworkingUI_Message {
    // message fields
    // @@protoc_insertion_point(field:CGameNetworkingUI_Message.connection_state)
    pub connection_state: ::std::vec::Vec<CGameNetworkingUI_ConnectionState>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameNetworkingUI_Message.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameNetworkingUI_Message {
    fn default() -> &'a CGameNetworkingUI_Message {
        <CGameNetworkingUI_Message as ::protobuf::Message>::default_instance()
    }
}

impl CGameNetworkingUI_Message {
    pub fn new() -> CGameNetworkingUI_Message {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CGameNetworkingUI_Message {
    const NAME: &'static str = "CGameNetworkingUI_Message";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.connection_state.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.connection_state {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.connection_state {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameNetworkingUI_Message {
        CGameNetworkingUI_Message::new()
    }

    fn clear(&mut self) {
        self.connection_state.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameNetworkingUI_Message {
        static instance: CGameNetworkingUI_Message = CGameNetworkingUI_Message {
            connection_state: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameNetworkingUI_ConnectionSummary)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameNetworkingUI_ConnectionSummary {
    // message fields
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionSummary.transport_kind)
    pub transport_kind: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionSummary.connection_state)
    pub connection_state: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionSummary.sdrpop_local)
    pub sdrpop_local: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionSummary.sdrpop_remote)
    pub sdrpop_remote: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionSummary.ping_ms)
    pub ping_ms: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionSummary.packet_loss)
    pub packet_loss: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionSummary.ping_default_internet_route)
    pub ping_default_internet_route: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionSummary.ip_was_shared)
    pub ip_was_shared: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameNetworkingUI_ConnectionSummary.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameNetworkingUI_ConnectionSummary {
    fn default() -> &'a CGameNetworkingUI_ConnectionSummary {
        <CGameNetworkingUI_ConnectionSummary as ::protobuf::Message>::default_instance()
    }
}

impl CGameNetworkingUI_ConnectionSummary {
    pub fn new() -> CGameNetworkingUI_ConnectionSummary {
        ::std::default::Default::default()
    }

    // optional uint32 transport_kind = 1;

    pub fn transport_kind(&self) -> u32 {
        self.transport_kind.unwrap_or(0)
    }

    pub fn clear_transport_kind(&mut self) {
        self.transport_kind = ::std::option::Option::None;
    }

    pub fn has_transport_kind(&self) -> bool {
        self.transport_kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transport_kind(&mut self, v: u32) {
        self.transport_kind = ::std::option::Option::Some(v);
    }

    // optional uint32 connection_state = 8;

    pub fn connection_state(&self) -> u32 {
        self.connection_state.unwrap_or(0)
    }

    pub fn clear_connection_state(&mut self) {
        self.connection_state = ::std::option::Option::None;
    }

    pub fn has_connection_state(&self) -> bool {
        self.connection_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_state(&mut self, v: u32) {
        self.connection_state = ::std::option::Option::Some(v);
    }

    // optional string sdrpop_local = 2;

    pub fn sdrpop_local(&self) -> &str {
        match self.sdrpop_local.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_sdrpop_local(&mut self) {
        self.sdrpop_local = ::std::option::Option::None;
    }

    pub fn has_sdrpop_local(&self) -> bool {
        self.sdrpop_local.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sdrpop_local(&mut self, v: ::std::string::String) {
        self.sdrpop_local = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sdrpop_local(&mut self) -> &mut ::std::string::String {
        if self.sdrpop_local.is_none() {
            self.sdrpop_local = ::std::option::Option::Some(::std::string::String::new());
        }
        self.sdrpop_local.as_mut().unwrap()
    }

    // Take field
    pub fn take_sdrpop_local(&mut self) -> ::std::string::String {
        self.sdrpop_local.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string sdrpop_remote = 3;

    pub fn sdrpop_remote(&self) -> &str {
        match self.sdrpop_remote.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_sdrpop_remote(&mut self) {
        self.sdrpop_remote = ::std::option::Option::None;
    }

    pub fn has_sdrpop_remote(&self) -> bool {
        self.sdrpop_remote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sdrpop_remote(&mut self, v: ::std::string::String) {
        self.sdrpop_remote = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sdrpop_remote(&mut self) -> &mut ::std::string::String {
        if self.sdrpop_remote.is_none() {
            self.sdrpop_remote = ::std::option::Option::Some(::std::string::String::new());
        }
        self.sdrpop_remote.as_mut().unwrap()
    }

    // Take field
    pub fn take_sdrpop_remote(&mut self) -> ::std::string::String {
        self.sdrpop_remote.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 ping_ms = 4;

    pub fn ping_ms(&self) -> u32 {
        self.ping_ms.unwrap_or(0)
    }

    pub fn clear_ping_ms(&mut self) {
        self.ping_ms = ::std::option::Option::None;
    }

    pub fn has_ping_ms(&self) -> bool {
        self.ping_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_ms(&mut self, v: u32) {
        self.ping_ms = ::std::option::Option::Some(v);
    }

    // optional float packet_loss = 5;

    pub fn packet_loss(&self) -> f32 {
        self.packet_loss.unwrap_or(0.)
    }

    pub fn clear_packet_loss(&mut self) {
        self.packet_loss = ::std::option::Option::None;
    }

    pub fn has_packet_loss(&self) -> bool {
        self.packet_loss.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packet_loss(&mut self, v: f32) {
        self.packet_loss = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_default_internet_route = 6;

    pub fn ping_default_internet_route(&self) -> u32 {
        self.ping_default_internet_route.unwrap_or(0)
    }

    pub fn clear_ping_default_internet_route(&mut self) {
        self.ping_default_internet_route = ::std::option::Option::None;
    }

    pub fn has_ping_default_internet_route(&self) -> bool {
        self.ping_default_internet_route.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_default_internet_route(&mut self, v: u32) {
        self.ping_default_internet_route = ::std::option::Option::Some(v);
    }

    // optional bool ip_was_shared = 7;

    pub fn ip_was_shared(&self) -> bool {
        self.ip_was_shared.unwrap_or(false)
    }

    pub fn clear_ip_was_shared(&mut self) {
        self.ip_was_shared = ::std::option::Option::None;
    }

    pub fn has_ip_was_shared(&self) -> bool {
        self.ip_was_shared.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip_was_shared(&mut self, v: bool) {
        self.ip_was_shared = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CGameNetworkingUI_ConnectionSummary {
    const NAME: &'static str = "CGameNetworkingUI_ConnectionSummary";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.transport_kind = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.connection_state = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.sdrpop_local = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.sdrpop_remote = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.ping_ms = ::std::option::Option::Some(is.read_uint32()?);
                },
                45 => {
                    self.packet_loss = ::std::option::Option::Some(is.read_float()?);
                },
                48 => {
                    self.ping_default_internet_route = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.ip_was_shared = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.transport_kind {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.connection_state {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.sdrpop_local.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.sdrpop_remote.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.ping_ms {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.packet_loss {
            my_size += 1 + 4;
        }
        if let Some(v) = self.ping_default_internet_route {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.ip_was_shared {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.transport_kind {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.connection_state {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.sdrpop_local.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.sdrpop_remote.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.ping_ms {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.packet_loss {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.ping_default_internet_route {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.ip_was_shared {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameNetworkingUI_ConnectionSummary {
        CGameNetworkingUI_ConnectionSummary::new()
    }

    fn clear(&mut self) {
        self.transport_kind = ::std::option::Option::None;
        self.connection_state = ::std::option::Option::None;
        self.sdrpop_local = ::std::option::Option::None;
        self.sdrpop_remote = ::std::option::Option::None;
        self.ping_ms = ::std::option::Option::None;
        self.packet_loss = ::std::option::Option::None;
        self.ping_default_internet_route = ::std::option::Option::None;
        self.ip_was_shared = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameNetworkingUI_ConnectionSummary {
        static instance: CGameNetworkingUI_ConnectionSummary = CGameNetworkingUI_ConnectionSummary {
            transport_kind: ::std::option::Option::None,
            connection_state: ::std::option::Option::None,
            sdrpop_local: ::std::option::Option::None,
            sdrpop_remote: ::std::option::Option::None,
            ping_ms: ::std::option::Option::None,
            packet_loss: ::std::option::Option::None,
            ping_default_internet_route: ::std::option::Option::None,
            ip_was_shared: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameNetworkingUI_AppSummary)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameNetworkingUI_AppSummary {
    // message fields
    // @@protoc_insertion_point(field:CGameNetworkingUI_AppSummary.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_AppSummary.ip_was_shared_with_friend)
    pub ip_was_shared_with_friend: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_AppSummary.ip_was_shared_with_nonfriend)
    pub ip_was_shared_with_nonfriend: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_AppSummary.active_connections)
    pub active_connections: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_AppSummary.main_cxn)
    pub main_cxn: ::protobuf::MessageField<CGameNetworkingUI_ConnectionSummary>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameNetworkingUI_AppSummary.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameNetworkingUI_AppSummary {
    fn default() -> &'a CGameNetworkingUI_AppSummary {
        <CGameNetworkingUI_AppSummary as ::protobuf::Message>::default_instance()
    }
}

impl CGameNetworkingUI_AppSummary {
    pub fn new() -> CGameNetworkingUI_AppSummary {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional bool ip_was_shared_with_friend = 10;

    pub fn ip_was_shared_with_friend(&self) -> bool {
        self.ip_was_shared_with_friend.unwrap_or(false)
    }

    pub fn clear_ip_was_shared_with_friend(&mut self) {
        self.ip_was_shared_with_friend = ::std::option::Option::None;
    }

    pub fn has_ip_was_shared_with_friend(&self) -> bool {
        self.ip_was_shared_with_friend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip_was_shared_with_friend(&mut self, v: bool) {
        self.ip_was_shared_with_friend = ::std::option::Option::Some(v);
    }

    // optional bool ip_was_shared_with_nonfriend = 11;

    pub fn ip_was_shared_with_nonfriend(&self) -> bool {
        self.ip_was_shared_with_nonfriend.unwrap_or(false)
    }

    pub fn clear_ip_was_shared_with_nonfriend(&mut self) {
        self.ip_was_shared_with_nonfriend = ::std::option::Option::None;
    }

    pub fn has_ip_was_shared_with_nonfriend(&self) -> bool {
        self.ip_was_shared_with_nonfriend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip_was_shared_with_nonfriend(&mut self, v: bool) {
        self.ip_was_shared_with_nonfriend = ::std::option::Option::Some(v);
    }

    // optional uint32 active_connections = 20;

    pub fn active_connections(&self) -> u32 {
        self.active_connections.unwrap_or(0)
    }

    pub fn clear_active_connections(&mut self) {
        self.active_connections = ::std::option::Option::None;
    }

    pub fn has_active_connections(&self) -> bool {
        self.active_connections.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_connections(&mut self, v: u32) {
        self.active_connections = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CGameNetworkingUI_AppSummary {
    const NAME: &'static str = "CGameNetworkingUI_AppSummary";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.ip_was_shared_with_friend = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.ip_was_shared_with_nonfriend = ::std::option::Option::Some(is.read_bool()?);
                },
                160 => {
                    self.active_connections = ::std::option::Option::Some(is.read_uint32()?);
                },
                242 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.main_cxn)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.ip_was_shared_with_friend {
            my_size += 1 + 1;
        }
        if let Some(v) = self.ip_was_shared_with_nonfriend {
            my_size += 1 + 1;
        }
        if let Some(v) = self.active_connections {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.main_cxn.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.ip_was_shared_with_friend {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.ip_was_shared_with_nonfriend {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.active_connections {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.main_cxn.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(30, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameNetworkingUI_AppSummary {
        CGameNetworkingUI_AppSummary::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.ip_was_shared_with_friend = ::std::option::Option::None;
        self.ip_was_shared_with_nonfriend = ::std::option::Option::None;
        self.active_connections = ::std::option::Option::None;
        self.main_cxn.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameNetworkingUI_AppSummary {
        static instance: CGameNetworkingUI_AppSummary = CGameNetworkingUI_AppSummary {
            appid: ::std::option::Option::None,
            ip_was_shared_with_friend: ::std::option::Option::None,
            ip_was_shared_with_nonfriend: ::std::option::Option::None,
            active_connections: ::std::option::Option::None,
            main_cxn: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}
#[allow(unused_imports)]
use crate::steamnetworkingsockets_messages::*;
#[allow(unused_imports)]
use crate::steamdatagram_messages_sdr::*;
impl crate::RpcMessage for CGameNetworkingUI_GlobalState {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CGameNetworkingUI_ConnectionState {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CGameNetworkingUI_Message {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CGameNetworkingUI_ConnectionSummary {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CGameNetworkingUI_AppSummary {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
