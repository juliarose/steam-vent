// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_store.steamclient.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

#[doc = "Registers a CD key with Steam on the logged in user's account"]
// @@protoc_insertion_point(message:CStore_RegisterCDKey_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_RegisterCDKey_Request {
    // message fields
    // @@protoc_insertion_point(field:CStore_RegisterCDKey_Request.activation_code)
    pub activation_code: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CStore_RegisterCDKey_Request.purchase_platform)
    pub purchase_platform: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CStore_RegisterCDKey_Request.is_request_from_client)
    pub is_request_from_client: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_RegisterCDKey_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_RegisterCDKey_Request {
    fn default() -> &'a CStore_RegisterCDKey_Request {
        <CStore_RegisterCDKey_Request as ::protobuf::Message>::default_instance()
    }
}

impl CStore_RegisterCDKey_Request {
    pub fn new() -> CStore_RegisterCDKey_Request {
        ::std::default::Default::default()
    }

    // optional string activation_code = 1;

    pub fn activation_code(&self) -> &str {
        match self.activation_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_activation_code(&mut self) {
        self.activation_code = ::std::option::Option::None;
    }

    pub fn has_activation_code(&self) -> bool {
        self.activation_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_activation_code(&mut self, v: ::std::string::String) {
        self.activation_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_activation_code(&mut self) -> &mut ::std::string::String {
        if self.activation_code.is_none() {
            self.activation_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.activation_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_activation_code(&mut self) -> ::std::string::String {
        self.activation_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 purchase_platform = 2;

    pub fn purchase_platform(&self) -> i32 {
        self.purchase_platform.unwrap_or(0)
    }

    pub fn clear_purchase_platform(&mut self) {
        self.purchase_platform = ::std::option::Option::None;
    }

    pub fn has_purchase_platform(&self) -> bool {
        self.purchase_platform.is_some()
    }

    // Param is passed by value, moved
    pub fn set_purchase_platform(&mut self, v: i32) {
        self.purchase_platform = ::std::option::Option::Some(v);
    }

    // optional bool is_request_from_client = 3;

    pub fn is_request_from_client(&self) -> bool {
        self.is_request_from_client.unwrap_or(false)
    }

    pub fn clear_is_request_from_client(&mut self) {
        self.is_request_from_client = ::std::option::Option::None;
    }

    pub fn has_is_request_from_client(&self) -> bool {
        self.is_request_from_client.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_request_from_client(&mut self, v: bool) {
        self.is_request_from_client = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CStore_RegisterCDKey_Request {
    const NAME: &'static str = "CStore_RegisterCDKey_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.activation_code = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.purchase_platform = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.is_request_from_client = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.activation_code.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.purchase_platform {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.is_request_from_client {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.activation_code.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.purchase_platform {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.is_request_from_client {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_RegisterCDKey_Request {
        CStore_RegisterCDKey_Request::new()
    }

    fn clear(&mut self) {
        self.activation_code = ::std::option::Option::None;
        self.purchase_platform = ::std::option::Option::None;
        self.is_request_from_client = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_RegisterCDKey_Request {
        static instance: CStore_RegisterCDKey_Request = CStore_RegisterCDKey_Request {
            activation_code: ::std::option::Option::None,
            purchase_platform: ::std::option::Option::None,
            is_request_from_client: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CStore_PurchaseReceiptInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_PurchaseReceiptInfo {
    // message fields
    // @@protoc_insertion_point(field:CStore_PurchaseReceiptInfo.transactionid)
    pub transactionid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CStore_PurchaseReceiptInfo.packageid)
    pub packageid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStore_PurchaseReceiptInfo.purchase_status)
    pub purchase_status: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStore_PurchaseReceiptInfo.result_detail)
    pub result_detail: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStore_PurchaseReceiptInfo.transaction_time)
    pub transaction_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStore_PurchaseReceiptInfo.payment_method)
    pub payment_method: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStore_PurchaseReceiptInfo.base_price)
    pub base_price: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CStore_PurchaseReceiptInfo.total_discount)
    pub total_discount: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CStore_PurchaseReceiptInfo.tax)
    pub tax: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CStore_PurchaseReceiptInfo.shipping)
    pub shipping: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CStore_PurchaseReceiptInfo.currency_code)
    pub currency_code: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStore_PurchaseReceiptInfo.country_code)
    pub country_code: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CStore_PurchaseReceiptInfo.error_headline)
    pub error_headline: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CStore_PurchaseReceiptInfo.error_string)
    pub error_string: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CStore_PurchaseReceiptInfo.error_link_text)
    pub error_link_text: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CStore_PurchaseReceiptInfo.error_link_url)
    pub error_link_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CStore_PurchaseReceiptInfo.error_appid)
    pub error_appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStore_PurchaseReceiptInfo.line_items)
    pub line_items: ::std::vec::Vec<cstore_purchase_receipt_info::LineItem>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_PurchaseReceiptInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_PurchaseReceiptInfo {
    fn default() -> &'a CStore_PurchaseReceiptInfo {
        <CStore_PurchaseReceiptInfo as ::protobuf::Message>::default_instance()
    }
}

impl CStore_PurchaseReceiptInfo {
    pub fn new() -> CStore_PurchaseReceiptInfo {
        ::std::default::Default::default()
    }

    // optional uint64 transactionid = 1;

    pub fn transactionid(&self) -> u64 {
        self.transactionid.unwrap_or(0)
    }

    pub fn clear_transactionid(&mut self) {
        self.transactionid = ::std::option::Option::None;
    }

    pub fn has_transactionid(&self) -> bool {
        self.transactionid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transactionid(&mut self, v: u64) {
        self.transactionid = ::std::option::Option::Some(v);
    }

    // optional uint32 packageid = 2;

    pub fn packageid(&self) -> u32 {
        self.packageid.unwrap_or(0)
    }

    pub fn clear_packageid(&mut self) {
        self.packageid = ::std::option::Option::None;
    }

    pub fn has_packageid(&self) -> bool {
        self.packageid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packageid(&mut self, v: u32) {
        self.packageid = ::std::option::Option::Some(v);
    }

    // optional uint32 purchase_status = 3;

    pub fn purchase_status(&self) -> u32 {
        self.purchase_status.unwrap_or(0)
    }

    pub fn clear_purchase_status(&mut self) {
        self.purchase_status = ::std::option::Option::None;
    }

    pub fn has_purchase_status(&self) -> bool {
        self.purchase_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_purchase_status(&mut self, v: u32) {
        self.purchase_status = ::std::option::Option::Some(v);
    }

    // optional uint32 result_detail = 4;

    pub fn result_detail(&self) -> u32 {
        self.result_detail.unwrap_or(0)
    }

    pub fn clear_result_detail(&mut self) {
        self.result_detail = ::std::option::Option::None;
    }

    pub fn has_result_detail(&self) -> bool {
        self.result_detail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result_detail(&mut self, v: u32) {
        self.result_detail = ::std::option::Option::Some(v);
    }

    // optional uint32 transaction_time = 5;

    pub fn transaction_time(&self) -> u32 {
        self.transaction_time.unwrap_or(0)
    }

    pub fn clear_transaction_time(&mut self) {
        self.transaction_time = ::std::option::Option::None;
    }

    pub fn has_transaction_time(&self) -> bool {
        self.transaction_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transaction_time(&mut self, v: u32) {
        self.transaction_time = ::std::option::Option::Some(v);
    }

    // optional uint32 payment_method = 6;

    pub fn payment_method(&self) -> u32 {
        self.payment_method.unwrap_or(0)
    }

    pub fn clear_payment_method(&mut self) {
        self.payment_method = ::std::option::Option::None;
    }

    pub fn has_payment_method(&self) -> bool {
        self.payment_method.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payment_method(&mut self, v: u32) {
        self.payment_method = ::std::option::Option::Some(v);
    }

    // optional uint64 base_price = 7;

    pub fn base_price(&self) -> u64 {
        self.base_price.unwrap_or(0)
    }

    pub fn clear_base_price(&mut self) {
        self.base_price = ::std::option::Option::None;
    }

    pub fn has_base_price(&self) -> bool {
        self.base_price.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base_price(&mut self, v: u64) {
        self.base_price = ::std::option::Option::Some(v);
    }

    // optional uint64 total_discount = 8;

    pub fn total_discount(&self) -> u64 {
        self.total_discount.unwrap_or(0)
    }

    pub fn clear_total_discount(&mut self) {
        self.total_discount = ::std::option::Option::None;
    }

    pub fn has_total_discount(&self) -> bool {
        self.total_discount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_discount(&mut self, v: u64) {
        self.total_discount = ::std::option::Option::Some(v);
    }

    // optional uint64 tax = 9;

    pub fn tax(&self) -> u64 {
        self.tax.unwrap_or(0)
    }

    pub fn clear_tax(&mut self) {
        self.tax = ::std::option::Option::None;
    }

    pub fn has_tax(&self) -> bool {
        self.tax.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tax(&mut self, v: u64) {
        self.tax = ::std::option::Option::Some(v);
    }

    // optional uint64 shipping = 10;

    pub fn shipping(&self) -> u64 {
        self.shipping.unwrap_or(0)
    }

    pub fn clear_shipping(&mut self) {
        self.shipping = ::std::option::Option::None;
    }

    pub fn has_shipping(&self) -> bool {
        self.shipping.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shipping(&mut self, v: u64) {
        self.shipping = ::std::option::Option::Some(v);
    }

    // optional uint32 currency_code = 11;

    pub fn currency_code(&self) -> u32 {
        self.currency_code.unwrap_or(0)
    }

    pub fn clear_currency_code(&mut self) {
        self.currency_code = ::std::option::Option::None;
    }

    pub fn has_currency_code(&self) -> bool {
        self.currency_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currency_code(&mut self, v: u32) {
        self.currency_code = ::std::option::Option::Some(v);
    }

    // optional string country_code = 12;

    pub fn country_code(&self) -> &str {
        match self.country_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_country_code(&mut self) {
        self.country_code = ::std::option::Option::None;
    }

    pub fn has_country_code(&self) -> bool {
        self.country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country_code(&mut self, v: ::std::string::String) {
        self.country_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_code(&mut self) -> &mut ::std::string::String {
        if self.country_code.is_none() {
            self.country_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_country_code(&mut self) -> ::std::string::String {
        self.country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string error_headline = 13;

    pub fn error_headline(&self) -> &str {
        match self.error_headline.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error_headline(&mut self) {
        self.error_headline = ::std::option::Option::None;
    }

    pub fn has_error_headline(&self) -> bool {
        self.error_headline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_headline(&mut self, v: ::std::string::String) {
        self.error_headline = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_headline(&mut self) -> &mut ::std::string::String {
        if self.error_headline.is_none() {
            self.error_headline = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error_headline.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_headline(&mut self) -> ::std::string::String {
        self.error_headline.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string error_string = 14;

    pub fn error_string(&self) -> &str {
        match self.error_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error_string(&mut self) {
        self.error_string = ::std::option::Option::None;
    }

    pub fn has_error_string(&self) -> bool {
        self.error_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_string(&mut self, v: ::std::string::String) {
        self.error_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_string(&mut self) -> &mut ::std::string::String {
        if self.error_string.is_none() {
            self.error_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_string(&mut self) -> ::std::string::String {
        self.error_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string error_link_text = 15;

    pub fn error_link_text(&self) -> &str {
        match self.error_link_text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error_link_text(&mut self) {
        self.error_link_text = ::std::option::Option::None;
    }

    pub fn has_error_link_text(&self) -> bool {
        self.error_link_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_link_text(&mut self, v: ::std::string::String) {
        self.error_link_text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_link_text(&mut self) -> &mut ::std::string::String {
        if self.error_link_text.is_none() {
            self.error_link_text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error_link_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_link_text(&mut self) -> ::std::string::String {
        self.error_link_text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string error_link_url = 16;

    pub fn error_link_url(&self) -> &str {
        match self.error_link_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error_link_url(&mut self) {
        self.error_link_url = ::std::option::Option::None;
    }

    pub fn has_error_link_url(&self) -> bool {
        self.error_link_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_link_url(&mut self, v: ::std::string::String) {
        self.error_link_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_link_url(&mut self) -> &mut ::std::string::String {
        if self.error_link_url.is_none() {
            self.error_link_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error_link_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_link_url(&mut self) -> ::std::string::String {
        self.error_link_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 error_appid = 17;

    pub fn error_appid(&self) -> u32 {
        self.error_appid.unwrap_or(0)
    }

    pub fn clear_error_appid(&mut self) {
        self.error_appid = ::std::option::Option::None;
    }

    pub fn has_error_appid(&self) -> bool {
        self.error_appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_appid(&mut self, v: u32) {
        self.error_appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CStore_PurchaseReceiptInfo {
    const NAME: &'static str = "CStore_PurchaseReceiptInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.transactionid = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.packageid = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.purchase_status = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.result_detail = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.transaction_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.payment_method = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.base_price = ::std::option::Option::Some(is.read_uint64()?);
                },
                64 => {
                    self.total_discount = ::std::option::Option::Some(is.read_uint64()?);
                },
                72 => {
                    self.tax = ::std::option::Option::Some(is.read_uint64()?);
                },
                80 => {
                    self.shipping = ::std::option::Option::Some(is.read_uint64()?);
                },
                88 => {
                    self.currency_code = ::std::option::Option::Some(is.read_uint32()?);
                },
                98 => {
                    self.country_code = ::std::option::Option::Some(is.read_string()?);
                },
                106 => {
                    self.error_headline = ::std::option::Option::Some(is.read_string()?);
                },
                114 => {
                    self.error_string = ::std::option::Option::Some(is.read_string()?);
                },
                122 => {
                    self.error_link_text = ::std::option::Option::Some(is.read_string()?);
                },
                130 => {
                    self.error_link_url = ::std::option::Option::Some(is.read_string()?);
                },
                136 => {
                    self.error_appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                146 => {
                    self.line_items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.transactionid {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.packageid {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.purchase_status {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.result_detail {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.transaction_time {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.payment_method {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.base_price {
            my_size += ::protobuf::rt::uint64_size(7, v);
        }
        if let Some(v) = self.total_discount {
            my_size += ::protobuf::rt::uint64_size(8, v);
        }
        if let Some(v) = self.tax {
            my_size += ::protobuf::rt::uint64_size(9, v);
        }
        if let Some(v) = self.shipping {
            my_size += ::protobuf::rt::uint64_size(10, v);
        }
        if let Some(v) = self.currency_code {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.country_code.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(v) = self.error_headline.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.error_string.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(v) = self.error_link_text.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.error_link_url.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        if let Some(v) = self.error_appid {
            my_size += ::protobuf::rt::uint32_size(17, v);
        }
        for value in &self.line_items {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.transactionid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.packageid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.purchase_status {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.result_detail {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.transaction_time {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.payment_method {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.base_price {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.total_discount {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.tax {
            os.write_uint64(9, v)?;
        }
        if let Some(v) = self.shipping {
            os.write_uint64(10, v)?;
        }
        if let Some(v) = self.currency_code {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.country_code.as_ref() {
            os.write_string(12, v)?;
        }
        if let Some(v) = self.error_headline.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.error_string.as_ref() {
            os.write_string(14, v)?;
        }
        if let Some(v) = self.error_link_text.as_ref() {
            os.write_string(15, v)?;
        }
        if let Some(v) = self.error_link_url.as_ref() {
            os.write_string(16, v)?;
        }
        if let Some(v) = self.error_appid {
            os.write_uint32(17, v)?;
        }
        for v in &self.line_items {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_PurchaseReceiptInfo {
        CStore_PurchaseReceiptInfo::new()
    }

    fn clear(&mut self) {
        self.transactionid = ::std::option::Option::None;
        self.packageid = ::std::option::Option::None;
        self.purchase_status = ::std::option::Option::None;
        self.result_detail = ::std::option::Option::None;
        self.transaction_time = ::std::option::Option::None;
        self.payment_method = ::std::option::Option::None;
        self.base_price = ::std::option::Option::None;
        self.total_discount = ::std::option::Option::None;
        self.tax = ::std::option::Option::None;
        self.shipping = ::std::option::Option::None;
        self.currency_code = ::std::option::Option::None;
        self.country_code = ::std::option::Option::None;
        self.error_headline = ::std::option::Option::None;
        self.error_string = ::std::option::Option::None;
        self.error_link_text = ::std::option::Option::None;
        self.error_link_url = ::std::option::Option::None;
        self.error_appid = ::std::option::Option::None;
        self.line_items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_PurchaseReceiptInfo {
        static instance: CStore_PurchaseReceiptInfo = CStore_PurchaseReceiptInfo {
            transactionid: ::std::option::Option::None,
            packageid: ::std::option::Option::None,
            purchase_status: ::std::option::Option::None,
            result_detail: ::std::option::Option::None,
            transaction_time: ::std::option::Option::None,
            payment_method: ::std::option::Option::None,
            base_price: ::std::option::Option::None,
            total_discount: ::std::option::Option::None,
            tax: ::std::option::Option::None,
            shipping: ::std::option::Option::None,
            currency_code: ::std::option::Option::None,
            country_code: ::std::option::Option::None,
            error_headline: ::std::option::Option::None,
            error_string: ::std::option::Option::None,
            error_link_text: ::std::option::Option::None,
            error_link_url: ::std::option::Option::None,
            error_appid: ::std::option::Option::None,
            line_items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CStore_PurchaseReceiptInfo`
pub mod cstore_purchase_receipt_info {
    // @@protoc_insertion_point(message:CStore_PurchaseReceiptInfo.LineItem)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LineItem {
        // message fields
        // @@protoc_insertion_point(field:CStore_PurchaseReceiptInfo.LineItem.packageid)
        pub packageid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CStore_PurchaseReceiptInfo.LineItem.appid)
        pub appid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CStore_PurchaseReceiptInfo.LineItem.line_item_description)
        pub line_item_description: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CStore_PurchaseReceiptInfo.LineItem.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LineItem {
        fn default() -> &'a LineItem {
            <LineItem as ::protobuf::Message>::default_instance()
        }
    }

    impl LineItem {
        pub fn new() -> LineItem {
            ::std::default::Default::default()
        }

        // optional uint32 packageid = 1;

        pub fn packageid(&self) -> u32 {
            self.packageid.unwrap_or(0)
        }

        pub fn clear_packageid(&mut self) {
            self.packageid = ::std::option::Option::None;
        }

        pub fn has_packageid(&self) -> bool {
            self.packageid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_packageid(&mut self, v: u32) {
            self.packageid = ::std::option::Option::Some(v);
        }

        // optional uint32 appid = 2;

        pub fn appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }

        // optional string line_item_description = 3;

        pub fn line_item_description(&self) -> &str {
            match self.line_item_description.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_line_item_description(&mut self) {
            self.line_item_description = ::std::option::Option::None;
        }

        pub fn has_line_item_description(&self) -> bool {
            self.line_item_description.is_some()
        }

        // Param is passed by value, moved
        pub fn set_line_item_description(&mut self, v: ::std::string::String) {
            self.line_item_description = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_line_item_description(&mut self) -> &mut ::std::string::String {
            if self.line_item_description.is_none() {
                self.line_item_description = ::std::option::Option::Some(::std::string::String::new());
            }
            self.line_item_description.as_mut().unwrap()
        }

        // Take field
        pub fn take_line_item_description(&mut self) -> ::std::string::String {
            self.line_item_description.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::protobuf::Message for LineItem {
        const NAME: &'static str = "LineItem";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.packageid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.line_item_description = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.packageid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.appid {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.line_item_description.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.packageid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.appid {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.line_item_description.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LineItem {
            LineItem::new()
        }

        fn clear(&mut self) {
            self.packageid = ::std::option::Option::None;
            self.appid = ::std::option::Option::None;
            self.line_item_description = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LineItem {
            static instance: LineItem = LineItem {
                packageid: ::std::option::Option::None,
                appid: ::std::option::Option::None,
                line_item_description: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CStore_RegisterCDKey_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_RegisterCDKey_Response {
    // message fields
    // @@protoc_insertion_point(field:CStore_RegisterCDKey_Response.purchase_result_details)
    pub purchase_result_details: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CStore_RegisterCDKey_Response.purchase_receipt_info)
    pub purchase_receipt_info: ::protobuf::MessageField<CStore_PurchaseReceiptInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_RegisterCDKey_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_RegisterCDKey_Response {
    fn default() -> &'a CStore_RegisterCDKey_Response {
        <CStore_RegisterCDKey_Response as ::protobuf::Message>::default_instance()
    }
}

impl CStore_RegisterCDKey_Response {
    pub fn new() -> CStore_RegisterCDKey_Response {
        ::std::default::Default::default()
    }

    // optional int32 purchase_result_details = 1;

    pub fn purchase_result_details(&self) -> i32 {
        self.purchase_result_details.unwrap_or(0)
    }

    pub fn clear_purchase_result_details(&mut self) {
        self.purchase_result_details = ::std::option::Option::None;
    }

    pub fn has_purchase_result_details(&self) -> bool {
        self.purchase_result_details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_purchase_result_details(&mut self, v: i32) {
        self.purchase_result_details = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CStore_RegisterCDKey_Response {
    const NAME: &'static str = "CStore_RegisterCDKey_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.purchase_result_details = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.purchase_receipt_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.purchase_result_details {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.purchase_receipt_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.purchase_result_details {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.purchase_receipt_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_RegisterCDKey_Response {
        CStore_RegisterCDKey_Response::new()
    }

    fn clear(&mut self) {
        self.purchase_result_details = ::std::option::Option::None;
        self.purchase_receipt_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_RegisterCDKey_Response {
        static instance: CStore_RegisterCDKey_Response = CStore_RegisterCDKey_Response {
            purchase_result_details: ::std::option::Option::None,
            purchase_receipt_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Get all whitelisted tags, with localized names."]
// @@protoc_insertion_point(message:CStore_GetMostPopularTags_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_GetMostPopularTags_Request {
    // message fields
    // @@protoc_insertion_point(field:CStore_GetMostPopularTags_Request.language)
    pub language: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_GetMostPopularTags_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_GetMostPopularTags_Request {
    fn default() -> &'a CStore_GetMostPopularTags_Request {
        <CStore_GetMostPopularTags_Request as ::protobuf::Message>::default_instance()
    }
}

impl CStore_GetMostPopularTags_Request {
    pub fn new() -> CStore_GetMostPopularTags_Request {
        ::std::default::Default::default()
    }

    // optional string language = 1;

    pub fn language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language = ::std::option::Option::Some(::std::string::String::new());
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CStore_GetMostPopularTags_Request {
    const NAME: &'static str = "CStore_GetMostPopularTags_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.language = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.language.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.language.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_GetMostPopularTags_Request {
        CStore_GetMostPopularTags_Request::new()
    }

    fn clear(&mut self) {
        self.language = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_GetMostPopularTags_Request {
        static instance: CStore_GetMostPopularTags_Request = CStore_GetMostPopularTags_Request {
            language: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CStore_GetMostPopularTags_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_GetMostPopularTags_Response {
    // message fields
    // @@protoc_insertion_point(field:CStore_GetMostPopularTags_Response.tags)
    pub tags: ::std::vec::Vec<cstore_get_most_popular_tags_response::Tag>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_GetMostPopularTags_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_GetMostPopularTags_Response {
    fn default() -> &'a CStore_GetMostPopularTags_Response {
        <CStore_GetMostPopularTags_Response as ::protobuf::Message>::default_instance()
    }
}

impl CStore_GetMostPopularTags_Response {
    pub fn new() -> CStore_GetMostPopularTags_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CStore_GetMostPopularTags_Response {
    const NAME: &'static str = "CStore_GetMostPopularTags_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.tags.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.tags {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.tags {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_GetMostPopularTags_Response {
        CStore_GetMostPopularTags_Response::new()
    }

    fn clear(&mut self) {
        self.tags.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_GetMostPopularTags_Response {
        static instance: CStore_GetMostPopularTags_Response = CStore_GetMostPopularTags_Response {
            tags: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CStore_GetMostPopularTags_Response`
pub mod cstore_get_most_popular_tags_response {
    // @@protoc_insertion_point(message:CStore_GetMostPopularTags_Response.Tag)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Tag {
        // message fields
        // @@protoc_insertion_point(field:CStore_GetMostPopularTags_Response.Tag.tagid)
        pub tagid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CStore_GetMostPopularTags_Response.Tag.name)
        pub name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CStore_GetMostPopularTags_Response.Tag.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Tag {
        fn default() -> &'a Tag {
            <Tag as ::protobuf::Message>::default_instance()
        }
    }

    impl Tag {
        pub fn new() -> Tag {
            ::std::default::Default::default()
        }

        // optional uint32 tagid = 1;

        pub fn tagid(&self) -> u32 {
            self.tagid.unwrap_or(0)
        }

        pub fn clear_tagid(&mut self) {
            self.tagid = ::std::option::Option::None;
        }

        pub fn has_tagid(&self) -> bool {
            self.tagid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tagid(&mut self, v: u32) {
            self.tagid = ::std::option::Option::Some(v);
        }

        // optional string name = 2;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::protobuf::Message for Tag {
        const NAME: &'static str = "Tag";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.tagid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.tagid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.tagid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Tag {
            Tag::new()
        }

        fn clear(&mut self) {
            self.tagid = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Tag {
            static instance: Tag = Tag {
                tagid: ::std::option::Option::None,
                name: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

#[doc = "Gets tag names in a different language"]
// @@protoc_insertion_point(message:CStore_GetLocalizedNameForTags_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_GetLocalizedNameForTags_Request {
    // message fields
    // @@protoc_insertion_point(field:CStore_GetLocalizedNameForTags_Request.language)
    pub language: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CStore_GetLocalizedNameForTags_Request.tagids)
    pub tagids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_GetLocalizedNameForTags_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_GetLocalizedNameForTags_Request {
    fn default() -> &'a CStore_GetLocalizedNameForTags_Request {
        <CStore_GetLocalizedNameForTags_Request as ::protobuf::Message>::default_instance()
    }
}

impl CStore_GetLocalizedNameForTags_Request {
    pub fn new() -> CStore_GetLocalizedNameForTags_Request {
        ::std::default::Default::default()
    }

    // optional string language = 1;

    pub fn language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language = ::std::option::Option::Some(::std::string::String::new());
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CStore_GetLocalizedNameForTags_Request {
    const NAME: &'static str = "CStore_GetLocalizedNameForTags_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.language = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.tagids)?;
                },
                16 => {
                    self.tagids.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.language.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.tagids {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.language.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.tagids {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_GetLocalizedNameForTags_Request {
        CStore_GetLocalizedNameForTags_Request::new()
    }

    fn clear(&mut self) {
        self.language = ::std::option::Option::None;
        self.tagids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_GetLocalizedNameForTags_Request {
        static instance: CStore_GetLocalizedNameForTags_Request = CStore_GetLocalizedNameForTags_Request {
            language: ::std::option::Option::None,
            tagids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CStore_GetLocalizedNameForTags_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_GetLocalizedNameForTags_Response {
    // message fields
    // @@protoc_insertion_point(field:CStore_GetLocalizedNameForTags_Response.tags)
    pub tags: ::std::vec::Vec<cstore_get_localized_name_for_tags_response::Tag>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_GetLocalizedNameForTags_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_GetLocalizedNameForTags_Response {
    fn default() -> &'a CStore_GetLocalizedNameForTags_Response {
        <CStore_GetLocalizedNameForTags_Response as ::protobuf::Message>::default_instance()
    }
}

impl CStore_GetLocalizedNameForTags_Response {
    pub fn new() -> CStore_GetLocalizedNameForTags_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CStore_GetLocalizedNameForTags_Response {
    const NAME: &'static str = "CStore_GetLocalizedNameForTags_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.tags.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.tags {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.tags {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_GetLocalizedNameForTags_Response {
        CStore_GetLocalizedNameForTags_Response::new()
    }

    fn clear(&mut self) {
        self.tags.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_GetLocalizedNameForTags_Response {
        static instance: CStore_GetLocalizedNameForTags_Response = CStore_GetLocalizedNameForTags_Response {
            tags: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CStore_GetLocalizedNameForTags_Response`
pub mod cstore_get_localized_name_for_tags_response {
    // @@protoc_insertion_point(message:CStore_GetLocalizedNameForTags_Response.Tag)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Tag {
        // message fields
        // @@protoc_insertion_point(field:CStore_GetLocalizedNameForTags_Response.Tag.tagid)
        pub tagid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CStore_GetLocalizedNameForTags_Response.Tag.english_name)
        pub english_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CStore_GetLocalizedNameForTags_Response.Tag.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CStore_GetLocalizedNameForTags_Response.Tag.normalized_name)
        pub normalized_name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CStore_GetLocalizedNameForTags_Response.Tag.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Tag {
        fn default() -> &'a Tag {
            <Tag as ::protobuf::Message>::default_instance()
        }
    }

    impl Tag {
        pub fn new() -> Tag {
            ::std::default::Default::default()
        }

        // optional uint32 tagid = 1;

        pub fn tagid(&self) -> u32 {
            self.tagid.unwrap_or(0)
        }

        pub fn clear_tagid(&mut self) {
            self.tagid = ::std::option::Option::None;
        }

        pub fn has_tagid(&self) -> bool {
            self.tagid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tagid(&mut self, v: u32) {
            self.tagid = ::std::option::Option::Some(v);
        }

        // optional string english_name = 2;

        pub fn english_name(&self) -> &str {
            match self.english_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_english_name(&mut self) {
            self.english_name = ::std::option::Option::None;
        }

        pub fn has_english_name(&self) -> bool {
            self.english_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_english_name(&mut self, v: ::std::string::String) {
            self.english_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_english_name(&mut self) -> &mut ::std::string::String {
            if self.english_name.is_none() {
                self.english_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.english_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_english_name(&mut self) -> ::std::string::String {
            self.english_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string name = 3;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string normalized_name = 4;

        pub fn normalized_name(&self) -> &str {
            match self.normalized_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_normalized_name(&mut self) {
            self.normalized_name = ::std::option::Option::None;
        }

        pub fn has_normalized_name(&self) -> bool {
            self.normalized_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_normalized_name(&mut self, v: ::std::string::String) {
            self.normalized_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_normalized_name(&mut self) -> &mut ::std::string::String {
            if self.normalized_name.is_none() {
                self.normalized_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.normalized_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_normalized_name(&mut self) -> ::std::string::String {
            self.normalized_name.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::protobuf::Message for Tag {
        const NAME: &'static str = "Tag";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.tagid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.english_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    34 => {
                        self.normalized_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.tagid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.english_name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.normalized_name.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.tagid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.english_name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.normalized_name.as_ref() {
                os.write_string(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Tag {
            Tag::new()
        }

        fn clear(&mut self) {
            self.tagid = ::std::option::Option::None;
            self.english_name = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.normalized_name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Tag {
            static instance: Tag = Tag {
                tagid: ::std::option::Option::None,
                english_name: ::std::option::Option::None,
                name: ::std::option::Option::None,
                normalized_name: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

#[doc = "Get the list of tags, localized"]
// @@protoc_insertion_point(message:CStore_GetTagList_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_GetTagList_Request {
    // message fields
    // @@protoc_insertion_point(field:CStore_GetTagList_Request.language)
    pub language: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CStore_GetTagList_Request.have_version_hash)
    pub have_version_hash: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_GetTagList_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_GetTagList_Request {
    fn default() -> &'a CStore_GetTagList_Request {
        <CStore_GetTagList_Request as ::protobuf::Message>::default_instance()
    }
}

impl CStore_GetTagList_Request {
    pub fn new() -> CStore_GetTagList_Request {
        ::std::default::Default::default()
    }

    // optional string language = 1;

    pub fn language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language = ::std::option::Option::Some(::std::string::String::new());
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string have_version_hash = 2;

    pub fn have_version_hash(&self) -> &str {
        match self.have_version_hash.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_have_version_hash(&mut self) {
        self.have_version_hash = ::std::option::Option::None;
    }

    pub fn has_have_version_hash(&self) -> bool {
        self.have_version_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_have_version_hash(&mut self, v: ::std::string::String) {
        self.have_version_hash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_have_version_hash(&mut self) -> &mut ::std::string::String {
        if self.have_version_hash.is_none() {
            self.have_version_hash = ::std::option::Option::Some(::std::string::String::new());
        }
        self.have_version_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_have_version_hash(&mut self) -> ::std::string::String {
        self.have_version_hash.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CStore_GetTagList_Request {
    const NAME: &'static str = "CStore_GetTagList_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.language = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.have_version_hash = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.language.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.have_version_hash.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.language.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.have_version_hash.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_GetTagList_Request {
        CStore_GetTagList_Request::new()
    }

    fn clear(&mut self) {
        self.language = ::std::option::Option::None;
        self.have_version_hash = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_GetTagList_Request {
        static instance: CStore_GetTagList_Request = CStore_GetTagList_Request {
            language: ::std::option::Option::None,
            have_version_hash: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CStore_GetTagList_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_GetTagList_Response {
    // message fields
    // @@protoc_insertion_point(field:CStore_GetTagList_Response.version_hash)
    pub version_hash: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CStore_GetTagList_Response.tags)
    pub tags: ::std::vec::Vec<cstore_get_tag_list_response::Tag>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_GetTagList_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_GetTagList_Response {
    fn default() -> &'a CStore_GetTagList_Response {
        <CStore_GetTagList_Response as ::protobuf::Message>::default_instance()
    }
}

impl CStore_GetTagList_Response {
    pub fn new() -> CStore_GetTagList_Response {
        ::std::default::Default::default()
    }

    // optional string version_hash = 1;

    pub fn version_hash(&self) -> &str {
        match self.version_hash.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_version_hash(&mut self) {
        self.version_hash = ::std::option::Option::None;
    }

    pub fn has_version_hash(&self) -> bool {
        self.version_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version_hash(&mut self, v: ::std::string::String) {
        self.version_hash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_hash(&mut self) -> &mut ::std::string::String {
        if self.version_hash.is_none() {
            self.version_hash = ::std::option::Option::Some(::std::string::String::new());
        }
        self.version_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_version_hash(&mut self) -> ::std::string::String {
        self.version_hash.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CStore_GetTagList_Response {
    const NAME: &'static str = "CStore_GetTagList_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.version_hash = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.tags.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version_hash.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.tags {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version_hash.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.tags {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_GetTagList_Response {
        CStore_GetTagList_Response::new()
    }

    fn clear(&mut self) {
        self.version_hash = ::std::option::Option::None;
        self.tags.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_GetTagList_Response {
        static instance: CStore_GetTagList_Response = CStore_GetTagList_Response {
            version_hash: ::std::option::Option::None,
            tags: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CStore_GetTagList_Response`
pub mod cstore_get_tag_list_response {
    // @@protoc_insertion_point(message:CStore_GetTagList_Response.Tag)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Tag {
        // message fields
        // @@protoc_insertion_point(field:CStore_GetTagList_Response.Tag.tagid)
        pub tagid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CStore_GetTagList_Response.Tag.name)
        pub name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CStore_GetTagList_Response.Tag.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Tag {
        fn default() -> &'a Tag {
            <Tag as ::protobuf::Message>::default_instance()
        }
    }

    impl Tag {
        pub fn new() -> Tag {
            ::std::default::Default::default()
        }

        // optional uint32 tagid = 1;

        pub fn tagid(&self) -> u32 {
            self.tagid.unwrap_or(0)
        }

        pub fn clear_tagid(&mut self) {
            self.tagid = ::std::option::Option::None;
        }

        pub fn has_tagid(&self) -> bool {
            self.tagid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tagid(&mut self, v: u32) {
            self.tagid = ::std::option::Option::Some(v);
        }

        // optional string name = 2;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::protobuf::Message for Tag {
        const NAME: &'static str = "Tag";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.tagid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.tagid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.tagid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Tag {
            Tag::new()
        }

        fn clear(&mut self) {
            self.tagid = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Tag {
            static instance: Tag = Tag {
                tagid: ::std::option::Option::None,
                name: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CStoreDiscoveryQueueSettings)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStoreDiscoveryQueueSettings {
    // message fields
    // @@protoc_insertion_point(field:CStoreDiscoveryQueueSettings.os_win)
    pub os_win: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStoreDiscoveryQueueSettings.os_mac)
    pub os_mac: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStoreDiscoveryQueueSettings.os_linux)
    pub os_linux: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStoreDiscoveryQueueSettings.full_controller_support)
    pub full_controller_support: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStoreDiscoveryQueueSettings.native_steam_controller)
    pub native_steam_controller: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStoreDiscoveryQueueSettings.include_coming_soon)
    pub include_coming_soon: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStoreDiscoveryQueueSettings.excluded_tagids)
    pub excluded_tagids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CStoreDiscoveryQueueSettings.exclude_early_access)
    pub exclude_early_access: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStoreDiscoveryQueueSettings.exclude_videos)
    pub exclude_videos: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStoreDiscoveryQueueSettings.exclude_software)
    pub exclude_software: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStoreDiscoveryQueueSettings.exclude_dlc)
    pub exclude_dlc: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStoreDiscoveryQueueSettings.exclude_soundtracks)
    pub exclude_soundtracks: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStoreDiscoveryQueueSettings.featured_tagids)
    pub featured_tagids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CStoreDiscoveryQueueSettings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStoreDiscoveryQueueSettings {
    fn default() -> &'a CStoreDiscoveryQueueSettings {
        <CStoreDiscoveryQueueSettings as ::protobuf::Message>::default_instance()
    }
}

impl CStoreDiscoveryQueueSettings {
    pub fn new() -> CStoreDiscoveryQueueSettings {
        ::std::default::Default::default()
    }

    // optional bool os_win = 4;

    pub fn os_win(&self) -> bool {
        self.os_win.unwrap_or(false)
    }

    pub fn clear_os_win(&mut self) {
        self.os_win = ::std::option::Option::None;
    }

    pub fn has_os_win(&self) -> bool {
        self.os_win.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os_win(&mut self, v: bool) {
        self.os_win = ::std::option::Option::Some(v);
    }

    // optional bool os_mac = 5;

    pub fn os_mac(&self) -> bool {
        self.os_mac.unwrap_or(false)
    }

    pub fn clear_os_mac(&mut self) {
        self.os_mac = ::std::option::Option::None;
    }

    pub fn has_os_mac(&self) -> bool {
        self.os_mac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os_mac(&mut self, v: bool) {
        self.os_mac = ::std::option::Option::Some(v);
    }

    // optional bool os_linux = 6;

    pub fn os_linux(&self) -> bool {
        self.os_linux.unwrap_or(false)
    }

    pub fn clear_os_linux(&mut self) {
        self.os_linux = ::std::option::Option::None;
    }

    pub fn has_os_linux(&self) -> bool {
        self.os_linux.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os_linux(&mut self, v: bool) {
        self.os_linux = ::std::option::Option::Some(v);
    }

    // optional bool full_controller_support = 7;

    pub fn full_controller_support(&self) -> bool {
        self.full_controller_support.unwrap_or(false)
    }

    pub fn clear_full_controller_support(&mut self) {
        self.full_controller_support = ::std::option::Option::None;
    }

    pub fn has_full_controller_support(&self) -> bool {
        self.full_controller_support.is_some()
    }

    // Param is passed by value, moved
    pub fn set_full_controller_support(&mut self, v: bool) {
        self.full_controller_support = ::std::option::Option::Some(v);
    }

    // optional bool native_steam_controller = 8;

    pub fn native_steam_controller(&self) -> bool {
        self.native_steam_controller.unwrap_or(false)
    }

    pub fn clear_native_steam_controller(&mut self) {
        self.native_steam_controller = ::std::option::Option::None;
    }

    pub fn has_native_steam_controller(&self) -> bool {
        self.native_steam_controller.is_some()
    }

    // Param is passed by value, moved
    pub fn set_native_steam_controller(&mut self, v: bool) {
        self.native_steam_controller = ::std::option::Option::Some(v);
    }

    // optional bool include_coming_soon = 9;

    pub fn include_coming_soon(&self) -> bool {
        self.include_coming_soon.unwrap_or(false)
    }

    pub fn clear_include_coming_soon(&mut self) {
        self.include_coming_soon = ::std::option::Option::None;
    }

    pub fn has_include_coming_soon(&self) -> bool {
        self.include_coming_soon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_coming_soon(&mut self, v: bool) {
        self.include_coming_soon = ::std::option::Option::Some(v);
    }

    // optional bool exclude_early_access = 11;

    pub fn exclude_early_access(&self) -> bool {
        self.exclude_early_access.unwrap_or(false)
    }

    pub fn clear_exclude_early_access(&mut self) {
        self.exclude_early_access = ::std::option::Option::None;
    }

    pub fn has_exclude_early_access(&self) -> bool {
        self.exclude_early_access.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exclude_early_access(&mut self, v: bool) {
        self.exclude_early_access = ::std::option::Option::Some(v);
    }

    // optional bool exclude_videos = 12;

    pub fn exclude_videos(&self) -> bool {
        self.exclude_videos.unwrap_or(false)
    }

    pub fn clear_exclude_videos(&mut self) {
        self.exclude_videos = ::std::option::Option::None;
    }

    pub fn has_exclude_videos(&self) -> bool {
        self.exclude_videos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exclude_videos(&mut self, v: bool) {
        self.exclude_videos = ::std::option::Option::Some(v);
    }

    // optional bool exclude_software = 13;

    pub fn exclude_software(&self) -> bool {
        self.exclude_software.unwrap_or(false)
    }

    pub fn clear_exclude_software(&mut self) {
        self.exclude_software = ::std::option::Option::None;
    }

    pub fn has_exclude_software(&self) -> bool {
        self.exclude_software.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exclude_software(&mut self, v: bool) {
        self.exclude_software = ::std::option::Option::Some(v);
    }

    // optional bool exclude_dlc = 14;

    pub fn exclude_dlc(&self) -> bool {
        self.exclude_dlc.unwrap_or(false)
    }

    pub fn clear_exclude_dlc(&mut self) {
        self.exclude_dlc = ::std::option::Option::None;
    }

    pub fn has_exclude_dlc(&self) -> bool {
        self.exclude_dlc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exclude_dlc(&mut self, v: bool) {
        self.exclude_dlc = ::std::option::Option::Some(v);
    }

    // optional bool exclude_soundtracks = 15;

    pub fn exclude_soundtracks(&self) -> bool {
        self.exclude_soundtracks.unwrap_or(false)
    }

    pub fn clear_exclude_soundtracks(&mut self) {
        self.exclude_soundtracks = ::std::option::Option::None;
    }

    pub fn has_exclude_soundtracks(&self) -> bool {
        self.exclude_soundtracks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exclude_soundtracks(&mut self, v: bool) {
        self.exclude_soundtracks = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CStoreDiscoveryQueueSettings {
    const NAME: &'static str = "CStoreDiscoveryQueueSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                32 => {
                    self.os_win = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.os_mac = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.os_linux = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.full_controller_support = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.native_steam_controller = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.include_coming_soon = ::std::option::Option::Some(is.read_bool()?);
                },
                82 => {
                    is.read_repeated_packed_uint32_into(&mut self.excluded_tagids)?;
                },
                80 => {
                    self.excluded_tagids.push(is.read_uint32()?);
                },
                88 => {
                    self.exclude_early_access = ::std::option::Option::Some(is.read_bool()?);
                },
                96 => {
                    self.exclude_videos = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.exclude_software = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.exclude_dlc = ::std::option::Option::Some(is.read_bool()?);
                },
                120 => {
                    self.exclude_soundtracks = ::std::option::Option::Some(is.read_bool()?);
                },
                130 => {
                    is.read_repeated_packed_uint32_into(&mut self.featured_tagids)?;
                },
                128 => {
                    self.featured_tagids.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.os_win {
            my_size += 1 + 1;
        }
        if let Some(v) = self.os_mac {
            my_size += 1 + 1;
        }
        if let Some(v) = self.os_linux {
            my_size += 1 + 1;
        }
        if let Some(v) = self.full_controller_support {
            my_size += 1 + 1;
        }
        if let Some(v) = self.native_steam_controller {
            my_size += 1 + 1;
        }
        if let Some(v) = self.include_coming_soon {
            my_size += 1 + 1;
        }
        for value in &self.excluded_tagids {
            my_size += ::protobuf::rt::uint32_size(10, *value);
        };
        if let Some(v) = self.exclude_early_access {
            my_size += 1 + 1;
        }
        if let Some(v) = self.exclude_videos {
            my_size += 1 + 1;
        }
        if let Some(v) = self.exclude_software {
            my_size += 1 + 1;
        }
        if let Some(v) = self.exclude_dlc {
            my_size += 1 + 1;
        }
        if let Some(v) = self.exclude_soundtracks {
            my_size += 1 + 1;
        }
        for value in &self.featured_tagids {
            my_size += ::protobuf::rt::uint32_size(16, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.os_win {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.os_mac {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.os_linux {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.full_controller_support {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.native_steam_controller {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.include_coming_soon {
            os.write_bool(9, v)?;
        }
        for v in &self.excluded_tagids {
            os.write_uint32(10, *v)?;
        };
        if let Some(v) = self.exclude_early_access {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.exclude_videos {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.exclude_software {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.exclude_dlc {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.exclude_soundtracks {
            os.write_bool(15, v)?;
        }
        for v in &self.featured_tagids {
            os.write_uint32(16, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStoreDiscoveryQueueSettings {
        CStoreDiscoveryQueueSettings::new()
    }

    fn clear(&mut self) {
        self.os_win = ::std::option::Option::None;
        self.os_mac = ::std::option::Option::None;
        self.os_linux = ::std::option::Option::None;
        self.full_controller_support = ::std::option::Option::None;
        self.native_steam_controller = ::std::option::Option::None;
        self.include_coming_soon = ::std::option::Option::None;
        self.excluded_tagids.clear();
        self.exclude_early_access = ::std::option::Option::None;
        self.exclude_videos = ::std::option::Option::None;
        self.exclude_software = ::std::option::Option::None;
        self.exclude_dlc = ::std::option::Option::None;
        self.exclude_soundtracks = ::std::option::Option::None;
        self.featured_tagids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStoreDiscoveryQueueSettings {
        static instance: CStoreDiscoveryQueueSettings = CStoreDiscoveryQueueSettings {
            os_win: ::std::option::Option::None,
            os_mac: ::std::option::Option::None,
            os_linux: ::std::option::Option::None,
            full_controller_support: ::std::option::Option::None,
            native_steam_controller: ::std::option::Option::None,
            include_coming_soon: ::std::option::Option::None,
            excluded_tagids: ::std::vec::Vec::new(),
            exclude_early_access: ::std::option::Option::None,
            exclude_videos: ::std::option::Option::None,
            exclude_software: ::std::option::Option::None,
            exclude_dlc: ::std::option::Option::None,
            exclude_soundtracks: ::std::option::Option::None,
            featured_tagids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Get a list of games for the user to explore on the store."]
// @@protoc_insertion_point(message:CStore_GetDiscoveryQueue_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_GetDiscoveryQueue_Request {
    // message fields
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueue_Request.queue_type)
    pub queue_type: ::std::option::Option<::protobuf::EnumOrUnknown<EStoreDiscoveryQueueType>>,
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueue_Request.country_code)
    pub country_code: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueue_Request.rebuild_queue)
    pub rebuild_queue: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueue_Request.settings_changed)
    pub settings_changed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueue_Request.settings)
    pub settings: ::protobuf::MessageField<CStoreDiscoveryQueueSettings>,
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueue_Request.rebuild_queue_if_stale)
    pub rebuild_queue_if_stale: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueue_Request.ignore_user_preferences)
    pub ignore_user_preferences: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueue_Request.no_experimental_results)
    pub no_experimental_results: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueue_Request.experimental_cohort)
    pub experimental_cohort: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueue_Request.debug_get_solr_query)
    pub debug_get_solr_query: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueue_Request.store_page_filter)
    pub store_page_filter: ::protobuf::MessageField<super::contenthubs::CStorePageFilter>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_GetDiscoveryQueue_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_GetDiscoveryQueue_Request {
    fn default() -> &'a CStore_GetDiscoveryQueue_Request {
        <CStore_GetDiscoveryQueue_Request as ::protobuf::Message>::default_instance()
    }
}

impl CStore_GetDiscoveryQueue_Request {
    pub fn new() -> CStore_GetDiscoveryQueue_Request {
        ::std::default::Default::default()
    }

    // optional .EStoreDiscoveryQueueType queue_type = 1;

    pub fn queue_type(&self) -> EStoreDiscoveryQueueType {
        match self.queue_type {
            Some(e) => e.enum_value_or(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeNew),
            None => EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeNew,
        }
    }

    pub fn clear_queue_type(&mut self) {
        self.queue_type = ::std::option::Option::None;
    }

    pub fn has_queue_type(&self) -> bool {
        self.queue_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queue_type(&mut self, v: EStoreDiscoveryQueueType) {
        self.queue_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string country_code = 2;

    pub fn country_code(&self) -> &str {
        match self.country_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_country_code(&mut self) {
        self.country_code = ::std::option::Option::None;
    }

    pub fn has_country_code(&self) -> bool {
        self.country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country_code(&mut self, v: ::std::string::String) {
        self.country_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_code(&mut self) -> &mut ::std::string::String {
        if self.country_code.is_none() {
            self.country_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_country_code(&mut self) -> ::std::string::String {
        self.country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool rebuild_queue = 3;

    pub fn rebuild_queue(&self) -> bool {
        self.rebuild_queue.unwrap_or(false)
    }

    pub fn clear_rebuild_queue(&mut self) {
        self.rebuild_queue = ::std::option::Option::None;
    }

    pub fn has_rebuild_queue(&self) -> bool {
        self.rebuild_queue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rebuild_queue(&mut self, v: bool) {
        self.rebuild_queue = ::std::option::Option::Some(v);
    }

    // optional bool settings_changed = 4;

    pub fn settings_changed(&self) -> bool {
        self.settings_changed.unwrap_or(false)
    }

    pub fn clear_settings_changed(&mut self) {
        self.settings_changed = ::std::option::Option::None;
    }

    pub fn has_settings_changed(&self) -> bool {
        self.settings_changed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_settings_changed(&mut self, v: bool) {
        self.settings_changed = ::std::option::Option::Some(v);
    }

    // optional bool rebuild_queue_if_stale = 6;

    pub fn rebuild_queue_if_stale(&self) -> bool {
        self.rebuild_queue_if_stale.unwrap_or(false)
    }

    pub fn clear_rebuild_queue_if_stale(&mut self) {
        self.rebuild_queue_if_stale = ::std::option::Option::None;
    }

    pub fn has_rebuild_queue_if_stale(&self) -> bool {
        self.rebuild_queue_if_stale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rebuild_queue_if_stale(&mut self, v: bool) {
        self.rebuild_queue_if_stale = ::std::option::Option::Some(v);
    }

    // optional bool ignore_user_preferences = 8;

    pub fn ignore_user_preferences(&self) -> bool {
        self.ignore_user_preferences.unwrap_or(false)
    }

    pub fn clear_ignore_user_preferences(&mut self) {
        self.ignore_user_preferences = ::std::option::Option::None;
    }

    pub fn has_ignore_user_preferences(&self) -> bool {
        self.ignore_user_preferences.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ignore_user_preferences(&mut self, v: bool) {
        self.ignore_user_preferences = ::std::option::Option::Some(v);
    }

    // optional bool no_experimental_results = 9;

    pub fn no_experimental_results(&self) -> bool {
        self.no_experimental_results.unwrap_or(false)
    }

    pub fn clear_no_experimental_results(&mut self) {
        self.no_experimental_results = ::std::option::Option::None;
    }

    pub fn has_no_experimental_results(&self) -> bool {
        self.no_experimental_results.is_some()
    }

    // Param is passed by value, moved
    pub fn set_no_experimental_results(&mut self, v: bool) {
        self.no_experimental_results = ::std::option::Option::Some(v);
    }

    // optional uint32 experimental_cohort = 10;

    pub fn experimental_cohort(&self) -> u32 {
        self.experimental_cohort.unwrap_or(0)
    }

    pub fn clear_experimental_cohort(&mut self) {
        self.experimental_cohort = ::std::option::Option::None;
    }

    pub fn has_experimental_cohort(&self) -> bool {
        self.experimental_cohort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_experimental_cohort(&mut self, v: u32) {
        self.experimental_cohort = ::std::option::Option::Some(v);
    }

    // optional bool debug_get_solr_query = 11;

    pub fn debug_get_solr_query(&self) -> bool {
        self.debug_get_solr_query.unwrap_or(false)
    }

    pub fn clear_debug_get_solr_query(&mut self) {
        self.debug_get_solr_query = ::std::option::Option::None;
    }

    pub fn has_debug_get_solr_query(&self) -> bool {
        self.debug_get_solr_query.is_some()
    }

    // Param is passed by value, moved
    pub fn set_debug_get_solr_query(&mut self, v: bool) {
        self.debug_get_solr_query = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CStore_GetDiscoveryQueue_Request {
    const NAME: &'static str = "CStore_GetDiscoveryQueue_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.queue_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.country_code = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.rebuild_queue = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.settings_changed = ::std::option::Option::Some(is.read_bool()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.settings)?;
                },
                48 => {
                    self.rebuild_queue_if_stale = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.ignore_user_preferences = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.no_experimental_results = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.experimental_cohort = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.debug_get_solr_query = ::std::option::Option::Some(is.read_bool()?);
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.store_page_filter)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.queue_type {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.country_code.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.rebuild_queue {
            my_size += 1 + 1;
        }
        if let Some(v) = self.settings_changed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.rebuild_queue_if_stale {
            my_size += 1 + 1;
        }
        if let Some(v) = self.ignore_user_preferences {
            my_size += 1 + 1;
        }
        if let Some(v) = self.no_experimental_results {
            my_size += 1 + 1;
        }
        if let Some(v) = self.experimental_cohort {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.debug_get_solr_query {
            my_size += 1 + 1;
        }
        if let Some(v) = self.store_page_filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.queue_type {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.country_code.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.rebuild_queue {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.settings_changed {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.settings.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.rebuild_queue_if_stale {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.ignore_user_preferences {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.no_experimental_results {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.experimental_cohort {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.debug_get_solr_query {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.store_page_filter.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_GetDiscoveryQueue_Request {
        CStore_GetDiscoveryQueue_Request::new()
    }

    fn clear(&mut self) {
        self.queue_type = ::std::option::Option::None;
        self.country_code = ::std::option::Option::None;
        self.rebuild_queue = ::std::option::Option::None;
        self.settings_changed = ::std::option::Option::None;
        self.settings.clear();
        self.rebuild_queue_if_stale = ::std::option::Option::None;
        self.ignore_user_preferences = ::std::option::Option::None;
        self.no_experimental_results = ::std::option::Option::None;
        self.experimental_cohort = ::std::option::Option::None;
        self.debug_get_solr_query = ::std::option::Option::None;
        self.store_page_filter.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_GetDiscoveryQueue_Request {
        static instance: CStore_GetDiscoveryQueue_Request = CStore_GetDiscoveryQueue_Request {
            queue_type: ::std::option::Option::None,
            country_code: ::std::option::Option::None,
            rebuild_queue: ::std::option::Option::None,
            settings_changed: ::std::option::Option::None,
            settings: ::protobuf::MessageField::none(),
            rebuild_queue_if_stale: ::std::option::Option::None,
            ignore_user_preferences: ::std::option::Option::None,
            no_experimental_results: ::std::option::Option::None,
            experimental_cohort: ::std::option::Option::None,
            debug_get_solr_query: ::std::option::Option::None,
            store_page_filter: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CStore_GetDiscoveryQueue_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_GetDiscoveryQueue_Response {
    // message fields
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueue_Response.appids)
    pub appids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueue_Response.country_code)
    pub country_code: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueue_Response.settings)
    pub settings: ::protobuf::MessageField<CStoreDiscoveryQueueSettings>,
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueue_Response.skipped)
    pub skipped: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueue_Response.exhausted)
    pub exhausted: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueue_Response.experimental_cohort)
    pub experimental_cohort: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueue_Response.debug_solr_query)
    pub debug_solr_query: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_GetDiscoveryQueue_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_GetDiscoveryQueue_Response {
    fn default() -> &'a CStore_GetDiscoveryQueue_Response {
        <CStore_GetDiscoveryQueue_Response as ::protobuf::Message>::default_instance()
    }
}

impl CStore_GetDiscoveryQueue_Response {
    pub fn new() -> CStore_GetDiscoveryQueue_Response {
        ::std::default::Default::default()
    }

    // optional string country_code = 2;

    pub fn country_code(&self) -> &str {
        match self.country_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_country_code(&mut self) {
        self.country_code = ::std::option::Option::None;
    }

    pub fn has_country_code(&self) -> bool {
        self.country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country_code(&mut self, v: ::std::string::String) {
        self.country_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_code(&mut self) -> &mut ::std::string::String {
        if self.country_code.is_none() {
            self.country_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_country_code(&mut self) -> ::std::string::String {
        self.country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 skipped = 4;

    pub fn skipped(&self) -> i32 {
        self.skipped.unwrap_or(0)
    }

    pub fn clear_skipped(&mut self) {
        self.skipped = ::std::option::Option::None;
    }

    pub fn has_skipped(&self) -> bool {
        self.skipped.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skipped(&mut self, v: i32) {
        self.skipped = ::std::option::Option::Some(v);
    }

    // optional bool exhausted = 5;

    pub fn exhausted(&self) -> bool {
        self.exhausted.unwrap_or(false)
    }

    pub fn clear_exhausted(&mut self) {
        self.exhausted = ::std::option::Option::None;
    }

    pub fn has_exhausted(&self) -> bool {
        self.exhausted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exhausted(&mut self, v: bool) {
        self.exhausted = ::std::option::Option::Some(v);
    }

    // optional uint32 experimental_cohort = 6;

    pub fn experimental_cohort(&self) -> u32 {
        self.experimental_cohort.unwrap_or(0)
    }

    pub fn clear_experimental_cohort(&mut self) {
        self.experimental_cohort = ::std::option::Option::None;
    }

    pub fn has_experimental_cohort(&self) -> bool {
        self.experimental_cohort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_experimental_cohort(&mut self, v: u32) {
        self.experimental_cohort = ::std::option::Option::Some(v);
    }

    // optional string debug_solr_query = 7;

    pub fn debug_solr_query(&self) -> &str {
        match self.debug_solr_query.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_debug_solr_query(&mut self) {
        self.debug_solr_query = ::std::option::Option::None;
    }

    pub fn has_debug_solr_query(&self) -> bool {
        self.debug_solr_query.is_some()
    }

    // Param is passed by value, moved
    pub fn set_debug_solr_query(&mut self, v: ::std::string::String) {
        self.debug_solr_query = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_debug_solr_query(&mut self) -> &mut ::std::string::String {
        if self.debug_solr_query.is_none() {
            self.debug_solr_query = ::std::option::Option::Some(::std::string::String::new());
        }
        self.debug_solr_query.as_mut().unwrap()
    }

    // Take field
    pub fn take_debug_solr_query(&mut self) -> ::std::string::String {
        self.debug_solr_query.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CStore_GetDiscoveryQueue_Response {
    const NAME: &'static str = "CStore_GetDiscoveryQueue_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.appids)?;
                },
                8 => {
                    self.appids.push(is.read_uint32()?);
                },
                18 => {
                    self.country_code = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.settings)?;
                },
                32 => {
                    self.skipped = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.exhausted = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.experimental_cohort = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.debug_solr_query = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.appids {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        if let Some(v) = self.country_code.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.skipped {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.exhausted {
            my_size += 1 + 1;
        }
        if let Some(v) = self.experimental_cohort {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.debug_solr_query.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.appids {
            os.write_uint32(1, *v)?;
        };
        if let Some(v) = self.country_code.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.settings.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.skipped {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.exhausted {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.experimental_cohort {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.debug_solr_query.as_ref() {
            os.write_string(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_GetDiscoveryQueue_Response {
        CStore_GetDiscoveryQueue_Response::new()
    }

    fn clear(&mut self) {
        self.appids.clear();
        self.country_code = ::std::option::Option::None;
        self.settings.clear();
        self.skipped = ::std::option::Option::None;
        self.exhausted = ::std::option::Option::None;
        self.experimental_cohort = ::std::option::Option::None;
        self.debug_solr_query = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_GetDiscoveryQueue_Response {
        static instance: CStore_GetDiscoveryQueue_Response = CStore_GetDiscoveryQueue_Response {
            appids: ::std::vec::Vec::new(),
            country_code: ::std::option::Option::None,
            settings: ::protobuf::MessageField::none(),
            skipped: ::std::option::Option::None,
            exhausted: ::std::option::Option::None,
            experimental_cohort: ::std::option::Option::None,
            debug_solr_query: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Get the settings that were used to generate a user's discovery queue."]
// @@protoc_insertion_point(message:CStore_GetDiscoveryQueueSettings_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_GetDiscoveryQueueSettings_Request {
    // message fields
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueueSettings_Request.queue_type)
    pub queue_type: ::std::option::Option<::protobuf::EnumOrUnknown<EStoreDiscoveryQueueType>>,
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueueSettings_Request.store_page_filter)
    pub store_page_filter: ::protobuf::MessageField<super::contenthubs::CStorePageFilter>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_GetDiscoveryQueueSettings_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_GetDiscoveryQueueSettings_Request {
    fn default() -> &'a CStore_GetDiscoveryQueueSettings_Request {
        <CStore_GetDiscoveryQueueSettings_Request as ::protobuf::Message>::default_instance()
    }
}

impl CStore_GetDiscoveryQueueSettings_Request {
    pub fn new() -> CStore_GetDiscoveryQueueSettings_Request {
        ::std::default::Default::default()
    }

    // optional .EStoreDiscoveryQueueType queue_type = 1;

    pub fn queue_type(&self) -> EStoreDiscoveryQueueType {
        match self.queue_type {
            Some(e) => e.enum_value_or(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeNew),
            None => EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeNew,
        }
    }

    pub fn clear_queue_type(&mut self) {
        self.queue_type = ::std::option::Option::None;
    }

    pub fn has_queue_type(&self) -> bool {
        self.queue_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queue_type(&mut self, v: EStoreDiscoveryQueueType) {
        self.queue_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::protobuf::Message for CStore_GetDiscoveryQueueSettings_Request {
    const NAME: &'static str = "CStore_GetDiscoveryQueueSettings_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.queue_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.store_page_filter)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.queue_type {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.store_page_filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.queue_type {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.store_page_filter.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_GetDiscoveryQueueSettings_Request {
        CStore_GetDiscoveryQueueSettings_Request::new()
    }

    fn clear(&mut self) {
        self.queue_type = ::std::option::Option::None;
        self.store_page_filter.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_GetDiscoveryQueueSettings_Request {
        static instance: CStore_GetDiscoveryQueueSettings_Request = CStore_GetDiscoveryQueueSettings_Request {
            queue_type: ::std::option::Option::None,
            store_page_filter: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CStore_GetDiscoveryQueueSettings_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_GetDiscoveryQueueSettings_Response {
    // message fields
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueueSettings_Response.country_code)
    pub country_code: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueueSettings_Response.settings)
    pub settings: ::protobuf::MessageField<CStoreDiscoveryQueueSettings>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_GetDiscoveryQueueSettings_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_GetDiscoveryQueueSettings_Response {
    fn default() -> &'a CStore_GetDiscoveryQueueSettings_Response {
        <CStore_GetDiscoveryQueueSettings_Response as ::protobuf::Message>::default_instance()
    }
}

impl CStore_GetDiscoveryQueueSettings_Response {
    pub fn new() -> CStore_GetDiscoveryQueueSettings_Response {
        ::std::default::Default::default()
    }

    // optional string country_code = 1;

    pub fn country_code(&self) -> &str {
        match self.country_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_country_code(&mut self) {
        self.country_code = ::std::option::Option::None;
    }

    pub fn has_country_code(&self) -> bool {
        self.country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country_code(&mut self, v: ::std::string::String) {
        self.country_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_code(&mut self) -> &mut ::std::string::String {
        if self.country_code.is_none() {
            self.country_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_country_code(&mut self) -> ::std::string::String {
        self.country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CStore_GetDiscoveryQueueSettings_Response {
    const NAME: &'static str = "CStore_GetDiscoveryQueueSettings_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.country_code = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.settings)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.country_code.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.country_code.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.settings.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_GetDiscoveryQueueSettings_Response {
        CStore_GetDiscoveryQueueSettings_Response::new()
    }

    fn clear(&mut self) {
        self.country_code = ::std::option::Option::None;
        self.settings.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_GetDiscoveryQueueSettings_Response {
        static instance: CStore_GetDiscoveryQueueSettings_Response = CStore_GetDiscoveryQueueSettings_Response {
            country_code: ::std::option::Option::None,
            settings: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Skip an item in the user's queue."]
// @@protoc_insertion_point(message:CStore_SkipDiscoveryQueueItem_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_SkipDiscoveryQueueItem_Request {
    // message fields
    // @@protoc_insertion_point(field:CStore_SkipDiscoveryQueueItem_Request.queue_type)
    pub queue_type: ::std::option::Option<::protobuf::EnumOrUnknown<EStoreDiscoveryQueueType>>,
    // @@protoc_insertion_point(field:CStore_SkipDiscoveryQueueItem_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStore_SkipDiscoveryQueueItem_Request.store_page_filter)
    pub store_page_filter: ::protobuf::MessageField<super::contenthubs::CStorePageFilter>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_SkipDiscoveryQueueItem_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_SkipDiscoveryQueueItem_Request {
    fn default() -> &'a CStore_SkipDiscoveryQueueItem_Request {
        <CStore_SkipDiscoveryQueueItem_Request as ::protobuf::Message>::default_instance()
    }
}

impl CStore_SkipDiscoveryQueueItem_Request {
    pub fn new() -> CStore_SkipDiscoveryQueueItem_Request {
        ::std::default::Default::default()
    }

    // optional .EStoreDiscoveryQueueType queue_type = 1;

    pub fn queue_type(&self) -> EStoreDiscoveryQueueType {
        match self.queue_type {
            Some(e) => e.enum_value_or(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeNew),
            None => EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeNew,
        }
    }

    pub fn clear_queue_type(&mut self) {
        self.queue_type = ::std::option::Option::None;
    }

    pub fn has_queue_type(&self) -> bool {
        self.queue_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queue_type(&mut self, v: EStoreDiscoveryQueueType) {
        self.queue_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 appid = 2;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CStore_SkipDiscoveryQueueItem_Request {
    const NAME: &'static str = "CStore_SkipDiscoveryQueueItem_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.queue_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.store_page_filter)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.queue_type {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.store_page_filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.queue_type {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.store_page_filter.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_SkipDiscoveryQueueItem_Request {
        CStore_SkipDiscoveryQueueItem_Request::new()
    }

    fn clear(&mut self) {
        self.queue_type = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.store_page_filter.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_SkipDiscoveryQueueItem_Request {
        static instance: CStore_SkipDiscoveryQueueItem_Request = CStore_SkipDiscoveryQueueItem_Request {
            queue_type: ::std::option::Option::None,
            appid: ::std::option::Option::None,
            store_page_filter: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CStore_SkipDiscoveryQueueItem_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_SkipDiscoveryQueueItem_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CStore_SkipDiscoveryQueueItem_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_SkipDiscoveryQueueItem_Response {
    fn default() -> &'a CStore_SkipDiscoveryQueueItem_Response {
        <CStore_SkipDiscoveryQueueItem_Response as ::protobuf::Message>::default_instance()
    }
}

impl CStore_SkipDiscoveryQueueItem_Response {
    pub fn new() -> CStore_SkipDiscoveryQueueItem_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CStore_SkipDiscoveryQueueItem_Response {
    const NAME: &'static str = "CStore_SkipDiscoveryQueueItem_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_SkipDiscoveryQueueItem_Response {
        CStore_SkipDiscoveryQueueItem_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_SkipDiscoveryQueueItem_Response {
        static instance: CStore_SkipDiscoveryQueueItem_Response = CStore_SkipDiscoveryQueueItem_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Get information about a user's relationship to a game - ownership, wishlist, discovery queue state, etc."]
// @@protoc_insertion_point(message:CStore_GetUserGameInterestState_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_GetUserGameInterestState_Request {
    // message fields
    // @@protoc_insertion_point(field:CStore_GetUserGameInterestState_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStore_GetUserGameInterestState_Request.store_appid)
    pub store_appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStore_GetUserGameInterestState_Request.beta_appid)
    pub beta_appid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_GetUserGameInterestState_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_GetUserGameInterestState_Request {
    fn default() -> &'a CStore_GetUserGameInterestState_Request {
        <CStore_GetUserGameInterestState_Request as ::protobuf::Message>::default_instance()
    }
}

impl CStore_GetUserGameInterestState_Request {
    pub fn new() -> CStore_GetUserGameInterestState_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 store_appid = 2;

    pub fn store_appid(&self) -> u32 {
        self.store_appid.unwrap_or(0)
    }

    pub fn clear_store_appid(&mut self) {
        self.store_appid = ::std::option::Option::None;
    }

    pub fn has_store_appid(&self) -> bool {
        self.store_appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_store_appid(&mut self, v: u32) {
        self.store_appid = ::std::option::Option::Some(v);
    }

    // optional uint32 beta_appid = 3;

    pub fn beta_appid(&self) -> u32 {
        self.beta_appid.unwrap_or(0)
    }

    pub fn clear_beta_appid(&mut self) {
        self.beta_appid = ::std::option::Option::None;
    }

    pub fn has_beta_appid(&self) -> bool {
        self.beta_appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_beta_appid(&mut self, v: u32) {
        self.beta_appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CStore_GetUserGameInterestState_Request {
    const NAME: &'static str = "CStore_GetUserGameInterestState_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.store_appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.beta_appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.store_appid {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.beta_appid {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.store_appid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.beta_appid {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_GetUserGameInterestState_Request {
        CStore_GetUserGameInterestState_Request::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.store_appid = ::std::option::Option::None;
        self.beta_appid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_GetUserGameInterestState_Request {
        static instance: CStore_GetUserGameInterestState_Request = CStore_GetUserGameInterestState_Request {
            appid: ::std::option::Option::None,
            store_appid: ::std::option::Option::None,
            beta_appid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CStore_GetUserGameInterestState_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_GetUserGameInterestState_Response {
    // message fields
    // @@protoc_insertion_point(field:CStore_GetUserGameInterestState_Response.owned)
    pub owned: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStore_GetUserGameInterestState_Response.wishlist)
    pub wishlist: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStore_GetUserGameInterestState_Response.ignored)
    pub ignored: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStore_GetUserGameInterestState_Response.following)
    pub following: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStore_GetUserGameInterestState_Response.in_queues)
    pub in_queues: ::std::vec::Vec<::protobuf::EnumOrUnknown<EStoreDiscoveryQueueType>>,
    // @@protoc_insertion_point(field:CStore_GetUserGameInterestState_Response.queues_with_skip)
    pub queues_with_skip: ::std::vec::Vec<::protobuf::EnumOrUnknown<EStoreDiscoveryQueueType>>,
    // @@protoc_insertion_point(field:CStore_GetUserGameInterestState_Response.queue_items_remaining)
    pub queue_items_remaining: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CStore_GetUserGameInterestState_Response.queue_items_next_appid)
    pub queue_items_next_appid: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CStore_GetUserGameInterestState_Response.temporarily_owned)
    pub temporarily_owned: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStore_GetUserGameInterestState_Response.queues)
    pub queues: ::std::vec::Vec<cstore_get_user_game_interest_state_response::InQueue>,
    // @@protoc_insertion_point(field:CStore_GetUserGameInterestState_Response.ignored_reason)
    pub ignored_reason: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CStore_GetUserGameInterestState_Response.beta_status)
    pub beta_status: ::std::option::Option<::protobuf::EnumOrUnknown<EPlaytestStatus>>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_GetUserGameInterestState_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_GetUserGameInterestState_Response {
    fn default() -> &'a CStore_GetUserGameInterestState_Response {
        <CStore_GetUserGameInterestState_Response as ::protobuf::Message>::default_instance()
    }
}

impl CStore_GetUserGameInterestState_Response {
    pub fn new() -> CStore_GetUserGameInterestState_Response {
        ::std::default::Default::default()
    }

    // optional bool owned = 1;

    pub fn owned(&self) -> bool {
        self.owned.unwrap_or(false)
    }

    pub fn clear_owned(&mut self) {
        self.owned = ::std::option::Option::None;
    }

    pub fn has_owned(&self) -> bool {
        self.owned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owned(&mut self, v: bool) {
        self.owned = ::std::option::Option::Some(v);
    }

    // optional bool wishlist = 2;

    pub fn wishlist(&self) -> bool {
        self.wishlist.unwrap_or(false)
    }

    pub fn clear_wishlist(&mut self) {
        self.wishlist = ::std::option::Option::None;
    }

    pub fn has_wishlist(&self) -> bool {
        self.wishlist.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wishlist(&mut self, v: bool) {
        self.wishlist = ::std::option::Option::Some(v);
    }

    // optional bool ignored = 3;

    pub fn ignored(&self) -> bool {
        self.ignored.unwrap_or(false)
    }

    pub fn clear_ignored(&mut self) {
        self.ignored = ::std::option::Option::None;
    }

    pub fn has_ignored(&self) -> bool {
        self.ignored.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ignored(&mut self, v: bool) {
        self.ignored = ::std::option::Option::Some(v);
    }

    // optional bool following = 4;

    pub fn following(&self) -> bool {
        self.following.unwrap_or(false)
    }

    pub fn clear_following(&mut self) {
        self.following = ::std::option::Option::None;
    }

    pub fn has_following(&self) -> bool {
        self.following.is_some()
    }

    // Param is passed by value, moved
    pub fn set_following(&mut self, v: bool) {
        self.following = ::std::option::Option::Some(v);
    }

    // optional bool temporarily_owned = 9;

    pub fn temporarily_owned(&self) -> bool {
        self.temporarily_owned.unwrap_or(false)
    }

    pub fn clear_temporarily_owned(&mut self) {
        self.temporarily_owned = ::std::option::Option::None;
    }

    pub fn has_temporarily_owned(&self) -> bool {
        self.temporarily_owned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_temporarily_owned(&mut self, v: bool) {
        self.temporarily_owned = ::std::option::Option::Some(v);
    }

    // optional int32 ignored_reason = 11;

    pub fn ignored_reason(&self) -> i32 {
        self.ignored_reason.unwrap_or(0)
    }

    pub fn clear_ignored_reason(&mut self) {
        self.ignored_reason = ::std::option::Option::None;
    }

    pub fn has_ignored_reason(&self) -> bool {
        self.ignored_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ignored_reason(&mut self, v: i32) {
        self.ignored_reason = ::std::option::Option::Some(v);
    }

    // optional .EPlaytestStatus beta_status = 12;

    pub fn beta_status(&self) -> EPlaytestStatus {
        match self.beta_status {
            Some(e) => e.enum_value_or(EPlaytestStatus::k_ETesterStatusNone),
            None => EPlaytestStatus::k_ETesterStatusNone,
        }
    }

    pub fn clear_beta_status(&mut self) {
        self.beta_status = ::std::option::Option::None;
    }

    pub fn has_beta_status(&self) -> bool {
        self.beta_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_beta_status(&mut self, v: EPlaytestStatus) {
        self.beta_status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::protobuf::Message for CStore_GetUserGameInterestState_Response {
    const NAME: &'static str = "CStore_GetUserGameInterestState_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.owned = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.wishlist = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.ignored = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.following = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.in_queues.push(is.read_enum_or_unknown()?);
                },
                42 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.in_queues)?
                },
                48 => {
                    self.queues_with_skip.push(is.read_enum_or_unknown()?);
                },
                50 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.queues_with_skip)?
                },
                58 => {
                    is.read_repeated_packed_int32_into(&mut self.queue_items_remaining)?;
                },
                56 => {
                    self.queue_items_remaining.push(is.read_int32()?);
                },
                66 => {
                    is.read_repeated_packed_uint32_into(&mut self.queue_items_next_appid)?;
                },
                64 => {
                    self.queue_items_next_appid.push(is.read_uint32()?);
                },
                72 => {
                    self.temporarily_owned = ::std::option::Option::Some(is.read_bool()?);
                },
                82 => {
                    self.queues.push(is.read_message()?);
                },
                88 => {
                    self.ignored_reason = ::std::option::Option::Some(is.read_int32()?);
                },
                96 => {
                    self.beta_status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.owned {
            my_size += 1 + 1;
        }
        if let Some(v) = self.wishlist {
            my_size += 1 + 1;
        }
        if let Some(v) = self.ignored {
            my_size += 1 + 1;
        }
        if let Some(v) = self.following {
            my_size += 1 + 1;
        }
        for value in &self.in_queues {
            my_size += ::protobuf::rt::int32_size(5, value.value());
        };
        for value in &self.queues_with_skip {
            my_size += ::protobuf::rt::int32_size(6, value.value());
        };
        for value in &self.queue_items_remaining {
            my_size += ::protobuf::rt::int32_size(7, *value);
        };
        for value in &self.queue_items_next_appid {
            my_size += ::protobuf::rt::uint32_size(8, *value);
        };
        if let Some(v) = self.temporarily_owned {
            my_size += 1 + 1;
        }
        for value in &self.queues {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.ignored_reason {
            my_size += ::protobuf::rt::int32_size(11, v);
        }
        if let Some(v) = self.beta_status {
            my_size += ::protobuf::rt::int32_size(12, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.owned {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.wishlist {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.ignored {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.following {
            os.write_bool(4, v)?;
        }
        for v in &self.in_queues {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(v))?;
        };
        for v in &self.queues_with_skip {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(v))?;
        };
        for v in &self.queue_items_remaining {
            os.write_int32(7, *v)?;
        };
        for v in &self.queue_items_next_appid {
            os.write_uint32(8, *v)?;
        };
        if let Some(v) = self.temporarily_owned {
            os.write_bool(9, v)?;
        }
        for v in &self.queues {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        if let Some(v) = self.ignored_reason {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.beta_status {
            os.write_enum(12, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_GetUserGameInterestState_Response {
        CStore_GetUserGameInterestState_Response::new()
    }

    fn clear(&mut self) {
        self.owned = ::std::option::Option::None;
        self.wishlist = ::std::option::Option::None;
        self.ignored = ::std::option::Option::None;
        self.following = ::std::option::Option::None;
        self.in_queues.clear();
        self.queues_with_skip.clear();
        self.queue_items_remaining.clear();
        self.queue_items_next_appid.clear();
        self.temporarily_owned = ::std::option::Option::None;
        self.queues.clear();
        self.ignored_reason = ::std::option::Option::None;
        self.beta_status = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_GetUserGameInterestState_Response {
        static instance: CStore_GetUserGameInterestState_Response = CStore_GetUserGameInterestState_Response {
            owned: ::std::option::Option::None,
            wishlist: ::std::option::Option::None,
            ignored: ::std::option::Option::None,
            following: ::std::option::Option::None,
            in_queues: ::std::vec::Vec::new(),
            queues_with_skip: ::std::vec::Vec::new(),
            queue_items_remaining: ::std::vec::Vec::new(),
            queue_items_next_appid: ::std::vec::Vec::new(),
            temporarily_owned: ::std::option::Option::None,
            queues: ::std::vec::Vec::new(),
            ignored_reason: ::std::option::Option::None,
            beta_status: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CStore_GetUserGameInterestState_Response`
pub mod cstore_get_user_game_interest_state_response {
    // @@protoc_insertion_point(message:CStore_GetUserGameInterestState_Response.InQueue)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct InQueue {
        // message fields
        // @@protoc_insertion_point(field:CStore_GetUserGameInterestState_Response.InQueue.type)
        pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<super::EStoreDiscoveryQueueType>>,
        // @@protoc_insertion_point(field:CStore_GetUserGameInterestState_Response.InQueue.skipped)
        pub skipped: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CStore_GetUserGameInterestState_Response.InQueue.items_remaining)
        pub items_remaining: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CStore_GetUserGameInterestState_Response.InQueue.next_appid)
        pub next_appid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CStore_GetUserGameInterestState_Response.InQueue.experimental_cohort)
        pub experimental_cohort: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CStore_GetUserGameInterestState_Response.InQueue.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a InQueue {
        fn default() -> &'a InQueue {
            <InQueue as ::protobuf::Message>::default_instance()
        }
    }

    impl InQueue {
        pub fn new() -> InQueue {
            ::std::default::Default::default()
        }

        // optional .EStoreDiscoveryQueueType type = 1;

        pub fn type_(&self) -> super::EStoreDiscoveryQueueType {
            match self.type_ {
                Some(e) => e.enum_value_or(super::EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeNew),
                None => super::EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeNew,
            }
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: super::EStoreDiscoveryQueueType) {
            self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional bool skipped = 2;

        pub fn skipped(&self) -> bool {
            self.skipped.unwrap_or(false)
        }

        pub fn clear_skipped(&mut self) {
            self.skipped = ::std::option::Option::None;
        }

        pub fn has_skipped(&self) -> bool {
            self.skipped.is_some()
        }

        // Param is passed by value, moved
        pub fn set_skipped(&mut self, v: bool) {
            self.skipped = ::std::option::Option::Some(v);
        }

        // optional int32 items_remaining = 3;

        pub fn items_remaining(&self) -> i32 {
            self.items_remaining.unwrap_or(0)
        }

        pub fn clear_items_remaining(&mut self) {
            self.items_remaining = ::std::option::Option::None;
        }

        pub fn has_items_remaining(&self) -> bool {
            self.items_remaining.is_some()
        }

        // Param is passed by value, moved
        pub fn set_items_remaining(&mut self, v: i32) {
            self.items_remaining = ::std::option::Option::Some(v);
        }

        // optional uint32 next_appid = 4;

        pub fn next_appid(&self) -> u32 {
            self.next_appid.unwrap_or(0)
        }

        pub fn clear_next_appid(&mut self) {
            self.next_appid = ::std::option::Option::None;
        }

        pub fn has_next_appid(&self) -> bool {
            self.next_appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_next_appid(&mut self, v: u32) {
            self.next_appid = ::std::option::Option::Some(v);
        }

        // optional uint32 experimental_cohort = 5;

        pub fn experimental_cohort(&self) -> u32 {
            self.experimental_cohort.unwrap_or(0)
        }

        pub fn clear_experimental_cohort(&mut self) {
            self.experimental_cohort = ::std::option::Option::None;
        }

        pub fn has_experimental_cohort(&self) -> bool {
            self.experimental_cohort.is_some()
        }

        // Param is passed by value, moved
        pub fn set_experimental_cohort(&mut self, v: u32) {
            self.experimental_cohort = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for InQueue {
        const NAME: &'static str = "InQueue";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    16 => {
                        self.skipped = ::std::option::Option::Some(is.read_bool()?);
                    },
                    24 => {
                        self.items_remaining = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.next_appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.experimental_cohort = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_ {
                my_size += ::protobuf::rt::int32_size(1, v.value());
            }
            if let Some(v) = self.skipped {
                my_size += 1 + 1;
            }
            if let Some(v) = self.items_remaining {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.next_appid {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.experimental_cohort {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.type_ {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.skipped {
                os.write_bool(2, v)?;
            }
            if let Some(v) = self.items_remaining {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.next_appid {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.experimental_cohort {
                os.write_uint32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> InQueue {
            InQueue::new()
        }

        fn clear(&mut self) {
            self.type_ = ::std::option::Option::None;
            self.skipped = ::std::option::Option::None;
            self.items_remaining = ::std::option::Option::None;
            self.next_appid = ::std::option::Option::None;
            self.experimental_cohort = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static InQueue {
            static instance: InQueue = InQueue {
                type_: ::std::option::Option::None,
                skipped: ::std::option::Option::None,
                items_remaining: ::std::option::Option::None,
                next_appid: ::std::option::Option::None,
                experimental_cohort: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

#[doc = "Returns all the apps skipped so far in the given discovery queue for the given user."]
// @@protoc_insertion_point(message:CStore_GetDiscoveryQueueSkippedApps_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_GetDiscoveryQueueSkippedApps_Request {
    // message fields
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueueSkippedApps_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueueSkippedApps_Request.queue_type)
    pub queue_type: ::std::option::Option<::protobuf::EnumOrUnknown<EStoreDiscoveryQueueType>>,
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueueSkippedApps_Request.store_page_filter)
    pub store_page_filter: ::protobuf::MessageField<super::contenthubs::CStorePageFilter>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_GetDiscoveryQueueSkippedApps_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_GetDiscoveryQueueSkippedApps_Request {
    fn default() -> &'a CStore_GetDiscoveryQueueSkippedApps_Request {
        <CStore_GetDiscoveryQueueSkippedApps_Request as ::protobuf::Message>::default_instance()
    }
}

impl CStore_GetDiscoveryQueueSkippedApps_Request {
    pub fn new() -> CStore_GetDiscoveryQueueSkippedApps_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional .EStoreDiscoveryQueueType queue_type = 2;

    pub fn queue_type(&self) -> EStoreDiscoveryQueueType {
        match self.queue_type {
            Some(e) => e.enum_value_or(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeNew),
            None => EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeNew,
        }
    }

    pub fn clear_queue_type(&mut self) {
        self.queue_type = ::std::option::Option::None;
    }

    pub fn has_queue_type(&self) -> bool {
        self.queue_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queue_type(&mut self, v: EStoreDiscoveryQueueType) {
        self.queue_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::protobuf::Message for CStore_GetDiscoveryQueueSkippedApps_Request {
    const NAME: &'static str = "CStore_GetDiscoveryQueueSkippedApps_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.queue_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.store_page_filter)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.queue_type {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.store_page_filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.queue_type {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.store_page_filter.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_GetDiscoveryQueueSkippedApps_Request {
        CStore_GetDiscoveryQueueSkippedApps_Request::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.queue_type = ::std::option::Option::None;
        self.store_page_filter.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_GetDiscoveryQueueSkippedApps_Request {
        static instance: CStore_GetDiscoveryQueueSkippedApps_Request = CStore_GetDiscoveryQueueSkippedApps_Request {
            steamid: ::std::option::Option::None,
            queue_type: ::std::option::Option::None,
            store_page_filter: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CStore_GetDiscoveryQueueSkippedApps_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_GetDiscoveryQueueSkippedApps_Response {
    // message fields
    // @@protoc_insertion_point(field:CStore_GetDiscoveryQueueSkippedApps_Response.appids)
    pub appids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_GetDiscoveryQueueSkippedApps_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_GetDiscoveryQueueSkippedApps_Response {
    fn default() -> &'a CStore_GetDiscoveryQueueSkippedApps_Response {
        <CStore_GetDiscoveryQueueSkippedApps_Response as ::protobuf::Message>::default_instance()
    }
}

impl CStore_GetDiscoveryQueueSkippedApps_Response {
    pub fn new() -> CStore_GetDiscoveryQueueSkippedApps_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CStore_GetDiscoveryQueueSkippedApps_Response {
    const NAME: &'static str = "CStore_GetDiscoveryQueueSkippedApps_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.appids)?;
                },
                8 => {
                    self.appids.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.appids {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.appids {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_GetDiscoveryQueueSkippedApps_Response {
        CStore_GetDiscoveryQueueSkippedApps_Response::new()
    }

    fn clear(&mut self) {
        self.appids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_GetDiscoveryQueueSkippedApps_Response {
        static instance: CStore_GetDiscoveryQueueSkippedApps_Response = CStore_GetDiscoveryQueueSkippedApps_Response {
            appids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Returns the desired ratings board and maximum rating to show on the store"]
// @@protoc_insertion_point(message:CStore_GetStorePreferences_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_GetStorePreferences_Request {
    // special fields
    // @@protoc_insertion_point(special_field:CStore_GetStorePreferences_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_GetStorePreferences_Request {
    fn default() -> &'a CStore_GetStorePreferences_Request {
        <CStore_GetStorePreferences_Request as ::protobuf::Message>::default_instance()
    }
}

impl CStore_GetStorePreferences_Request {
    pub fn new() -> CStore_GetStorePreferences_Request {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CStore_GetStorePreferences_Request {
    const NAME: &'static str = "CStore_GetStorePreferences_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_GetStorePreferences_Request {
        CStore_GetStorePreferences_Request::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_GetStorePreferences_Request {
        static instance: CStore_GetStorePreferences_Request = CStore_GetStorePreferences_Request {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CStore_UserPreferences)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_UserPreferences {
    // message fields
    // @@protoc_insertion_point(field:CStore_UserPreferences.primary_language)
    pub primary_language: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CStore_UserPreferences.secondary_languages)
    pub secondary_languages: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStore_UserPreferences.platform_windows)
    pub platform_windows: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStore_UserPreferences.platform_mac)
    pub platform_mac: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStore_UserPreferences.platform_linux)
    pub platform_linux: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStore_UserPreferences.timestamp_updated)
    pub timestamp_updated: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStore_UserPreferences.hide_store_broadcast)
    pub hide_store_broadcast: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStore_UserPreferences.review_score_preference)
    pub review_score_preference: ::std::option::Option<::protobuf::EnumOrUnknown<EUserReviewScorePreference>>,
    // @@protoc_insertion_point(field:CStore_UserPreferences.timestamp_content_descriptor_preferences_updated)
    pub timestamp_content_descriptor_preferences_updated: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CStore_UserPreferences.provide_deck_feedback)
    pub provide_deck_feedback: ::std::option::Option<::protobuf::EnumOrUnknown<super::enums::EProvideDeckFeedbackPreference>>,
    // @@protoc_insertion_point(field:CStore_UserPreferences.additional_languages)
    pub additional_languages: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_UserPreferences.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_UserPreferences {
    fn default() -> &'a CStore_UserPreferences {
        <CStore_UserPreferences as ::protobuf::Message>::default_instance()
    }
}

impl CStore_UserPreferences {
    pub fn new() -> CStore_UserPreferences {
        ::std::default::Default::default()
    }

    // optional int32 primary_language = 1;

    pub fn primary_language(&self) -> i32 {
        self.primary_language.unwrap_or(0)
    }

    pub fn clear_primary_language(&mut self) {
        self.primary_language = ::std::option::Option::None;
    }

    pub fn has_primary_language(&self) -> bool {
        self.primary_language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_primary_language(&mut self, v: i32) {
        self.primary_language = ::std::option::Option::Some(v);
    }

    // optional uint32 secondary_languages = 2;

    pub fn secondary_languages(&self) -> u32 {
        self.secondary_languages.unwrap_or(0)
    }

    pub fn clear_secondary_languages(&mut self) {
        self.secondary_languages = ::std::option::Option::None;
    }

    pub fn has_secondary_languages(&self) -> bool {
        self.secondary_languages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secondary_languages(&mut self, v: u32) {
        self.secondary_languages = ::std::option::Option::Some(v);
    }

    // optional bool platform_windows = 3;

    pub fn platform_windows(&self) -> bool {
        self.platform_windows.unwrap_or(false)
    }

    pub fn clear_platform_windows(&mut self) {
        self.platform_windows = ::std::option::Option::None;
    }

    pub fn has_platform_windows(&self) -> bool {
        self.platform_windows.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platform_windows(&mut self, v: bool) {
        self.platform_windows = ::std::option::Option::Some(v);
    }

    // optional bool platform_mac = 4;

    pub fn platform_mac(&self) -> bool {
        self.platform_mac.unwrap_or(false)
    }

    pub fn clear_platform_mac(&mut self) {
        self.platform_mac = ::std::option::Option::None;
    }

    pub fn has_platform_mac(&self) -> bool {
        self.platform_mac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platform_mac(&mut self, v: bool) {
        self.platform_mac = ::std::option::Option::Some(v);
    }

    // optional bool platform_linux = 5;

    pub fn platform_linux(&self) -> bool {
        self.platform_linux.unwrap_or(false)
    }

    pub fn clear_platform_linux(&mut self) {
        self.platform_linux = ::std::option::Option::None;
    }

    pub fn has_platform_linux(&self) -> bool {
        self.platform_linux.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platform_linux(&mut self, v: bool) {
        self.platform_linux = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp_updated = 8;

    pub fn timestamp_updated(&self) -> u32 {
        self.timestamp_updated.unwrap_or(0)
    }

    pub fn clear_timestamp_updated(&mut self) {
        self.timestamp_updated = ::std::option::Option::None;
    }

    pub fn has_timestamp_updated(&self) -> bool {
        self.timestamp_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp_updated(&mut self, v: u32) {
        self.timestamp_updated = ::std::option::Option::Some(v);
    }

    // optional bool hide_store_broadcast = 9;

    pub fn hide_store_broadcast(&self) -> bool {
        self.hide_store_broadcast.unwrap_or(false)
    }

    pub fn clear_hide_store_broadcast(&mut self) {
        self.hide_store_broadcast = ::std::option::Option::None;
    }

    pub fn has_hide_store_broadcast(&self) -> bool {
        self.hide_store_broadcast.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hide_store_broadcast(&mut self, v: bool) {
        self.hide_store_broadcast = ::std::option::Option::Some(v);
    }

    // optional .EUserReviewScorePreference review_score_preference = 10;

    pub fn review_score_preference(&self) -> EUserReviewScorePreference {
        match self.review_score_preference {
            Some(e) => e.enum_value_or(EUserReviewScorePreference::k_EUserReviewScorePreference_Unset),
            None => EUserReviewScorePreference::k_EUserReviewScorePreference_Unset,
        }
    }

    pub fn clear_review_score_preference(&mut self) {
        self.review_score_preference = ::std::option::Option::None;
    }

    pub fn has_review_score_preference(&self) -> bool {
        self.review_score_preference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_review_score_preference(&mut self, v: EUserReviewScorePreference) {
        self.review_score_preference = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 timestamp_content_descriptor_preferences_updated = 11;

    pub fn timestamp_content_descriptor_preferences_updated(&self) -> i32 {
        self.timestamp_content_descriptor_preferences_updated.unwrap_or(0)
    }

    pub fn clear_timestamp_content_descriptor_preferences_updated(&mut self) {
        self.timestamp_content_descriptor_preferences_updated = ::std::option::Option::None;
    }

    pub fn has_timestamp_content_descriptor_preferences_updated(&self) -> bool {
        self.timestamp_content_descriptor_preferences_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp_content_descriptor_preferences_updated(&mut self, v: i32) {
        self.timestamp_content_descriptor_preferences_updated = ::std::option::Option::Some(v);
    }

    // optional .EProvideDeckFeedbackPreference provide_deck_feedback = 12;

    pub fn provide_deck_feedback(&self) -> super::enums::EProvideDeckFeedbackPreference {
        match self.provide_deck_feedback {
            Some(e) => e.enum_value_or(super::enums::EProvideDeckFeedbackPreference::k_EProvideDeckFeedbackPreference_Unset),
            None => super::enums::EProvideDeckFeedbackPreference::k_EProvideDeckFeedbackPreference_Unset,
        }
    }

    pub fn clear_provide_deck_feedback(&mut self) {
        self.provide_deck_feedback = ::std::option::Option::None;
    }

    pub fn has_provide_deck_feedback(&self) -> bool {
        self.provide_deck_feedback.is_some()
    }

    // Param is passed by value, moved
    pub fn set_provide_deck_feedback(&mut self, v: super::enums::EProvideDeckFeedbackPreference) {
        self.provide_deck_feedback = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string additional_languages = 13;

    pub fn additional_languages(&self) -> &str {
        match self.additional_languages.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_additional_languages(&mut self) {
        self.additional_languages = ::std::option::Option::None;
    }

    pub fn has_additional_languages(&self) -> bool {
        self.additional_languages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_additional_languages(&mut self, v: ::std::string::String) {
        self.additional_languages = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_additional_languages(&mut self) -> &mut ::std::string::String {
        if self.additional_languages.is_none() {
            self.additional_languages = ::std::option::Option::Some(::std::string::String::new());
        }
        self.additional_languages.as_mut().unwrap()
    }

    // Take field
    pub fn take_additional_languages(&mut self) -> ::std::string::String {
        self.additional_languages.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CStore_UserPreferences {
    const NAME: &'static str = "CStore_UserPreferences";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.primary_language = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.secondary_languages = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.platform_windows = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.platform_mac = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.platform_linux = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.timestamp_updated = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.hide_store_broadcast = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.review_score_preference = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                88 => {
                    self.timestamp_content_descriptor_preferences_updated = ::std::option::Option::Some(is.read_int32()?);
                },
                96 => {
                    self.provide_deck_feedback = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                106 => {
                    self.additional_languages = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.primary_language {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.secondary_languages {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.platform_windows {
            my_size += 1 + 1;
        }
        if let Some(v) = self.platform_mac {
            my_size += 1 + 1;
        }
        if let Some(v) = self.platform_linux {
            my_size += 1 + 1;
        }
        if let Some(v) = self.timestamp_updated {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.hide_store_broadcast {
            my_size += 1 + 1;
        }
        if let Some(v) = self.review_score_preference {
            my_size += ::protobuf::rt::int32_size(10, v.value());
        }
        if let Some(v) = self.timestamp_content_descriptor_preferences_updated {
            my_size += ::protobuf::rt::int32_size(11, v);
        }
        if let Some(v) = self.provide_deck_feedback {
            my_size += ::protobuf::rt::int32_size(12, v.value());
        }
        if let Some(v) = self.additional_languages.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.primary_language {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.secondary_languages {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.platform_windows {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.platform_mac {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.platform_linux {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.timestamp_updated {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.hide_store_broadcast {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.review_score_preference {
            os.write_enum(10, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.timestamp_content_descriptor_preferences_updated {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.provide_deck_feedback {
            os.write_enum(12, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.additional_languages.as_ref() {
            os.write_string(13, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_UserPreferences {
        CStore_UserPreferences::new()
    }

    fn clear(&mut self) {
        self.primary_language = ::std::option::Option::None;
        self.secondary_languages = ::std::option::Option::None;
        self.platform_windows = ::std::option::Option::None;
        self.platform_mac = ::std::option::Option::None;
        self.platform_linux = ::std::option::Option::None;
        self.timestamp_updated = ::std::option::Option::None;
        self.hide_store_broadcast = ::std::option::Option::None;
        self.review_score_preference = ::std::option::Option::None;
        self.timestamp_content_descriptor_preferences_updated = ::std::option::Option::None;
        self.provide_deck_feedback = ::std::option::Option::None;
        self.additional_languages = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_UserPreferences {
        static instance: CStore_UserPreferences = CStore_UserPreferences {
            primary_language: ::std::option::Option::None,
            secondary_languages: ::std::option::Option::None,
            platform_windows: ::std::option::Option::None,
            platform_mac: ::std::option::Option::None,
            platform_linux: ::std::option::Option::None,
            timestamp_updated: ::std::option::Option::None,
            hide_store_broadcast: ::std::option::Option::None,
            review_score_preference: ::std::option::Option::None,
            timestamp_content_descriptor_preferences_updated: ::std::option::Option::None,
            provide_deck_feedback: ::std::option::Option::None,
            additional_languages: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CStore_UserTagPreferences)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_UserTagPreferences {
    // message fields
    // @@protoc_insertion_point(field:CStore_UserTagPreferences.tags_to_exclude)
    pub tags_to_exclude: ::std::vec::Vec<cstore_user_tag_preferences::Tag>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_UserTagPreferences.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_UserTagPreferences {
    fn default() -> &'a CStore_UserTagPreferences {
        <CStore_UserTagPreferences as ::protobuf::Message>::default_instance()
    }
}

impl CStore_UserTagPreferences {
    pub fn new() -> CStore_UserTagPreferences {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CStore_UserTagPreferences {
    const NAME: &'static str = "CStore_UserTagPreferences";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.tags_to_exclude.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.tags_to_exclude {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.tags_to_exclude {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_UserTagPreferences {
        CStore_UserTagPreferences::new()
    }

    fn clear(&mut self) {
        self.tags_to_exclude.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_UserTagPreferences {
        static instance: CStore_UserTagPreferences = CStore_UserTagPreferences {
            tags_to_exclude: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CStore_UserTagPreferences`
pub mod cstore_user_tag_preferences {
    // @@protoc_insertion_point(message:CStore_UserTagPreferences.Tag)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Tag {
        // message fields
        // @@protoc_insertion_point(field:CStore_UserTagPreferences.Tag.tagid)
        pub tagid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CStore_UserTagPreferences.Tag.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CStore_UserTagPreferences.Tag.timestamp_added)
        pub timestamp_added: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CStore_UserTagPreferences.Tag.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Tag {
        fn default() -> &'a Tag {
            <Tag as ::protobuf::Message>::default_instance()
        }
    }

    impl Tag {
        pub fn new() -> Tag {
            ::std::default::Default::default()
        }

        // optional uint32 tagid = 1;

        pub fn tagid(&self) -> u32 {
            self.tagid.unwrap_or(0)
        }

        pub fn clear_tagid(&mut self) {
            self.tagid = ::std::option::Option::None;
        }

        pub fn has_tagid(&self) -> bool {
            self.tagid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tagid(&mut self, v: u32) {
            self.tagid = ::std::option::Option::Some(v);
        }

        // optional string name = 2;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 timestamp_added = 3;

        pub fn timestamp_added(&self) -> u32 {
            self.timestamp_added.unwrap_or(0)
        }

        pub fn clear_timestamp_added(&mut self) {
            self.timestamp_added = ::std::option::Option::None;
        }

        pub fn has_timestamp_added(&self) -> bool {
            self.timestamp_added.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp_added(&mut self, v: u32) {
            self.timestamp_added = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Tag {
        const NAME: &'static str = "Tag";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.tagid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.timestamp_added = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.tagid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.timestamp_added {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.tagid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.timestamp_added {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Tag {
            Tag::new()
        }

        fn clear(&mut self) {
            self.tagid = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.timestamp_added = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Tag {
            static instance: Tag = Tag {
                tagid: ::std::option::Option::None,
                name: ::std::option::Option::None,
                timestamp_added: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CStore_GetStorePreferences_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_GetStorePreferences_Response {
    // message fields
    // @@protoc_insertion_point(field:CStore_GetStorePreferences_Response.preferences)
    pub preferences: ::protobuf::MessageField<CStore_UserPreferences>,
    // @@protoc_insertion_point(field:CStore_GetStorePreferences_Response.tag_preferences)
    pub tag_preferences: ::protobuf::MessageField<CStore_UserTagPreferences>,
    // @@protoc_insertion_point(field:CStore_GetStorePreferences_Response.content_descriptor_preferences)
    pub content_descriptor_preferences: ::protobuf::MessageField<super::steammessages_base::UserContentDescriptorPreferences>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_GetStorePreferences_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_GetStorePreferences_Response {
    fn default() -> &'a CStore_GetStorePreferences_Response {
        <CStore_GetStorePreferences_Response as ::protobuf::Message>::default_instance()
    }
}

impl CStore_GetStorePreferences_Response {
    pub fn new() -> CStore_GetStorePreferences_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CStore_GetStorePreferences_Response {
    const NAME: &'static str = "CStore_GetStorePreferences_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.preferences)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.tag_preferences)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.content_descriptor_preferences)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.preferences.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.tag_preferences.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.content_descriptor_preferences.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.preferences.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.tag_preferences.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.content_descriptor_preferences.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_GetStorePreferences_Response {
        CStore_GetStorePreferences_Response::new()
    }

    fn clear(&mut self) {
        self.preferences.clear();
        self.tag_preferences.clear();
        self.content_descriptor_preferences.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_GetStorePreferences_Response {
        static instance: CStore_GetStorePreferences_Response = CStore_GetStorePreferences_Response {
            preferences: ::protobuf::MessageField::none(),
            tag_preferences: ::protobuf::MessageField::none(),
            content_descriptor_preferences: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Get trending apps among friends"]
// @@protoc_insertion_point(message:CStore_GetTrendingAppsAmongFriends_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_GetTrendingAppsAmongFriends_Request {
    // message fields
    // @@protoc_insertion_point(field:CStore_GetTrendingAppsAmongFriends_Request.num_apps)
    pub num_apps: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStore_GetTrendingAppsAmongFriends_Request.num_top_friends)
    pub num_top_friends: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_GetTrendingAppsAmongFriends_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_GetTrendingAppsAmongFriends_Request {
    fn default() -> &'a CStore_GetTrendingAppsAmongFriends_Request {
        <CStore_GetTrendingAppsAmongFriends_Request as ::protobuf::Message>::default_instance()
    }
}

impl CStore_GetTrendingAppsAmongFriends_Request {
    pub fn new() -> CStore_GetTrendingAppsAmongFriends_Request {
        ::std::default::Default::default()
    }

    // optional uint32 num_apps = 1;

    pub fn num_apps(&self) -> u32 {
        self.num_apps.unwrap_or(0)
    }

    pub fn clear_num_apps(&mut self) {
        self.num_apps = ::std::option::Option::None;
    }

    pub fn has_num_apps(&self) -> bool {
        self.num_apps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_apps(&mut self, v: u32) {
        self.num_apps = ::std::option::Option::Some(v);
    }

    // optional uint32 num_top_friends = 2;

    pub fn num_top_friends(&self) -> u32 {
        self.num_top_friends.unwrap_or(0)
    }

    pub fn clear_num_top_friends(&mut self) {
        self.num_top_friends = ::std::option::Option::None;
    }

    pub fn has_num_top_friends(&self) -> bool {
        self.num_top_friends.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_top_friends(&mut self, v: u32) {
        self.num_top_friends = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CStore_GetTrendingAppsAmongFriends_Request {
    const NAME: &'static str = "CStore_GetTrendingAppsAmongFriends_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.num_apps = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.num_top_friends = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.num_apps {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.num_top_friends {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.num_apps {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.num_top_friends {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_GetTrendingAppsAmongFriends_Request {
        CStore_GetTrendingAppsAmongFriends_Request::new()
    }

    fn clear(&mut self) {
        self.num_apps = ::std::option::Option::None;
        self.num_top_friends = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_GetTrendingAppsAmongFriends_Request {
        static instance: CStore_GetTrendingAppsAmongFriends_Request = CStore_GetTrendingAppsAmongFriends_Request {
            num_apps: ::std::option::Option::None,
            num_top_friends: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CStore_GetTrendingAppsAmongFriends_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_GetTrendingAppsAmongFriends_Response {
    // message fields
    // @@protoc_insertion_point(field:CStore_GetTrendingAppsAmongFriends_Response.trending_apps)
    pub trending_apps: ::std::vec::Vec<cstore_get_trending_apps_among_friends_response::TrendingAppData>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_GetTrendingAppsAmongFriends_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_GetTrendingAppsAmongFriends_Response {
    fn default() -> &'a CStore_GetTrendingAppsAmongFriends_Response {
        <CStore_GetTrendingAppsAmongFriends_Response as ::protobuf::Message>::default_instance()
    }
}

impl CStore_GetTrendingAppsAmongFriends_Response {
    pub fn new() -> CStore_GetTrendingAppsAmongFriends_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CStore_GetTrendingAppsAmongFriends_Response {
    const NAME: &'static str = "CStore_GetTrendingAppsAmongFriends_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.trending_apps.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.trending_apps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.trending_apps {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_GetTrendingAppsAmongFriends_Response {
        CStore_GetTrendingAppsAmongFriends_Response::new()
    }

    fn clear(&mut self) {
        self.trending_apps.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_GetTrendingAppsAmongFriends_Response {
        static instance: CStore_GetTrendingAppsAmongFriends_Response = CStore_GetTrendingAppsAmongFriends_Response {
            trending_apps: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CStore_GetTrendingAppsAmongFriends_Response`
pub mod cstore_get_trending_apps_among_friends_response {
    // @@protoc_insertion_point(message:CStore_GetTrendingAppsAmongFriends_Response.TrendingAppData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TrendingAppData {
        // message fields
        // @@protoc_insertion_point(field:CStore_GetTrendingAppsAmongFriends_Response.TrendingAppData.appid)
        pub appid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CStore_GetTrendingAppsAmongFriends_Response.TrendingAppData.steamids_top_friends)
        pub steamids_top_friends: ::std::vec::Vec<u64>,
        // @@protoc_insertion_point(field:CStore_GetTrendingAppsAmongFriends_Response.TrendingAppData.total_friends)
        pub total_friends: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CStore_GetTrendingAppsAmongFriends_Response.TrendingAppData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TrendingAppData {
        fn default() -> &'a TrendingAppData {
            <TrendingAppData as ::protobuf::Message>::default_instance()
        }
    }

    impl TrendingAppData {
        pub fn new() -> TrendingAppData {
            ::std::default::Default::default()
        }

        // optional uint32 appid = 1;

        pub fn appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }

        // optional uint32 total_friends = 3;

        pub fn total_friends(&self) -> u32 {
            self.total_friends.unwrap_or(0)
        }

        pub fn clear_total_friends(&mut self) {
            self.total_friends = ::std::option::Option::None;
        }

        pub fn has_total_friends(&self) -> bool {
            self.total_friends.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_friends(&mut self, v: u32) {
            self.total_friends = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for TrendingAppData {
        const NAME: &'static str = "TrendingAppData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        is.read_repeated_packed_uint64_into(&mut self.steamids_top_friends)?;
                    },
                    16 => {
                        self.steamids_top_friends.push(is.read_uint64()?);
                    },
                    24 => {
                        self.total_friends = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.appid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            for value in &self.steamids_top_friends {
                my_size += ::protobuf::rt::uint64_size(2, *value);
            };
            if let Some(v) = self.total_friends {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.appid {
                os.write_uint32(1, v)?;
            }
            for v in &self.steamids_top_friends {
                os.write_uint64(2, *v)?;
            };
            if let Some(v) = self.total_friends {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TrendingAppData {
            TrendingAppData::new()
        }

        fn clear(&mut self) {
            self.appid = ::std::option::Option::None;
            self.steamids_top_friends.clear();
            self.total_friends = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TrendingAppData {
            static instance: TrendingAppData = TrendingAppData {
                appid: ::std::option::Option::None,
                steamids_top_friends: ::std::vec::Vec::new(),
                total_friends: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

#[doc = "Upserts user feedback regarding the published Steam Deck Compatibility rating for a game"]
// @@protoc_insertion_point(message:CSteamDeckCompatibility_SetFeedback_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamDeckCompatibility_SetFeedback_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamDeckCompatibility_SetFeedback_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSteamDeckCompatibility_SetFeedback_Request.feedback)
    pub feedback: ::std::option::Option<::protobuf::EnumOrUnknown<super::enums::ESteamDeckCompatibilityFeedback>>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamDeckCompatibility_SetFeedback_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamDeckCompatibility_SetFeedback_Request {
    fn default() -> &'a CSteamDeckCompatibility_SetFeedback_Request {
        <CSteamDeckCompatibility_SetFeedback_Request as ::protobuf::Message>::default_instance()
    }
}

impl CSteamDeckCompatibility_SetFeedback_Request {
    pub fn new() -> CSteamDeckCompatibility_SetFeedback_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional .ESteamDeckCompatibilityFeedback feedback = 2;

    pub fn feedback(&self) -> super::enums::ESteamDeckCompatibilityFeedback {
        match self.feedback {
            Some(e) => e.enum_value_or(super::enums::ESteamDeckCompatibilityFeedback::k_ESteamDeckCompatibilityFeedback_Unset),
            None => super::enums::ESteamDeckCompatibilityFeedback::k_ESteamDeckCompatibilityFeedback_Unset,
        }
    }

    pub fn clear_feedback(&mut self) {
        self.feedback = ::std::option::Option::None;
    }

    pub fn has_feedback(&self) -> bool {
        self.feedback.is_some()
    }

    // Param is passed by value, moved
    pub fn set_feedback(&mut self, v: super::enums::ESteamDeckCompatibilityFeedback) {
        self.feedback = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::protobuf::Message for CSteamDeckCompatibility_SetFeedback_Request {
    const NAME: &'static str = "CSteamDeckCompatibility_SetFeedback_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.feedback = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.feedback {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.feedback {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamDeckCompatibility_SetFeedback_Request {
        CSteamDeckCompatibility_SetFeedback_Request::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.feedback = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamDeckCompatibility_SetFeedback_Request {
        static instance: CSteamDeckCompatibility_SetFeedback_Request = CSteamDeckCompatibility_SetFeedback_Request {
            appid: ::std::option::Option::None,
            feedback: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamDeckCompatibility_SetFeedback_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamDeckCompatibility_SetFeedback_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CSteamDeckCompatibility_SetFeedback_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamDeckCompatibility_SetFeedback_Response {
    fn default() -> &'a CSteamDeckCompatibility_SetFeedback_Response {
        <CSteamDeckCompatibility_SetFeedback_Response as ::protobuf::Message>::default_instance()
    }
}

impl CSteamDeckCompatibility_SetFeedback_Response {
    pub fn new() -> CSteamDeckCompatibility_SetFeedback_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CSteamDeckCompatibility_SetFeedback_Response {
    const NAME: &'static str = "CSteamDeckCompatibility_SetFeedback_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamDeckCompatibility_SetFeedback_Response {
        CSteamDeckCompatibility_SetFeedback_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamDeckCompatibility_SetFeedback_Response {
        static instance: CSteamDeckCompatibility_SetFeedback_Response = CSteamDeckCompatibility_SetFeedback_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Returns whether we should ask the user if the compatibility rating is correct"]
// @@protoc_insertion_point(message:CSteamDeckCompatibility_ShouldPrompt_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamDeckCompatibility_ShouldPrompt_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamDeckCompatibility_ShouldPrompt_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamDeckCompatibility_ShouldPrompt_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamDeckCompatibility_ShouldPrompt_Request {
    fn default() -> &'a CSteamDeckCompatibility_ShouldPrompt_Request {
        <CSteamDeckCompatibility_ShouldPrompt_Request as ::protobuf::Message>::default_instance()
    }
}

impl CSteamDeckCompatibility_ShouldPrompt_Request {
    pub fn new() -> CSteamDeckCompatibility_ShouldPrompt_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSteamDeckCompatibility_ShouldPrompt_Request {
    const NAME: &'static str = "CSteamDeckCompatibility_ShouldPrompt_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamDeckCompatibility_ShouldPrompt_Request {
        CSteamDeckCompatibility_ShouldPrompt_Request::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamDeckCompatibility_ShouldPrompt_Request {
        static instance: CSteamDeckCompatibility_ShouldPrompt_Request = CSteamDeckCompatibility_ShouldPrompt_Request {
            appid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamDeckCompatibility_ShouldPrompt_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamDeckCompatibility_ShouldPrompt_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamDeckCompatibility_ShouldPrompt_Response.prompt)
    pub prompt: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamDeckCompatibility_ShouldPrompt_Response.feedback_eligible)
    pub feedback_eligible: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamDeckCompatibility_ShouldPrompt_Response.existing_feedback)
    pub existing_feedback: ::std::option::Option<::protobuf::EnumOrUnknown<super::enums::ESteamDeckCompatibilityFeedback>>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamDeckCompatibility_ShouldPrompt_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamDeckCompatibility_ShouldPrompt_Response {
    fn default() -> &'a CSteamDeckCompatibility_ShouldPrompt_Response {
        <CSteamDeckCompatibility_ShouldPrompt_Response as ::protobuf::Message>::default_instance()
    }
}

impl CSteamDeckCompatibility_ShouldPrompt_Response {
    pub fn new() -> CSteamDeckCompatibility_ShouldPrompt_Response {
        ::std::default::Default::default()
    }

    // optional bool prompt = 1;

    pub fn prompt(&self) -> bool {
        self.prompt.unwrap_or(false)
    }

    pub fn clear_prompt(&mut self) {
        self.prompt = ::std::option::Option::None;
    }

    pub fn has_prompt(&self) -> bool {
        self.prompt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prompt(&mut self, v: bool) {
        self.prompt = ::std::option::Option::Some(v);
    }

    // optional bool feedback_eligible = 2;

    pub fn feedback_eligible(&self) -> bool {
        self.feedback_eligible.unwrap_or(false)
    }

    pub fn clear_feedback_eligible(&mut self) {
        self.feedback_eligible = ::std::option::Option::None;
    }

    pub fn has_feedback_eligible(&self) -> bool {
        self.feedback_eligible.is_some()
    }

    // Param is passed by value, moved
    pub fn set_feedback_eligible(&mut self, v: bool) {
        self.feedback_eligible = ::std::option::Option::Some(v);
    }

    // optional .ESteamDeckCompatibilityFeedback existing_feedback = 3;

    pub fn existing_feedback(&self) -> super::enums::ESteamDeckCompatibilityFeedback {
        match self.existing_feedback {
            Some(e) => e.enum_value_or(super::enums::ESteamDeckCompatibilityFeedback::k_ESteamDeckCompatibilityFeedback_Unset),
            None => super::enums::ESteamDeckCompatibilityFeedback::k_ESteamDeckCompatibilityFeedback_Unset,
        }
    }

    pub fn clear_existing_feedback(&mut self) {
        self.existing_feedback = ::std::option::Option::None;
    }

    pub fn has_existing_feedback(&self) -> bool {
        self.existing_feedback.is_some()
    }

    // Param is passed by value, moved
    pub fn set_existing_feedback(&mut self, v: super::enums::ESteamDeckCompatibilityFeedback) {
        self.existing_feedback = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::protobuf::Message for CSteamDeckCompatibility_ShouldPrompt_Response {
    const NAME: &'static str = "CSteamDeckCompatibility_ShouldPrompt_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.prompt = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.feedback_eligible = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.existing_feedback = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.prompt {
            my_size += 1 + 1;
        }
        if let Some(v) = self.feedback_eligible {
            my_size += 1 + 1;
        }
        if let Some(v) = self.existing_feedback {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.prompt {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.feedback_eligible {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.existing_feedback {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamDeckCompatibility_ShouldPrompt_Response {
        CSteamDeckCompatibility_ShouldPrompt_Response::new()
    }

    fn clear(&mut self) {
        self.prompt = ::std::option::Option::None;
        self.feedback_eligible = ::std::option::Option::None;
        self.existing_feedback = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamDeckCompatibility_ShouldPrompt_Response {
        static instance: CSteamDeckCompatibility_ShouldPrompt_Response = CSteamDeckCompatibility_ShouldPrompt_Response {
            prompt: ::std::option::Option::None,
            feedback_eligible: ::std::option::Option::None,
            existing_feedback: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Notification from server to client that the user's store preferences have changed"]
// @@protoc_insertion_point(message:CStore_StorePreferencesChanged_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStore_StorePreferencesChanged_Notification {
    // message fields
    // @@protoc_insertion_point(field:CStore_StorePreferencesChanged_Notification.preferences)
    pub preferences: ::protobuf::MessageField<CStore_UserPreferences>,
    // @@protoc_insertion_point(field:CStore_StorePreferencesChanged_Notification.tag_preferences)
    pub tag_preferences: ::protobuf::MessageField<CStore_UserTagPreferences>,
    // @@protoc_insertion_point(field:CStore_StorePreferencesChanged_Notification.content_descriptor_preferences)
    pub content_descriptor_preferences: ::protobuf::MessageField<super::steammessages_base::UserContentDescriptorPreferences>,
    // special fields
    // @@protoc_insertion_point(special_field:CStore_StorePreferencesChanged_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStore_StorePreferencesChanged_Notification {
    fn default() -> &'a CStore_StorePreferencesChanged_Notification {
        <CStore_StorePreferencesChanged_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CStore_StorePreferencesChanged_Notification {
    pub fn new() -> CStore_StorePreferencesChanged_Notification {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CStore_StorePreferencesChanged_Notification {
    const NAME: &'static str = "CStore_StorePreferencesChanged_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.preferences)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.tag_preferences)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.content_descriptor_preferences)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.preferences.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.tag_preferences.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.content_descriptor_preferences.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.preferences.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.tag_preferences.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.content_descriptor_preferences.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStore_StorePreferencesChanged_Notification {
        CStore_StorePreferencesChanged_Notification::new()
    }

    fn clear(&mut self) {
        self.preferences.clear();
        self.tag_preferences.clear();
        self.content_descriptor_preferences.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStore_StorePreferencesChanged_Notification {
        static instance: CStore_StorePreferencesChanged_Notification = CStore_StorePreferencesChanged_Notification {
            preferences: ::protobuf::MessageField::none(),
            tag_preferences: ::protobuf::MessageField::none(),
            content_descriptor_preferences: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStoreDiscoveryQueueType)
pub enum EStoreDiscoveryQueueType {
    // @@protoc_insertion_point(enum_value:EStoreDiscoveryQueueType.k_EStoreDiscoveryQueueTypeNew)
    k_EStoreDiscoveryQueueTypeNew = 0,
    // @@protoc_insertion_point(enum_value:EStoreDiscoveryQueueType.k_EStoreDiscoveryQueueTypeComingSoon)
    k_EStoreDiscoveryQueueTypeComingSoon = 1,
    // @@protoc_insertion_point(enum_value:EStoreDiscoveryQueueType.k_EStoreDiscoveryQueueTypeRecommended)
    k_EStoreDiscoveryQueueTypeRecommended = 2,
    // @@protoc_insertion_point(enum_value:EStoreDiscoveryQueueType.k_EStoreDiscoveryQueueTypeEveryNewRelease)
    k_EStoreDiscoveryQueueTypeEveryNewRelease = 3,
    // @@protoc_insertion_point(enum_value:EStoreDiscoveryQueueType.k_EStoreDiscoveryQueueTypeMLRecommender)
    k_EStoreDiscoveryQueueTypeMLRecommender = 5,
    // @@protoc_insertion_point(enum_value:EStoreDiscoveryQueueType.k_EStoreDiscoveryQueueTypeWishlistOnSale)
    k_EStoreDiscoveryQueueTypeWishlistOnSale = 6,
    // @@protoc_insertion_point(enum_value:EStoreDiscoveryQueueType.k_EStoreDiscoveryQueueTypeDLC)
    k_EStoreDiscoveryQueueTypeDLC = 7,
    // @@protoc_insertion_point(enum_value:EStoreDiscoveryQueueType.k_EStoreDiscoveryQueueTypeDLCOnSale)
    k_EStoreDiscoveryQueueTypeDLCOnSale = 8,
    // @@protoc_insertion_point(enum_value:EStoreDiscoveryQueueType.k_EStoreDiscoveryQueueTypeRecommendedComingSoon)
    k_EStoreDiscoveryQueueTypeRecommendedComingSoon = 9,
    // @@protoc_insertion_point(enum_value:EStoreDiscoveryQueueType.k_EStoreDiscoveryQueueTypeRecommendedFree)
    k_EStoreDiscoveryQueueTypeRecommendedFree = 10,
    // @@protoc_insertion_point(enum_value:EStoreDiscoveryQueueType.k_EStoreDiscoveryQueueTypeRecommendedOnSale)
    k_EStoreDiscoveryQueueTypeRecommendedOnSale = 11,
    // @@protoc_insertion_point(enum_value:EStoreDiscoveryQueueType.k_EStoreDiscoveryQueueTypeRecommendedDemos)
    k_EStoreDiscoveryQueueTypeRecommendedDemos = 12,
    // @@protoc_insertion_point(enum_value:EStoreDiscoveryQueueType.k_EStoreDiscoveryQueueTypeDLCNewReleases)
    k_EStoreDiscoveryQueueTypeDLCNewReleases = 13,
    // @@protoc_insertion_point(enum_value:EStoreDiscoveryQueueType.k_EStoreDiscoveryQueueTypeDLCTopSellers)
    k_EStoreDiscoveryQueueTypeDLCTopSellers = 14,
    // @@protoc_insertion_point(enum_value:EStoreDiscoveryQueueType.k_EStoreDiscoveryQueueTypeMAX)
    k_EStoreDiscoveryQueueTypeMAX = 15,
}

impl ::protobuf::Enum for EStoreDiscoveryQueueType {
    const NAME: &'static str = "EStoreDiscoveryQueueType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStoreDiscoveryQueueType> {
        match value {
            0 => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeNew),
            1 => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeComingSoon),
            2 => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeRecommended),
            3 => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeEveryNewRelease),
            5 => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeMLRecommender),
            6 => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeWishlistOnSale),
            7 => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeDLC),
            8 => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeDLCOnSale),
            9 => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeRecommendedComingSoon),
            10 => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeRecommendedFree),
            11 => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeRecommendedOnSale),
            12 => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeRecommendedDemos),
            13 => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeDLCNewReleases),
            14 => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeDLCTopSellers),
            15 => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeMAX),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStoreDiscoveryQueueType> {
        match str {
            "k_EStoreDiscoveryQueueTypeNew" => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeNew),
            "k_EStoreDiscoveryQueueTypeComingSoon" => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeComingSoon),
            "k_EStoreDiscoveryQueueTypeRecommended" => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeRecommended),
            "k_EStoreDiscoveryQueueTypeEveryNewRelease" => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeEveryNewRelease),
            "k_EStoreDiscoveryQueueTypeMLRecommender" => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeMLRecommender),
            "k_EStoreDiscoveryQueueTypeWishlistOnSale" => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeWishlistOnSale),
            "k_EStoreDiscoveryQueueTypeDLC" => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeDLC),
            "k_EStoreDiscoveryQueueTypeDLCOnSale" => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeDLCOnSale),
            "k_EStoreDiscoveryQueueTypeRecommendedComingSoon" => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeRecommendedComingSoon),
            "k_EStoreDiscoveryQueueTypeRecommendedFree" => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeRecommendedFree),
            "k_EStoreDiscoveryQueueTypeRecommendedOnSale" => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeRecommendedOnSale),
            "k_EStoreDiscoveryQueueTypeRecommendedDemos" => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeRecommendedDemos),
            "k_EStoreDiscoveryQueueTypeDLCNewReleases" => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeDLCNewReleases),
            "k_EStoreDiscoveryQueueTypeDLCTopSellers" => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeDLCTopSellers),
            "k_EStoreDiscoveryQueueTypeMAX" => ::std::option::Option::Some(EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeMAX),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStoreDiscoveryQueueType] = &[
        EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeNew,
        EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeComingSoon,
        EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeRecommended,
        EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeEveryNewRelease,
        EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeMLRecommender,
        EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeWishlistOnSale,
        EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeDLC,
        EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeDLCOnSale,
        EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeRecommendedComingSoon,
        EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeRecommendedFree,
        EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeRecommendedOnSale,
        EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeRecommendedDemos,
        EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeDLCNewReleases,
        EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeDLCTopSellers,
        EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeMAX,
    ];
}

impl ::std::default::Default for EStoreDiscoveryQueueType {
    fn default() -> Self {
        EStoreDiscoveryQueueType::k_EStoreDiscoveryQueueTypeNew
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EPlaytestStatus)
pub enum EPlaytestStatus {
    // @@protoc_insertion_point(enum_value:EPlaytestStatus.k_ETesterStatusNone)
    k_ETesterStatusNone = 0,
    // @@protoc_insertion_point(enum_value:EPlaytestStatus.k_ETesterStatusPending)
    k_ETesterStatusPending = 1,
    // @@protoc_insertion_point(enum_value:EPlaytestStatus.k_ETesterStatusInvited)
    k_ETesterStatusInvited = 2,
    // @@protoc_insertion_point(enum_value:EPlaytestStatus.k_ETesterStatusGranted)
    k_ETesterStatusGranted = 3,
}

impl ::protobuf::Enum for EPlaytestStatus {
    const NAME: &'static str = "EPlaytestStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EPlaytestStatus> {
        match value {
            0 => ::std::option::Option::Some(EPlaytestStatus::k_ETesterStatusNone),
            1 => ::std::option::Option::Some(EPlaytestStatus::k_ETesterStatusPending),
            2 => ::std::option::Option::Some(EPlaytestStatus::k_ETesterStatusInvited),
            3 => ::std::option::Option::Some(EPlaytestStatus::k_ETesterStatusGranted),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EPlaytestStatus> {
        match str {
            "k_ETesterStatusNone" => ::std::option::Option::Some(EPlaytestStatus::k_ETesterStatusNone),
            "k_ETesterStatusPending" => ::std::option::Option::Some(EPlaytestStatus::k_ETesterStatusPending),
            "k_ETesterStatusInvited" => ::std::option::Option::Some(EPlaytestStatus::k_ETesterStatusInvited),
            "k_ETesterStatusGranted" => ::std::option::Option::Some(EPlaytestStatus::k_ETesterStatusGranted),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EPlaytestStatus] = &[
        EPlaytestStatus::k_ETesterStatusNone,
        EPlaytestStatus::k_ETesterStatusPending,
        EPlaytestStatus::k_ETesterStatusInvited,
        EPlaytestStatus::k_ETesterStatusGranted,
    ];
}

impl ::std::default::Default for EPlaytestStatus {
    fn default() -> Self {
        EPlaytestStatus::k_ETesterStatusNone
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EUserReviewScorePreference)
pub enum EUserReviewScorePreference {
    // @@protoc_insertion_point(enum_value:EUserReviewScorePreference.k_EUserReviewScorePreference_Unset)
    k_EUserReviewScorePreference_Unset = 0,
    // @@protoc_insertion_point(enum_value:EUserReviewScorePreference.k_EUserReviewScorePreference_IncludeAll)
    k_EUserReviewScorePreference_IncludeAll = 1,
    // @@protoc_insertion_point(enum_value:EUserReviewScorePreference.k_EUserReviewScorePreference_ExcludeBombs)
    k_EUserReviewScorePreference_ExcludeBombs = 2,
}

impl ::protobuf::Enum for EUserReviewScorePreference {
    const NAME: &'static str = "EUserReviewScorePreference";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EUserReviewScorePreference> {
        match value {
            0 => ::std::option::Option::Some(EUserReviewScorePreference::k_EUserReviewScorePreference_Unset),
            1 => ::std::option::Option::Some(EUserReviewScorePreference::k_EUserReviewScorePreference_IncludeAll),
            2 => ::std::option::Option::Some(EUserReviewScorePreference::k_EUserReviewScorePreference_ExcludeBombs),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EUserReviewScorePreference> {
        match str {
            "k_EUserReviewScorePreference_Unset" => ::std::option::Option::Some(EUserReviewScorePreference::k_EUserReviewScorePreference_Unset),
            "k_EUserReviewScorePreference_IncludeAll" => ::std::option::Option::Some(EUserReviewScorePreference::k_EUserReviewScorePreference_IncludeAll),
            "k_EUserReviewScorePreference_ExcludeBombs" => ::std::option::Option::Some(EUserReviewScorePreference::k_EUserReviewScorePreference_ExcludeBombs),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EUserReviewScorePreference] = &[
        EUserReviewScorePreference::k_EUserReviewScorePreference_Unset,
        EUserReviewScorePreference::k_EUserReviewScorePreference_IncludeAll,
        EUserReviewScorePreference::k_EUserReviewScorePreference_ExcludeBombs,
    ];
}

impl ::std::default::Default for EUserReviewScorePreference {
    fn default() -> Self {
        EUserReviewScorePreference::k_EUserReviewScorePreference_Unset
    }
}

#[allow(unused_imports)]
use crate::steammessages_base::*;
#[allow(unused_imports)]
use crate::steammessages_unified_base_steamclient::*;
#[allow(unused_imports)]
use crate::contenthubs::*;
#[allow(unused_imports)]
use crate::enums::*;
impl crate::RpcMessage for CStore_RegisterCDKey_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStore_PurchaseReceiptInfo {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStore_RegisterCDKey_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStore_GetMostPopularTags_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStore_GetMostPopularTags_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStore_GetLocalizedNameForTags_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStore_GetLocalizedNameForTags_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStore_GetTagList_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStore_GetTagList_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStoreDiscoveryQueueSettings {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStore_GetDiscoveryQueue_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStore_GetDiscoveryQueue_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStore_GetDiscoveryQueueSettings_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStore_GetDiscoveryQueueSettings_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStore_SkipDiscoveryQueueItem_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStore_SkipDiscoveryQueueItem_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStore_GetUserGameInterestState_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStore_GetUserGameInterestState_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStore_GetDiscoveryQueueSkippedApps_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStore_GetDiscoveryQueueSkippedApps_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStore_GetStorePreferences_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStore_UserPreferences {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStore_UserTagPreferences {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStore_GetStorePreferences_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStore_GetTrendingAppsAmongFriends_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStore_GetTrendingAppsAmongFriends_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamDeckCompatibility_SetFeedback_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamDeckCompatibility_SetFeedback_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamDeckCompatibility_ShouldPrompt_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamDeckCompatibility_ShouldPrompt_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStore_StorePreferencesChanged_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
///A service to access store data.
struct Store {}
impl crate::RpcService for Store {
    const SERVICE_NAME: &'static str = "Store";
}
///Steam store to client notifications
struct StoreClient {}
impl crate::RpcService for StoreClient {
    const SERVICE_NAME: &'static str = "StoreClient";
}
impl crate::RpcMethod for CSteamDeckCompatibility_SetFeedback_Request {
    const METHOD_NAME: &'static str = "Store.SetCompatibilityFeedback#1";
    type Response = CSteamDeckCompatibility_SetFeedback_Response;
}
impl crate::RpcMethod for CSteamDeckCompatibility_ShouldPrompt_Request {
    const METHOD_NAME: &'static str = "Store.ShouldPromptForCompatibilityFeedback#1";
    type Response = CSteamDeckCompatibility_ShouldPrompt_Response;
}
impl crate::RpcMethod for CStore_GetDiscoveryQueueSettings_Request {
    const METHOD_NAME: &'static str = "Store.GetDiscoveryQueueSettings#1";
    type Response = CStore_GetDiscoveryQueueSettings_Response;
}
impl crate::RpcMethod for CStore_GetDiscoveryQueueSkippedApps_Request {
    const METHOD_NAME: &'static str = "Store.GetDiscoveryQueueSkippedApps#1";
    type Response = CStore_GetDiscoveryQueueSkippedApps_Response;
}
impl crate::RpcMethod for CStore_GetDiscoveryQueue_Request {
    const METHOD_NAME: &'static str = "Store.GetDiscoveryQueue#1";
    type Response = CStore_GetDiscoveryQueue_Response;
}
impl crate::RpcMethod for CStore_GetLocalizedNameForTags_Request {
    const METHOD_NAME: &'static str = "Store.GetLocalizedNameForTags#1";
    type Response = CStore_GetLocalizedNameForTags_Response;
}
impl crate::RpcMethod for CStore_GetMostPopularTags_Request {
    const METHOD_NAME: &'static str = "Store.GetMostPopularTags#1";
    type Response = CStore_GetMostPopularTags_Response;
}
impl crate::RpcMethod for CStore_GetStorePreferences_Request {
    const METHOD_NAME: &'static str = "Store.GetStorePreferences#1";
    type Response = CStore_GetStorePreferences_Response;
}
impl crate::RpcMethod for CStore_GetTagList_Request {
    const METHOD_NAME: &'static str = "Store.GetTagList#1";
    type Response = CStore_GetTagList_Response;
}
impl crate::RpcMethod for CStore_GetTrendingAppsAmongFriends_Request {
    const METHOD_NAME: &'static str = "Store.GetTrendingAppsAmongFriends#1";
    type Response = CStore_GetTrendingAppsAmongFriends_Response;
}
impl crate::RpcMethod for CStore_GetUserGameInterestState_Request {
    const METHOD_NAME: &'static str = "Store.GetUserGameInterestState#1";
    type Response = CStore_GetUserGameInterestState_Response;
}
impl crate::RpcMethod for CStore_RegisterCDKey_Request {
    const METHOD_NAME: &'static str = "Store.RegisterCDKey#1";
    type Response = CStore_RegisterCDKey_Response;
}
impl crate::RpcMethod for CStore_SkipDiscoveryQueueItem_Request {
    const METHOD_NAME: &'static str = "Store.SkipDiscoveryQueueItem#1";
    type Response = CStore_SkipDiscoveryQueueItem_Response;
}
impl crate::RpcMethod for CStore_StorePreferencesChanged_Notification {
    const METHOD_NAME: &'static str = "StoreClient.NotifyStorePreferencesChanged#1";
    type Response = ();
}
