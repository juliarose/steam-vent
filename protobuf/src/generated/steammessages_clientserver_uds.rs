// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_clientserver_uds.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:CMsgClientUDSP2PSessionStarted)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUDSP2PSessionStarted {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUDSP2PSessionStarted.steamid_remote)
    pub steamid_remote: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUDSP2PSessionStarted.appid)
    pub appid: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUDSP2PSessionStarted.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUDSP2PSessionStarted {
    fn default() -> &'a CMsgClientUDSP2PSessionStarted {
        <CMsgClientUDSP2PSessionStarted as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUDSP2PSessionStarted {
    pub fn new() -> CMsgClientUDSP2PSessionStarted {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_remote = 1;

    pub fn steamid_remote(&self) -> u64 {
        self.steamid_remote.unwrap_or(0)
    }

    pub fn clear_steamid_remote(&mut self) {
        self.steamid_remote = ::std::option::Option::None;
    }

    pub fn has_steamid_remote(&self) -> bool {
        self.steamid_remote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_remote(&mut self, v: u64) {
        self.steamid_remote = ::std::option::Option::Some(v);
    }

    // optional int32 appid = 2;

    pub fn appid(&self) -> i32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: i32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUDSP2PSessionStarted {
    const NAME: &'static str = "CMsgClientUDSP2PSessionStarted";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid_remote = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.appid = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_remote {
            my_size += 1 + 8;
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid_remote {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.appid {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUDSP2PSessionStarted {
        CMsgClientUDSP2PSessionStarted::new()
    }

    fn clear(&mut self) {
        self.steamid_remote = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUDSP2PSessionStarted {
        static instance: CMsgClientUDSP2PSessionStarted = CMsgClientUDSP2PSessionStarted {
            steamid_remote: ::std::option::Option::None,
            appid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientUDSP2PSessionEnded)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUDSP2PSessionEnded {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUDSP2PSessionEnded.steamid_remote)
    pub steamid_remote: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUDSP2PSessionEnded.appid)
    pub appid: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUDSP2PSessionEnded.session_length_sec)
    pub session_length_sec: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUDSP2PSessionEnded.session_error)
    pub session_error: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUDSP2PSessionEnded.nattype)
    pub nattype: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUDSP2PSessionEnded.bytes_recv)
    pub bytes_recv: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUDSP2PSessionEnded.bytes_sent)
    pub bytes_sent: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUDSP2PSessionEnded.bytes_sent_relay)
    pub bytes_sent_relay: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUDSP2PSessionEnded.bytes_recv_relay)
    pub bytes_recv_relay: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUDSP2PSessionEnded.time_to_connect_ms)
    pub time_to_connect_ms: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUDSP2PSessionEnded.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUDSP2PSessionEnded {
    fn default() -> &'a CMsgClientUDSP2PSessionEnded {
        <CMsgClientUDSP2PSessionEnded as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUDSP2PSessionEnded {
    pub fn new() -> CMsgClientUDSP2PSessionEnded {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_remote = 1;

    pub fn steamid_remote(&self) -> u64 {
        self.steamid_remote.unwrap_or(0)
    }

    pub fn clear_steamid_remote(&mut self) {
        self.steamid_remote = ::std::option::Option::None;
    }

    pub fn has_steamid_remote(&self) -> bool {
        self.steamid_remote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_remote(&mut self, v: u64) {
        self.steamid_remote = ::std::option::Option::Some(v);
    }

    // optional int32 appid = 2;

    pub fn appid(&self) -> i32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: i32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional int32 session_length_sec = 3;

    pub fn session_length_sec(&self) -> i32 {
        self.session_length_sec.unwrap_or(0)
    }

    pub fn clear_session_length_sec(&mut self) {
        self.session_length_sec = ::std::option::Option::None;
    }

    pub fn has_session_length_sec(&self) -> bool {
        self.session_length_sec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_length_sec(&mut self, v: i32) {
        self.session_length_sec = ::std::option::Option::Some(v);
    }

    // optional int32 session_error = 4;

    pub fn session_error(&self) -> i32 {
        self.session_error.unwrap_or(0)
    }

    pub fn clear_session_error(&mut self) {
        self.session_error = ::std::option::Option::None;
    }

    pub fn has_session_error(&self) -> bool {
        self.session_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_error(&mut self, v: i32) {
        self.session_error = ::std::option::Option::Some(v);
    }

    // optional int32 nattype = 5;

    pub fn nattype(&self) -> i32 {
        self.nattype.unwrap_or(0)
    }

    pub fn clear_nattype(&mut self) {
        self.nattype = ::std::option::Option::None;
    }

    pub fn has_nattype(&self) -> bool {
        self.nattype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nattype(&mut self, v: i32) {
        self.nattype = ::std::option::Option::Some(v);
    }

    // optional int32 bytes_recv = 6;

    pub fn bytes_recv(&self) -> i32 {
        self.bytes_recv.unwrap_or(0)
    }

    pub fn clear_bytes_recv(&mut self) {
        self.bytes_recv = ::std::option::Option::None;
    }

    pub fn has_bytes_recv(&self) -> bool {
        self.bytes_recv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_recv(&mut self, v: i32) {
        self.bytes_recv = ::std::option::Option::Some(v);
    }

    // optional int32 bytes_sent = 7;

    pub fn bytes_sent(&self) -> i32 {
        self.bytes_sent.unwrap_or(0)
    }

    pub fn clear_bytes_sent(&mut self) {
        self.bytes_sent = ::std::option::Option::None;
    }

    pub fn has_bytes_sent(&self) -> bool {
        self.bytes_sent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_sent(&mut self, v: i32) {
        self.bytes_sent = ::std::option::Option::Some(v);
    }

    // optional int32 bytes_sent_relay = 8;

    pub fn bytes_sent_relay(&self) -> i32 {
        self.bytes_sent_relay.unwrap_or(0)
    }

    pub fn clear_bytes_sent_relay(&mut self) {
        self.bytes_sent_relay = ::std::option::Option::None;
    }

    pub fn has_bytes_sent_relay(&self) -> bool {
        self.bytes_sent_relay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_sent_relay(&mut self, v: i32) {
        self.bytes_sent_relay = ::std::option::Option::Some(v);
    }

    // optional int32 bytes_recv_relay = 9;

    pub fn bytes_recv_relay(&self) -> i32 {
        self.bytes_recv_relay.unwrap_or(0)
    }

    pub fn clear_bytes_recv_relay(&mut self) {
        self.bytes_recv_relay = ::std::option::Option::None;
    }

    pub fn has_bytes_recv_relay(&self) -> bool {
        self.bytes_recv_relay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_recv_relay(&mut self, v: i32) {
        self.bytes_recv_relay = ::std::option::Option::Some(v);
    }

    // optional int32 time_to_connect_ms = 10;

    pub fn time_to_connect_ms(&self) -> i32 {
        self.time_to_connect_ms.unwrap_or(0)
    }

    pub fn clear_time_to_connect_ms(&mut self) {
        self.time_to_connect_ms = ::std::option::Option::None;
    }

    pub fn has_time_to_connect_ms(&self) -> bool {
        self.time_to_connect_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_to_connect_ms(&mut self, v: i32) {
        self.time_to_connect_ms = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUDSP2PSessionEnded {
    const NAME: &'static str = "CMsgClientUDSP2PSessionEnded";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid_remote = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.appid = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.session_length_sec = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.session_error = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.nattype = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.bytes_recv = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.bytes_sent = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.bytes_sent_relay = ::std::option::Option::Some(is.read_int32()?);
                },
                72 => {
                    self.bytes_recv_relay = ::std::option::Option::Some(is.read_int32()?);
                },
                80 => {
                    self.time_to_connect_ms = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_remote {
            my_size += 1 + 8;
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.session_length_sec {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.session_error {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.nattype {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.bytes_recv {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.bytes_sent {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.bytes_sent_relay {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.bytes_recv_relay {
            my_size += ::protobuf::rt::int32_size(9, v);
        }
        if let Some(v) = self.time_to_connect_ms {
            my_size += ::protobuf::rt::int32_size(10, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid_remote {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.appid {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.session_length_sec {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.session_error {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.nattype {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.bytes_recv {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.bytes_sent {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.bytes_sent_relay {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.bytes_recv_relay {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.time_to_connect_ms {
            os.write_int32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUDSP2PSessionEnded {
        CMsgClientUDSP2PSessionEnded::new()
    }

    fn clear(&mut self) {
        self.steamid_remote = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.session_length_sec = ::std::option::Option::None;
        self.session_error = ::std::option::Option::None;
        self.nattype = ::std::option::Option::None;
        self.bytes_recv = ::std::option::Option::None;
        self.bytes_sent = ::std::option::Option::None;
        self.bytes_sent_relay = ::std::option::Option::None;
        self.bytes_recv_relay = ::std::option::Option::None;
        self.time_to_connect_ms = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUDSP2PSessionEnded {
        static instance: CMsgClientUDSP2PSessionEnded = CMsgClientUDSP2PSessionEnded {
            steamid_remote: ::std::option::Option::None,
            appid: ::std::option::Option::None,
            session_length_sec: ::std::option::Option::None,
            session_error: ::std::option::Option::None,
            nattype: ::std::option::Option::None,
            bytes_recv: ::std::option::Option::None,
            bytes_sent: ::std::option::Option::None,
            bytes_sent_relay: ::std::option::Option::None,
            bytes_recv_relay: ::std::option::Option::None,
            time_to_connect_ms: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientGetClientDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGetClientDetails {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetClientDetails.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetClientDetails {
    fn default() -> &'a CMsgClientGetClientDetails {
        <CMsgClientGetClientDetails as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetClientDetails {
    pub fn new() -> CMsgClientGetClientDetails {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientGetClientDetails {
    const NAME: &'static str = "CMsgClientGetClientDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetClientDetails {
        CMsgClientGetClientDetails::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetClientDetails {
        static instance: CMsgClientGetClientDetails = CMsgClientGetClientDetails {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientGetClientDetailsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGetClientDetailsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGetClientDetailsResponse.package_version)
    pub package_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientGetClientDetailsResponse.os)
    pub os: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientGetClientDetailsResponse.machine_name)
    pub machine_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientGetClientDetailsResponse.ip_public)
    pub ip_public: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientGetClientDetailsResponse.ip_private)
    pub ip_private: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientGetClientDetailsResponse.games_running)
    pub games_running: ::std::vec::Vec<cmsg_client_get_client_details_response::Game>,
    // @@protoc_insertion_point(field:CMsgClientGetClientDetailsResponse.bytes_available)
    pub bytes_available: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientGetClientDetailsResponse.protocol_version)
    pub protocol_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientGetClientDetailsResponse.clientcomm_version)
    pub clientcomm_version: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetClientDetailsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetClientDetailsResponse {
    fn default() -> &'a CMsgClientGetClientDetailsResponse {
        <CMsgClientGetClientDetailsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetClientDetailsResponse {
    pub fn new() -> CMsgClientGetClientDetailsResponse {
        ::std::default::Default::default()
    }

    // optional uint32 package_version = 1;

    pub fn package_version(&self) -> u32 {
        self.package_version.unwrap_or(0)
    }

    pub fn clear_package_version(&mut self) {
        self.package_version = ::std::option::Option::None;
    }

    pub fn has_package_version(&self) -> bool {
        self.package_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_package_version(&mut self, v: u32) {
        self.package_version = ::std::option::Option::Some(v);
    }

    // optional string os = 2;

    pub fn os(&self) -> &str {
        match self.os.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_os(&mut self) {
        self.os = ::std::option::Option::None;
    }

    pub fn has_os(&self) -> bool {
        self.os.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os(&mut self, v: ::std::string::String) {
        self.os = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_os(&mut self) -> &mut ::std::string::String {
        if self.os.is_none() {
            self.os = ::std::option::Option::Some(::std::string::String::new());
        }
        self.os.as_mut().unwrap()
    }

    // Take field
    pub fn take_os(&mut self) -> ::std::string::String {
        self.os.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string machine_name = 3;

    pub fn machine_name(&self) -> &str {
        match self.machine_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_machine_name(&mut self) {
        self.machine_name = ::std::option::Option::None;
    }

    pub fn has_machine_name(&self) -> bool {
        self.machine_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_machine_name(&mut self, v: ::std::string::String) {
        self.machine_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_machine_name(&mut self) -> &mut ::std::string::String {
        if self.machine_name.is_none() {
            self.machine_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.machine_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_machine_name(&mut self) -> ::std::string::String {
        self.machine_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string ip_public = 4;

    pub fn ip_public(&self) -> &str {
        match self.ip_public.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_ip_public(&mut self) {
        self.ip_public = ::std::option::Option::None;
    }

    pub fn has_ip_public(&self) -> bool {
        self.ip_public.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip_public(&mut self, v: ::std::string::String) {
        self.ip_public = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip_public(&mut self) -> &mut ::std::string::String {
        if self.ip_public.is_none() {
            self.ip_public = ::std::option::Option::Some(::std::string::String::new());
        }
        self.ip_public.as_mut().unwrap()
    }

    // Take field
    pub fn take_ip_public(&mut self) -> ::std::string::String {
        self.ip_public.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string ip_private = 5;

    pub fn ip_private(&self) -> &str {
        match self.ip_private.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_ip_private(&mut self) {
        self.ip_private = ::std::option::Option::None;
    }

    pub fn has_ip_private(&self) -> bool {
        self.ip_private.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip_private(&mut self, v: ::std::string::String) {
        self.ip_private = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip_private(&mut self) -> &mut ::std::string::String {
        if self.ip_private.is_none() {
            self.ip_private = ::std::option::Option::Some(::std::string::String::new());
        }
        self.ip_private.as_mut().unwrap()
    }

    // Take field
    pub fn take_ip_private(&mut self) -> ::std::string::String {
        self.ip_private.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 bytes_available = 7;

    pub fn bytes_available(&self) -> u64 {
        self.bytes_available.unwrap_or(0)
    }

    pub fn clear_bytes_available(&mut self) {
        self.bytes_available = ::std::option::Option::None;
    }

    pub fn has_bytes_available(&self) -> bool {
        self.bytes_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_available(&mut self, v: u64) {
        self.bytes_available = ::std::option::Option::Some(v);
    }

    // optional uint32 protocol_version = 8;

    pub fn protocol_version(&self) -> u32 {
        self.protocol_version.unwrap_or(0)
    }

    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: u32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }

    // optional uint32 clientcomm_version = 9;

    pub fn clientcomm_version(&self) -> u32 {
        self.clientcomm_version.unwrap_or(0)
    }

    pub fn clear_clientcomm_version(&mut self) {
        self.clientcomm_version = ::std::option::Option::None;
    }

    pub fn has_clientcomm_version(&self) -> bool {
        self.clientcomm_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientcomm_version(&mut self, v: u32) {
        self.clientcomm_version = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientGetClientDetailsResponse {
    const NAME: &'static str = "CMsgClientGetClientDetailsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.package_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.os = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.machine_name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.ip_public = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.ip_private = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.games_running.push(is.read_message()?);
                },
                56 => {
                    self.bytes_available = ::std::option::Option::Some(is.read_uint64()?);
                },
                64 => {
                    self.protocol_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.clientcomm_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.package_version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.os.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.machine_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.ip_public.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.ip_private.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        for value in &self.games_running {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.bytes_available {
            my_size += ::protobuf::rt::uint64_size(7, v);
        }
        if let Some(v) = self.protocol_version {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.clientcomm_version {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.package_version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.os.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.machine_name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.ip_public.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.ip_private.as_ref() {
            os.write_string(5, v)?;
        }
        for v in &self.games_running {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if let Some(v) = self.bytes_available {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.protocol_version {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.clientcomm_version {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetClientDetailsResponse {
        CMsgClientGetClientDetailsResponse::new()
    }

    fn clear(&mut self) {
        self.package_version = ::std::option::Option::None;
        self.os = ::std::option::Option::None;
        self.machine_name = ::std::option::Option::None;
        self.ip_public = ::std::option::Option::None;
        self.ip_private = ::std::option::Option::None;
        self.games_running.clear();
        self.bytes_available = ::std::option::Option::None;
        self.protocol_version = ::std::option::Option::None;
        self.clientcomm_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetClientDetailsResponse {
        static instance: CMsgClientGetClientDetailsResponse = CMsgClientGetClientDetailsResponse {
            package_version: ::std::option::Option::None,
            os: ::std::option::Option::None,
            machine_name: ::std::option::Option::None,
            ip_public: ::std::option::Option::None,
            ip_private: ::std::option::Option::None,
            games_running: ::std::vec::Vec::new(),
            bytes_available: ::std::option::Option::None,
            protocol_version: ::std::option::Option::None,
            clientcomm_version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientGetClientDetailsResponse`
pub mod cmsg_client_get_client_details_response {
    // @@protoc_insertion_point(message:CMsgClientGetClientDetailsResponse.Game)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Game {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientGetClientDetailsResponse.Game.appid)
        pub appid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGetClientDetailsResponse.Game.extra_info)
        pub extra_info: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientGetClientDetailsResponse.Game.time_running_sec)
        pub time_running_sec: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientGetClientDetailsResponse.Game.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Game {
        fn default() -> &'a Game {
            <Game as ::protobuf::Message>::default_instance()
        }
    }

    impl Game {
        pub fn new() -> Game {
            ::std::default::Default::default()
        }

        // optional uint32 appid = 1;

        pub fn appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }

        // optional string extra_info = 2;

        pub fn extra_info(&self) -> &str {
            match self.extra_info.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_extra_info(&mut self) {
            self.extra_info = ::std::option::Option::None;
        }

        pub fn has_extra_info(&self) -> bool {
            self.extra_info.is_some()
        }

        // Param is passed by value, moved
        pub fn set_extra_info(&mut self, v: ::std::string::String) {
            self.extra_info = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_extra_info(&mut self) -> &mut ::std::string::String {
            if self.extra_info.is_none() {
                self.extra_info = ::std::option::Option::Some(::std::string::String::new());
            }
            self.extra_info.as_mut().unwrap()
        }

        // Take field
        pub fn take_extra_info(&mut self) -> ::std::string::String {
            self.extra_info.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 time_running_sec = 3;

        pub fn time_running_sec(&self) -> u32 {
            self.time_running_sec.unwrap_or(0)
        }

        pub fn clear_time_running_sec(&mut self) {
            self.time_running_sec = ::std::option::Option::None;
        }

        pub fn has_time_running_sec(&self) -> bool {
            self.time_running_sec.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_running_sec(&mut self, v: u32) {
            self.time_running_sec = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Game {
        const NAME: &'static str = "Game";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.extra_info = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.time_running_sec = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.appid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.extra_info.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.time_running_sec {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.appid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.extra_info.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.time_running_sec {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Game {
            Game::new()
        }

        fn clear(&mut self) {
            self.appid = ::std::option::Option::None;
            self.extra_info = ::std::option::Option::None;
            self.time_running_sec = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Game {
            static instance: Game = Game {
                appid: ::std::option::Option::None,
                extra_info: ::std::option::Option::None,
                time_running_sec: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientGetClientAppList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGetClientAppList {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGetClientAppList.media)
    pub media: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientGetClientAppList.tools)
    pub tools: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientGetClientAppList.games)
    pub games: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientGetClientAppList.only_installed)
    pub only_installed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientGetClientAppList.only_changing)
    pub only_changing: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientGetClientAppList.comics)
    pub comics: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientGetClientAppList.include_client_info)
    pub include_client_info: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetClientAppList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetClientAppList {
    fn default() -> &'a CMsgClientGetClientAppList {
        <CMsgClientGetClientAppList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetClientAppList {
    pub fn new() -> CMsgClientGetClientAppList {
        ::std::default::Default::default()
    }

    // optional bool media = 1;

    pub fn media(&self) -> bool {
        self.media.unwrap_or(false)
    }

    pub fn clear_media(&mut self) {
        self.media = ::std::option::Option::None;
    }

    pub fn has_media(&self) -> bool {
        self.media.is_some()
    }

    // Param is passed by value, moved
    pub fn set_media(&mut self, v: bool) {
        self.media = ::std::option::Option::Some(v);
    }

    // optional bool tools = 2;

    pub fn tools(&self) -> bool {
        self.tools.unwrap_or(false)
    }

    pub fn clear_tools(&mut self) {
        self.tools = ::std::option::Option::None;
    }

    pub fn has_tools(&self) -> bool {
        self.tools.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tools(&mut self, v: bool) {
        self.tools = ::std::option::Option::Some(v);
    }

    // optional bool games = 3;

    pub fn games(&self) -> bool {
        self.games.unwrap_or(false)
    }

    pub fn clear_games(&mut self) {
        self.games = ::std::option::Option::None;
    }

    pub fn has_games(&self) -> bool {
        self.games.is_some()
    }

    // Param is passed by value, moved
    pub fn set_games(&mut self, v: bool) {
        self.games = ::std::option::Option::Some(v);
    }

    // optional bool only_installed = 4;

    pub fn only_installed(&self) -> bool {
        self.only_installed.unwrap_or(false)
    }

    pub fn clear_only_installed(&mut self) {
        self.only_installed = ::std::option::Option::None;
    }

    pub fn has_only_installed(&self) -> bool {
        self.only_installed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_only_installed(&mut self, v: bool) {
        self.only_installed = ::std::option::Option::Some(v);
    }

    // optional bool only_changing = 5;

    pub fn only_changing(&self) -> bool {
        self.only_changing.unwrap_or(false)
    }

    pub fn clear_only_changing(&mut self) {
        self.only_changing = ::std::option::Option::None;
    }

    pub fn has_only_changing(&self) -> bool {
        self.only_changing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_only_changing(&mut self, v: bool) {
        self.only_changing = ::std::option::Option::Some(v);
    }

    // optional bool comics = 6;

    pub fn comics(&self) -> bool {
        self.comics.unwrap_or(false)
    }

    pub fn clear_comics(&mut self) {
        self.comics = ::std::option::Option::None;
    }

    pub fn has_comics(&self) -> bool {
        self.comics.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comics(&mut self, v: bool) {
        self.comics = ::std::option::Option::Some(v);
    }

    // optional bool include_client_info = 7;

    pub fn include_client_info(&self) -> bool {
        self.include_client_info.unwrap_or(false)
    }

    pub fn clear_include_client_info(&mut self) {
        self.include_client_info = ::std::option::Option::None;
    }

    pub fn has_include_client_info(&self) -> bool {
        self.include_client_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_client_info(&mut self, v: bool) {
        self.include_client_info = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientGetClientAppList {
    const NAME: &'static str = "CMsgClientGetClientAppList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.media = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.tools = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.games = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.only_installed = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.only_changing = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.comics = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.include_client_info = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.media {
            my_size += 1 + 1;
        }
        if let Some(v) = self.tools {
            my_size += 1 + 1;
        }
        if let Some(v) = self.games {
            my_size += 1 + 1;
        }
        if let Some(v) = self.only_installed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.only_changing {
            my_size += 1 + 1;
        }
        if let Some(v) = self.comics {
            my_size += 1 + 1;
        }
        if let Some(v) = self.include_client_info {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.media {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.tools {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.games {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.only_installed {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.only_changing {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.comics {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.include_client_info {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetClientAppList {
        CMsgClientGetClientAppList::new()
    }

    fn clear(&mut self) {
        self.media = ::std::option::Option::None;
        self.tools = ::std::option::Option::None;
        self.games = ::std::option::Option::None;
        self.only_installed = ::std::option::Option::None;
        self.only_changing = ::std::option::Option::None;
        self.comics = ::std::option::Option::None;
        self.include_client_info = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetClientAppList {
        static instance: CMsgClientGetClientAppList = CMsgClientGetClientAppList {
            media: ::std::option::Option::None,
            tools: ::std::option::Option::None,
            games: ::std::option::Option::None,
            only_installed: ::std::option::Option::None,
            only_changing: ::std::option::Option::None,
            comics: ::std::option::Option::None,
            include_client_info: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientGetClientAppListResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGetClientAppListResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.apps)
    pub apps: ::std::vec::Vec<cmsg_client_get_client_app_list_response::App>,
    // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.bytes_available)
    pub bytes_available: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.client_info)
    pub client_info: ::protobuf::MessageField<CMsgClientGetClientDetailsResponse>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetClientAppListResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetClientAppListResponse {
    fn default() -> &'a CMsgClientGetClientAppListResponse {
        <CMsgClientGetClientAppListResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetClientAppListResponse {
    pub fn new() -> CMsgClientGetClientAppListResponse {
        ::std::default::Default::default()
    }

    // optional uint64 bytes_available = 2;

    pub fn bytes_available(&self) -> u64 {
        self.bytes_available.unwrap_or(0)
    }

    pub fn clear_bytes_available(&mut self) {
        self.bytes_available = ::std::option::Option::None;
    }

    pub fn has_bytes_available(&self) -> bool {
        self.bytes_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_available(&mut self, v: u64) {
        self.bytes_available = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientGetClientAppListResponse {
    const NAME: &'static str = "CMsgClientGetClientAppListResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.apps.push(is.read_message()?);
                },
                16 => {
                    self.bytes_available = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.client_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.apps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.bytes_available {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.client_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.apps {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.bytes_available {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.client_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetClientAppListResponse {
        CMsgClientGetClientAppListResponse::new()
    }

    fn clear(&mut self) {
        self.apps.clear();
        self.bytes_available = ::std::option::Option::None;
        self.client_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetClientAppListResponse {
        static instance: CMsgClientGetClientAppListResponse = CMsgClientGetClientAppListResponse {
            apps: ::std::vec::Vec::new(),
            bytes_available: ::std::option::Option::None,
            client_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientGetClientAppListResponse`
pub mod cmsg_client_get_client_app_list_response {
    // @@protoc_insertion_point(message:CMsgClientGetClientAppListResponse.App)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct App {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.appid)
        pub appid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.category)
        pub category: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.app_type)
        pub app_type: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.favorite)
        pub favorite: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.installed)
        pub installed: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.auto_update)
        pub auto_update: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.bytes_downloaded)
        pub bytes_downloaded: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.bytes_to_download)
        pub bytes_to_download: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.bytes_download_rate)
        pub bytes_download_rate: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.dlcs)
        pub dlcs: ::std::vec::Vec<app::DLC>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.download_paused)
        pub download_paused: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.num_downloading)
        pub num_downloading: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.num_paused)
        pub num_paused: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.changing)
        pub changing: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.available_on_platform)
        pub available_on_platform: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.bytes_staged)
        pub bytes_staged: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.bytes_to_stage)
        pub bytes_to_stage: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.bytes_required)
        pub bytes_required: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.source_buildid)
        pub source_buildid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.target_buildid)
        pub target_buildid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.estimated_seconds_remaining)
        pub estimated_seconds_remaining: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.queue_position)
        pub queue_position: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.uninstalling)
        pub uninstalling: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.rt_time_scheduled)
        pub rt_time_scheduled: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientGetClientAppListResponse.App.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a App {
        fn default() -> &'a App {
            <App as ::protobuf::Message>::default_instance()
        }
    }

    impl App {
        pub fn new() -> App {
            ::std::default::Default::default()
        }

        // optional uint32 appid = 1;

        pub fn appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }

        // optional string category = 2;

        pub fn category(&self) -> &str {
            match self.category.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_category(&mut self) {
            self.category = ::std::option::Option::None;
        }

        pub fn has_category(&self) -> bool {
            self.category.is_some()
        }

        // Param is passed by value, moved
        pub fn set_category(&mut self, v: ::std::string::String) {
            self.category = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_category(&mut self) -> &mut ::std::string::String {
            if self.category.is_none() {
                self.category = ::std::option::Option::Some(::std::string::String::new());
            }
            self.category.as_mut().unwrap()
        }

        // Take field
        pub fn take_category(&mut self) -> ::std::string::String {
            self.category.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string app_type = 10;

        pub fn app_type(&self) -> &str {
            match self.app_type.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_app_type(&mut self) {
            self.app_type = ::std::option::Option::None;
        }

        pub fn has_app_type(&self) -> bool {
            self.app_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_app_type(&mut self, v: ::std::string::String) {
            self.app_type = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_app_type(&mut self) -> &mut ::std::string::String {
            if self.app_type.is_none() {
                self.app_type = ::std::option::Option::Some(::std::string::String::new());
            }
            self.app_type.as_mut().unwrap()
        }

        // Take field
        pub fn take_app_type(&mut self) -> ::std::string::String {
            self.app_type.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool favorite = 3;

        pub fn favorite(&self) -> bool {
            self.favorite.unwrap_or(false)
        }

        pub fn clear_favorite(&mut self) {
            self.favorite = ::std::option::Option::None;
        }

        pub fn has_favorite(&self) -> bool {
            self.favorite.is_some()
        }

        // Param is passed by value, moved
        pub fn set_favorite(&mut self, v: bool) {
            self.favorite = ::std::option::Option::Some(v);
        }

        // optional bool installed = 4;

        pub fn installed(&self) -> bool {
            self.installed.unwrap_or(false)
        }

        pub fn clear_installed(&mut self) {
            self.installed = ::std::option::Option::None;
        }

        pub fn has_installed(&self) -> bool {
            self.installed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_installed(&mut self, v: bool) {
            self.installed = ::std::option::Option::Some(v);
        }

        // optional bool auto_update = 5;

        pub fn auto_update(&self) -> bool {
            self.auto_update.unwrap_or(false)
        }

        pub fn clear_auto_update(&mut self) {
            self.auto_update = ::std::option::Option::None;
        }

        pub fn has_auto_update(&self) -> bool {
            self.auto_update.is_some()
        }

        // Param is passed by value, moved
        pub fn set_auto_update(&mut self, v: bool) {
            self.auto_update = ::std::option::Option::Some(v);
        }

        // optional uint64 bytes_downloaded = 6;

        pub fn bytes_downloaded(&self) -> u64 {
            self.bytes_downloaded.unwrap_or(0)
        }

        pub fn clear_bytes_downloaded(&mut self) {
            self.bytes_downloaded = ::std::option::Option::None;
        }

        pub fn has_bytes_downloaded(&self) -> bool {
            self.bytes_downloaded.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bytes_downloaded(&mut self, v: u64) {
            self.bytes_downloaded = ::std::option::Option::Some(v);
        }

        // optional uint64 bytes_to_download = 7;

        pub fn bytes_to_download(&self) -> u64 {
            self.bytes_to_download.unwrap_or(0)
        }

        pub fn clear_bytes_to_download(&mut self) {
            self.bytes_to_download = ::std::option::Option::None;
        }

        pub fn has_bytes_to_download(&self) -> bool {
            self.bytes_to_download.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bytes_to_download(&mut self, v: u64) {
            self.bytes_to_download = ::std::option::Option::Some(v);
        }

        // optional uint32 bytes_download_rate = 8;

        pub fn bytes_download_rate(&self) -> u32 {
            self.bytes_download_rate.unwrap_or(0)
        }

        pub fn clear_bytes_download_rate(&mut self) {
            self.bytes_download_rate = ::std::option::Option::None;
        }

        pub fn has_bytes_download_rate(&self) -> bool {
            self.bytes_download_rate.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bytes_download_rate(&mut self, v: u32) {
            self.bytes_download_rate = ::std::option::Option::Some(v);
        }

        // optional bool download_paused = 11;

        pub fn download_paused(&self) -> bool {
            self.download_paused.unwrap_or(false)
        }

        pub fn clear_download_paused(&mut self) {
            self.download_paused = ::std::option::Option::None;
        }

        pub fn has_download_paused(&self) -> bool {
            self.download_paused.is_some()
        }

        // Param is passed by value, moved
        pub fn set_download_paused(&mut self, v: bool) {
            self.download_paused = ::std::option::Option::Some(v);
        }

        // optional uint32 num_downloading = 12;

        pub fn num_downloading(&self) -> u32 {
            self.num_downloading.unwrap_or(0)
        }

        pub fn clear_num_downloading(&mut self) {
            self.num_downloading = ::std::option::Option::None;
        }

        pub fn has_num_downloading(&self) -> bool {
            self.num_downloading.is_some()
        }

        // Param is passed by value, moved
        pub fn set_num_downloading(&mut self, v: u32) {
            self.num_downloading = ::std::option::Option::Some(v);
        }

        // optional uint32 num_paused = 13;

        pub fn num_paused(&self) -> u32 {
            self.num_paused.unwrap_or(0)
        }

        pub fn clear_num_paused(&mut self) {
            self.num_paused = ::std::option::Option::None;
        }

        pub fn has_num_paused(&self) -> bool {
            self.num_paused.is_some()
        }

        // Param is passed by value, moved
        pub fn set_num_paused(&mut self, v: u32) {
            self.num_paused = ::std::option::Option::Some(v);
        }

        // optional bool changing = 14;

        pub fn changing(&self) -> bool {
            self.changing.unwrap_or(false)
        }

        pub fn clear_changing(&mut self) {
            self.changing = ::std::option::Option::None;
        }

        pub fn has_changing(&self) -> bool {
            self.changing.is_some()
        }

        // Param is passed by value, moved
        pub fn set_changing(&mut self, v: bool) {
            self.changing = ::std::option::Option::Some(v);
        }

        // optional bool available_on_platform = 15;

        pub fn available_on_platform(&self) -> bool {
            self.available_on_platform.unwrap_or(false)
        }

        pub fn clear_available_on_platform(&mut self) {
            self.available_on_platform = ::std::option::Option::None;
        }

        pub fn has_available_on_platform(&self) -> bool {
            self.available_on_platform.is_some()
        }

        // Param is passed by value, moved
        pub fn set_available_on_platform(&mut self, v: bool) {
            self.available_on_platform = ::std::option::Option::Some(v);
        }

        // optional uint64 bytes_staged = 16;

        pub fn bytes_staged(&self) -> u64 {
            self.bytes_staged.unwrap_or(0)
        }

        pub fn clear_bytes_staged(&mut self) {
            self.bytes_staged = ::std::option::Option::None;
        }

        pub fn has_bytes_staged(&self) -> bool {
            self.bytes_staged.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bytes_staged(&mut self, v: u64) {
            self.bytes_staged = ::std::option::Option::Some(v);
        }

        // optional uint64 bytes_to_stage = 17;

        pub fn bytes_to_stage(&self) -> u64 {
            self.bytes_to_stage.unwrap_or(0)
        }

        pub fn clear_bytes_to_stage(&mut self) {
            self.bytes_to_stage = ::std::option::Option::None;
        }

        pub fn has_bytes_to_stage(&self) -> bool {
            self.bytes_to_stage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bytes_to_stage(&mut self, v: u64) {
            self.bytes_to_stage = ::std::option::Option::Some(v);
        }

        // optional uint64 bytes_required = 18;

        pub fn bytes_required(&self) -> u64 {
            self.bytes_required.unwrap_or(0)
        }

        pub fn clear_bytes_required(&mut self) {
            self.bytes_required = ::std::option::Option::None;
        }

        pub fn has_bytes_required(&self) -> bool {
            self.bytes_required.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bytes_required(&mut self, v: u64) {
            self.bytes_required = ::std::option::Option::Some(v);
        }

        // optional uint32 source_buildid = 19;

        pub fn source_buildid(&self) -> u32 {
            self.source_buildid.unwrap_or(0)
        }

        pub fn clear_source_buildid(&mut self) {
            self.source_buildid = ::std::option::Option::None;
        }

        pub fn has_source_buildid(&self) -> bool {
            self.source_buildid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_source_buildid(&mut self, v: u32) {
            self.source_buildid = ::std::option::Option::Some(v);
        }

        // optional uint32 target_buildid = 20;

        pub fn target_buildid(&self) -> u32 {
            self.target_buildid.unwrap_or(0)
        }

        pub fn clear_target_buildid(&mut self) {
            self.target_buildid = ::std::option::Option::None;
        }

        pub fn has_target_buildid(&self) -> bool {
            self.target_buildid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_target_buildid(&mut self, v: u32) {
            self.target_buildid = ::std::option::Option::Some(v);
        }

        // optional uint32 estimated_seconds_remaining = 21;

        pub fn estimated_seconds_remaining(&self) -> u32 {
            self.estimated_seconds_remaining.unwrap_or(0)
        }

        pub fn clear_estimated_seconds_remaining(&mut self) {
            self.estimated_seconds_remaining = ::std::option::Option::None;
        }

        pub fn has_estimated_seconds_remaining(&self) -> bool {
            self.estimated_seconds_remaining.is_some()
        }

        // Param is passed by value, moved
        pub fn set_estimated_seconds_remaining(&mut self, v: u32) {
            self.estimated_seconds_remaining = ::std::option::Option::Some(v);
        }

        // optional int32 queue_position = 22;

        pub fn queue_position(&self) -> i32 {
            self.queue_position.unwrap_or(0)
        }

        pub fn clear_queue_position(&mut self) {
            self.queue_position = ::std::option::Option::None;
        }

        pub fn has_queue_position(&self) -> bool {
            self.queue_position.is_some()
        }

        // Param is passed by value, moved
        pub fn set_queue_position(&mut self, v: i32) {
            self.queue_position = ::std::option::Option::Some(v);
        }

        // optional bool uninstalling = 23;

        pub fn uninstalling(&self) -> bool {
            self.uninstalling.unwrap_or(false)
        }

        pub fn clear_uninstalling(&mut self) {
            self.uninstalling = ::std::option::Option::None;
        }

        pub fn has_uninstalling(&self) -> bool {
            self.uninstalling.is_some()
        }

        // Param is passed by value, moved
        pub fn set_uninstalling(&mut self, v: bool) {
            self.uninstalling = ::std::option::Option::Some(v);
        }

        // optional uint32 rt_time_scheduled = 24;

        pub fn rt_time_scheduled(&self) -> u32 {
            self.rt_time_scheduled.unwrap_or(0)
        }

        pub fn clear_rt_time_scheduled(&mut self) {
            self.rt_time_scheduled = ::std::option::Option::None;
        }

        pub fn has_rt_time_scheduled(&self) -> bool {
            self.rt_time_scheduled.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rt_time_scheduled(&mut self, v: u32) {
            self.rt_time_scheduled = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for App {
        const NAME: &'static str = "App";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.category = ::std::option::Option::Some(is.read_string()?);
                    },
                    82 => {
                        self.app_type = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.favorite = ::std::option::Option::Some(is.read_bool()?);
                    },
                    32 => {
                        self.installed = ::std::option::Option::Some(is.read_bool()?);
                    },
                    40 => {
                        self.auto_update = ::std::option::Option::Some(is.read_bool()?);
                    },
                    48 => {
                        self.bytes_downloaded = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    56 => {
                        self.bytes_to_download = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    64 => {
                        self.bytes_download_rate = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    74 => {
                        self.dlcs.push(is.read_message()?);
                    },
                    88 => {
                        self.download_paused = ::std::option::Option::Some(is.read_bool()?);
                    },
                    96 => {
                        self.num_downloading = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    104 => {
                        self.num_paused = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    112 => {
                        self.changing = ::std::option::Option::Some(is.read_bool()?);
                    },
                    120 => {
                        self.available_on_platform = ::std::option::Option::Some(is.read_bool()?);
                    },
                    128 => {
                        self.bytes_staged = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    136 => {
                        self.bytes_to_stage = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    144 => {
                        self.bytes_required = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    152 => {
                        self.source_buildid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    160 => {
                        self.target_buildid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    168 => {
                        self.estimated_seconds_remaining = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    176 => {
                        self.queue_position = ::std::option::Option::Some(is.read_int32()?);
                    },
                    184 => {
                        self.uninstalling = ::std::option::Option::Some(is.read_bool()?);
                    },
                    192 => {
                        self.rt_time_scheduled = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.appid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.category.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.app_type.as_ref() {
                my_size += ::protobuf::rt::string_size(10, &v);
            }
            if let Some(v) = self.favorite {
                my_size += 1 + 1;
            }
            if let Some(v) = self.installed {
                my_size += 1 + 1;
            }
            if let Some(v) = self.auto_update {
                my_size += 1 + 1;
            }
            if let Some(v) = self.bytes_downloaded {
                my_size += ::protobuf::rt::uint64_size(6, v);
            }
            if let Some(v) = self.bytes_to_download {
                my_size += ::protobuf::rt::uint64_size(7, v);
            }
            if let Some(v) = self.bytes_download_rate {
                my_size += ::protobuf::rt::uint32_size(8, v);
            }
            for value in &self.dlcs {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.download_paused {
                my_size += 1 + 1;
            }
            if let Some(v) = self.num_downloading {
                my_size += ::protobuf::rt::uint32_size(12, v);
            }
            if let Some(v) = self.num_paused {
                my_size += ::protobuf::rt::uint32_size(13, v);
            }
            if let Some(v) = self.changing {
                my_size += 1 + 1;
            }
            if let Some(v) = self.available_on_platform {
                my_size += 1 + 1;
            }
            if let Some(v) = self.bytes_staged {
                my_size += ::protobuf::rt::uint64_size(16, v);
            }
            if let Some(v) = self.bytes_to_stage {
                my_size += ::protobuf::rt::uint64_size(17, v);
            }
            if let Some(v) = self.bytes_required {
                my_size += ::protobuf::rt::uint64_size(18, v);
            }
            if let Some(v) = self.source_buildid {
                my_size += ::protobuf::rt::uint32_size(19, v);
            }
            if let Some(v) = self.target_buildid {
                my_size += ::protobuf::rt::uint32_size(20, v);
            }
            if let Some(v) = self.estimated_seconds_remaining {
                my_size += ::protobuf::rt::uint32_size(21, v);
            }
            if let Some(v) = self.queue_position {
                my_size += ::protobuf::rt::int32_size(22, v);
            }
            if let Some(v) = self.uninstalling {
                my_size += 2 + 1;
            }
            if let Some(v) = self.rt_time_scheduled {
                my_size += ::protobuf::rt::uint32_size(24, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.appid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.category.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.app_type.as_ref() {
                os.write_string(10, v)?;
            }
            if let Some(v) = self.favorite {
                os.write_bool(3, v)?;
            }
            if let Some(v) = self.installed {
                os.write_bool(4, v)?;
            }
            if let Some(v) = self.auto_update {
                os.write_bool(5, v)?;
            }
            if let Some(v) = self.bytes_downloaded {
                os.write_uint64(6, v)?;
            }
            if let Some(v) = self.bytes_to_download {
                os.write_uint64(7, v)?;
            }
            if let Some(v) = self.bytes_download_rate {
                os.write_uint32(8, v)?;
            }
            for v in &self.dlcs {
                ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
            };
            if let Some(v) = self.download_paused {
                os.write_bool(11, v)?;
            }
            if let Some(v) = self.num_downloading {
                os.write_uint32(12, v)?;
            }
            if let Some(v) = self.num_paused {
                os.write_uint32(13, v)?;
            }
            if let Some(v) = self.changing {
                os.write_bool(14, v)?;
            }
            if let Some(v) = self.available_on_platform {
                os.write_bool(15, v)?;
            }
            if let Some(v) = self.bytes_staged {
                os.write_uint64(16, v)?;
            }
            if let Some(v) = self.bytes_to_stage {
                os.write_uint64(17, v)?;
            }
            if let Some(v) = self.bytes_required {
                os.write_uint64(18, v)?;
            }
            if let Some(v) = self.source_buildid {
                os.write_uint32(19, v)?;
            }
            if let Some(v) = self.target_buildid {
                os.write_uint32(20, v)?;
            }
            if let Some(v) = self.estimated_seconds_remaining {
                os.write_uint32(21, v)?;
            }
            if let Some(v) = self.queue_position {
                os.write_int32(22, v)?;
            }
            if let Some(v) = self.uninstalling {
                os.write_bool(23, v)?;
            }
            if let Some(v) = self.rt_time_scheduled {
                os.write_uint32(24, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> App {
            App::new()
        }

        fn clear(&mut self) {
            self.appid = ::std::option::Option::None;
            self.category = ::std::option::Option::None;
            self.app_type = ::std::option::Option::None;
            self.favorite = ::std::option::Option::None;
            self.installed = ::std::option::Option::None;
            self.auto_update = ::std::option::Option::None;
            self.bytes_downloaded = ::std::option::Option::None;
            self.bytes_to_download = ::std::option::Option::None;
            self.bytes_download_rate = ::std::option::Option::None;
            self.dlcs.clear();
            self.download_paused = ::std::option::Option::None;
            self.num_downloading = ::std::option::Option::None;
            self.num_paused = ::std::option::Option::None;
            self.changing = ::std::option::Option::None;
            self.available_on_platform = ::std::option::Option::None;
            self.bytes_staged = ::std::option::Option::None;
            self.bytes_to_stage = ::std::option::Option::None;
            self.bytes_required = ::std::option::Option::None;
            self.source_buildid = ::std::option::Option::None;
            self.target_buildid = ::std::option::Option::None;
            self.estimated_seconds_remaining = ::std::option::Option::None;
            self.queue_position = ::std::option::Option::None;
            self.uninstalling = ::std::option::Option::None;
            self.rt_time_scheduled = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static App {
            static instance: App = App {
                appid: ::std::option::Option::None,
                category: ::std::option::Option::None,
                app_type: ::std::option::Option::None,
                favorite: ::std::option::Option::None,
                installed: ::std::option::Option::None,
                auto_update: ::std::option::Option::None,
                bytes_downloaded: ::std::option::Option::None,
                bytes_to_download: ::std::option::Option::None,
                bytes_download_rate: ::std::option::Option::None,
                dlcs: ::std::vec::Vec::new(),
                download_paused: ::std::option::Option::None,
                num_downloading: ::std::option::Option::None,
                num_paused: ::std::option::Option::None,
                changing: ::std::option::Option::None,
                available_on_platform: ::std::option::Option::None,
                bytes_staged: ::std::option::Option::None,
                bytes_to_stage: ::std::option::Option::None,
                bytes_required: ::std::option::Option::None,
                source_buildid: ::std::option::Option::None,
                target_buildid: ::std::option::Option::None,
                estimated_seconds_remaining: ::std::option::Option::None,
                queue_position: ::std::option::Option::None,
                uninstalling: ::std::option::Option::None,
                rt_time_scheduled: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `App`
    pub mod app {
        // @@protoc_insertion_point(message:CMsgClientGetClientAppListResponse.App.DLC)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct DLC {
            // message fields
            // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.DLC.appid)
            pub appid: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.DLC.installed)
            pub installed: ::std::option::Option<bool>,
            // special fields
            // @@protoc_insertion_point(special_field:CMsgClientGetClientAppListResponse.App.DLC.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a DLC {
            fn default() -> &'a DLC {
                <DLC as ::protobuf::Message>::default_instance()
            }
        }

        impl DLC {
            pub fn new() -> DLC {
                ::std::default::Default::default()
            }

            // optional uint32 appid = 1;

            pub fn appid(&self) -> u32 {
                self.appid.unwrap_or(0)
            }

            pub fn clear_appid(&mut self) {
                self.appid = ::std::option::Option::None;
            }

            pub fn has_appid(&self) -> bool {
                self.appid.is_some()
            }

            // Param is passed by value, moved
            pub fn set_appid(&mut self, v: u32) {
                self.appid = ::std::option::Option::Some(v);
            }

            // optional bool installed = 2;

            pub fn installed(&self) -> bool {
                self.installed.unwrap_or(false)
            }

            pub fn clear_installed(&mut self) {
                self.installed = ::std::option::Option::None;
            }

            pub fn has_installed(&self) -> bool {
                self.installed.is_some()
            }

            // Param is passed by value, moved
            pub fn set_installed(&mut self, v: bool) {
                self.installed = ::std::option::Option::Some(v);
            }
        }

        impl ::protobuf::Message for DLC {
            const NAME: &'static str = "DLC";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.appid = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        16 => {
                            self.installed = ::std::option::Option::Some(is.read_bool()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.appid {
                    my_size += ::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.installed {
                    my_size += 1 + 1;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.appid {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.installed {
                    os.write_bool(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> DLC {
                DLC::new()
            }

            fn clear(&mut self) {
                self.appid = ::std::option::Option::None;
                self.installed = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static DLC {
                static instance: DLC = DLC {
                    appid: ::std::option::Option::None,
                    installed: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientInstallClientApp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientInstallClientApp {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientInstallClientApp.appid)
    pub appid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientInstallClientApp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientInstallClientApp {
    fn default() -> &'a CMsgClientInstallClientApp {
        <CMsgClientInstallClientApp as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientInstallClientApp {
    pub fn new() -> CMsgClientInstallClientApp {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientInstallClientApp {
    const NAME: &'static str = "CMsgClientInstallClientApp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientInstallClientApp {
        CMsgClientInstallClientApp::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientInstallClientApp {
        static instance: CMsgClientInstallClientApp = CMsgClientInstallClientApp {
            appid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientInstallClientAppResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientInstallClientAppResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientInstallClientAppResponse.result)
    pub result: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientInstallClientAppResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientInstallClientAppResponse {
    fn default() -> &'a CMsgClientInstallClientAppResponse {
        <CMsgClientInstallClientAppResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientInstallClientAppResponse {
    pub fn new() -> CMsgClientInstallClientAppResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientInstallClientAppResponse {
    const NAME: &'static str = "CMsgClientInstallClientAppResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientInstallClientAppResponse {
        CMsgClientInstallClientAppResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientInstallClientAppResponse {
        static instance: CMsgClientInstallClientAppResponse = CMsgClientInstallClientAppResponse {
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientUninstallClientApp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUninstallClientApp {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUninstallClientApp.appid)
    pub appid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUninstallClientApp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUninstallClientApp {
    fn default() -> &'a CMsgClientUninstallClientApp {
        <CMsgClientUninstallClientApp as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUninstallClientApp {
    pub fn new() -> CMsgClientUninstallClientApp {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUninstallClientApp {
    const NAME: &'static str = "CMsgClientUninstallClientApp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUninstallClientApp {
        CMsgClientUninstallClientApp::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUninstallClientApp {
        static instance: CMsgClientUninstallClientApp = CMsgClientUninstallClientApp {
            appid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientUninstallClientAppResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUninstallClientAppResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUninstallClientAppResponse.result)
    pub result: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUninstallClientAppResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUninstallClientAppResponse {
    fn default() -> &'a CMsgClientUninstallClientAppResponse {
        <CMsgClientUninstallClientAppResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUninstallClientAppResponse {
    pub fn new() -> CMsgClientUninstallClientAppResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUninstallClientAppResponse {
    const NAME: &'static str = "CMsgClientUninstallClientAppResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUninstallClientAppResponse {
        CMsgClientUninstallClientAppResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUninstallClientAppResponse {
        static instance: CMsgClientUninstallClientAppResponse = CMsgClientUninstallClientAppResponse {
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientSetClientAppUpdateState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientSetClientAppUpdateState {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientSetClientAppUpdateState.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientSetClientAppUpdateState.update)
    pub update: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientSetClientAppUpdateState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientSetClientAppUpdateState {
    fn default() -> &'a CMsgClientSetClientAppUpdateState {
        <CMsgClientSetClientAppUpdateState as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientSetClientAppUpdateState {
    pub fn new() -> CMsgClientSetClientAppUpdateState {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional bool update = 2;

    pub fn update(&self) -> bool {
        self.update.unwrap_or(false)
    }

    pub fn clear_update(&mut self) {
        self.update = ::std::option::Option::None;
    }

    pub fn has_update(&self) -> bool {
        self.update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update(&mut self, v: bool) {
        self.update = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientSetClientAppUpdateState {
    const NAME: &'static str = "CMsgClientSetClientAppUpdateState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.update = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.update {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.update {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientSetClientAppUpdateState {
        CMsgClientSetClientAppUpdateState::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.update = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientSetClientAppUpdateState {
        static instance: CMsgClientSetClientAppUpdateState = CMsgClientSetClientAppUpdateState {
            appid: ::std::option::Option::None,
            update: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientSetClientAppUpdateStateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientSetClientAppUpdateStateResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientSetClientAppUpdateStateResponse.result)
    pub result: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientSetClientAppUpdateStateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientSetClientAppUpdateStateResponse {
    fn default() -> &'a CMsgClientSetClientAppUpdateStateResponse {
        <CMsgClientSetClientAppUpdateStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientSetClientAppUpdateStateResponse {
    pub fn new() -> CMsgClientSetClientAppUpdateStateResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientSetClientAppUpdateStateResponse {
    const NAME: &'static str = "CMsgClientSetClientAppUpdateStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientSetClientAppUpdateStateResponse {
        CMsgClientSetClientAppUpdateStateResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientSetClientAppUpdateStateResponse {
        static instance: CMsgClientSetClientAppUpdateStateResponse = CMsgClientSetClientAppUpdateStateResponse {
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientEnableOrDisableDownloads)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientEnableOrDisableDownloads {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientEnableOrDisableDownloads.enable)
    pub enable: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientEnableOrDisableDownloads.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientEnableOrDisableDownloads {
    fn default() -> &'a CMsgClientEnableOrDisableDownloads {
        <CMsgClientEnableOrDisableDownloads as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientEnableOrDisableDownloads {
    pub fn new() -> CMsgClientEnableOrDisableDownloads {
        ::std::default::Default::default()
    }

    // optional bool enable = 1;

    pub fn enable(&self) -> bool {
        self.enable.unwrap_or(false)
    }

    pub fn clear_enable(&mut self) {
        self.enable = ::std::option::Option::None;
    }

    pub fn has_enable(&self) -> bool {
        self.enable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable(&mut self, v: bool) {
        self.enable = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientEnableOrDisableDownloads {
    const NAME: &'static str = "CMsgClientEnableOrDisableDownloads";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.enable = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.enable {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.enable {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientEnableOrDisableDownloads {
        CMsgClientEnableOrDisableDownloads::new()
    }

    fn clear(&mut self) {
        self.enable = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientEnableOrDisableDownloads {
        static instance: CMsgClientEnableOrDisableDownloads = CMsgClientEnableOrDisableDownloads {
            enable: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientEnableOrDisableDownloadsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientEnableOrDisableDownloadsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientEnableOrDisableDownloadsResponse.result)
    pub result: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientEnableOrDisableDownloadsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientEnableOrDisableDownloadsResponse {
    fn default() -> &'a CMsgClientEnableOrDisableDownloadsResponse {
        <CMsgClientEnableOrDisableDownloadsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientEnableOrDisableDownloadsResponse {
    pub fn new() -> CMsgClientEnableOrDisableDownloadsResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientEnableOrDisableDownloadsResponse {
    const NAME: &'static str = "CMsgClientEnableOrDisableDownloadsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientEnableOrDisableDownloadsResponse {
        CMsgClientEnableOrDisableDownloadsResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientEnableOrDisableDownloadsResponse {
        static instance: CMsgClientEnableOrDisableDownloadsResponse = CMsgClientEnableOrDisableDownloadsResponse {
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}
#[allow(unused_imports)]
use crate::steammessages_base::*;
impl crate::RpcMessage for CMsgClientUDSP2PSessionStarted {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientUDSP2PSessionStarted {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientUDSP2PSessionStarted;
}
impl crate::RpcMessage for CMsgClientUDSP2PSessionEnded {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientUDSP2PSessionEnded {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientUDSP2PSessionEnded;
}
impl crate::RpcMessage for CMsgClientGetClientDetails {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientGetClientDetails {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientGetClientDetails;
}
impl crate::RpcMessage for CMsgClientGetClientDetailsResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientGetClientDetailsResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientGetClientDetailsResponse;
}
impl crate::RpcMessage for CMsgClientGetClientAppList {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientGetClientAppList {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientGetClientAppList;
}
impl crate::RpcMessage for CMsgClientGetClientAppListResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientGetClientAppListResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientGetClientAppListResponse;
}
impl crate::RpcMessage for CMsgClientInstallClientApp {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientInstallClientApp {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientInstallClientApp;
}
impl crate::RpcMessage for CMsgClientInstallClientAppResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientInstallClientAppResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientInstallClientAppResponse;
}
impl crate::RpcMessage for CMsgClientUninstallClientApp {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientUninstallClientApp {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientUninstallClientApp;
}
impl crate::RpcMessage for CMsgClientUninstallClientAppResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientUninstallClientAppResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientUninstallClientAppResponse;
}
impl crate::RpcMessage for CMsgClientSetClientAppUpdateState {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientSetClientAppUpdateState {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientSetClientAppUpdateState;
}
impl crate::RpcMessage for CMsgClientSetClientAppUpdateStateResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientSetClientAppUpdateStateResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientSetClientAppUpdateStateResponse;
}
impl crate::RpcMessage for CMsgClientEnableOrDisableDownloads {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientEnableOrDisableDownloads {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientEnableOrDisableDownloads;
}
impl crate::RpcMessage for CMsgClientEnableOrDisableDownloadsResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientEnableOrDisableDownloadsResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientEnableOrDisableDownloadsResponse;
}
