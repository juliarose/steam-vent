// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_clientsettings.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:CMsgHotkey)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgHotkey {
    // message fields
    // @@protoc_insertion_point(field:CMsgHotkey.key_code)
    pub key_code: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHotkey.alt_key)
    pub alt_key: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgHotkey.shift_key)
    pub shift_key: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgHotkey.ctrl_key)
    pub ctrl_key: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgHotkey.meta_key)
    pub meta_key: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgHotkey.display_name)
    pub display_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgHotkey.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgHotkey {
    fn default() -> &'a CMsgHotkey {
        <CMsgHotkey as ::protobuf::Message>::default_instance()
    }
}

impl CMsgHotkey {
    pub fn new() -> CMsgHotkey {
        ::std::default::Default::default()
    }

    // optional uint32 key_code = 1;

    pub fn key_code(&self) -> u32 {
        self.key_code.unwrap_or(0)
    }

    pub fn clear_key_code(&mut self) {
        self.key_code = ::std::option::Option::None;
    }

    pub fn has_key_code(&self) -> bool {
        self.key_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key_code(&mut self, v: u32) {
        self.key_code = ::std::option::Option::Some(v);
    }

    // optional bool alt_key = 2;

    pub fn alt_key(&self) -> bool {
        self.alt_key.unwrap_or(false)
    }

    pub fn clear_alt_key(&mut self) {
        self.alt_key = ::std::option::Option::None;
    }

    pub fn has_alt_key(&self) -> bool {
        self.alt_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_alt_key(&mut self, v: bool) {
        self.alt_key = ::std::option::Option::Some(v);
    }

    // optional bool shift_key = 3;

    pub fn shift_key(&self) -> bool {
        self.shift_key.unwrap_or(false)
    }

    pub fn clear_shift_key(&mut self) {
        self.shift_key = ::std::option::Option::None;
    }

    pub fn has_shift_key(&self) -> bool {
        self.shift_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shift_key(&mut self, v: bool) {
        self.shift_key = ::std::option::Option::Some(v);
    }

    // optional bool ctrl_key = 4;

    pub fn ctrl_key(&self) -> bool {
        self.ctrl_key.unwrap_or(false)
    }

    pub fn clear_ctrl_key(&mut self) {
        self.ctrl_key = ::std::option::Option::None;
    }

    pub fn has_ctrl_key(&self) -> bool {
        self.ctrl_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctrl_key(&mut self, v: bool) {
        self.ctrl_key = ::std::option::Option::Some(v);
    }

    // optional bool meta_key = 5;

    pub fn meta_key(&self) -> bool {
        self.meta_key.unwrap_or(false)
    }

    pub fn clear_meta_key(&mut self) {
        self.meta_key = ::std::option::Option::None;
    }

    pub fn has_meta_key(&self) -> bool {
        self.meta_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_meta_key(&mut self, v: bool) {
        self.meta_key = ::std::option::Option::Some(v);
    }

    // optional string display_name = 6;

    pub fn display_name(&self) -> &str {
        match self.display_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_display_name(&mut self) {
        self.display_name = ::std::option::Option::None;
    }

    pub fn has_display_name(&self) -> bool {
        self.display_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_name(&mut self, v: ::std::string::String) {
        self.display_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display_name(&mut self) -> &mut ::std::string::String {
        if self.display_name.is_none() {
            self.display_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.display_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_display_name(&mut self) -> ::std::string::String {
        self.display_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgHotkey {
    const NAME: &'static str = "CMsgHotkey";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.key_code = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.alt_key = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.shift_key = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.ctrl_key = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.meta_key = ::std::option::Option::Some(is.read_bool()?);
                },
                50 => {
                    self.display_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key_code {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.alt_key {
            my_size += 1 + 1;
        }
        if let Some(v) = self.shift_key {
            my_size += 1 + 1;
        }
        if let Some(v) = self.ctrl_key {
            my_size += 1 + 1;
        }
        if let Some(v) = self.meta_key {
            my_size += 1 + 1;
        }
        if let Some(v) = self.display_name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key_code {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.alt_key {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.shift_key {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.ctrl_key {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.meta_key {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.display_name.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgHotkey {
        CMsgHotkey::new()
    }

    fn clear(&mut self) {
        self.key_code = ::std::option::Option::None;
        self.alt_key = ::std::option::Option::None;
        self.shift_key = ::std::option::Option::None;
        self.ctrl_key = ::std::option::Option::None;
        self.meta_key = ::std::option::Option::None;
        self.display_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgHotkey {
        static instance: CMsgHotkey = CMsgHotkey {
            key_code: ::std::option::Option::None,
            alt_key: ::std::option::Option::None,
            shift_key: ::std::option::Option::None,
            ctrl_key: ::std::option::Option::None,
            meta_key: ::std::option::Option::None,
            display_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientSettings)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientSettings {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientSettings.no_save_personal_info)
    pub no_save_personal_info: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.oobe_test_mode_enabled)
    pub oobe_test_mode_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.in_client_beta)
    pub in_client_beta: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.is_steam_sideloaded)
    pub is_steam_sideloaded: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.preferred_monitor)
    pub preferred_monitor: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientSettings.steam_cef_gpu_blocklist_disabled)
    pub steam_cef_gpu_blocklist_disabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.bigpicture_windowed)
    pub bigpicture_windowed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.display_name)
    pub display_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientSettings.is_external_display)
    pub is_external_display: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.steam_os_underscan_level)
    pub steam_os_underscan_level: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.steam_os_underscan_enabled)
    pub steam_os_underscan_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.min_scale_factor)
    pub min_scale_factor: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.max_scale_factor)
    pub max_scale_factor: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.auto_scale_factor)
    pub auto_scale_factor: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.enable_test_updaters)
    pub enable_test_updaters: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.small_mode)
    pub small_mode: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.skip_steamvr_install_dialog)
    pub skip_steamvr_install_dialog: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.always_show_user_chooser)
    pub always_show_user_chooser: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.show_family_sharing_notifications)
    pub show_family_sharing_notifications: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.overlay_fps_counter_corner)
    pub overlay_fps_counter_corner: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.overlay_fps_counter_high_contrast)
    pub overlay_fps_counter_high_contrast: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.overlay_key)
    pub overlay_key: ::protobuf::MessageField<CMsgHotkey>,
    // @@protoc_insertion_point(field:CMsgClientSettings.screenshot_key)
    pub screenshot_key: ::protobuf::MessageField<CMsgHotkey>,
    // @@protoc_insertion_point(field:CMsgClientSettings.enable_overlay)
    pub enable_overlay: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.disable_desktop_game_theater)
    pub disable_desktop_game_theater: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.enable_screenshot_notification)
    pub enable_screenshot_notification: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.enable_screenshot_sound)
    pub enable_screenshot_sound: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.save_uncompressed_screenshots)
    pub save_uncompressed_screenshots: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.screenshots_path)
    pub screenshots_path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientSettings.default_ping_rate)
    pub default_ping_rate: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.server_ping_rate)
    pub server_ping_rate: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.steam_networking_share_ip)
    pub steam_networking_share_ip: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.web_browser_home)
    pub web_browser_home: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientSettings.voice_mic_device_name)
    pub voice_mic_device_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientSettings.voice_mic_input_gain)
    pub voice_mic_input_gain: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.voice_speaker_output_gain)
    pub voice_speaker_output_gain: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.voice_push_to_talk_setting)
    pub voice_push_to_talk_setting: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.voice_push_to_talk_key)
    pub voice_push_to_talk_key: ::protobuf::MessageField<CMsgHotkey>,
    // @@protoc_insertion_point(field:CMsgClientSettings.overlay_toolbar_list_view)
    pub overlay_toolbar_list_view: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.always_use_gamepadui_overlay)
    pub always_use_gamepadui_overlay: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.overlay_tabs)
    pub overlay_tabs: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientSettings.overlay_scale_interface)
    pub overlay_scale_interface: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.smooth_scroll_webviews)
    pub smooth_scroll_webviews: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.enable_gpu_accelerated_webviews)
    pub enable_gpu_accelerated_webviews: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.enable_hardware_video_decoding)
    pub enable_hardware_video_decoding: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.run_at_startup)
    pub run_at_startup: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.enable_dpi_scaling)
    pub enable_dpi_scaling: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.enable_marketing_messages)
    pub enable_marketing_messages: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.start_in_big_picture_mode)
    pub start_in_big_picture_mode: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.jumplist_flags)
    pub jumplist_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.enable_ui_sounds)
    pub enable_ui_sounds: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.disable_all_toasts)
    pub disable_all_toasts: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.disable_toasts_in_game)
    pub disable_toasts_in_game: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.play_sound_on_toast)
    pub play_sound_on_toast: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.library_display_size)
    pub library_display_size: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.library_whats_new_show_only_product_updates)
    pub library_whats_new_show_only_product_updates: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.show_store_content_on_home)
    pub show_store_content_on_home: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.start_page)
    pub start_page: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientSettings.library_low_bandwidth_mode)
    pub library_low_bandwidth_mode: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.library_low_perf_mode)
    pub library_low_perf_mode: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.library_disable_community_content)
    pub library_disable_community_content: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.library_display_icon_in_game_list)
    pub library_display_icon_in_game_list: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.ready_to_play_includes_streaming)
    pub ready_to_play_includes_streaming: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.show_steam_deck_info)
    pub show_steam_deck_info: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.enable_shader_precache)
    pub enable_shader_precache: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.enable_shader_background_processing)
    pub enable_shader_background_processing: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.shader_precached_size)
    pub shader_precached_size: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientSettings.needs_steam_service_repair)
    pub needs_steam_service_repair: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.download_peer_content)
    pub download_peer_content: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.download_rate_bits_per_s)
    pub download_rate_bits_per_s: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.restrict_auto_updates)
    pub restrict_auto_updates: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.restrict_auto_updates_start)
    pub restrict_auto_updates_start: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.restrict_auto_updates_end)
    pub restrict_auto_updates_end: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.download_region)
    pub download_region: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.download_while_app_running)
    pub download_while_app_running: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.download_throttle_while_streaming)
    pub download_throttle_while_streaming: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.download_throttle_rate)
    pub download_throttle_rate: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.cloud_enabled)
    pub cloud_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.show_screenshot_manager)
    pub show_screenshot_manager: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.music_volume)
    pub music_volume: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.music_pause_on_app_start)
    pub music_pause_on_app_start: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.music_pause_on_voice_chat)
    pub music_pause_on_voice_chat: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.music_download_high_quality)
    pub music_download_high_quality: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.music_playlist_notification)
    pub music_playlist_notification: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.broadcast_permissions)
    pub broadcast_permissions: ::std::option::Option<::protobuf::EnumOrUnknown<super::enums::EBroadcastPermission>>,
    // @@protoc_insertion_point(field:CMsgClientSettings.broadcast_output_width)
    pub broadcast_output_width: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.broadcast_output_height)
    pub broadcast_output_height: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.broadcast_bitrate)
    pub broadcast_bitrate: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.broadcast_encoding_option)
    pub broadcast_encoding_option: ::std::option::Option<::protobuf::EnumOrUnknown<super::enums::EBroadcastEncoderSetting>>,
    // @@protoc_insertion_point(field:CMsgClientSettings.broadcast_record_all_video)
    pub broadcast_record_all_video: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.broadcast_record_all_audio)
    pub broadcast_record_all_audio: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.broadcast_record_microphone)
    pub broadcast_record_microphone: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.broadcast_show_upload_stats)
    pub broadcast_show_upload_stats: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.broadcast_show_live_reminder)
    pub broadcast_show_live_reminder: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.broadcast_chat_corner)
    pub broadcast_chat_corner: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.steam_input_configurator_error_msg_enable)
    pub steam_input_configurator_error_msg_enable: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.controller_guide_button_focus_steam)
    pub controller_guide_button_focus_steam: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.controller_ps4_support)
    pub controller_ps4_support: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.controller_xbox_support)
    pub controller_xbox_support: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.controller_xbox_driver)
    pub controller_xbox_driver: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.controller_switch_support)
    pub controller_switch_support: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.controller_generic_support)
    pub controller_generic_support: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.controller_power_off_timeout)
    pub controller_power_off_timeout: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.turn_off_controller_on_exit)
    pub turn_off_controller_on_exit: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.controller_combine_nintendo_joycons)
    pub controller_combine_nintendo_joycons: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.startup_movie_id)
    pub startup_movie_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientSettings.startup_movie_local_path)
    pub startup_movie_local_path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientSettings.startup_movie_shuffle)
    pub startup_movie_shuffle: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.startup_movie_used_for_resume)
    pub startup_movie_used_for_resume: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.game_notes_enable_spellcheck)
    pub game_notes_enable_spellcheck: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.screenshot_items_per_row)
    pub screenshot_items_per_row: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientSettings.g_background_enabled)
    pub g_background_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientSettings.g_background_path)
    pub g_background_path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientSettings.g_background_max_keep)
    pub g_background_max_keep: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientSettings.show_timestamps_in_console)
    pub show_timestamps_in_console: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientSettings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientSettings {
    fn default() -> &'a CMsgClientSettings {
        <CMsgClientSettings as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientSettings {
    pub fn new() -> CMsgClientSettings {
        ::std::default::Default::default()
    }

    // optional bool no_save_personal_info = 1;

    pub fn no_save_personal_info(&self) -> bool {
        self.no_save_personal_info.unwrap_or(false)
    }

    pub fn clear_no_save_personal_info(&mut self) {
        self.no_save_personal_info = ::std::option::Option::None;
    }

    pub fn has_no_save_personal_info(&self) -> bool {
        self.no_save_personal_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_no_save_personal_info(&mut self, v: bool) {
        self.no_save_personal_info = ::std::option::Option::Some(v);
    }

    // optional bool oobe_test_mode_enabled = 2;

    pub fn oobe_test_mode_enabled(&self) -> bool {
        self.oobe_test_mode_enabled.unwrap_or(false)
    }

    pub fn clear_oobe_test_mode_enabled(&mut self) {
        self.oobe_test_mode_enabled = ::std::option::Option::None;
    }

    pub fn has_oobe_test_mode_enabled(&self) -> bool {
        self.oobe_test_mode_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_oobe_test_mode_enabled(&mut self, v: bool) {
        self.oobe_test_mode_enabled = ::std::option::Option::Some(v);
    }

    // optional bool in_client_beta = 3;

    pub fn in_client_beta(&self) -> bool {
        self.in_client_beta.unwrap_or(false)
    }

    pub fn clear_in_client_beta(&mut self) {
        self.in_client_beta = ::std::option::Option::None;
    }

    pub fn has_in_client_beta(&self) -> bool {
        self.in_client_beta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_client_beta(&mut self, v: bool) {
        self.in_client_beta = ::std::option::Option::Some(v);
    }

    // optional bool is_steam_sideloaded = 4;

    pub fn is_steam_sideloaded(&self) -> bool {
        self.is_steam_sideloaded.unwrap_or(false)
    }

    pub fn clear_is_steam_sideloaded(&mut self) {
        self.is_steam_sideloaded = ::std::option::Option::None;
    }

    pub fn has_is_steam_sideloaded(&self) -> bool {
        self.is_steam_sideloaded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_steam_sideloaded(&mut self, v: bool) {
        self.is_steam_sideloaded = ::std::option::Option::Some(v);
    }

    // optional string preferred_monitor = 5;

    pub fn preferred_monitor(&self) -> &str {
        match self.preferred_monitor.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_preferred_monitor(&mut self) {
        self.preferred_monitor = ::std::option::Option::None;
    }

    pub fn has_preferred_monitor(&self) -> bool {
        self.preferred_monitor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preferred_monitor(&mut self, v: ::std::string::String) {
        self.preferred_monitor = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preferred_monitor(&mut self) -> &mut ::std::string::String {
        if self.preferred_monitor.is_none() {
            self.preferred_monitor = ::std::option::Option::Some(::std::string::String::new());
        }
        self.preferred_monitor.as_mut().unwrap()
    }

    // Take field
    pub fn take_preferred_monitor(&mut self) -> ::std::string::String {
        self.preferred_monitor.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool steam_cef_gpu_blocklist_disabled = 6;

    pub fn steam_cef_gpu_blocklist_disabled(&self) -> bool {
        self.steam_cef_gpu_blocklist_disabled.unwrap_or(false)
    }

    pub fn clear_steam_cef_gpu_blocklist_disabled(&mut self) {
        self.steam_cef_gpu_blocklist_disabled = ::std::option::Option::None;
    }

    pub fn has_steam_cef_gpu_blocklist_disabled(&self) -> bool {
        self.steam_cef_gpu_blocklist_disabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_cef_gpu_blocklist_disabled(&mut self, v: bool) {
        self.steam_cef_gpu_blocklist_disabled = ::std::option::Option::Some(v);
    }

    // optional bool bigpicture_windowed = 7;

    pub fn bigpicture_windowed(&self) -> bool {
        self.bigpicture_windowed.unwrap_or(false)
    }

    pub fn clear_bigpicture_windowed(&mut self) {
        self.bigpicture_windowed = ::std::option::Option::None;
    }

    pub fn has_bigpicture_windowed(&self) -> bool {
        self.bigpicture_windowed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bigpicture_windowed(&mut self, v: bool) {
        self.bigpicture_windowed = ::std::option::Option::Some(v);
    }

    // optional string display_name = 8;

    pub fn display_name(&self) -> &str {
        match self.display_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_display_name(&mut self) {
        self.display_name = ::std::option::Option::None;
    }

    pub fn has_display_name(&self) -> bool {
        self.display_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_name(&mut self, v: ::std::string::String) {
        self.display_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display_name(&mut self) -> &mut ::std::string::String {
        if self.display_name.is_none() {
            self.display_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.display_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_display_name(&mut self) -> ::std::string::String {
        self.display_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_external_display = 9;

    pub fn is_external_display(&self) -> bool {
        self.is_external_display.unwrap_or(false)
    }

    pub fn clear_is_external_display(&mut self) {
        self.is_external_display = ::std::option::Option::None;
    }

    pub fn has_is_external_display(&self) -> bool {
        self.is_external_display.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_external_display(&mut self, v: bool) {
        self.is_external_display = ::std::option::Option::Some(v);
    }

    // optional float steam_os_underscan_level = 10;

    pub fn steam_os_underscan_level(&self) -> f32 {
        self.steam_os_underscan_level.unwrap_or(0.)
    }

    pub fn clear_steam_os_underscan_level(&mut self) {
        self.steam_os_underscan_level = ::std::option::Option::None;
    }

    pub fn has_steam_os_underscan_level(&self) -> bool {
        self.steam_os_underscan_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_os_underscan_level(&mut self, v: f32) {
        self.steam_os_underscan_level = ::std::option::Option::Some(v);
    }

    // optional bool steam_os_underscan_enabled = 11;

    pub fn steam_os_underscan_enabled(&self) -> bool {
        self.steam_os_underscan_enabled.unwrap_or(false)
    }

    pub fn clear_steam_os_underscan_enabled(&mut self) {
        self.steam_os_underscan_enabled = ::std::option::Option::None;
    }

    pub fn has_steam_os_underscan_enabled(&self) -> bool {
        self.steam_os_underscan_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_os_underscan_enabled(&mut self, v: bool) {
        self.steam_os_underscan_enabled = ::std::option::Option::Some(v);
    }

    // optional float min_scale_factor = 12;

    pub fn min_scale_factor(&self) -> f32 {
        self.min_scale_factor.unwrap_or(0.)
    }

    pub fn clear_min_scale_factor(&mut self) {
        self.min_scale_factor = ::std::option::Option::None;
    }

    pub fn has_min_scale_factor(&self) -> bool {
        self.min_scale_factor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_scale_factor(&mut self, v: f32) {
        self.min_scale_factor = ::std::option::Option::Some(v);
    }

    // optional float max_scale_factor = 13;

    pub fn max_scale_factor(&self) -> f32 {
        self.max_scale_factor.unwrap_or(0.)
    }

    pub fn clear_max_scale_factor(&mut self) {
        self.max_scale_factor = ::std::option::Option::None;
    }

    pub fn has_max_scale_factor(&self) -> bool {
        self.max_scale_factor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_scale_factor(&mut self, v: f32) {
        self.max_scale_factor = ::std::option::Option::Some(v);
    }

    // optional float auto_scale_factor = 14;

    pub fn auto_scale_factor(&self) -> f32 {
        self.auto_scale_factor.unwrap_or(0.)
    }

    pub fn clear_auto_scale_factor(&mut self) {
        self.auto_scale_factor = ::std::option::Option::None;
    }

    pub fn has_auto_scale_factor(&self) -> bool {
        self.auto_scale_factor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auto_scale_factor(&mut self, v: f32) {
        self.auto_scale_factor = ::std::option::Option::Some(v);
    }

    // optional bool enable_test_updaters = 15;

    pub fn enable_test_updaters(&self) -> bool {
        self.enable_test_updaters.unwrap_or(false)
    }

    pub fn clear_enable_test_updaters(&mut self) {
        self.enable_test_updaters = ::std::option::Option::None;
    }

    pub fn has_enable_test_updaters(&self) -> bool {
        self.enable_test_updaters.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_test_updaters(&mut self, v: bool) {
        self.enable_test_updaters = ::std::option::Option::Some(v);
    }

    // optional bool small_mode = 16;

    pub fn small_mode(&self) -> bool {
        self.small_mode.unwrap_or(false)
    }

    pub fn clear_small_mode(&mut self) {
        self.small_mode = ::std::option::Option::None;
    }

    pub fn has_small_mode(&self) -> bool {
        self.small_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_small_mode(&mut self, v: bool) {
        self.small_mode = ::std::option::Option::Some(v);
    }

    // optional bool skip_steamvr_install_dialog = 19;

    pub fn skip_steamvr_install_dialog(&self) -> bool {
        self.skip_steamvr_install_dialog.unwrap_or(false)
    }

    pub fn clear_skip_steamvr_install_dialog(&mut self) {
        self.skip_steamvr_install_dialog = ::std::option::Option::None;
    }

    pub fn has_skip_steamvr_install_dialog(&self) -> bool {
        self.skip_steamvr_install_dialog.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skip_steamvr_install_dialog(&mut self, v: bool) {
        self.skip_steamvr_install_dialog = ::std::option::Option::Some(v);
    }

    // optional bool always_show_user_chooser = 20;

    pub fn always_show_user_chooser(&self) -> bool {
        self.always_show_user_chooser.unwrap_or(false)
    }

    pub fn clear_always_show_user_chooser(&mut self) {
        self.always_show_user_chooser = ::std::option::Option::None;
    }

    pub fn has_always_show_user_chooser(&self) -> bool {
        self.always_show_user_chooser.is_some()
    }

    // Param is passed by value, moved
    pub fn set_always_show_user_chooser(&mut self, v: bool) {
        self.always_show_user_chooser = ::std::option::Option::Some(v);
    }

    // optional bool show_family_sharing_notifications = 3000;

    pub fn show_family_sharing_notifications(&self) -> bool {
        self.show_family_sharing_notifications.unwrap_or(false)
    }

    pub fn clear_show_family_sharing_notifications(&mut self) {
        self.show_family_sharing_notifications = ::std::option::Option::None;
    }

    pub fn has_show_family_sharing_notifications(&self) -> bool {
        self.show_family_sharing_notifications.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_family_sharing_notifications(&mut self, v: bool) {
        self.show_family_sharing_notifications = ::std::option::Option::Some(v);
    }

    // optional int32 overlay_fps_counter_corner = 4000;

    pub fn overlay_fps_counter_corner(&self) -> i32 {
        self.overlay_fps_counter_corner.unwrap_or(0)
    }

    pub fn clear_overlay_fps_counter_corner(&mut self) {
        self.overlay_fps_counter_corner = ::std::option::Option::None;
    }

    pub fn has_overlay_fps_counter_corner(&self) -> bool {
        self.overlay_fps_counter_corner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overlay_fps_counter_corner(&mut self, v: i32) {
        self.overlay_fps_counter_corner = ::std::option::Option::Some(v);
    }

    // optional bool overlay_fps_counter_high_contrast = 4001;

    pub fn overlay_fps_counter_high_contrast(&self) -> bool {
        self.overlay_fps_counter_high_contrast.unwrap_or(false)
    }

    pub fn clear_overlay_fps_counter_high_contrast(&mut self) {
        self.overlay_fps_counter_high_contrast = ::std::option::Option::None;
    }

    pub fn has_overlay_fps_counter_high_contrast(&self) -> bool {
        self.overlay_fps_counter_high_contrast.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overlay_fps_counter_high_contrast(&mut self, v: bool) {
        self.overlay_fps_counter_high_contrast = ::std::option::Option::Some(v);
    }

    // optional bool enable_overlay = 4004;

    pub fn enable_overlay(&self) -> bool {
        self.enable_overlay.unwrap_or(false)
    }

    pub fn clear_enable_overlay(&mut self) {
        self.enable_overlay = ::std::option::Option::None;
    }

    pub fn has_enable_overlay(&self) -> bool {
        self.enable_overlay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_overlay(&mut self, v: bool) {
        self.enable_overlay = ::std::option::Option::Some(v);
    }

    // optional bool disable_desktop_game_theater = 4005;

    pub fn disable_desktop_game_theater(&self) -> bool {
        self.disable_desktop_game_theater.unwrap_or(false)
    }

    pub fn clear_disable_desktop_game_theater(&mut self) {
        self.disable_desktop_game_theater = ::std::option::Option::None;
    }

    pub fn has_disable_desktop_game_theater(&self) -> bool {
        self.disable_desktop_game_theater.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable_desktop_game_theater(&mut self, v: bool) {
        self.disable_desktop_game_theater = ::std::option::Option::Some(v);
    }

    // optional bool enable_screenshot_notification = 4006;

    pub fn enable_screenshot_notification(&self) -> bool {
        self.enable_screenshot_notification.unwrap_or(false)
    }

    pub fn clear_enable_screenshot_notification(&mut self) {
        self.enable_screenshot_notification = ::std::option::Option::None;
    }

    pub fn has_enable_screenshot_notification(&self) -> bool {
        self.enable_screenshot_notification.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_screenshot_notification(&mut self, v: bool) {
        self.enable_screenshot_notification = ::std::option::Option::Some(v);
    }

    // optional bool enable_screenshot_sound = 4007;

    pub fn enable_screenshot_sound(&self) -> bool {
        self.enable_screenshot_sound.unwrap_or(false)
    }

    pub fn clear_enable_screenshot_sound(&mut self) {
        self.enable_screenshot_sound = ::std::option::Option::None;
    }

    pub fn has_enable_screenshot_sound(&self) -> bool {
        self.enable_screenshot_sound.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_screenshot_sound(&mut self, v: bool) {
        self.enable_screenshot_sound = ::std::option::Option::Some(v);
    }

    // optional bool save_uncompressed_screenshots = 4008;

    pub fn save_uncompressed_screenshots(&self) -> bool {
        self.save_uncompressed_screenshots.unwrap_or(false)
    }

    pub fn clear_save_uncompressed_screenshots(&mut self) {
        self.save_uncompressed_screenshots = ::std::option::Option::None;
    }

    pub fn has_save_uncompressed_screenshots(&self) -> bool {
        self.save_uncompressed_screenshots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_save_uncompressed_screenshots(&mut self, v: bool) {
        self.save_uncompressed_screenshots = ::std::option::Option::Some(v);
    }

    // optional string screenshots_path = 4009;

    pub fn screenshots_path(&self) -> &str {
        match self.screenshots_path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_screenshots_path(&mut self) {
        self.screenshots_path = ::std::option::Option::None;
    }

    pub fn has_screenshots_path(&self) -> bool {
        self.screenshots_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screenshots_path(&mut self, v: ::std::string::String) {
        self.screenshots_path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_screenshots_path(&mut self) -> &mut ::std::string::String {
        if self.screenshots_path.is_none() {
            self.screenshots_path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.screenshots_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_screenshots_path(&mut self) -> ::std::string::String {
        self.screenshots_path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 default_ping_rate = 4010;

    pub fn default_ping_rate(&self) -> i32 {
        self.default_ping_rate.unwrap_or(0)
    }

    pub fn clear_default_ping_rate(&mut self) {
        self.default_ping_rate = ::std::option::Option::None;
    }

    pub fn has_default_ping_rate(&self) -> bool {
        self.default_ping_rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_ping_rate(&mut self, v: i32) {
        self.default_ping_rate = ::std::option::Option::Some(v);
    }

    // optional int32 server_ping_rate = 4011;

    pub fn server_ping_rate(&self) -> i32 {
        self.server_ping_rate.unwrap_or(0)
    }

    pub fn clear_server_ping_rate(&mut self) {
        self.server_ping_rate = ::std::option::Option::None;
    }

    pub fn has_server_ping_rate(&self) -> bool {
        self.server_ping_rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_ping_rate(&mut self, v: i32) {
        self.server_ping_rate = ::std::option::Option::Some(v);
    }

    // optional int32 steam_networking_share_ip = 4012;

    pub fn steam_networking_share_ip(&self) -> i32 {
        self.steam_networking_share_ip.unwrap_or(0)
    }

    pub fn clear_steam_networking_share_ip(&mut self) {
        self.steam_networking_share_ip = ::std::option::Option::None;
    }

    pub fn has_steam_networking_share_ip(&self) -> bool {
        self.steam_networking_share_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_networking_share_ip(&mut self, v: i32) {
        self.steam_networking_share_ip = ::std::option::Option::Some(v);
    }

    // optional string web_browser_home = 4013;

    pub fn web_browser_home(&self) -> &str {
        match self.web_browser_home.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_web_browser_home(&mut self) {
        self.web_browser_home = ::std::option::Option::None;
    }

    pub fn has_web_browser_home(&self) -> bool {
        self.web_browser_home.is_some()
    }

    // Param is passed by value, moved
    pub fn set_web_browser_home(&mut self, v: ::std::string::String) {
        self.web_browser_home = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_web_browser_home(&mut self) -> &mut ::std::string::String {
        if self.web_browser_home.is_none() {
            self.web_browser_home = ::std::option::Option::Some(::std::string::String::new());
        }
        self.web_browser_home.as_mut().unwrap()
    }

    // Take field
    pub fn take_web_browser_home(&mut self) -> ::std::string::String {
        self.web_browser_home.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string voice_mic_device_name = 4014;

    pub fn voice_mic_device_name(&self) -> &str {
        match self.voice_mic_device_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_voice_mic_device_name(&mut self) {
        self.voice_mic_device_name = ::std::option::Option::None;
    }

    pub fn has_voice_mic_device_name(&self) -> bool {
        self.voice_mic_device_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_mic_device_name(&mut self, v: ::std::string::String) {
        self.voice_mic_device_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_voice_mic_device_name(&mut self) -> &mut ::std::string::String {
        if self.voice_mic_device_name.is_none() {
            self.voice_mic_device_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.voice_mic_device_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_voice_mic_device_name(&mut self) -> ::std::string::String {
        self.voice_mic_device_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional float voice_mic_input_gain = 4015;

    pub fn voice_mic_input_gain(&self) -> f32 {
        self.voice_mic_input_gain.unwrap_or(0.)
    }

    pub fn clear_voice_mic_input_gain(&mut self) {
        self.voice_mic_input_gain = ::std::option::Option::None;
    }

    pub fn has_voice_mic_input_gain(&self) -> bool {
        self.voice_mic_input_gain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_mic_input_gain(&mut self, v: f32) {
        self.voice_mic_input_gain = ::std::option::Option::Some(v);
    }

    // optional float voice_speaker_output_gain = 4016;

    pub fn voice_speaker_output_gain(&self) -> f32 {
        self.voice_speaker_output_gain.unwrap_or(0.)
    }

    pub fn clear_voice_speaker_output_gain(&mut self) {
        self.voice_speaker_output_gain = ::std::option::Option::None;
    }

    pub fn has_voice_speaker_output_gain(&self) -> bool {
        self.voice_speaker_output_gain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_speaker_output_gain(&mut self, v: f32) {
        self.voice_speaker_output_gain = ::std::option::Option::Some(v);
    }

    // optional int32 voice_push_to_talk_setting = 4017;

    pub fn voice_push_to_talk_setting(&self) -> i32 {
        self.voice_push_to_talk_setting.unwrap_or(0)
    }

    pub fn clear_voice_push_to_talk_setting(&mut self) {
        self.voice_push_to_talk_setting = ::std::option::Option::None;
    }

    pub fn has_voice_push_to_talk_setting(&self) -> bool {
        self.voice_push_to_talk_setting.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_push_to_talk_setting(&mut self, v: i32) {
        self.voice_push_to_talk_setting = ::std::option::Option::Some(v);
    }

    // optional bool overlay_toolbar_list_view = 4019;

    pub fn overlay_toolbar_list_view(&self) -> bool {
        self.overlay_toolbar_list_view.unwrap_or(false)
    }

    pub fn clear_overlay_toolbar_list_view(&mut self) {
        self.overlay_toolbar_list_view = ::std::option::Option::None;
    }

    pub fn has_overlay_toolbar_list_view(&self) -> bool {
        self.overlay_toolbar_list_view.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overlay_toolbar_list_view(&mut self, v: bool) {
        self.overlay_toolbar_list_view = ::std::option::Option::Some(v);
    }

    // optional bool always_use_gamepadui_overlay = 4020;

    pub fn always_use_gamepadui_overlay(&self) -> bool {
        self.always_use_gamepadui_overlay.unwrap_or(false)
    }

    pub fn clear_always_use_gamepadui_overlay(&mut self) {
        self.always_use_gamepadui_overlay = ::std::option::Option::None;
    }

    pub fn has_always_use_gamepadui_overlay(&self) -> bool {
        self.always_use_gamepadui_overlay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_always_use_gamepadui_overlay(&mut self, v: bool) {
        self.always_use_gamepadui_overlay = ::std::option::Option::Some(v);
    }

    // optional string overlay_tabs = 4021;

    pub fn overlay_tabs(&self) -> &str {
        match self.overlay_tabs.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_overlay_tabs(&mut self) {
        self.overlay_tabs = ::std::option::Option::None;
    }

    pub fn has_overlay_tabs(&self) -> bool {
        self.overlay_tabs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overlay_tabs(&mut self, v: ::std::string::String) {
        self.overlay_tabs = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_overlay_tabs(&mut self) -> &mut ::std::string::String {
        if self.overlay_tabs.is_none() {
            self.overlay_tabs = ::std::option::Option::Some(::std::string::String::new());
        }
        self.overlay_tabs.as_mut().unwrap()
    }

    // Take field
    pub fn take_overlay_tabs(&mut self) -> ::std::string::String {
        self.overlay_tabs.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool overlay_scale_interface = 4022;

    pub fn overlay_scale_interface(&self) -> bool {
        self.overlay_scale_interface.unwrap_or(false)
    }

    pub fn clear_overlay_scale_interface(&mut self) {
        self.overlay_scale_interface = ::std::option::Option::None;
    }

    pub fn has_overlay_scale_interface(&self) -> bool {
        self.overlay_scale_interface.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overlay_scale_interface(&mut self, v: bool) {
        self.overlay_scale_interface = ::std::option::Option::Some(v);
    }

    // optional bool smooth_scroll_webviews = 5000;

    pub fn smooth_scroll_webviews(&self) -> bool {
        self.smooth_scroll_webviews.unwrap_or(false)
    }

    pub fn clear_smooth_scroll_webviews(&mut self) {
        self.smooth_scroll_webviews = ::std::option::Option::None;
    }

    pub fn has_smooth_scroll_webviews(&self) -> bool {
        self.smooth_scroll_webviews.is_some()
    }

    // Param is passed by value, moved
    pub fn set_smooth_scroll_webviews(&mut self, v: bool) {
        self.smooth_scroll_webviews = ::std::option::Option::Some(v);
    }

    // optional bool enable_gpu_accelerated_webviews = 5001;

    pub fn enable_gpu_accelerated_webviews(&self) -> bool {
        self.enable_gpu_accelerated_webviews.unwrap_or(false)
    }

    pub fn clear_enable_gpu_accelerated_webviews(&mut self) {
        self.enable_gpu_accelerated_webviews = ::std::option::Option::None;
    }

    pub fn has_enable_gpu_accelerated_webviews(&self) -> bool {
        self.enable_gpu_accelerated_webviews.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_gpu_accelerated_webviews(&mut self, v: bool) {
        self.enable_gpu_accelerated_webviews = ::std::option::Option::Some(v);
    }

    // optional bool enable_hardware_video_decoding = 5003;

    pub fn enable_hardware_video_decoding(&self) -> bool {
        self.enable_hardware_video_decoding.unwrap_or(false)
    }

    pub fn clear_enable_hardware_video_decoding(&mut self) {
        self.enable_hardware_video_decoding = ::std::option::Option::None;
    }

    pub fn has_enable_hardware_video_decoding(&self) -> bool {
        self.enable_hardware_video_decoding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_hardware_video_decoding(&mut self, v: bool) {
        self.enable_hardware_video_decoding = ::std::option::Option::Some(v);
    }

    // optional bool run_at_startup = 5004;

    pub fn run_at_startup(&self) -> bool {
        self.run_at_startup.unwrap_or(false)
    }

    pub fn clear_run_at_startup(&mut self) {
        self.run_at_startup = ::std::option::Option::None;
    }

    pub fn has_run_at_startup(&self) -> bool {
        self.run_at_startup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_run_at_startup(&mut self, v: bool) {
        self.run_at_startup = ::std::option::Option::Some(v);
    }

    // optional bool enable_dpi_scaling = 5005;

    pub fn enable_dpi_scaling(&self) -> bool {
        self.enable_dpi_scaling.unwrap_or(false)
    }

    pub fn clear_enable_dpi_scaling(&mut self) {
        self.enable_dpi_scaling = ::std::option::Option::None;
    }

    pub fn has_enable_dpi_scaling(&self) -> bool {
        self.enable_dpi_scaling.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_dpi_scaling(&mut self, v: bool) {
        self.enable_dpi_scaling = ::std::option::Option::Some(v);
    }

    // optional bool enable_marketing_messages = 5006;

    pub fn enable_marketing_messages(&self) -> bool {
        self.enable_marketing_messages.unwrap_or(false)
    }

    pub fn clear_enable_marketing_messages(&mut self) {
        self.enable_marketing_messages = ::std::option::Option::None;
    }

    pub fn has_enable_marketing_messages(&self) -> bool {
        self.enable_marketing_messages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_marketing_messages(&mut self, v: bool) {
        self.enable_marketing_messages = ::std::option::Option::Some(v);
    }

    // optional bool start_in_big_picture_mode = 5007;

    pub fn start_in_big_picture_mode(&self) -> bool {
        self.start_in_big_picture_mode.unwrap_or(false)
    }

    pub fn clear_start_in_big_picture_mode(&mut self) {
        self.start_in_big_picture_mode = ::std::option::Option::None;
    }

    pub fn has_start_in_big_picture_mode(&self) -> bool {
        self.start_in_big_picture_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_in_big_picture_mode(&mut self, v: bool) {
        self.start_in_big_picture_mode = ::std::option::Option::Some(v);
    }

    // optional uint32 jumplist_flags = 5008;

    pub fn jumplist_flags(&self) -> u32 {
        self.jumplist_flags.unwrap_or(0)
    }

    pub fn clear_jumplist_flags(&mut self) {
        self.jumplist_flags = ::std::option::Option::None;
    }

    pub fn has_jumplist_flags(&self) -> bool {
        self.jumplist_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jumplist_flags(&mut self, v: u32) {
        self.jumplist_flags = ::std::option::Option::Some(v);
    }

    // optional bool enable_ui_sounds = 5009;

    pub fn enable_ui_sounds(&self) -> bool {
        self.enable_ui_sounds.unwrap_or(false)
    }

    pub fn clear_enable_ui_sounds(&mut self) {
        self.enable_ui_sounds = ::std::option::Option::None;
    }

    pub fn has_enable_ui_sounds(&self) -> bool {
        self.enable_ui_sounds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_ui_sounds(&mut self, v: bool) {
        self.enable_ui_sounds = ::std::option::Option::Some(v);
    }

    // optional bool disable_all_toasts = 6000;

    pub fn disable_all_toasts(&self) -> bool {
        self.disable_all_toasts.unwrap_or(false)
    }

    pub fn clear_disable_all_toasts(&mut self) {
        self.disable_all_toasts = ::std::option::Option::None;
    }

    pub fn has_disable_all_toasts(&self) -> bool {
        self.disable_all_toasts.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable_all_toasts(&mut self, v: bool) {
        self.disable_all_toasts = ::std::option::Option::Some(v);
    }

    // optional bool disable_toasts_in_game = 6001;

    pub fn disable_toasts_in_game(&self) -> bool {
        self.disable_toasts_in_game.unwrap_or(false)
    }

    pub fn clear_disable_toasts_in_game(&mut self) {
        self.disable_toasts_in_game = ::std::option::Option::None;
    }

    pub fn has_disable_toasts_in_game(&self) -> bool {
        self.disable_toasts_in_game.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable_toasts_in_game(&mut self, v: bool) {
        self.disable_toasts_in_game = ::std::option::Option::Some(v);
    }

    // optional bool play_sound_on_toast = 6002;

    pub fn play_sound_on_toast(&self) -> bool {
        self.play_sound_on_toast.unwrap_or(false)
    }

    pub fn clear_play_sound_on_toast(&mut self) {
        self.play_sound_on_toast = ::std::option::Option::None;
    }

    pub fn has_play_sound_on_toast(&self) -> bool {
        self.play_sound_on_toast.is_some()
    }

    // Param is passed by value, moved
    pub fn set_play_sound_on_toast(&mut self, v: bool) {
        self.play_sound_on_toast = ::std::option::Option::Some(v);
    }

    // optional int32 library_display_size = 7000;

    pub fn library_display_size(&self) -> i32 {
        self.library_display_size.unwrap_or(0)
    }

    pub fn clear_library_display_size(&mut self) {
        self.library_display_size = ::std::option::Option::None;
    }

    pub fn has_library_display_size(&self) -> bool {
        self.library_display_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_library_display_size(&mut self, v: i32) {
        self.library_display_size = ::std::option::Option::Some(v);
    }

    // optional bool library_whats_new_show_only_product_updates = 7001;

    pub fn library_whats_new_show_only_product_updates(&self) -> bool {
        self.library_whats_new_show_only_product_updates.unwrap_or(false)
    }

    pub fn clear_library_whats_new_show_only_product_updates(&mut self) {
        self.library_whats_new_show_only_product_updates = ::std::option::Option::None;
    }

    pub fn has_library_whats_new_show_only_product_updates(&self) -> bool {
        self.library_whats_new_show_only_product_updates.is_some()
    }

    // Param is passed by value, moved
    pub fn set_library_whats_new_show_only_product_updates(&mut self, v: bool) {
        self.library_whats_new_show_only_product_updates = ::std::option::Option::Some(v);
    }

    // optional bool show_store_content_on_home = 7002;

    pub fn show_store_content_on_home(&self) -> bool {
        self.show_store_content_on_home.unwrap_or(false)
    }

    pub fn clear_show_store_content_on_home(&mut self) {
        self.show_store_content_on_home = ::std::option::Option::None;
    }

    pub fn has_show_store_content_on_home(&self) -> bool {
        self.show_store_content_on_home.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_store_content_on_home(&mut self, v: bool) {
        self.show_store_content_on_home = ::std::option::Option::Some(v);
    }

    // optional string start_page = 7003;

    pub fn start_page(&self) -> &str {
        match self.start_page.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_start_page(&mut self) {
        self.start_page = ::std::option::Option::None;
    }

    pub fn has_start_page(&self) -> bool {
        self.start_page.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_page(&mut self, v: ::std::string::String) {
        self.start_page = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_page(&mut self) -> &mut ::std::string::String {
        if self.start_page.is_none() {
            self.start_page = ::std::option::Option::Some(::std::string::String::new());
        }
        self.start_page.as_mut().unwrap()
    }

    // Take field
    pub fn take_start_page(&mut self) -> ::std::string::String {
        self.start_page.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool library_low_bandwidth_mode = 7004;

    pub fn library_low_bandwidth_mode(&self) -> bool {
        self.library_low_bandwidth_mode.unwrap_or(false)
    }

    pub fn clear_library_low_bandwidth_mode(&mut self) {
        self.library_low_bandwidth_mode = ::std::option::Option::None;
    }

    pub fn has_library_low_bandwidth_mode(&self) -> bool {
        self.library_low_bandwidth_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_library_low_bandwidth_mode(&mut self, v: bool) {
        self.library_low_bandwidth_mode = ::std::option::Option::Some(v);
    }

    // optional bool library_low_perf_mode = 7005;

    pub fn library_low_perf_mode(&self) -> bool {
        self.library_low_perf_mode.unwrap_or(false)
    }

    pub fn clear_library_low_perf_mode(&mut self) {
        self.library_low_perf_mode = ::std::option::Option::None;
    }

    pub fn has_library_low_perf_mode(&self) -> bool {
        self.library_low_perf_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_library_low_perf_mode(&mut self, v: bool) {
        self.library_low_perf_mode = ::std::option::Option::Some(v);
    }

    // optional bool library_disable_community_content = 7006;

    pub fn library_disable_community_content(&self) -> bool {
        self.library_disable_community_content.unwrap_or(false)
    }

    pub fn clear_library_disable_community_content(&mut self) {
        self.library_disable_community_content = ::std::option::Option::None;
    }

    pub fn has_library_disable_community_content(&self) -> bool {
        self.library_disable_community_content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_library_disable_community_content(&mut self, v: bool) {
        self.library_disable_community_content = ::std::option::Option::Some(v);
    }

    // optional bool library_display_icon_in_game_list = 7007;

    pub fn library_display_icon_in_game_list(&self) -> bool {
        self.library_display_icon_in_game_list.unwrap_or(false)
    }

    pub fn clear_library_display_icon_in_game_list(&mut self) {
        self.library_display_icon_in_game_list = ::std::option::Option::None;
    }

    pub fn has_library_display_icon_in_game_list(&self) -> bool {
        self.library_display_icon_in_game_list.is_some()
    }

    // Param is passed by value, moved
    pub fn set_library_display_icon_in_game_list(&mut self, v: bool) {
        self.library_display_icon_in_game_list = ::std::option::Option::Some(v);
    }

    // optional bool ready_to_play_includes_streaming = 7008;

    pub fn ready_to_play_includes_streaming(&self) -> bool {
        self.ready_to_play_includes_streaming.unwrap_or(false)
    }

    pub fn clear_ready_to_play_includes_streaming(&mut self) {
        self.ready_to_play_includes_streaming = ::std::option::Option::None;
    }

    pub fn has_ready_to_play_includes_streaming(&self) -> bool {
        self.ready_to_play_includes_streaming.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ready_to_play_includes_streaming(&mut self, v: bool) {
        self.ready_to_play_includes_streaming = ::std::option::Option::Some(v);
    }

    // optional bool show_steam_deck_info = 7009;

    pub fn show_steam_deck_info(&self) -> bool {
        self.show_steam_deck_info.unwrap_or(false)
    }

    pub fn clear_show_steam_deck_info(&mut self) {
        self.show_steam_deck_info = ::std::option::Option::None;
    }

    pub fn has_show_steam_deck_info(&self) -> bool {
        self.show_steam_deck_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_steam_deck_info(&mut self, v: bool) {
        self.show_steam_deck_info = ::std::option::Option::Some(v);
    }

    // optional bool enable_shader_precache = 8000;

    pub fn enable_shader_precache(&self) -> bool {
        self.enable_shader_precache.unwrap_or(false)
    }

    pub fn clear_enable_shader_precache(&mut self) {
        self.enable_shader_precache = ::std::option::Option::None;
    }

    pub fn has_enable_shader_precache(&self) -> bool {
        self.enable_shader_precache.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_shader_precache(&mut self, v: bool) {
        self.enable_shader_precache = ::std::option::Option::Some(v);
    }

    // optional bool enable_shader_background_processing = 8001;

    pub fn enable_shader_background_processing(&self) -> bool {
        self.enable_shader_background_processing.unwrap_or(false)
    }

    pub fn clear_enable_shader_background_processing(&mut self) {
        self.enable_shader_background_processing = ::std::option::Option::None;
    }

    pub fn has_enable_shader_background_processing(&self) -> bool {
        self.enable_shader_background_processing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_shader_background_processing(&mut self, v: bool) {
        self.enable_shader_background_processing = ::std::option::Option::Some(v);
    }

    // optional uint64 shader_precached_size = 8002;

    pub fn shader_precached_size(&self) -> u64 {
        self.shader_precached_size.unwrap_or(0)
    }

    pub fn clear_shader_precached_size(&mut self) {
        self.shader_precached_size = ::std::option::Option::None;
    }

    pub fn has_shader_precached_size(&self) -> bool {
        self.shader_precached_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shader_precached_size(&mut self, v: u64) {
        self.shader_precached_size = ::std::option::Option::Some(v);
    }

    // optional bool needs_steam_service_repair = 8003;

    pub fn needs_steam_service_repair(&self) -> bool {
        self.needs_steam_service_repair.unwrap_or(false)
    }

    pub fn clear_needs_steam_service_repair(&mut self) {
        self.needs_steam_service_repair = ::std::option::Option::None;
    }

    pub fn has_needs_steam_service_repair(&self) -> bool {
        self.needs_steam_service_repair.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needs_steam_service_repair(&mut self, v: bool) {
        self.needs_steam_service_repair = ::std::option::Option::Some(v);
    }

    // optional int32 download_peer_content = 8004;

    pub fn download_peer_content(&self) -> i32 {
        self.download_peer_content.unwrap_or(0)
    }

    pub fn clear_download_peer_content(&mut self) {
        self.download_peer_content = ::std::option::Option::None;
    }

    pub fn has_download_peer_content(&self) -> bool {
        self.download_peer_content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_peer_content(&mut self, v: i32) {
        self.download_peer_content = ::std::option::Option::Some(v);
    }

    // optional bool download_rate_bits_per_s = 8005;

    pub fn download_rate_bits_per_s(&self) -> bool {
        self.download_rate_bits_per_s.unwrap_or(false)
    }

    pub fn clear_download_rate_bits_per_s(&mut self) {
        self.download_rate_bits_per_s = ::std::option::Option::None;
    }

    pub fn has_download_rate_bits_per_s(&self) -> bool {
        self.download_rate_bits_per_s.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_rate_bits_per_s(&mut self, v: bool) {
        self.download_rate_bits_per_s = ::std::option::Option::Some(v);
    }

    // optional bool restrict_auto_updates = 8006;

    pub fn restrict_auto_updates(&self) -> bool {
        self.restrict_auto_updates.unwrap_or(false)
    }

    pub fn clear_restrict_auto_updates(&mut self) {
        self.restrict_auto_updates = ::std::option::Option::None;
    }

    pub fn has_restrict_auto_updates(&self) -> bool {
        self.restrict_auto_updates.is_some()
    }

    // Param is passed by value, moved
    pub fn set_restrict_auto_updates(&mut self, v: bool) {
        self.restrict_auto_updates = ::std::option::Option::Some(v);
    }

    // optional int32 restrict_auto_updates_start = 8007;

    pub fn restrict_auto_updates_start(&self) -> i32 {
        self.restrict_auto_updates_start.unwrap_or(0)
    }

    pub fn clear_restrict_auto_updates_start(&mut self) {
        self.restrict_auto_updates_start = ::std::option::Option::None;
    }

    pub fn has_restrict_auto_updates_start(&self) -> bool {
        self.restrict_auto_updates_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_restrict_auto_updates_start(&mut self, v: i32) {
        self.restrict_auto_updates_start = ::std::option::Option::Some(v);
    }

    // optional int32 restrict_auto_updates_end = 8008;

    pub fn restrict_auto_updates_end(&self) -> i32 {
        self.restrict_auto_updates_end.unwrap_or(0)
    }

    pub fn clear_restrict_auto_updates_end(&mut self) {
        self.restrict_auto_updates_end = ::std::option::Option::None;
    }

    pub fn has_restrict_auto_updates_end(&self) -> bool {
        self.restrict_auto_updates_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_restrict_auto_updates_end(&mut self, v: i32) {
        self.restrict_auto_updates_end = ::std::option::Option::Some(v);
    }

    // optional int32 download_region = 8009;

    pub fn download_region(&self) -> i32 {
        self.download_region.unwrap_or(0)
    }

    pub fn clear_download_region(&mut self) {
        self.download_region = ::std::option::Option::None;
    }

    pub fn has_download_region(&self) -> bool {
        self.download_region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_region(&mut self, v: i32) {
        self.download_region = ::std::option::Option::Some(v);
    }

    // optional bool download_while_app_running = 8010;

    pub fn download_while_app_running(&self) -> bool {
        self.download_while_app_running.unwrap_or(false)
    }

    pub fn clear_download_while_app_running(&mut self) {
        self.download_while_app_running = ::std::option::Option::None;
    }

    pub fn has_download_while_app_running(&self) -> bool {
        self.download_while_app_running.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_while_app_running(&mut self, v: bool) {
        self.download_while_app_running = ::std::option::Option::Some(v);
    }

    // optional bool download_throttle_while_streaming = 8011;

    pub fn download_throttle_while_streaming(&self) -> bool {
        self.download_throttle_while_streaming.unwrap_or(false)
    }

    pub fn clear_download_throttle_while_streaming(&mut self) {
        self.download_throttle_while_streaming = ::std::option::Option::None;
    }

    pub fn has_download_throttle_while_streaming(&self) -> bool {
        self.download_throttle_while_streaming.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_throttle_while_streaming(&mut self, v: bool) {
        self.download_throttle_while_streaming = ::std::option::Option::Some(v);
    }

    // optional int32 download_throttle_rate = 8012;

    pub fn download_throttle_rate(&self) -> i32 {
        self.download_throttle_rate.unwrap_or(0)
    }

    pub fn clear_download_throttle_rate(&mut self) {
        self.download_throttle_rate = ::std::option::Option::None;
    }

    pub fn has_download_throttle_rate(&self) -> bool {
        self.download_throttle_rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_throttle_rate(&mut self, v: i32) {
        self.download_throttle_rate = ::std::option::Option::Some(v);
    }

    // optional bool cloud_enabled = 10000;

    pub fn cloud_enabled(&self) -> bool {
        self.cloud_enabled.unwrap_or(false)
    }

    pub fn clear_cloud_enabled(&mut self) {
        self.cloud_enabled = ::std::option::Option::None;
    }

    pub fn has_cloud_enabled(&self) -> bool {
        self.cloud_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cloud_enabled(&mut self, v: bool) {
        self.cloud_enabled = ::std::option::Option::Some(v);
    }

    // optional bool show_screenshot_manager = 10001;

    pub fn show_screenshot_manager(&self) -> bool {
        self.show_screenshot_manager.unwrap_or(false)
    }

    pub fn clear_show_screenshot_manager(&mut self) {
        self.show_screenshot_manager = ::std::option::Option::None;
    }

    pub fn has_show_screenshot_manager(&self) -> bool {
        self.show_screenshot_manager.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_screenshot_manager(&mut self, v: bool) {
        self.show_screenshot_manager = ::std::option::Option::Some(v);
    }

    // optional int32 music_volume = 11000;

    pub fn music_volume(&self) -> i32 {
        self.music_volume.unwrap_or(0)
    }

    pub fn clear_music_volume(&mut self) {
        self.music_volume = ::std::option::Option::None;
    }

    pub fn has_music_volume(&self) -> bool {
        self.music_volume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_music_volume(&mut self, v: i32) {
        self.music_volume = ::std::option::Option::Some(v);
    }

    // optional bool music_pause_on_app_start = 11001;

    pub fn music_pause_on_app_start(&self) -> bool {
        self.music_pause_on_app_start.unwrap_or(false)
    }

    pub fn clear_music_pause_on_app_start(&mut self) {
        self.music_pause_on_app_start = ::std::option::Option::None;
    }

    pub fn has_music_pause_on_app_start(&self) -> bool {
        self.music_pause_on_app_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_music_pause_on_app_start(&mut self, v: bool) {
        self.music_pause_on_app_start = ::std::option::Option::Some(v);
    }

    // optional bool music_pause_on_voice_chat = 11002;

    pub fn music_pause_on_voice_chat(&self) -> bool {
        self.music_pause_on_voice_chat.unwrap_or(false)
    }

    pub fn clear_music_pause_on_voice_chat(&mut self) {
        self.music_pause_on_voice_chat = ::std::option::Option::None;
    }

    pub fn has_music_pause_on_voice_chat(&self) -> bool {
        self.music_pause_on_voice_chat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_music_pause_on_voice_chat(&mut self, v: bool) {
        self.music_pause_on_voice_chat = ::std::option::Option::Some(v);
    }

    // optional bool music_download_high_quality = 11003;

    pub fn music_download_high_quality(&self) -> bool {
        self.music_download_high_quality.unwrap_or(false)
    }

    pub fn clear_music_download_high_quality(&mut self) {
        self.music_download_high_quality = ::std::option::Option::None;
    }

    pub fn has_music_download_high_quality(&self) -> bool {
        self.music_download_high_quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_music_download_high_quality(&mut self, v: bool) {
        self.music_download_high_quality = ::std::option::Option::Some(v);
    }

    // optional bool music_playlist_notification = 11004;

    pub fn music_playlist_notification(&self) -> bool {
        self.music_playlist_notification.unwrap_or(false)
    }

    pub fn clear_music_playlist_notification(&mut self) {
        self.music_playlist_notification = ::std::option::Option::None;
    }

    pub fn has_music_playlist_notification(&self) -> bool {
        self.music_playlist_notification.is_some()
    }

    // Param is passed by value, moved
    pub fn set_music_playlist_notification(&mut self, v: bool) {
        self.music_playlist_notification = ::std::option::Option::Some(v);
    }

    // optional .EBroadcastPermission broadcast_permissions = 12000;

    pub fn broadcast_permissions(&self) -> super::enums::EBroadcastPermission {
        match self.broadcast_permissions {
            Some(e) => e.enum_value_or(super::enums::EBroadcastPermission::k_EBroadcastPermissionDisabled),
            None => super::enums::EBroadcastPermission::k_EBroadcastPermissionDisabled,
        }
    }

    pub fn clear_broadcast_permissions(&mut self) {
        self.broadcast_permissions = ::std::option::Option::None;
    }

    pub fn has_broadcast_permissions(&self) -> bool {
        self.broadcast_permissions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_permissions(&mut self, v: super::enums::EBroadcastPermission) {
        self.broadcast_permissions = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 broadcast_output_width = 12001;

    pub fn broadcast_output_width(&self) -> i32 {
        self.broadcast_output_width.unwrap_or(0)
    }

    pub fn clear_broadcast_output_width(&mut self) {
        self.broadcast_output_width = ::std::option::Option::None;
    }

    pub fn has_broadcast_output_width(&self) -> bool {
        self.broadcast_output_width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_output_width(&mut self, v: i32) {
        self.broadcast_output_width = ::std::option::Option::Some(v);
    }

    // optional int32 broadcast_output_height = 12002;

    pub fn broadcast_output_height(&self) -> i32 {
        self.broadcast_output_height.unwrap_or(0)
    }

    pub fn clear_broadcast_output_height(&mut self) {
        self.broadcast_output_height = ::std::option::Option::None;
    }

    pub fn has_broadcast_output_height(&self) -> bool {
        self.broadcast_output_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_output_height(&mut self, v: i32) {
        self.broadcast_output_height = ::std::option::Option::Some(v);
    }

    // optional int32 broadcast_bitrate = 12003;

    pub fn broadcast_bitrate(&self) -> i32 {
        self.broadcast_bitrate.unwrap_or(0)
    }

    pub fn clear_broadcast_bitrate(&mut self) {
        self.broadcast_bitrate = ::std::option::Option::None;
    }

    pub fn has_broadcast_bitrate(&self) -> bool {
        self.broadcast_bitrate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_bitrate(&mut self, v: i32) {
        self.broadcast_bitrate = ::std::option::Option::Some(v);
    }

    // optional .EBroadcastEncoderSetting broadcast_encoding_option = 12004;

    pub fn broadcast_encoding_option(&self) -> super::enums::EBroadcastEncoderSetting {
        match self.broadcast_encoding_option {
            Some(e) => e.enum_value_or(super::enums::EBroadcastEncoderSetting::k_EBroadcastEncoderBestQuality),
            None => super::enums::EBroadcastEncoderSetting::k_EBroadcastEncoderBestQuality,
        }
    }

    pub fn clear_broadcast_encoding_option(&mut self) {
        self.broadcast_encoding_option = ::std::option::Option::None;
    }

    pub fn has_broadcast_encoding_option(&self) -> bool {
        self.broadcast_encoding_option.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_encoding_option(&mut self, v: super::enums::EBroadcastEncoderSetting) {
        self.broadcast_encoding_option = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool broadcast_record_all_video = 12005;

    pub fn broadcast_record_all_video(&self) -> bool {
        self.broadcast_record_all_video.unwrap_or(false)
    }

    pub fn clear_broadcast_record_all_video(&mut self) {
        self.broadcast_record_all_video = ::std::option::Option::None;
    }

    pub fn has_broadcast_record_all_video(&self) -> bool {
        self.broadcast_record_all_video.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_record_all_video(&mut self, v: bool) {
        self.broadcast_record_all_video = ::std::option::Option::Some(v);
    }

    // optional bool broadcast_record_all_audio = 12006;

    pub fn broadcast_record_all_audio(&self) -> bool {
        self.broadcast_record_all_audio.unwrap_or(false)
    }

    pub fn clear_broadcast_record_all_audio(&mut self) {
        self.broadcast_record_all_audio = ::std::option::Option::None;
    }

    pub fn has_broadcast_record_all_audio(&self) -> bool {
        self.broadcast_record_all_audio.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_record_all_audio(&mut self, v: bool) {
        self.broadcast_record_all_audio = ::std::option::Option::Some(v);
    }

    // optional bool broadcast_record_microphone = 12007;

    pub fn broadcast_record_microphone(&self) -> bool {
        self.broadcast_record_microphone.unwrap_or(false)
    }

    pub fn clear_broadcast_record_microphone(&mut self) {
        self.broadcast_record_microphone = ::std::option::Option::None;
    }

    pub fn has_broadcast_record_microphone(&self) -> bool {
        self.broadcast_record_microphone.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_record_microphone(&mut self, v: bool) {
        self.broadcast_record_microphone = ::std::option::Option::Some(v);
    }

    // optional bool broadcast_show_upload_stats = 12008;

    pub fn broadcast_show_upload_stats(&self) -> bool {
        self.broadcast_show_upload_stats.unwrap_or(false)
    }

    pub fn clear_broadcast_show_upload_stats(&mut self) {
        self.broadcast_show_upload_stats = ::std::option::Option::None;
    }

    pub fn has_broadcast_show_upload_stats(&self) -> bool {
        self.broadcast_show_upload_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_show_upload_stats(&mut self, v: bool) {
        self.broadcast_show_upload_stats = ::std::option::Option::Some(v);
    }

    // optional bool broadcast_show_live_reminder = 12009;

    pub fn broadcast_show_live_reminder(&self) -> bool {
        self.broadcast_show_live_reminder.unwrap_or(false)
    }

    pub fn clear_broadcast_show_live_reminder(&mut self) {
        self.broadcast_show_live_reminder = ::std::option::Option::None;
    }

    pub fn has_broadcast_show_live_reminder(&self) -> bool {
        self.broadcast_show_live_reminder.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_show_live_reminder(&mut self, v: bool) {
        self.broadcast_show_live_reminder = ::std::option::Option::Some(v);
    }

    // optional int32 broadcast_chat_corner = 12010;

    pub fn broadcast_chat_corner(&self) -> i32 {
        self.broadcast_chat_corner.unwrap_or(0)
    }

    pub fn clear_broadcast_chat_corner(&mut self) {
        self.broadcast_chat_corner = ::std::option::Option::None;
    }

    pub fn has_broadcast_chat_corner(&self) -> bool {
        self.broadcast_chat_corner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_chat_corner(&mut self, v: i32) {
        self.broadcast_chat_corner = ::std::option::Option::Some(v);
    }

    // optional bool steam_input_configurator_error_msg_enable = 14001;

    pub fn steam_input_configurator_error_msg_enable(&self) -> bool {
        self.steam_input_configurator_error_msg_enable.unwrap_or(false)
    }

    pub fn clear_steam_input_configurator_error_msg_enable(&mut self) {
        self.steam_input_configurator_error_msg_enable = ::std::option::Option::None;
    }

    pub fn has_steam_input_configurator_error_msg_enable(&self) -> bool {
        self.steam_input_configurator_error_msg_enable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_input_configurator_error_msg_enable(&mut self, v: bool) {
        self.steam_input_configurator_error_msg_enable = ::std::option::Option::Some(v);
    }

    // optional bool controller_guide_button_focus_steam = 14002;

    pub fn controller_guide_button_focus_steam(&self) -> bool {
        self.controller_guide_button_focus_steam.unwrap_or(false)
    }

    pub fn clear_controller_guide_button_focus_steam(&mut self) {
        self.controller_guide_button_focus_steam = ::std::option::Option::None;
    }

    pub fn has_controller_guide_button_focus_steam(&self) -> bool {
        self.controller_guide_button_focus_steam.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_guide_button_focus_steam(&mut self, v: bool) {
        self.controller_guide_button_focus_steam = ::std::option::Option::Some(v);
    }

    // optional bool controller_ps4_support = 14003;

    pub fn controller_ps4_support(&self) -> bool {
        self.controller_ps4_support.unwrap_or(false)
    }

    pub fn clear_controller_ps4_support(&mut self) {
        self.controller_ps4_support = ::std::option::Option::None;
    }

    pub fn has_controller_ps4_support(&self) -> bool {
        self.controller_ps4_support.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_ps4_support(&mut self, v: bool) {
        self.controller_ps4_support = ::std::option::Option::Some(v);
    }

    // optional bool controller_xbox_support = 14004;

    pub fn controller_xbox_support(&self) -> bool {
        self.controller_xbox_support.unwrap_or(false)
    }

    pub fn clear_controller_xbox_support(&mut self) {
        self.controller_xbox_support = ::std::option::Option::None;
    }

    pub fn has_controller_xbox_support(&self) -> bool {
        self.controller_xbox_support.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_xbox_support(&mut self, v: bool) {
        self.controller_xbox_support = ::std::option::Option::Some(v);
    }

    // optional bool controller_xbox_driver = 14005;

    pub fn controller_xbox_driver(&self) -> bool {
        self.controller_xbox_driver.unwrap_or(false)
    }

    pub fn clear_controller_xbox_driver(&mut self) {
        self.controller_xbox_driver = ::std::option::Option::None;
    }

    pub fn has_controller_xbox_driver(&self) -> bool {
        self.controller_xbox_driver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_xbox_driver(&mut self, v: bool) {
        self.controller_xbox_driver = ::std::option::Option::Some(v);
    }

    // optional bool controller_switch_support = 14006;

    pub fn controller_switch_support(&self) -> bool {
        self.controller_switch_support.unwrap_or(false)
    }

    pub fn clear_controller_switch_support(&mut self) {
        self.controller_switch_support = ::std::option::Option::None;
    }

    pub fn has_controller_switch_support(&self) -> bool {
        self.controller_switch_support.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_switch_support(&mut self, v: bool) {
        self.controller_switch_support = ::std::option::Option::Some(v);
    }

    // optional bool controller_generic_support = 14007;

    pub fn controller_generic_support(&self) -> bool {
        self.controller_generic_support.unwrap_or(false)
    }

    pub fn clear_controller_generic_support(&mut self) {
        self.controller_generic_support = ::std::option::Option::None;
    }

    pub fn has_controller_generic_support(&self) -> bool {
        self.controller_generic_support.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_generic_support(&mut self, v: bool) {
        self.controller_generic_support = ::std::option::Option::Some(v);
    }

    // optional int32 controller_power_off_timeout = 14008;

    pub fn controller_power_off_timeout(&self) -> i32 {
        self.controller_power_off_timeout.unwrap_or(0)
    }

    pub fn clear_controller_power_off_timeout(&mut self) {
        self.controller_power_off_timeout = ::std::option::Option::None;
    }

    pub fn has_controller_power_off_timeout(&self) -> bool {
        self.controller_power_off_timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_power_off_timeout(&mut self, v: i32) {
        self.controller_power_off_timeout = ::std::option::Option::Some(v);
    }

    // optional bool turn_off_controller_on_exit = 14009;

    pub fn turn_off_controller_on_exit(&self) -> bool {
        self.turn_off_controller_on_exit.unwrap_or(false)
    }

    pub fn clear_turn_off_controller_on_exit(&mut self) {
        self.turn_off_controller_on_exit = ::std::option::Option::None;
    }

    pub fn has_turn_off_controller_on_exit(&self) -> bool {
        self.turn_off_controller_on_exit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_turn_off_controller_on_exit(&mut self, v: bool) {
        self.turn_off_controller_on_exit = ::std::option::Option::Some(v);
    }

    // optional bool controller_combine_nintendo_joycons = 14010;

    pub fn controller_combine_nintendo_joycons(&self) -> bool {
        self.controller_combine_nintendo_joycons.unwrap_or(false)
    }

    pub fn clear_controller_combine_nintendo_joycons(&mut self) {
        self.controller_combine_nintendo_joycons = ::std::option::Option::None;
    }

    pub fn has_controller_combine_nintendo_joycons(&self) -> bool {
        self.controller_combine_nintendo_joycons.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_combine_nintendo_joycons(&mut self, v: bool) {
        self.controller_combine_nintendo_joycons = ::std::option::Option::Some(v);
    }

    // optional uint64 startup_movie_id = 16000;

    pub fn startup_movie_id(&self) -> u64 {
        self.startup_movie_id.unwrap_or(0)
    }

    pub fn clear_startup_movie_id(&mut self) {
        self.startup_movie_id = ::std::option::Option::None;
    }

    pub fn has_startup_movie_id(&self) -> bool {
        self.startup_movie_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startup_movie_id(&mut self, v: u64) {
        self.startup_movie_id = ::std::option::Option::Some(v);
    }

    // optional string startup_movie_local_path = 16001;

    pub fn startup_movie_local_path(&self) -> &str {
        match self.startup_movie_local_path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_startup_movie_local_path(&mut self) {
        self.startup_movie_local_path = ::std::option::Option::None;
    }

    pub fn has_startup_movie_local_path(&self) -> bool {
        self.startup_movie_local_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startup_movie_local_path(&mut self, v: ::std::string::String) {
        self.startup_movie_local_path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_startup_movie_local_path(&mut self) -> &mut ::std::string::String {
        if self.startup_movie_local_path.is_none() {
            self.startup_movie_local_path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.startup_movie_local_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_startup_movie_local_path(&mut self) -> ::std::string::String {
        self.startup_movie_local_path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool startup_movie_shuffle = 16002;

    pub fn startup_movie_shuffle(&self) -> bool {
        self.startup_movie_shuffle.unwrap_or(false)
    }

    pub fn clear_startup_movie_shuffle(&mut self) {
        self.startup_movie_shuffle = ::std::option::Option::None;
    }

    pub fn has_startup_movie_shuffle(&self) -> bool {
        self.startup_movie_shuffle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startup_movie_shuffle(&mut self, v: bool) {
        self.startup_movie_shuffle = ::std::option::Option::Some(v);
    }

    // optional bool startup_movie_used_for_resume = 16003;

    pub fn startup_movie_used_for_resume(&self) -> bool {
        self.startup_movie_used_for_resume.unwrap_or(false)
    }

    pub fn clear_startup_movie_used_for_resume(&mut self) {
        self.startup_movie_used_for_resume = ::std::option::Option::None;
    }

    pub fn has_startup_movie_used_for_resume(&self) -> bool {
        self.startup_movie_used_for_resume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startup_movie_used_for_resume(&mut self, v: bool) {
        self.startup_movie_used_for_resume = ::std::option::Option::Some(v);
    }

    // optional bool game_notes_enable_spellcheck = 17001;

    pub fn game_notes_enable_spellcheck(&self) -> bool {
        self.game_notes_enable_spellcheck.unwrap_or(false)
    }

    pub fn clear_game_notes_enable_spellcheck(&mut self) {
        self.game_notes_enable_spellcheck = ::std::option::Option::None;
    }

    pub fn has_game_notes_enable_spellcheck(&self) -> bool {
        self.game_notes_enable_spellcheck.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_notes_enable_spellcheck(&mut self, v: bool) {
        self.game_notes_enable_spellcheck = ::std::option::Option::Some(v);
    }

    // optional int32 screenshot_items_per_row = 18000;

    pub fn screenshot_items_per_row(&self) -> i32 {
        self.screenshot_items_per_row.unwrap_or(0)
    }

    pub fn clear_screenshot_items_per_row(&mut self) {
        self.screenshot_items_per_row = ::std::option::Option::None;
    }

    pub fn has_screenshot_items_per_row(&self) -> bool {
        self.screenshot_items_per_row.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screenshot_items_per_row(&mut self, v: i32) {
        self.screenshot_items_per_row = ::std::option::Option::Some(v);
    }

    // optional bool g_background_enabled = 18200;

    pub fn g_background_enabled(&self) -> bool {
        self.g_background_enabled.unwrap_or(false)
    }

    pub fn clear_g_background_enabled(&mut self) {
        self.g_background_enabled = ::std::option::Option::None;
    }

    pub fn has_g_background_enabled(&self) -> bool {
        self.g_background_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_g_background_enabled(&mut self, v: bool) {
        self.g_background_enabled = ::std::option::Option::Some(v);
    }

    // optional string g_background_path = 18201;

    pub fn g_background_path(&self) -> &str {
        match self.g_background_path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_g_background_path(&mut self) {
        self.g_background_path = ::std::option::Option::None;
    }

    pub fn has_g_background_path(&self) -> bool {
        self.g_background_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_g_background_path(&mut self, v: ::std::string::String) {
        self.g_background_path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_g_background_path(&mut self) -> &mut ::std::string::String {
        if self.g_background_path.is_none() {
            self.g_background_path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.g_background_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_g_background_path(&mut self) -> ::std::string::String {
        self.g_background_path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string g_background_max_keep = 18202;

    pub fn g_background_max_keep(&self) -> &str {
        match self.g_background_max_keep.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_g_background_max_keep(&mut self) {
        self.g_background_max_keep = ::std::option::Option::None;
    }

    pub fn has_g_background_max_keep(&self) -> bool {
        self.g_background_max_keep.is_some()
    }

    // Param is passed by value, moved
    pub fn set_g_background_max_keep(&mut self, v: ::std::string::String) {
        self.g_background_max_keep = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_g_background_max_keep(&mut self) -> &mut ::std::string::String {
        if self.g_background_max_keep.is_none() {
            self.g_background_max_keep = ::std::option::Option::Some(::std::string::String::new());
        }
        self.g_background_max_keep.as_mut().unwrap()
    }

    // Take field
    pub fn take_g_background_max_keep(&mut self) -> ::std::string::String {
        self.g_background_max_keep.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool show_timestamps_in_console = 20000;

    pub fn show_timestamps_in_console(&self) -> bool {
        self.show_timestamps_in_console.unwrap_or(false)
    }

    pub fn clear_show_timestamps_in_console(&mut self) {
        self.show_timestamps_in_console = ::std::option::Option::None;
    }

    pub fn has_show_timestamps_in_console(&self) -> bool {
        self.show_timestamps_in_console.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_timestamps_in_console(&mut self, v: bool) {
        self.show_timestamps_in_console = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientSettings {
    const NAME: &'static str = "CMsgClientSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.no_save_personal_info = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.oobe_test_mode_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.in_client_beta = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.is_steam_sideloaded = ::std::option::Option::Some(is.read_bool()?);
                },
                42 => {
                    self.preferred_monitor = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.steam_cef_gpu_blocklist_disabled = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.bigpicture_windowed = ::std::option::Option::Some(is.read_bool()?);
                },
                66 => {
                    self.display_name = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.is_external_display = ::std::option::Option::Some(is.read_bool()?);
                },
                85 => {
                    self.steam_os_underscan_level = ::std::option::Option::Some(is.read_float()?);
                },
                88 => {
                    self.steam_os_underscan_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                101 => {
                    self.min_scale_factor = ::std::option::Option::Some(is.read_float()?);
                },
                109 => {
                    self.max_scale_factor = ::std::option::Option::Some(is.read_float()?);
                },
                117 => {
                    self.auto_scale_factor = ::std::option::Option::Some(is.read_float()?);
                },
                120 => {
                    self.enable_test_updaters = ::std::option::Option::Some(is.read_bool()?);
                },
                128 => {
                    self.small_mode = ::std::option::Option::Some(is.read_bool()?);
                },
                152 => {
                    self.skip_steamvr_install_dialog = ::std::option::Option::Some(is.read_bool()?);
                },
                160 => {
                    self.always_show_user_chooser = ::std::option::Option::Some(is.read_bool()?);
                },
                24000 => {
                    self.show_family_sharing_notifications = ::std::option::Option::Some(is.read_bool()?);
                },
                32000 => {
                    self.overlay_fps_counter_corner = ::std::option::Option::Some(is.read_int32()?);
                },
                32008 => {
                    self.overlay_fps_counter_high_contrast = ::std::option::Option::Some(is.read_bool()?);
                },
                32018 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.overlay_key)?;
                },
                32026 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.screenshot_key)?;
                },
                32032 => {
                    self.enable_overlay = ::std::option::Option::Some(is.read_bool()?);
                },
                32040 => {
                    self.disable_desktop_game_theater = ::std::option::Option::Some(is.read_bool()?);
                },
                32048 => {
                    self.enable_screenshot_notification = ::std::option::Option::Some(is.read_bool()?);
                },
                32056 => {
                    self.enable_screenshot_sound = ::std::option::Option::Some(is.read_bool()?);
                },
                32064 => {
                    self.save_uncompressed_screenshots = ::std::option::Option::Some(is.read_bool()?);
                },
                32074 => {
                    self.screenshots_path = ::std::option::Option::Some(is.read_string()?);
                },
                32080 => {
                    self.default_ping_rate = ::std::option::Option::Some(is.read_int32()?);
                },
                32088 => {
                    self.server_ping_rate = ::std::option::Option::Some(is.read_int32()?);
                },
                32096 => {
                    self.steam_networking_share_ip = ::std::option::Option::Some(is.read_int32()?);
                },
                32106 => {
                    self.web_browser_home = ::std::option::Option::Some(is.read_string()?);
                },
                32114 => {
                    self.voice_mic_device_name = ::std::option::Option::Some(is.read_string()?);
                },
                32125 => {
                    self.voice_mic_input_gain = ::std::option::Option::Some(is.read_float()?);
                },
                32133 => {
                    self.voice_speaker_output_gain = ::std::option::Option::Some(is.read_float()?);
                },
                32136 => {
                    self.voice_push_to_talk_setting = ::std::option::Option::Some(is.read_int32()?);
                },
                32146 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.voice_push_to_talk_key)?;
                },
                32152 => {
                    self.overlay_toolbar_list_view = ::std::option::Option::Some(is.read_bool()?);
                },
                32160 => {
                    self.always_use_gamepadui_overlay = ::std::option::Option::Some(is.read_bool()?);
                },
                32170 => {
                    self.overlay_tabs = ::std::option::Option::Some(is.read_string()?);
                },
                32176 => {
                    self.overlay_scale_interface = ::std::option::Option::Some(is.read_bool()?);
                },
                40000 => {
                    self.smooth_scroll_webviews = ::std::option::Option::Some(is.read_bool()?);
                },
                40008 => {
                    self.enable_gpu_accelerated_webviews = ::std::option::Option::Some(is.read_bool()?);
                },
                40024 => {
                    self.enable_hardware_video_decoding = ::std::option::Option::Some(is.read_bool()?);
                },
                40032 => {
                    self.run_at_startup = ::std::option::Option::Some(is.read_bool()?);
                },
                40040 => {
                    self.enable_dpi_scaling = ::std::option::Option::Some(is.read_bool()?);
                },
                40048 => {
                    self.enable_marketing_messages = ::std::option::Option::Some(is.read_bool()?);
                },
                40056 => {
                    self.start_in_big_picture_mode = ::std::option::Option::Some(is.read_bool()?);
                },
                40064 => {
                    self.jumplist_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                40072 => {
                    self.enable_ui_sounds = ::std::option::Option::Some(is.read_bool()?);
                },
                48000 => {
                    self.disable_all_toasts = ::std::option::Option::Some(is.read_bool()?);
                },
                48008 => {
                    self.disable_toasts_in_game = ::std::option::Option::Some(is.read_bool()?);
                },
                48016 => {
                    self.play_sound_on_toast = ::std::option::Option::Some(is.read_bool()?);
                },
                56000 => {
                    self.library_display_size = ::std::option::Option::Some(is.read_int32()?);
                },
                56008 => {
                    self.library_whats_new_show_only_product_updates = ::std::option::Option::Some(is.read_bool()?);
                },
                56016 => {
                    self.show_store_content_on_home = ::std::option::Option::Some(is.read_bool()?);
                },
                56026 => {
                    self.start_page = ::std::option::Option::Some(is.read_string()?);
                },
                56032 => {
                    self.library_low_bandwidth_mode = ::std::option::Option::Some(is.read_bool()?);
                },
                56040 => {
                    self.library_low_perf_mode = ::std::option::Option::Some(is.read_bool()?);
                },
                56048 => {
                    self.library_disable_community_content = ::std::option::Option::Some(is.read_bool()?);
                },
                56056 => {
                    self.library_display_icon_in_game_list = ::std::option::Option::Some(is.read_bool()?);
                },
                56064 => {
                    self.ready_to_play_includes_streaming = ::std::option::Option::Some(is.read_bool()?);
                },
                56072 => {
                    self.show_steam_deck_info = ::std::option::Option::Some(is.read_bool()?);
                },
                64000 => {
                    self.enable_shader_precache = ::std::option::Option::Some(is.read_bool()?);
                },
                64008 => {
                    self.enable_shader_background_processing = ::std::option::Option::Some(is.read_bool()?);
                },
                64016 => {
                    self.shader_precached_size = ::std::option::Option::Some(is.read_uint64()?);
                },
                64024 => {
                    self.needs_steam_service_repair = ::std::option::Option::Some(is.read_bool()?);
                },
                64032 => {
                    self.download_peer_content = ::std::option::Option::Some(is.read_int32()?);
                },
                64040 => {
                    self.download_rate_bits_per_s = ::std::option::Option::Some(is.read_bool()?);
                },
                64048 => {
                    self.restrict_auto_updates = ::std::option::Option::Some(is.read_bool()?);
                },
                64056 => {
                    self.restrict_auto_updates_start = ::std::option::Option::Some(is.read_int32()?);
                },
                64064 => {
                    self.restrict_auto_updates_end = ::std::option::Option::Some(is.read_int32()?);
                },
                64072 => {
                    self.download_region = ::std::option::Option::Some(is.read_int32()?);
                },
                64080 => {
                    self.download_while_app_running = ::std::option::Option::Some(is.read_bool()?);
                },
                64088 => {
                    self.download_throttle_while_streaming = ::std::option::Option::Some(is.read_bool()?);
                },
                64096 => {
                    self.download_throttle_rate = ::std::option::Option::Some(is.read_int32()?);
                },
                80000 => {
                    self.cloud_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                80008 => {
                    self.show_screenshot_manager = ::std::option::Option::Some(is.read_bool()?);
                },
                88000 => {
                    self.music_volume = ::std::option::Option::Some(is.read_int32()?);
                },
                88008 => {
                    self.music_pause_on_app_start = ::std::option::Option::Some(is.read_bool()?);
                },
                88016 => {
                    self.music_pause_on_voice_chat = ::std::option::Option::Some(is.read_bool()?);
                },
                88024 => {
                    self.music_download_high_quality = ::std::option::Option::Some(is.read_bool()?);
                },
                88032 => {
                    self.music_playlist_notification = ::std::option::Option::Some(is.read_bool()?);
                },
                96000 => {
                    self.broadcast_permissions = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                96008 => {
                    self.broadcast_output_width = ::std::option::Option::Some(is.read_int32()?);
                },
                96016 => {
                    self.broadcast_output_height = ::std::option::Option::Some(is.read_int32()?);
                },
                96024 => {
                    self.broadcast_bitrate = ::std::option::Option::Some(is.read_int32()?);
                },
                96032 => {
                    self.broadcast_encoding_option = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                96040 => {
                    self.broadcast_record_all_video = ::std::option::Option::Some(is.read_bool()?);
                },
                96048 => {
                    self.broadcast_record_all_audio = ::std::option::Option::Some(is.read_bool()?);
                },
                96056 => {
                    self.broadcast_record_microphone = ::std::option::Option::Some(is.read_bool()?);
                },
                96064 => {
                    self.broadcast_show_upload_stats = ::std::option::Option::Some(is.read_bool()?);
                },
                96072 => {
                    self.broadcast_show_live_reminder = ::std::option::Option::Some(is.read_bool()?);
                },
                96080 => {
                    self.broadcast_chat_corner = ::std::option::Option::Some(is.read_int32()?);
                },
                112008 => {
                    self.steam_input_configurator_error_msg_enable = ::std::option::Option::Some(is.read_bool()?);
                },
                112016 => {
                    self.controller_guide_button_focus_steam = ::std::option::Option::Some(is.read_bool()?);
                },
                112024 => {
                    self.controller_ps4_support = ::std::option::Option::Some(is.read_bool()?);
                },
                112032 => {
                    self.controller_xbox_support = ::std::option::Option::Some(is.read_bool()?);
                },
                112040 => {
                    self.controller_xbox_driver = ::std::option::Option::Some(is.read_bool()?);
                },
                112048 => {
                    self.controller_switch_support = ::std::option::Option::Some(is.read_bool()?);
                },
                112056 => {
                    self.controller_generic_support = ::std::option::Option::Some(is.read_bool()?);
                },
                112064 => {
                    self.controller_power_off_timeout = ::std::option::Option::Some(is.read_int32()?);
                },
                112072 => {
                    self.turn_off_controller_on_exit = ::std::option::Option::Some(is.read_bool()?);
                },
                112080 => {
                    self.controller_combine_nintendo_joycons = ::std::option::Option::Some(is.read_bool()?);
                },
                128000 => {
                    self.startup_movie_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                128010 => {
                    self.startup_movie_local_path = ::std::option::Option::Some(is.read_string()?);
                },
                128016 => {
                    self.startup_movie_shuffle = ::std::option::Option::Some(is.read_bool()?);
                },
                128024 => {
                    self.startup_movie_used_for_resume = ::std::option::Option::Some(is.read_bool()?);
                },
                136008 => {
                    self.game_notes_enable_spellcheck = ::std::option::Option::Some(is.read_bool()?);
                },
                144000 => {
                    self.screenshot_items_per_row = ::std::option::Option::Some(is.read_int32()?);
                },
                145600 => {
                    self.g_background_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                145610 => {
                    self.g_background_path = ::std::option::Option::Some(is.read_string()?);
                },
                145618 => {
                    self.g_background_max_keep = ::std::option::Option::Some(is.read_string()?);
                },
                160000 => {
                    self.show_timestamps_in_console = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.no_save_personal_info {
            my_size += 1 + 1;
        }
        if let Some(v) = self.oobe_test_mode_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.in_client_beta {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_steam_sideloaded {
            my_size += 1 + 1;
        }
        if let Some(v) = self.preferred_monitor.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.steam_cef_gpu_blocklist_disabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.bigpicture_windowed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.display_name.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.is_external_display {
            my_size += 1 + 1;
        }
        if let Some(v) = self.steam_os_underscan_level {
            my_size += 1 + 4;
        }
        if let Some(v) = self.steam_os_underscan_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.min_scale_factor {
            my_size += 1 + 4;
        }
        if let Some(v) = self.max_scale_factor {
            my_size += 1 + 4;
        }
        if let Some(v) = self.auto_scale_factor {
            my_size += 1 + 4;
        }
        if let Some(v) = self.enable_test_updaters {
            my_size += 1 + 1;
        }
        if let Some(v) = self.small_mode {
            my_size += 2 + 1;
        }
        if let Some(v) = self.skip_steamvr_install_dialog {
            my_size += 2 + 1;
        }
        if let Some(v) = self.always_show_user_chooser {
            my_size += 2 + 1;
        }
        if let Some(v) = self.show_family_sharing_notifications {
            my_size += 3 + 1;
        }
        if let Some(v) = self.overlay_fps_counter_corner {
            my_size += ::protobuf::rt::int32_size(4000, v);
        }
        if let Some(v) = self.overlay_fps_counter_high_contrast {
            my_size += 3 + 1;
        }
        if let Some(v) = self.overlay_key.as_ref() {
            let len = v.compute_size();
            my_size += 3 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.screenshot_key.as_ref() {
            let len = v.compute_size();
            my_size += 3 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.enable_overlay {
            my_size += 3 + 1;
        }
        if let Some(v) = self.disable_desktop_game_theater {
            my_size += 3 + 1;
        }
        if let Some(v) = self.enable_screenshot_notification {
            my_size += 3 + 1;
        }
        if let Some(v) = self.enable_screenshot_sound {
            my_size += 3 + 1;
        }
        if let Some(v) = self.save_uncompressed_screenshots {
            my_size += 3 + 1;
        }
        if let Some(v) = self.screenshots_path.as_ref() {
            my_size += ::protobuf::rt::string_size(4009, &v);
        }
        if let Some(v) = self.default_ping_rate {
            my_size += ::protobuf::rt::int32_size(4010, v);
        }
        if let Some(v) = self.server_ping_rate {
            my_size += ::protobuf::rt::int32_size(4011, v);
        }
        if let Some(v) = self.steam_networking_share_ip {
            my_size += ::protobuf::rt::int32_size(4012, v);
        }
        if let Some(v) = self.web_browser_home.as_ref() {
            my_size += ::protobuf::rt::string_size(4013, &v);
        }
        if let Some(v) = self.voice_mic_device_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4014, &v);
        }
        if let Some(v) = self.voice_mic_input_gain {
            my_size += 3 + 4;
        }
        if let Some(v) = self.voice_speaker_output_gain {
            my_size += 3 + 4;
        }
        if let Some(v) = self.voice_push_to_talk_setting {
            my_size += ::protobuf::rt::int32_size(4017, v);
        }
        if let Some(v) = self.voice_push_to_talk_key.as_ref() {
            let len = v.compute_size();
            my_size += 3 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.overlay_toolbar_list_view {
            my_size += 3 + 1;
        }
        if let Some(v) = self.always_use_gamepadui_overlay {
            my_size += 3 + 1;
        }
        if let Some(v) = self.overlay_tabs.as_ref() {
            my_size += ::protobuf::rt::string_size(4021, &v);
        }
        if let Some(v) = self.overlay_scale_interface {
            my_size += 3 + 1;
        }
        if let Some(v) = self.smooth_scroll_webviews {
            my_size += 3 + 1;
        }
        if let Some(v) = self.enable_gpu_accelerated_webviews {
            my_size += 3 + 1;
        }
        if let Some(v) = self.enable_hardware_video_decoding {
            my_size += 3 + 1;
        }
        if let Some(v) = self.run_at_startup {
            my_size += 3 + 1;
        }
        if let Some(v) = self.enable_dpi_scaling {
            my_size += 3 + 1;
        }
        if let Some(v) = self.enable_marketing_messages {
            my_size += 3 + 1;
        }
        if let Some(v) = self.start_in_big_picture_mode {
            my_size += 3 + 1;
        }
        if let Some(v) = self.jumplist_flags {
            my_size += ::protobuf::rt::uint32_size(5008, v);
        }
        if let Some(v) = self.enable_ui_sounds {
            my_size += 3 + 1;
        }
        if let Some(v) = self.disable_all_toasts {
            my_size += 3 + 1;
        }
        if let Some(v) = self.disable_toasts_in_game {
            my_size += 3 + 1;
        }
        if let Some(v) = self.play_sound_on_toast {
            my_size += 3 + 1;
        }
        if let Some(v) = self.library_display_size {
            my_size += ::protobuf::rt::int32_size(7000, v);
        }
        if let Some(v) = self.library_whats_new_show_only_product_updates {
            my_size += 3 + 1;
        }
        if let Some(v) = self.show_store_content_on_home {
            my_size += 3 + 1;
        }
        if let Some(v) = self.start_page.as_ref() {
            my_size += ::protobuf::rt::string_size(7003, &v);
        }
        if let Some(v) = self.library_low_bandwidth_mode {
            my_size += 3 + 1;
        }
        if let Some(v) = self.library_low_perf_mode {
            my_size += 3 + 1;
        }
        if let Some(v) = self.library_disable_community_content {
            my_size += 3 + 1;
        }
        if let Some(v) = self.library_display_icon_in_game_list {
            my_size += 3 + 1;
        }
        if let Some(v) = self.ready_to_play_includes_streaming {
            my_size += 3 + 1;
        }
        if let Some(v) = self.show_steam_deck_info {
            my_size += 3 + 1;
        }
        if let Some(v) = self.enable_shader_precache {
            my_size += 3 + 1;
        }
        if let Some(v) = self.enable_shader_background_processing {
            my_size += 3 + 1;
        }
        if let Some(v) = self.shader_precached_size {
            my_size += ::protobuf::rt::uint64_size(8002, v);
        }
        if let Some(v) = self.needs_steam_service_repair {
            my_size += 3 + 1;
        }
        if let Some(v) = self.download_peer_content {
            my_size += ::protobuf::rt::int32_size(8004, v);
        }
        if let Some(v) = self.download_rate_bits_per_s {
            my_size += 3 + 1;
        }
        if let Some(v) = self.restrict_auto_updates {
            my_size += 3 + 1;
        }
        if let Some(v) = self.restrict_auto_updates_start {
            my_size += ::protobuf::rt::int32_size(8007, v);
        }
        if let Some(v) = self.restrict_auto_updates_end {
            my_size += ::protobuf::rt::int32_size(8008, v);
        }
        if let Some(v) = self.download_region {
            my_size += ::protobuf::rt::int32_size(8009, v);
        }
        if let Some(v) = self.download_while_app_running {
            my_size += 3 + 1;
        }
        if let Some(v) = self.download_throttle_while_streaming {
            my_size += 3 + 1;
        }
        if let Some(v) = self.download_throttle_rate {
            my_size += ::protobuf::rt::int32_size(8012, v);
        }
        if let Some(v) = self.cloud_enabled {
            my_size += 3 + 1;
        }
        if let Some(v) = self.show_screenshot_manager {
            my_size += 3 + 1;
        }
        if let Some(v) = self.music_volume {
            my_size += ::protobuf::rt::int32_size(11000, v);
        }
        if let Some(v) = self.music_pause_on_app_start {
            my_size += 3 + 1;
        }
        if let Some(v) = self.music_pause_on_voice_chat {
            my_size += 3 + 1;
        }
        if let Some(v) = self.music_download_high_quality {
            my_size += 3 + 1;
        }
        if let Some(v) = self.music_playlist_notification {
            my_size += 3 + 1;
        }
        if let Some(v) = self.broadcast_permissions {
            my_size += ::protobuf::rt::int32_size(12000, v.value());
        }
        if let Some(v) = self.broadcast_output_width {
            my_size += ::protobuf::rt::int32_size(12001, v);
        }
        if let Some(v) = self.broadcast_output_height {
            my_size += ::protobuf::rt::int32_size(12002, v);
        }
        if let Some(v) = self.broadcast_bitrate {
            my_size += ::protobuf::rt::int32_size(12003, v);
        }
        if let Some(v) = self.broadcast_encoding_option {
            my_size += ::protobuf::rt::int32_size(12004, v.value());
        }
        if let Some(v) = self.broadcast_record_all_video {
            my_size += 3 + 1;
        }
        if let Some(v) = self.broadcast_record_all_audio {
            my_size += 3 + 1;
        }
        if let Some(v) = self.broadcast_record_microphone {
            my_size += 3 + 1;
        }
        if let Some(v) = self.broadcast_show_upload_stats {
            my_size += 3 + 1;
        }
        if let Some(v) = self.broadcast_show_live_reminder {
            my_size += 3 + 1;
        }
        if let Some(v) = self.broadcast_chat_corner {
            my_size += ::protobuf::rt::int32_size(12010, v);
        }
        if let Some(v) = self.steam_input_configurator_error_msg_enable {
            my_size += 3 + 1;
        }
        if let Some(v) = self.controller_guide_button_focus_steam {
            my_size += 3 + 1;
        }
        if let Some(v) = self.controller_ps4_support {
            my_size += 3 + 1;
        }
        if let Some(v) = self.controller_xbox_support {
            my_size += 3 + 1;
        }
        if let Some(v) = self.controller_xbox_driver {
            my_size += 3 + 1;
        }
        if let Some(v) = self.controller_switch_support {
            my_size += 3 + 1;
        }
        if let Some(v) = self.controller_generic_support {
            my_size += 3 + 1;
        }
        if let Some(v) = self.controller_power_off_timeout {
            my_size += ::protobuf::rt::int32_size(14008, v);
        }
        if let Some(v) = self.turn_off_controller_on_exit {
            my_size += 3 + 1;
        }
        if let Some(v) = self.controller_combine_nintendo_joycons {
            my_size += 3 + 1;
        }
        if let Some(v) = self.startup_movie_id {
            my_size += ::protobuf::rt::uint64_size(16000, v);
        }
        if let Some(v) = self.startup_movie_local_path.as_ref() {
            my_size += ::protobuf::rt::string_size(16001, &v);
        }
        if let Some(v) = self.startup_movie_shuffle {
            my_size += 3 + 1;
        }
        if let Some(v) = self.startup_movie_used_for_resume {
            my_size += 3 + 1;
        }
        if let Some(v) = self.game_notes_enable_spellcheck {
            my_size += 3 + 1;
        }
        if let Some(v) = self.screenshot_items_per_row {
            my_size += ::protobuf::rt::int32_size(18000, v);
        }
        if let Some(v) = self.g_background_enabled {
            my_size += 3 + 1;
        }
        if let Some(v) = self.g_background_path.as_ref() {
            my_size += ::protobuf::rt::string_size(18201, &v);
        }
        if let Some(v) = self.g_background_max_keep.as_ref() {
            my_size += ::protobuf::rt::string_size(18202, &v);
        }
        if let Some(v) = self.show_timestamps_in_console {
            my_size += 3 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.no_save_personal_info {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.oobe_test_mode_enabled {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.in_client_beta {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.is_steam_sideloaded {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.preferred_monitor.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.steam_cef_gpu_blocklist_disabled {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.bigpicture_windowed {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.display_name.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.is_external_display {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.steam_os_underscan_level {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.steam_os_underscan_enabled {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.min_scale_factor {
            os.write_float(12, v)?;
        }
        if let Some(v) = self.max_scale_factor {
            os.write_float(13, v)?;
        }
        if let Some(v) = self.auto_scale_factor {
            os.write_float(14, v)?;
        }
        if let Some(v) = self.enable_test_updaters {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.small_mode {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.skip_steamvr_install_dialog {
            os.write_bool(19, v)?;
        }
        if let Some(v) = self.always_show_user_chooser {
            os.write_bool(20, v)?;
        }
        if let Some(v) = self.show_family_sharing_notifications {
            os.write_bool(3000, v)?;
        }
        if let Some(v) = self.overlay_fps_counter_corner {
            os.write_int32(4000, v)?;
        }
        if let Some(v) = self.overlay_fps_counter_high_contrast {
            os.write_bool(4001, v)?;
        }
        if let Some(v) = self.overlay_key.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4002, v, os)?;
        }
        if let Some(v) = self.screenshot_key.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4003, v, os)?;
        }
        if let Some(v) = self.enable_overlay {
            os.write_bool(4004, v)?;
        }
        if let Some(v) = self.disable_desktop_game_theater {
            os.write_bool(4005, v)?;
        }
        if let Some(v) = self.enable_screenshot_notification {
            os.write_bool(4006, v)?;
        }
        if let Some(v) = self.enable_screenshot_sound {
            os.write_bool(4007, v)?;
        }
        if let Some(v) = self.save_uncompressed_screenshots {
            os.write_bool(4008, v)?;
        }
        if let Some(v) = self.screenshots_path.as_ref() {
            os.write_string(4009, v)?;
        }
        if let Some(v) = self.default_ping_rate {
            os.write_int32(4010, v)?;
        }
        if let Some(v) = self.server_ping_rate {
            os.write_int32(4011, v)?;
        }
        if let Some(v) = self.steam_networking_share_ip {
            os.write_int32(4012, v)?;
        }
        if let Some(v) = self.web_browser_home.as_ref() {
            os.write_string(4013, v)?;
        }
        if let Some(v) = self.voice_mic_device_name.as_ref() {
            os.write_string(4014, v)?;
        }
        if let Some(v) = self.voice_mic_input_gain {
            os.write_float(4015, v)?;
        }
        if let Some(v) = self.voice_speaker_output_gain {
            os.write_float(4016, v)?;
        }
        if let Some(v) = self.voice_push_to_talk_setting {
            os.write_int32(4017, v)?;
        }
        if let Some(v) = self.voice_push_to_talk_key.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4018, v, os)?;
        }
        if let Some(v) = self.overlay_toolbar_list_view {
            os.write_bool(4019, v)?;
        }
        if let Some(v) = self.always_use_gamepadui_overlay {
            os.write_bool(4020, v)?;
        }
        if let Some(v) = self.overlay_tabs.as_ref() {
            os.write_string(4021, v)?;
        }
        if let Some(v) = self.overlay_scale_interface {
            os.write_bool(4022, v)?;
        }
        if let Some(v) = self.smooth_scroll_webviews {
            os.write_bool(5000, v)?;
        }
        if let Some(v) = self.enable_gpu_accelerated_webviews {
            os.write_bool(5001, v)?;
        }
        if let Some(v) = self.enable_hardware_video_decoding {
            os.write_bool(5003, v)?;
        }
        if let Some(v) = self.run_at_startup {
            os.write_bool(5004, v)?;
        }
        if let Some(v) = self.enable_dpi_scaling {
            os.write_bool(5005, v)?;
        }
        if let Some(v) = self.enable_marketing_messages {
            os.write_bool(5006, v)?;
        }
        if let Some(v) = self.start_in_big_picture_mode {
            os.write_bool(5007, v)?;
        }
        if let Some(v) = self.jumplist_flags {
            os.write_uint32(5008, v)?;
        }
        if let Some(v) = self.enable_ui_sounds {
            os.write_bool(5009, v)?;
        }
        if let Some(v) = self.disable_all_toasts {
            os.write_bool(6000, v)?;
        }
        if let Some(v) = self.disable_toasts_in_game {
            os.write_bool(6001, v)?;
        }
        if let Some(v) = self.play_sound_on_toast {
            os.write_bool(6002, v)?;
        }
        if let Some(v) = self.library_display_size {
            os.write_int32(7000, v)?;
        }
        if let Some(v) = self.library_whats_new_show_only_product_updates {
            os.write_bool(7001, v)?;
        }
        if let Some(v) = self.show_store_content_on_home {
            os.write_bool(7002, v)?;
        }
        if let Some(v) = self.start_page.as_ref() {
            os.write_string(7003, v)?;
        }
        if let Some(v) = self.library_low_bandwidth_mode {
            os.write_bool(7004, v)?;
        }
        if let Some(v) = self.library_low_perf_mode {
            os.write_bool(7005, v)?;
        }
        if let Some(v) = self.library_disable_community_content {
            os.write_bool(7006, v)?;
        }
        if let Some(v) = self.library_display_icon_in_game_list {
            os.write_bool(7007, v)?;
        }
        if let Some(v) = self.ready_to_play_includes_streaming {
            os.write_bool(7008, v)?;
        }
        if let Some(v) = self.show_steam_deck_info {
            os.write_bool(7009, v)?;
        }
        if let Some(v) = self.enable_shader_precache {
            os.write_bool(8000, v)?;
        }
        if let Some(v) = self.enable_shader_background_processing {
            os.write_bool(8001, v)?;
        }
        if let Some(v) = self.shader_precached_size {
            os.write_uint64(8002, v)?;
        }
        if let Some(v) = self.needs_steam_service_repair {
            os.write_bool(8003, v)?;
        }
        if let Some(v) = self.download_peer_content {
            os.write_int32(8004, v)?;
        }
        if let Some(v) = self.download_rate_bits_per_s {
            os.write_bool(8005, v)?;
        }
        if let Some(v) = self.restrict_auto_updates {
            os.write_bool(8006, v)?;
        }
        if let Some(v) = self.restrict_auto_updates_start {
            os.write_int32(8007, v)?;
        }
        if let Some(v) = self.restrict_auto_updates_end {
            os.write_int32(8008, v)?;
        }
        if let Some(v) = self.download_region {
            os.write_int32(8009, v)?;
        }
        if let Some(v) = self.download_while_app_running {
            os.write_bool(8010, v)?;
        }
        if let Some(v) = self.download_throttle_while_streaming {
            os.write_bool(8011, v)?;
        }
        if let Some(v) = self.download_throttle_rate {
            os.write_int32(8012, v)?;
        }
        if let Some(v) = self.cloud_enabled {
            os.write_bool(10000, v)?;
        }
        if let Some(v) = self.show_screenshot_manager {
            os.write_bool(10001, v)?;
        }
        if let Some(v) = self.music_volume {
            os.write_int32(11000, v)?;
        }
        if let Some(v) = self.music_pause_on_app_start {
            os.write_bool(11001, v)?;
        }
        if let Some(v) = self.music_pause_on_voice_chat {
            os.write_bool(11002, v)?;
        }
        if let Some(v) = self.music_download_high_quality {
            os.write_bool(11003, v)?;
        }
        if let Some(v) = self.music_playlist_notification {
            os.write_bool(11004, v)?;
        }
        if let Some(v) = self.broadcast_permissions {
            os.write_enum(12000, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.broadcast_output_width {
            os.write_int32(12001, v)?;
        }
        if let Some(v) = self.broadcast_output_height {
            os.write_int32(12002, v)?;
        }
        if let Some(v) = self.broadcast_bitrate {
            os.write_int32(12003, v)?;
        }
        if let Some(v) = self.broadcast_encoding_option {
            os.write_enum(12004, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.broadcast_record_all_video {
            os.write_bool(12005, v)?;
        }
        if let Some(v) = self.broadcast_record_all_audio {
            os.write_bool(12006, v)?;
        }
        if let Some(v) = self.broadcast_record_microphone {
            os.write_bool(12007, v)?;
        }
        if let Some(v) = self.broadcast_show_upload_stats {
            os.write_bool(12008, v)?;
        }
        if let Some(v) = self.broadcast_show_live_reminder {
            os.write_bool(12009, v)?;
        }
        if let Some(v) = self.broadcast_chat_corner {
            os.write_int32(12010, v)?;
        }
        if let Some(v) = self.steam_input_configurator_error_msg_enable {
            os.write_bool(14001, v)?;
        }
        if let Some(v) = self.controller_guide_button_focus_steam {
            os.write_bool(14002, v)?;
        }
        if let Some(v) = self.controller_ps4_support {
            os.write_bool(14003, v)?;
        }
        if let Some(v) = self.controller_xbox_support {
            os.write_bool(14004, v)?;
        }
        if let Some(v) = self.controller_xbox_driver {
            os.write_bool(14005, v)?;
        }
        if let Some(v) = self.controller_switch_support {
            os.write_bool(14006, v)?;
        }
        if let Some(v) = self.controller_generic_support {
            os.write_bool(14007, v)?;
        }
        if let Some(v) = self.controller_power_off_timeout {
            os.write_int32(14008, v)?;
        }
        if let Some(v) = self.turn_off_controller_on_exit {
            os.write_bool(14009, v)?;
        }
        if let Some(v) = self.controller_combine_nintendo_joycons {
            os.write_bool(14010, v)?;
        }
        if let Some(v) = self.startup_movie_id {
            os.write_uint64(16000, v)?;
        }
        if let Some(v) = self.startup_movie_local_path.as_ref() {
            os.write_string(16001, v)?;
        }
        if let Some(v) = self.startup_movie_shuffle {
            os.write_bool(16002, v)?;
        }
        if let Some(v) = self.startup_movie_used_for_resume {
            os.write_bool(16003, v)?;
        }
        if let Some(v) = self.game_notes_enable_spellcheck {
            os.write_bool(17001, v)?;
        }
        if let Some(v) = self.screenshot_items_per_row {
            os.write_int32(18000, v)?;
        }
        if let Some(v) = self.g_background_enabled {
            os.write_bool(18200, v)?;
        }
        if let Some(v) = self.g_background_path.as_ref() {
            os.write_string(18201, v)?;
        }
        if let Some(v) = self.g_background_max_keep.as_ref() {
            os.write_string(18202, v)?;
        }
        if let Some(v) = self.show_timestamps_in_console {
            os.write_bool(20000, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientSettings {
        CMsgClientSettings::new()
    }

    fn clear(&mut self) {
        self.no_save_personal_info = ::std::option::Option::None;
        self.oobe_test_mode_enabled = ::std::option::Option::None;
        self.in_client_beta = ::std::option::Option::None;
        self.is_steam_sideloaded = ::std::option::Option::None;
        self.preferred_monitor = ::std::option::Option::None;
        self.steam_cef_gpu_blocklist_disabled = ::std::option::Option::None;
        self.bigpicture_windowed = ::std::option::Option::None;
        self.display_name = ::std::option::Option::None;
        self.is_external_display = ::std::option::Option::None;
        self.steam_os_underscan_level = ::std::option::Option::None;
        self.steam_os_underscan_enabled = ::std::option::Option::None;
        self.min_scale_factor = ::std::option::Option::None;
        self.max_scale_factor = ::std::option::Option::None;
        self.auto_scale_factor = ::std::option::Option::None;
        self.enable_test_updaters = ::std::option::Option::None;
        self.small_mode = ::std::option::Option::None;
        self.skip_steamvr_install_dialog = ::std::option::Option::None;
        self.always_show_user_chooser = ::std::option::Option::None;
        self.show_family_sharing_notifications = ::std::option::Option::None;
        self.overlay_fps_counter_corner = ::std::option::Option::None;
        self.overlay_fps_counter_high_contrast = ::std::option::Option::None;
        self.overlay_key.clear();
        self.screenshot_key.clear();
        self.enable_overlay = ::std::option::Option::None;
        self.disable_desktop_game_theater = ::std::option::Option::None;
        self.enable_screenshot_notification = ::std::option::Option::None;
        self.enable_screenshot_sound = ::std::option::Option::None;
        self.save_uncompressed_screenshots = ::std::option::Option::None;
        self.screenshots_path = ::std::option::Option::None;
        self.default_ping_rate = ::std::option::Option::None;
        self.server_ping_rate = ::std::option::Option::None;
        self.steam_networking_share_ip = ::std::option::Option::None;
        self.web_browser_home = ::std::option::Option::None;
        self.voice_mic_device_name = ::std::option::Option::None;
        self.voice_mic_input_gain = ::std::option::Option::None;
        self.voice_speaker_output_gain = ::std::option::Option::None;
        self.voice_push_to_talk_setting = ::std::option::Option::None;
        self.voice_push_to_talk_key.clear();
        self.overlay_toolbar_list_view = ::std::option::Option::None;
        self.always_use_gamepadui_overlay = ::std::option::Option::None;
        self.overlay_tabs = ::std::option::Option::None;
        self.overlay_scale_interface = ::std::option::Option::None;
        self.smooth_scroll_webviews = ::std::option::Option::None;
        self.enable_gpu_accelerated_webviews = ::std::option::Option::None;
        self.enable_hardware_video_decoding = ::std::option::Option::None;
        self.run_at_startup = ::std::option::Option::None;
        self.enable_dpi_scaling = ::std::option::Option::None;
        self.enable_marketing_messages = ::std::option::Option::None;
        self.start_in_big_picture_mode = ::std::option::Option::None;
        self.jumplist_flags = ::std::option::Option::None;
        self.enable_ui_sounds = ::std::option::Option::None;
        self.disable_all_toasts = ::std::option::Option::None;
        self.disable_toasts_in_game = ::std::option::Option::None;
        self.play_sound_on_toast = ::std::option::Option::None;
        self.library_display_size = ::std::option::Option::None;
        self.library_whats_new_show_only_product_updates = ::std::option::Option::None;
        self.show_store_content_on_home = ::std::option::Option::None;
        self.start_page = ::std::option::Option::None;
        self.library_low_bandwidth_mode = ::std::option::Option::None;
        self.library_low_perf_mode = ::std::option::Option::None;
        self.library_disable_community_content = ::std::option::Option::None;
        self.library_display_icon_in_game_list = ::std::option::Option::None;
        self.ready_to_play_includes_streaming = ::std::option::Option::None;
        self.show_steam_deck_info = ::std::option::Option::None;
        self.enable_shader_precache = ::std::option::Option::None;
        self.enable_shader_background_processing = ::std::option::Option::None;
        self.shader_precached_size = ::std::option::Option::None;
        self.needs_steam_service_repair = ::std::option::Option::None;
        self.download_peer_content = ::std::option::Option::None;
        self.download_rate_bits_per_s = ::std::option::Option::None;
        self.restrict_auto_updates = ::std::option::Option::None;
        self.restrict_auto_updates_start = ::std::option::Option::None;
        self.restrict_auto_updates_end = ::std::option::Option::None;
        self.download_region = ::std::option::Option::None;
        self.download_while_app_running = ::std::option::Option::None;
        self.download_throttle_while_streaming = ::std::option::Option::None;
        self.download_throttle_rate = ::std::option::Option::None;
        self.cloud_enabled = ::std::option::Option::None;
        self.show_screenshot_manager = ::std::option::Option::None;
        self.music_volume = ::std::option::Option::None;
        self.music_pause_on_app_start = ::std::option::Option::None;
        self.music_pause_on_voice_chat = ::std::option::Option::None;
        self.music_download_high_quality = ::std::option::Option::None;
        self.music_playlist_notification = ::std::option::Option::None;
        self.broadcast_permissions = ::std::option::Option::None;
        self.broadcast_output_width = ::std::option::Option::None;
        self.broadcast_output_height = ::std::option::Option::None;
        self.broadcast_bitrate = ::std::option::Option::None;
        self.broadcast_encoding_option = ::std::option::Option::None;
        self.broadcast_record_all_video = ::std::option::Option::None;
        self.broadcast_record_all_audio = ::std::option::Option::None;
        self.broadcast_record_microphone = ::std::option::Option::None;
        self.broadcast_show_upload_stats = ::std::option::Option::None;
        self.broadcast_show_live_reminder = ::std::option::Option::None;
        self.broadcast_chat_corner = ::std::option::Option::None;
        self.steam_input_configurator_error_msg_enable = ::std::option::Option::None;
        self.controller_guide_button_focus_steam = ::std::option::Option::None;
        self.controller_ps4_support = ::std::option::Option::None;
        self.controller_xbox_support = ::std::option::Option::None;
        self.controller_xbox_driver = ::std::option::Option::None;
        self.controller_switch_support = ::std::option::Option::None;
        self.controller_generic_support = ::std::option::Option::None;
        self.controller_power_off_timeout = ::std::option::Option::None;
        self.turn_off_controller_on_exit = ::std::option::Option::None;
        self.controller_combine_nintendo_joycons = ::std::option::Option::None;
        self.startup_movie_id = ::std::option::Option::None;
        self.startup_movie_local_path = ::std::option::Option::None;
        self.startup_movie_shuffle = ::std::option::Option::None;
        self.startup_movie_used_for_resume = ::std::option::Option::None;
        self.game_notes_enable_spellcheck = ::std::option::Option::None;
        self.screenshot_items_per_row = ::std::option::Option::None;
        self.g_background_enabled = ::std::option::Option::None;
        self.g_background_path = ::std::option::Option::None;
        self.g_background_max_keep = ::std::option::Option::None;
        self.show_timestamps_in_console = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientSettings {
        static instance: CMsgClientSettings = CMsgClientSettings {
            no_save_personal_info: ::std::option::Option::None,
            oobe_test_mode_enabled: ::std::option::Option::None,
            in_client_beta: ::std::option::Option::None,
            is_steam_sideloaded: ::std::option::Option::None,
            preferred_monitor: ::std::option::Option::None,
            steam_cef_gpu_blocklist_disabled: ::std::option::Option::None,
            bigpicture_windowed: ::std::option::Option::None,
            display_name: ::std::option::Option::None,
            is_external_display: ::std::option::Option::None,
            steam_os_underscan_level: ::std::option::Option::None,
            steam_os_underscan_enabled: ::std::option::Option::None,
            min_scale_factor: ::std::option::Option::None,
            max_scale_factor: ::std::option::Option::None,
            auto_scale_factor: ::std::option::Option::None,
            enable_test_updaters: ::std::option::Option::None,
            small_mode: ::std::option::Option::None,
            skip_steamvr_install_dialog: ::std::option::Option::None,
            always_show_user_chooser: ::std::option::Option::None,
            show_family_sharing_notifications: ::std::option::Option::None,
            overlay_fps_counter_corner: ::std::option::Option::None,
            overlay_fps_counter_high_contrast: ::std::option::Option::None,
            overlay_key: ::protobuf::MessageField::none(),
            screenshot_key: ::protobuf::MessageField::none(),
            enable_overlay: ::std::option::Option::None,
            disable_desktop_game_theater: ::std::option::Option::None,
            enable_screenshot_notification: ::std::option::Option::None,
            enable_screenshot_sound: ::std::option::Option::None,
            save_uncompressed_screenshots: ::std::option::Option::None,
            screenshots_path: ::std::option::Option::None,
            default_ping_rate: ::std::option::Option::None,
            server_ping_rate: ::std::option::Option::None,
            steam_networking_share_ip: ::std::option::Option::None,
            web_browser_home: ::std::option::Option::None,
            voice_mic_device_name: ::std::option::Option::None,
            voice_mic_input_gain: ::std::option::Option::None,
            voice_speaker_output_gain: ::std::option::Option::None,
            voice_push_to_talk_setting: ::std::option::Option::None,
            voice_push_to_talk_key: ::protobuf::MessageField::none(),
            overlay_toolbar_list_view: ::std::option::Option::None,
            always_use_gamepadui_overlay: ::std::option::Option::None,
            overlay_tabs: ::std::option::Option::None,
            overlay_scale_interface: ::std::option::Option::None,
            smooth_scroll_webviews: ::std::option::Option::None,
            enable_gpu_accelerated_webviews: ::std::option::Option::None,
            enable_hardware_video_decoding: ::std::option::Option::None,
            run_at_startup: ::std::option::Option::None,
            enable_dpi_scaling: ::std::option::Option::None,
            enable_marketing_messages: ::std::option::Option::None,
            start_in_big_picture_mode: ::std::option::Option::None,
            jumplist_flags: ::std::option::Option::None,
            enable_ui_sounds: ::std::option::Option::None,
            disable_all_toasts: ::std::option::Option::None,
            disable_toasts_in_game: ::std::option::Option::None,
            play_sound_on_toast: ::std::option::Option::None,
            library_display_size: ::std::option::Option::None,
            library_whats_new_show_only_product_updates: ::std::option::Option::None,
            show_store_content_on_home: ::std::option::Option::None,
            start_page: ::std::option::Option::None,
            library_low_bandwidth_mode: ::std::option::Option::None,
            library_low_perf_mode: ::std::option::Option::None,
            library_disable_community_content: ::std::option::Option::None,
            library_display_icon_in_game_list: ::std::option::Option::None,
            ready_to_play_includes_streaming: ::std::option::Option::None,
            show_steam_deck_info: ::std::option::Option::None,
            enable_shader_precache: ::std::option::Option::None,
            enable_shader_background_processing: ::std::option::Option::None,
            shader_precached_size: ::std::option::Option::None,
            needs_steam_service_repair: ::std::option::Option::None,
            download_peer_content: ::std::option::Option::None,
            download_rate_bits_per_s: ::std::option::Option::None,
            restrict_auto_updates: ::std::option::Option::None,
            restrict_auto_updates_start: ::std::option::Option::None,
            restrict_auto_updates_end: ::std::option::Option::None,
            download_region: ::std::option::Option::None,
            download_while_app_running: ::std::option::Option::None,
            download_throttle_while_streaming: ::std::option::Option::None,
            download_throttle_rate: ::std::option::Option::None,
            cloud_enabled: ::std::option::Option::None,
            show_screenshot_manager: ::std::option::Option::None,
            music_volume: ::std::option::Option::None,
            music_pause_on_app_start: ::std::option::Option::None,
            music_pause_on_voice_chat: ::std::option::Option::None,
            music_download_high_quality: ::std::option::Option::None,
            music_playlist_notification: ::std::option::Option::None,
            broadcast_permissions: ::std::option::Option::None,
            broadcast_output_width: ::std::option::Option::None,
            broadcast_output_height: ::std::option::Option::None,
            broadcast_bitrate: ::std::option::Option::None,
            broadcast_encoding_option: ::std::option::Option::None,
            broadcast_record_all_video: ::std::option::Option::None,
            broadcast_record_all_audio: ::std::option::Option::None,
            broadcast_record_microphone: ::std::option::Option::None,
            broadcast_show_upload_stats: ::std::option::Option::None,
            broadcast_show_live_reminder: ::std::option::Option::None,
            broadcast_chat_corner: ::std::option::Option::None,
            steam_input_configurator_error_msg_enable: ::std::option::Option::None,
            controller_guide_button_focus_steam: ::std::option::Option::None,
            controller_ps4_support: ::std::option::Option::None,
            controller_xbox_support: ::std::option::Option::None,
            controller_xbox_driver: ::std::option::Option::None,
            controller_switch_support: ::std::option::Option::None,
            controller_generic_support: ::std::option::Option::None,
            controller_power_off_timeout: ::std::option::Option::None,
            turn_off_controller_on_exit: ::std::option::Option::None,
            controller_combine_nintendo_joycons: ::std::option::Option::None,
            startup_movie_id: ::std::option::Option::None,
            startup_movie_local_path: ::std::option::Option::None,
            startup_movie_shuffle: ::std::option::Option::None,
            startup_movie_used_for_resume: ::std::option::Option::None,
            game_notes_enable_spellcheck: ::std::option::Option::None,
            screenshot_items_per_row: ::std::option::Option::None,
            g_background_enabled: ::std::option::Option::None,
            g_background_path: ::std::option::Option::None,
            g_background_max_keep: ::std::option::Option::None,
            show_timestamps_in_console: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EClientSettingStore)
pub enum EClientSettingStore {
    // @@protoc_insertion_point(enum_value:EClientSettingStore.k_EClientSettingStore_Invalid)
    k_EClientSettingStore_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EClientSettingStore.k_EClientSettingStore_ConfigStore_Install)
    k_EClientSettingStore_ConfigStore_Install = 1,
    // @@protoc_insertion_point(enum_value:EClientSettingStore.k_EClientSettingStore_ConfigStore_UserRoaming)
    k_EClientSettingStore_ConfigStore_UserRoaming = 2,
    // @@protoc_insertion_point(enum_value:EClientSettingStore.k_EClientSettingStore_ConfigStore_UserLocal)
    k_EClientSettingStore_ConfigStore_UserLocal = 3,
    // @@protoc_insertion_point(enum_value:EClientSettingStore.k_EClientSettingStore_Registry)
    k_EClientSettingStore_Registry = 4,
    // @@protoc_insertion_point(enum_value:EClientSettingStore.k_EClientSettingStore_CustomFunc)
    k_EClientSettingStore_CustomFunc = 5,
}

impl ::protobuf::Enum for EClientSettingStore {
    const NAME: &'static str = "EClientSettingStore";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EClientSettingStore> {
        match value {
            0 => ::std::option::Option::Some(EClientSettingStore::k_EClientSettingStore_Invalid),
            1 => ::std::option::Option::Some(EClientSettingStore::k_EClientSettingStore_ConfigStore_Install),
            2 => ::std::option::Option::Some(EClientSettingStore::k_EClientSettingStore_ConfigStore_UserRoaming),
            3 => ::std::option::Option::Some(EClientSettingStore::k_EClientSettingStore_ConfigStore_UserLocal),
            4 => ::std::option::Option::Some(EClientSettingStore::k_EClientSettingStore_Registry),
            5 => ::std::option::Option::Some(EClientSettingStore::k_EClientSettingStore_CustomFunc),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EClientSettingStore> {
        match str {
            "k_EClientSettingStore_Invalid" => ::std::option::Option::Some(EClientSettingStore::k_EClientSettingStore_Invalid),
            "k_EClientSettingStore_ConfigStore_Install" => ::std::option::Option::Some(EClientSettingStore::k_EClientSettingStore_ConfigStore_Install),
            "k_EClientSettingStore_ConfigStore_UserRoaming" => ::std::option::Option::Some(EClientSettingStore::k_EClientSettingStore_ConfigStore_UserRoaming),
            "k_EClientSettingStore_ConfigStore_UserLocal" => ::std::option::Option::Some(EClientSettingStore::k_EClientSettingStore_ConfigStore_UserLocal),
            "k_EClientSettingStore_Registry" => ::std::option::Option::Some(EClientSettingStore::k_EClientSettingStore_Registry),
            "k_EClientSettingStore_CustomFunc" => ::std::option::Option::Some(EClientSettingStore::k_EClientSettingStore_CustomFunc),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EClientSettingStore] = &[
        EClientSettingStore::k_EClientSettingStore_Invalid,
        EClientSettingStore::k_EClientSettingStore_ConfigStore_Install,
        EClientSettingStore::k_EClientSettingStore_ConfigStore_UserRoaming,
        EClientSettingStore::k_EClientSettingStore_ConfigStore_UserLocal,
        EClientSettingStore::k_EClientSettingStore_Registry,
        EClientSettingStore::k_EClientSettingStore_CustomFunc,
    ];
}

impl ::std::default::Default for EClientSettingStore {
    fn default() -> Self {
        EClientSettingStore::k_EClientSettingStore_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EOverlayToggleBarLocation)
pub enum EOverlayToggleBarLocation {
    // @@protoc_insertion_point(enum_value:EOverlayToggleBarLocation.k_EOverlayToggleBarLocation_Bottom)
    k_EOverlayToggleBarLocation_Bottom = 0,
    // @@protoc_insertion_point(enum_value:EOverlayToggleBarLocation.k_EOverlayToggleBarLocation_Left)
    k_EOverlayToggleBarLocation_Left = 1,
    // @@protoc_insertion_point(enum_value:EOverlayToggleBarLocation.k_EOverlayToggleBarLocation_Right)
    k_EOverlayToggleBarLocation_Right = 2,
    // @@protoc_insertion_point(enum_value:EOverlayToggleBarLocation.k_EOverlayToggleBarLocation_Top)
    k_EOverlayToggleBarLocation_Top = 3,
}

impl ::protobuf::Enum for EOverlayToggleBarLocation {
    const NAME: &'static str = "EOverlayToggleBarLocation";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EOverlayToggleBarLocation> {
        match value {
            0 => ::std::option::Option::Some(EOverlayToggleBarLocation::k_EOverlayToggleBarLocation_Bottom),
            1 => ::std::option::Option::Some(EOverlayToggleBarLocation::k_EOverlayToggleBarLocation_Left),
            2 => ::std::option::Option::Some(EOverlayToggleBarLocation::k_EOverlayToggleBarLocation_Right),
            3 => ::std::option::Option::Some(EOverlayToggleBarLocation::k_EOverlayToggleBarLocation_Top),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EOverlayToggleBarLocation> {
        match str {
            "k_EOverlayToggleBarLocation_Bottom" => ::std::option::Option::Some(EOverlayToggleBarLocation::k_EOverlayToggleBarLocation_Bottom),
            "k_EOverlayToggleBarLocation_Left" => ::std::option::Option::Some(EOverlayToggleBarLocation::k_EOverlayToggleBarLocation_Left),
            "k_EOverlayToggleBarLocation_Right" => ::std::option::Option::Some(EOverlayToggleBarLocation::k_EOverlayToggleBarLocation_Right),
            "k_EOverlayToggleBarLocation_Top" => ::std::option::Option::Some(EOverlayToggleBarLocation::k_EOverlayToggleBarLocation_Top),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EOverlayToggleBarLocation] = &[
        EOverlayToggleBarLocation::k_EOverlayToggleBarLocation_Bottom,
        EOverlayToggleBarLocation::k_EOverlayToggleBarLocation_Left,
        EOverlayToggleBarLocation::k_EOverlayToggleBarLocation_Right,
        EOverlayToggleBarLocation::k_EOverlayToggleBarLocation_Top,
    ];
}

impl ::std::default::Default for EOverlayToggleBarLocation {
    fn default() -> Self {
        EOverlayToggleBarLocation::k_EOverlayToggleBarLocation_Bottom
    }
}


// Extension generation with lite runtime is not supported
#[allow(unused_imports)]
use crate::enums::*;
impl crate::RpcMessage for CMsgHotkey {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgClientSettings {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
