// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_chat.steamclient.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

#[doc = "Request to be notified of online friend persona state information.  Responses sent via CMsgClientPersonaState."]
// @@protoc_insertion_point(message:CChat_RequestFriendPersonaStates_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChat_RequestFriendPersonaStates_Request {
    // special fields
    // @@protoc_insertion_point(special_field:CChat_RequestFriendPersonaStates_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChat_RequestFriendPersonaStates_Request {
    fn default() -> &'a CChat_RequestFriendPersonaStates_Request {
        <CChat_RequestFriendPersonaStates_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChat_RequestFriendPersonaStates_Request {
    pub fn new() -> CChat_RequestFriendPersonaStates_Request {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChat_RequestFriendPersonaStates_Request {
    const NAME: &'static str = "CChat_RequestFriendPersonaStates_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChat_RequestFriendPersonaStates_Request {
        CChat_RequestFriendPersonaStates_Request::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChat_RequestFriendPersonaStates_Request {
        static instance: CChat_RequestFriendPersonaStates_Request = CChat_RequestFriendPersonaStates_Request {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChat_RequestFriendPersonaStates_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChat_RequestFriendPersonaStates_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChat_RequestFriendPersonaStates_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChat_RequestFriendPersonaStates_Response {
    fn default() -> &'a CChat_RequestFriendPersonaStates_Response {
        <CChat_RequestFriendPersonaStates_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChat_RequestFriendPersonaStates_Response {
    pub fn new() -> CChat_RequestFriendPersonaStates_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChat_RequestFriendPersonaStates_Response {
    const NAME: &'static str = "CChat_RequestFriendPersonaStates_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChat_RequestFriendPersonaStates_Response {
        CChat_RequestFriendPersonaStates_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChat_RequestFriendPersonaStates_Response {
        static instance: CChat_RequestFriendPersonaStates_Response = CChat_RequestFriendPersonaStates_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Create's a chat group that can contain other chat rooms"]
// @@protoc_insertion_point(message:CChatRoom_CreateChatRoomGroup_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_CreateChatRoomGroup_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_CreateChatRoomGroup_Request.steamid_partner)
    pub steamid_partner: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_CreateChatRoomGroup_Request.steamid_invited)
    pub steamid_invited: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_CreateChatRoomGroup_Request.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoom_CreateChatRoomGroup_Request.steamid_invitees)
    pub steamid_invitees: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CChatRoom_CreateChatRoomGroup_Request.watching_broadcast_accountid)
    pub watching_broadcast_accountid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_CreateChatRoomGroup_Request.watching_broadcast_channel_id)
    pub watching_broadcast_channel_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_CreateChatRoomGroup_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_CreateChatRoomGroup_Request {
    fn default() -> &'a CChatRoom_CreateChatRoomGroup_Request {
        <CChatRoom_CreateChatRoomGroup_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_CreateChatRoomGroup_Request {
    pub fn new() -> CChatRoom_CreateChatRoomGroup_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_partner = 1;

    pub fn steamid_partner(&self) -> u64 {
        self.steamid_partner.unwrap_or(0)
    }

    pub fn clear_steamid_partner(&mut self) {
        self.steamid_partner = ::std::option::Option::None;
    }

    pub fn has_steamid_partner(&self) -> bool {
        self.steamid_partner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_partner(&mut self, v: u64) {
        self.steamid_partner = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid_invited = 2;

    pub fn steamid_invited(&self) -> u64 {
        self.steamid_invited.unwrap_or(0)
    }

    pub fn clear_steamid_invited(&mut self) {
        self.steamid_invited = ::std::option::Option::None;
    }

    pub fn has_steamid_invited(&self) -> bool {
        self.steamid_invited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_invited(&mut self, v: u64) {
        self.steamid_invited = ::std::option::Option::Some(v);
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 watching_broadcast_accountid = 6;

    pub fn watching_broadcast_accountid(&self) -> u32 {
        self.watching_broadcast_accountid.unwrap_or(0)
    }

    pub fn clear_watching_broadcast_accountid(&mut self) {
        self.watching_broadcast_accountid = ::std::option::Option::None;
    }

    pub fn has_watching_broadcast_accountid(&self) -> bool {
        self.watching_broadcast_accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watching_broadcast_accountid(&mut self, v: u32) {
        self.watching_broadcast_accountid = ::std::option::Option::Some(v);
    }

    // optional uint64 watching_broadcast_channel_id = 7;

    pub fn watching_broadcast_channel_id(&self) -> u64 {
        self.watching_broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_watching_broadcast_channel_id(&mut self) {
        self.watching_broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_watching_broadcast_channel_id(&self) -> bool {
        self.watching_broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watching_broadcast_channel_id(&mut self, v: u64) {
        self.watching_broadcast_channel_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_CreateChatRoomGroup_Request {
    const NAME: &'static str = "CChatRoom_CreateChatRoomGroup_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid_partner = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.steamid_invited = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    is.read_repeated_packed_fixed64_into(&mut self.steamid_invitees)?;
                },
                33 => {
                    self.steamid_invitees.push(is.read_fixed64()?);
                },
                48 => {
                    self.watching_broadcast_accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.watching_broadcast_channel_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_partner {
            my_size += 1 + 8;
        }
        if let Some(v) = self.steamid_invited {
            my_size += 1 + 8;
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += 9 * self.steamid_invitees.len() as u64;
        if let Some(v) = self.watching_broadcast_accountid {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.watching_broadcast_channel_id {
            my_size += ::protobuf::rt::uint64_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid_partner {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.steamid_invited {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.steamid_invitees {
            os.write_fixed64(4, *v)?;
        };
        if let Some(v) = self.watching_broadcast_accountid {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.watching_broadcast_channel_id {
            os.write_uint64(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_CreateChatRoomGroup_Request {
        CChatRoom_CreateChatRoomGroup_Request::new()
    }

    fn clear(&mut self) {
        self.steamid_partner = ::std::option::Option::None;
        self.steamid_invited = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.steamid_invitees.clear();
        self.watching_broadcast_accountid = ::std::option::Option::None;
        self.watching_broadcast_channel_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_CreateChatRoomGroup_Request {
        static instance: CChatRoom_CreateChatRoomGroup_Request = CChatRoom_CreateChatRoomGroup_Request {
            steamid_partner: ::std::option::Option::None,
            steamid_invited: ::std::option::Option::None,
            name: ::std::option::Option::None,
            steamid_invitees: ::std::vec::Vec::new(),
            watching_broadcast_accountid: ::std::option::Option::None,
            watching_broadcast_channel_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRole)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRole {
    // message fields
    // @@protoc_insertion_point(field:CChatRole.role_id)
    pub role_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRole.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRole.ordinal)
    pub ordinal: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRole.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRole {
    fn default() -> &'a CChatRole {
        <CChatRole as ::protobuf::Message>::default_instance()
    }
}

impl CChatRole {
    pub fn new() -> CChatRole {
        ::std::default::Default::default()
    }

    // optional uint64 role_id = 1;

    pub fn role_id(&self) -> u64 {
        self.role_id.unwrap_or(0)
    }

    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u64) {
        self.role_id = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 ordinal = 3;

    pub fn ordinal(&self) -> u32 {
        self.ordinal.unwrap_or(0)
    }

    pub fn clear_ordinal(&mut self) {
        self.ordinal = ::std::option::Option::None;
    }

    pub fn has_ordinal(&self) -> bool {
        self.ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordinal(&mut self, v: u32) {
        self.ordinal = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRole {
    const NAME: &'static str = "CChatRole";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.role_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.ordinal = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.role_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.ordinal {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.role_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.ordinal {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRole {
        CChatRole::new()
    }

    fn clear(&mut self) {
        self.role_id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.ordinal = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRole {
        static instance: CChatRole = CChatRole {
            role_id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            ordinal: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoleActions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoleActions {
    // message fields
    // @@protoc_insertion_point(field:CChatRoleActions.role_id)
    pub role_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoleActions.can_create_rename_delete_channel)
    pub can_create_rename_delete_channel: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CChatRoleActions.can_kick)
    pub can_kick: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CChatRoleActions.can_ban)
    pub can_ban: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CChatRoleActions.can_invite)
    pub can_invite: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CChatRoleActions.can_change_tagline_avatar_name)
    pub can_change_tagline_avatar_name: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CChatRoleActions.can_chat)
    pub can_chat: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CChatRoleActions.can_view_history)
    pub can_view_history: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CChatRoleActions.can_change_group_roles)
    pub can_change_group_roles: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CChatRoleActions.can_change_user_roles)
    pub can_change_user_roles: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CChatRoleActions.can_mention_all)
    pub can_mention_all: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CChatRoleActions.can_set_watching_broadcast)
    pub can_set_watching_broadcast: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoleActions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoleActions {
    fn default() -> &'a CChatRoleActions {
        <CChatRoleActions as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoleActions {
    pub fn new() -> CChatRoleActions {
        ::std::default::Default::default()
    }

    // optional uint64 role_id = 1;

    pub fn role_id(&self) -> u64 {
        self.role_id.unwrap_or(0)
    }

    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u64) {
        self.role_id = ::std::option::Option::Some(v);
    }

    // optional bool can_create_rename_delete_channel = 2;

    pub fn can_create_rename_delete_channel(&self) -> bool {
        self.can_create_rename_delete_channel.unwrap_or(false)
    }

    pub fn clear_can_create_rename_delete_channel(&mut self) {
        self.can_create_rename_delete_channel = ::std::option::Option::None;
    }

    pub fn has_can_create_rename_delete_channel(&self) -> bool {
        self.can_create_rename_delete_channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_create_rename_delete_channel(&mut self, v: bool) {
        self.can_create_rename_delete_channel = ::std::option::Option::Some(v);
    }

    // optional bool can_kick = 3;

    pub fn can_kick(&self) -> bool {
        self.can_kick.unwrap_or(false)
    }

    pub fn clear_can_kick(&mut self) {
        self.can_kick = ::std::option::Option::None;
    }

    pub fn has_can_kick(&self) -> bool {
        self.can_kick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_kick(&mut self, v: bool) {
        self.can_kick = ::std::option::Option::Some(v);
    }

    // optional bool can_ban = 4;

    pub fn can_ban(&self) -> bool {
        self.can_ban.unwrap_or(false)
    }

    pub fn clear_can_ban(&mut self) {
        self.can_ban = ::std::option::Option::None;
    }

    pub fn has_can_ban(&self) -> bool {
        self.can_ban.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_ban(&mut self, v: bool) {
        self.can_ban = ::std::option::Option::Some(v);
    }

    // optional bool can_invite = 5;

    pub fn can_invite(&self) -> bool {
        self.can_invite.unwrap_or(false)
    }

    pub fn clear_can_invite(&mut self) {
        self.can_invite = ::std::option::Option::None;
    }

    pub fn has_can_invite(&self) -> bool {
        self.can_invite.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_invite(&mut self, v: bool) {
        self.can_invite = ::std::option::Option::Some(v);
    }

    // optional bool can_change_tagline_avatar_name = 6;

    pub fn can_change_tagline_avatar_name(&self) -> bool {
        self.can_change_tagline_avatar_name.unwrap_or(false)
    }

    pub fn clear_can_change_tagline_avatar_name(&mut self) {
        self.can_change_tagline_avatar_name = ::std::option::Option::None;
    }

    pub fn has_can_change_tagline_avatar_name(&self) -> bool {
        self.can_change_tagline_avatar_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_change_tagline_avatar_name(&mut self, v: bool) {
        self.can_change_tagline_avatar_name = ::std::option::Option::Some(v);
    }

    // optional bool can_chat = 7;

    pub fn can_chat(&self) -> bool {
        self.can_chat.unwrap_or(false)
    }

    pub fn clear_can_chat(&mut self) {
        self.can_chat = ::std::option::Option::None;
    }

    pub fn has_can_chat(&self) -> bool {
        self.can_chat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_chat(&mut self, v: bool) {
        self.can_chat = ::std::option::Option::Some(v);
    }

    // optional bool can_view_history = 8;

    pub fn can_view_history(&self) -> bool {
        self.can_view_history.unwrap_or(false)
    }

    pub fn clear_can_view_history(&mut self) {
        self.can_view_history = ::std::option::Option::None;
    }

    pub fn has_can_view_history(&self) -> bool {
        self.can_view_history.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_view_history(&mut self, v: bool) {
        self.can_view_history = ::std::option::Option::Some(v);
    }

    // optional bool can_change_group_roles = 9;

    pub fn can_change_group_roles(&self) -> bool {
        self.can_change_group_roles.unwrap_or(false)
    }

    pub fn clear_can_change_group_roles(&mut self) {
        self.can_change_group_roles = ::std::option::Option::None;
    }

    pub fn has_can_change_group_roles(&self) -> bool {
        self.can_change_group_roles.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_change_group_roles(&mut self, v: bool) {
        self.can_change_group_roles = ::std::option::Option::Some(v);
    }

    // optional bool can_change_user_roles = 10;

    pub fn can_change_user_roles(&self) -> bool {
        self.can_change_user_roles.unwrap_or(false)
    }

    pub fn clear_can_change_user_roles(&mut self) {
        self.can_change_user_roles = ::std::option::Option::None;
    }

    pub fn has_can_change_user_roles(&self) -> bool {
        self.can_change_user_roles.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_change_user_roles(&mut self, v: bool) {
        self.can_change_user_roles = ::std::option::Option::Some(v);
    }

    // optional bool can_mention_all = 11;

    pub fn can_mention_all(&self) -> bool {
        self.can_mention_all.unwrap_or(false)
    }

    pub fn clear_can_mention_all(&mut self) {
        self.can_mention_all = ::std::option::Option::None;
    }

    pub fn has_can_mention_all(&self) -> bool {
        self.can_mention_all.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_mention_all(&mut self, v: bool) {
        self.can_mention_all = ::std::option::Option::Some(v);
    }

    // optional bool can_set_watching_broadcast = 12;

    pub fn can_set_watching_broadcast(&self) -> bool {
        self.can_set_watching_broadcast.unwrap_or(false)
    }

    pub fn clear_can_set_watching_broadcast(&mut self) {
        self.can_set_watching_broadcast = ::std::option::Option::None;
    }

    pub fn has_can_set_watching_broadcast(&self) -> bool {
        self.can_set_watching_broadcast.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_set_watching_broadcast(&mut self, v: bool) {
        self.can_set_watching_broadcast = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoleActions {
    const NAME: &'static str = "CChatRoleActions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.role_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.can_create_rename_delete_channel = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.can_kick = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.can_ban = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.can_invite = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.can_change_tagline_avatar_name = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.can_chat = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.can_view_history = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.can_change_group_roles = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.can_change_user_roles = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.can_mention_all = ::std::option::Option::Some(is.read_bool()?);
                },
                96 => {
                    self.can_set_watching_broadcast = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.role_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.can_create_rename_delete_channel {
            my_size += 1 + 1;
        }
        if let Some(v) = self.can_kick {
            my_size += 1 + 1;
        }
        if let Some(v) = self.can_ban {
            my_size += 1 + 1;
        }
        if let Some(v) = self.can_invite {
            my_size += 1 + 1;
        }
        if let Some(v) = self.can_change_tagline_avatar_name {
            my_size += 1 + 1;
        }
        if let Some(v) = self.can_chat {
            my_size += 1 + 1;
        }
        if let Some(v) = self.can_view_history {
            my_size += 1 + 1;
        }
        if let Some(v) = self.can_change_group_roles {
            my_size += 1 + 1;
        }
        if let Some(v) = self.can_change_user_roles {
            my_size += 1 + 1;
        }
        if let Some(v) = self.can_mention_all {
            my_size += 1 + 1;
        }
        if let Some(v) = self.can_set_watching_broadcast {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.role_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.can_create_rename_delete_channel {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.can_kick {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.can_ban {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.can_invite {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.can_change_tagline_avatar_name {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.can_chat {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.can_view_history {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.can_change_group_roles {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.can_change_user_roles {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.can_mention_all {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.can_set_watching_broadcast {
            os.write_bool(12, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoleActions {
        CChatRoleActions::new()
    }

    fn clear(&mut self) {
        self.role_id = ::std::option::Option::None;
        self.can_create_rename_delete_channel = ::std::option::Option::None;
        self.can_kick = ::std::option::Option::None;
        self.can_ban = ::std::option::Option::None;
        self.can_invite = ::std::option::Option::None;
        self.can_change_tagline_avatar_name = ::std::option::Option::None;
        self.can_chat = ::std::option::Option::None;
        self.can_view_history = ::std::option::Option::None;
        self.can_change_group_roles = ::std::option::Option::None;
        self.can_change_user_roles = ::std::option::Option::None;
        self.can_mention_all = ::std::option::Option::None;
        self.can_set_watching_broadcast = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoleActions {
        static instance: CChatRoleActions = CChatRoleActions {
            role_id: ::std::option::Option::None,
            can_create_rename_delete_channel: ::std::option::Option::None,
            can_kick: ::std::option::Option::None,
            can_ban: ::std::option::Option::None,
            can_invite: ::std::option::Option::None,
            can_change_tagline_avatar_name: ::std::option::Option::None,
            can_chat: ::std::option::Option::None,
            can_view_history: ::std::option::Option::None,
            can_change_group_roles: ::std::option::Option::None,
            can_change_user_roles: ::std::option::Option::None,
            can_mention_all: ::std::option::Option::None,
            can_set_watching_broadcast: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatPartyBeacon)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatPartyBeacon {
    // message fields
    // @@protoc_insertion_point(field:CChatPartyBeacon.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatPartyBeacon.steamid_owner)
    pub steamid_owner: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatPartyBeacon.beacon_id)
    pub beacon_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatPartyBeacon.game_metadata)
    pub game_metadata: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatPartyBeacon.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatPartyBeacon {
    fn default() -> &'a CChatPartyBeacon {
        <CChatPartyBeacon as ::protobuf::Message>::default_instance()
    }
}

impl CChatPartyBeacon {
    pub fn new() -> CChatPartyBeacon {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid_owner = 2;

    pub fn steamid_owner(&self) -> u64 {
        self.steamid_owner.unwrap_or(0)
    }

    pub fn clear_steamid_owner(&mut self) {
        self.steamid_owner = ::std::option::Option::None;
    }

    pub fn has_steamid_owner(&self) -> bool {
        self.steamid_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_owner(&mut self, v: u64) {
        self.steamid_owner = ::std::option::Option::Some(v);
    }

    // optional fixed64 beacon_id = 3;

    pub fn beacon_id(&self) -> u64 {
        self.beacon_id.unwrap_or(0)
    }

    pub fn clear_beacon_id(&mut self) {
        self.beacon_id = ::std::option::Option::None;
    }

    pub fn has_beacon_id(&self) -> bool {
        self.beacon_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_beacon_id(&mut self, v: u64) {
        self.beacon_id = ::std::option::Option::Some(v);
    }

    // optional string game_metadata = 4;

    pub fn game_metadata(&self) -> &str {
        match self.game_metadata.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_metadata(&mut self) {
        self.game_metadata = ::std::option::Option::None;
    }

    pub fn has_game_metadata(&self) -> bool {
        self.game_metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_metadata(&mut self, v: ::std::string::String) {
        self.game_metadata = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_metadata(&mut self) -> &mut ::std::string::String {
        if self.game_metadata.is_none() {
            self.game_metadata = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_metadata(&mut self) -> ::std::string::String {
        self.game_metadata.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CChatPartyBeacon {
    const NAME: &'static str = "CChatPartyBeacon";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steamid_owner = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.beacon_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                34 => {
                    self.game_metadata = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steamid_owner {
            my_size += 1 + 8;
        }
        if let Some(v) = self.beacon_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.game_metadata.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steamid_owner {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.beacon_id {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.game_metadata.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatPartyBeacon {
        CChatPartyBeacon::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steamid_owner = ::std::option::Option::None;
        self.beacon_id = ::std::option::Option::None;
        self.game_metadata = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatPartyBeacon {
        static instance: CChatPartyBeacon = CChatPartyBeacon {
            app_id: ::std::option::Option::None,
            steamid_owner: ::std::option::Option::None,
            beacon_id: ::std::option::Option::None,
            game_metadata: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoomGroupHeaderState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoomGroupHeaderState {
    // message fields
    // @@protoc_insertion_point(field:CChatRoomGroupHeaderState.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoomGroupHeaderState.chat_name)
    pub chat_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoomGroupHeaderState.clanid)
    pub clanid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoomGroupHeaderState.accountid_owner)
    pub accountid_owner: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoomGroupHeaderState.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoomGroupHeaderState.tagline)
    pub tagline: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoomGroupHeaderState.avatar_sha)
    pub avatar_sha: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CChatRoomGroupHeaderState.default_role_id)
    pub default_role_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoomGroupHeaderState.roles)
    pub roles: ::std::vec::Vec<CChatRole>,
    // @@protoc_insertion_point(field:CChatRoomGroupHeaderState.role_actions)
    pub role_actions: ::std::vec::Vec<CChatRoleActions>,
    // @@protoc_insertion_point(field:CChatRoomGroupHeaderState.watching_broadcast_accountid)
    pub watching_broadcast_accountid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoomGroupHeaderState.party_beacons)
    pub party_beacons: ::std::vec::Vec<CChatPartyBeacon>,
    // @@protoc_insertion_point(field:CChatRoomGroupHeaderState.watching_broadcast_channel_id)
    pub watching_broadcast_channel_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoomGroupHeaderState.active_minigame_id)
    pub active_minigame_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoomGroupHeaderState.avatar_ugc_url)
    pub avatar_ugc_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoomGroupHeaderState.disabled)
    pub disabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoomGroupHeaderState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoomGroupHeaderState {
    fn default() -> &'a CChatRoomGroupHeaderState {
        <CChatRoomGroupHeaderState as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoomGroupHeaderState {
    pub fn new() -> CChatRoomGroupHeaderState {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional string chat_name = 2;

    pub fn chat_name(&self) -> &str {
        match self.chat_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_chat_name(&mut self) {
        self.chat_name = ::std::option::Option::None;
    }

    pub fn has_chat_name(&self) -> bool {
        self.chat_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_name(&mut self, v: ::std::string::String) {
        self.chat_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_name(&mut self) -> &mut ::std::string::String {
        if self.chat_name.is_none() {
            self.chat_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.chat_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_chat_name(&mut self) -> ::std::string::String {
        self.chat_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 clanid = 13;

    pub fn clanid(&self) -> u32 {
        self.clanid.unwrap_or(0)
    }

    pub fn clear_clanid(&mut self) {
        self.clanid = ::std::option::Option::None;
    }

    pub fn has_clanid(&self) -> bool {
        self.clanid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clanid(&mut self, v: u32) {
        self.clanid = ::std::option::Option::Some(v);
    }

    // optional uint32 accountid_owner = 14;

    pub fn accountid_owner(&self) -> u32 {
        self.accountid_owner.unwrap_or(0)
    }

    pub fn clear_accountid_owner(&mut self) {
        self.accountid_owner = ::std::option::Option::None;
    }

    pub fn has_accountid_owner(&self) -> bool {
        self.accountid_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid_owner(&mut self, v: u32) {
        self.accountid_owner = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 21;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string tagline = 15;

    pub fn tagline(&self) -> &str {
        match self.tagline.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_tagline(&mut self) {
        self.tagline = ::std::option::Option::None;
    }

    pub fn has_tagline(&self) -> bool {
        self.tagline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tagline(&mut self, v: ::std::string::String) {
        self.tagline = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tagline(&mut self) -> &mut ::std::string::String {
        if self.tagline.is_none() {
            self.tagline = ::std::option::Option::Some(::std::string::String::new());
        }
        self.tagline.as_mut().unwrap()
    }

    // Take field
    pub fn take_tagline(&mut self) -> ::std::string::String {
        self.tagline.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes avatar_sha = 16;

    pub fn avatar_sha(&self) -> &[u8] {
        match self.avatar_sha.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_avatar_sha(&mut self) {
        self.avatar_sha = ::std::option::Option::None;
    }

    pub fn has_avatar_sha(&self) -> bool {
        self.avatar_sha.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avatar_sha(&mut self, v: ::std::vec::Vec<u8>) {
        self.avatar_sha = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar_sha(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.avatar_sha.is_none() {
            self.avatar_sha = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.avatar_sha.as_mut().unwrap()
    }

    // Take field
    pub fn take_avatar_sha(&mut self) -> ::std::vec::Vec<u8> {
        self.avatar_sha.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 default_role_id = 17;

    pub fn default_role_id(&self) -> u64 {
        self.default_role_id.unwrap_or(0)
    }

    pub fn clear_default_role_id(&mut self) {
        self.default_role_id = ::std::option::Option::None;
    }

    pub fn has_default_role_id(&self) -> bool {
        self.default_role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_role_id(&mut self, v: u64) {
        self.default_role_id = ::std::option::Option::Some(v);
    }

    // optional uint32 watching_broadcast_accountid = 20;

    pub fn watching_broadcast_accountid(&self) -> u32 {
        self.watching_broadcast_accountid.unwrap_or(0)
    }

    pub fn clear_watching_broadcast_accountid(&mut self) {
        self.watching_broadcast_accountid = ::std::option::Option::None;
    }

    pub fn has_watching_broadcast_accountid(&self) -> bool {
        self.watching_broadcast_accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watching_broadcast_accountid(&mut self, v: u32) {
        self.watching_broadcast_accountid = ::std::option::Option::Some(v);
    }

    // optional uint64 watching_broadcast_channel_id = 23;

    pub fn watching_broadcast_channel_id(&self) -> u64 {
        self.watching_broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_watching_broadcast_channel_id(&mut self) {
        self.watching_broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_watching_broadcast_channel_id(&self) -> bool {
        self.watching_broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watching_broadcast_channel_id(&mut self, v: u64) {
        self.watching_broadcast_channel_id = ::std::option::Option::Some(v);
    }

    // optional uint64 active_minigame_id = 24;

    pub fn active_minigame_id(&self) -> u64 {
        self.active_minigame_id.unwrap_or(0)
    }

    pub fn clear_active_minigame_id(&mut self) {
        self.active_minigame_id = ::std::option::Option::None;
    }

    pub fn has_active_minigame_id(&self) -> bool {
        self.active_minigame_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_minigame_id(&mut self, v: u64) {
        self.active_minigame_id = ::std::option::Option::Some(v);
    }

    // optional string avatar_ugc_url = 25;

    pub fn avatar_ugc_url(&self) -> &str {
        match self.avatar_ugc_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_avatar_ugc_url(&mut self) {
        self.avatar_ugc_url = ::std::option::Option::None;
    }

    pub fn has_avatar_ugc_url(&self) -> bool {
        self.avatar_ugc_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avatar_ugc_url(&mut self, v: ::std::string::String) {
        self.avatar_ugc_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar_ugc_url(&mut self) -> &mut ::std::string::String {
        if self.avatar_ugc_url.is_none() {
            self.avatar_ugc_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.avatar_ugc_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_avatar_ugc_url(&mut self) -> ::std::string::String {
        self.avatar_ugc_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool disabled = 26;

    pub fn disabled(&self) -> bool {
        self.disabled.unwrap_or(false)
    }

    pub fn clear_disabled(&mut self) {
        self.disabled = ::std::option::Option::None;
    }

    pub fn has_disabled(&self) -> bool {
        self.disabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disabled(&mut self, v: bool) {
        self.disabled = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoomGroupHeaderState {
    const NAME: &'static str = "CChatRoomGroupHeaderState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.chat_name = ::std::option::Option::Some(is.read_string()?);
                },
                104 => {
                    self.clanid = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.accountid_owner = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                122 => {
                    self.tagline = ::std::option::Option::Some(is.read_string()?);
                },
                130 => {
                    self.avatar_sha = ::std::option::Option::Some(is.read_bytes()?);
                },
                136 => {
                    self.default_role_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                146 => {
                    self.roles.push(is.read_message()?);
                },
                154 => {
                    self.role_actions.push(is.read_message()?);
                },
                160 => {
                    self.watching_broadcast_accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                178 => {
                    self.party_beacons.push(is.read_message()?);
                },
                184 => {
                    self.watching_broadcast_channel_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                192 => {
                    self.active_minigame_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                202 => {
                    self.avatar_ugc_url = ::std::option::Option::Some(is.read_string()?);
                },
                208 => {
                    self.disabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.clanid {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.accountid_owner {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.tagline.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.avatar_sha.as_ref() {
            my_size += ::protobuf::rt::bytes_size(16, &v);
        }
        if let Some(v) = self.default_role_id {
            my_size += ::protobuf::rt::uint64_size(17, v);
        }
        for value in &self.roles {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.role_actions {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.watching_broadcast_accountid {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        for value in &self.party_beacons {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.watching_broadcast_channel_id {
            my_size += ::protobuf::rt::uint64_size(23, v);
        }
        if let Some(v) = self.active_minigame_id {
            my_size += ::protobuf::rt::uint64_size(24, v);
        }
        if let Some(v) = self.avatar_ugc_url.as_ref() {
            my_size += ::protobuf::rt::string_size(25, &v);
        }
        if let Some(v) = self.disabled {
            my_size += 2 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.clanid {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.accountid_owner {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.tagline.as_ref() {
            os.write_string(15, v)?;
        }
        if let Some(v) = self.avatar_sha.as_ref() {
            os.write_bytes(16, v)?;
        }
        if let Some(v) = self.default_role_id {
            os.write_uint64(17, v)?;
        }
        for v in &self.roles {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        };
        for v in &self.role_actions {
            ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        };
        if let Some(v) = self.watching_broadcast_accountid {
            os.write_uint32(20, v)?;
        }
        for v in &self.party_beacons {
            ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
        };
        if let Some(v) = self.watching_broadcast_channel_id {
            os.write_uint64(23, v)?;
        }
        if let Some(v) = self.active_minigame_id {
            os.write_uint64(24, v)?;
        }
        if let Some(v) = self.avatar_ugc_url.as_ref() {
            os.write_string(25, v)?;
        }
        if let Some(v) = self.disabled {
            os.write_bool(26, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoomGroupHeaderState {
        CChatRoomGroupHeaderState::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_name = ::std::option::Option::None;
        self.clanid = ::std::option::Option::None;
        self.accountid_owner = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.tagline = ::std::option::Option::None;
        self.avatar_sha = ::std::option::Option::None;
        self.default_role_id = ::std::option::Option::None;
        self.roles.clear();
        self.role_actions.clear();
        self.watching_broadcast_accountid = ::std::option::Option::None;
        self.party_beacons.clear();
        self.watching_broadcast_channel_id = ::std::option::Option::None;
        self.active_minigame_id = ::std::option::Option::None;
        self.avatar_ugc_url = ::std::option::Option::None;
        self.disabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoomGroupHeaderState {
        static instance: CChatRoomGroupHeaderState = CChatRoomGroupHeaderState {
            chat_group_id: ::std::option::Option::None,
            chat_name: ::std::option::Option::None,
            clanid: ::std::option::Option::None,
            accountid_owner: ::std::option::Option::None,
            appid: ::std::option::Option::None,
            tagline: ::std::option::Option::None,
            avatar_sha: ::std::option::Option::None,
            default_role_id: ::std::option::Option::None,
            roles: ::std::vec::Vec::new(),
            role_actions: ::std::vec::Vec::new(),
            watching_broadcast_accountid: ::std::option::Option::None,
            party_beacons: ::std::vec::Vec::new(),
            watching_broadcast_channel_id: ::std::option::Option::None,
            active_minigame_id: ::std::option::Option::None,
            avatar_ugc_url: ::std::option::Option::None,
            disabled: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoomMember)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoomMember {
    // message fields
    // @@protoc_insertion_point(field:CChatRoomMember.accountid)
    pub accountid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoomMember.state)
    pub state: ::std::option::Option<::protobuf::EnumOrUnknown<EChatRoomJoinState>>,
    // @@protoc_insertion_point(field:CChatRoomMember.rank)
    pub rank: ::std::option::Option<::protobuf::EnumOrUnknown<EChatRoomGroupRank>>,
    // @@protoc_insertion_point(field:CChatRoomMember.time_kick_expire)
    pub time_kick_expire: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoomMember.role_ids)
    pub role_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoomMember.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoomMember {
    fn default() -> &'a CChatRoomMember {
        <CChatRoomMember as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoomMember {
    pub fn new() -> CChatRoomMember {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;

    pub fn accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional .EChatRoomJoinState state = 3;

    pub fn state(&self) -> EChatRoomJoinState {
        match self.state {
            Some(e) => e.enum_value_or(EChatRoomJoinState::k_EChatRoomJoinState_Default),
            None => EChatRoomJoinState::k_EChatRoomJoinState_Default,
        }
    }

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: EChatRoomJoinState) {
        self.state = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .EChatRoomGroupRank rank = 4;

    pub fn rank(&self) -> EChatRoomGroupRank {
        match self.rank {
            Some(e) => e.enum_value_or(EChatRoomGroupRank::k_EChatRoomGroupRank_Default),
            None => EChatRoomGroupRank::k_EChatRoomGroupRank_Default,
        }
    }

    pub fn clear_rank(&mut self) {
        self.rank = ::std::option::Option::None;
    }

    pub fn has_rank(&self) -> bool {
        self.rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank(&mut self, v: EChatRoomGroupRank) {
        self.rank = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 time_kick_expire = 6;

    pub fn time_kick_expire(&self) -> u32 {
        self.time_kick_expire.unwrap_or(0)
    }

    pub fn clear_time_kick_expire(&mut self) {
        self.time_kick_expire = ::std::option::Option::None;
    }

    pub fn has_time_kick_expire(&self) -> bool {
        self.time_kick_expire.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_kick_expire(&mut self, v: u32) {
        self.time_kick_expire = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoomMember {
    const NAME: &'static str = "CChatRoomMember";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.rank = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                48 => {
                    self.time_kick_expire = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    is.read_repeated_packed_uint64_into(&mut self.role_ids)?;
                },
                56 => {
                    self.role_ids.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.state {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.rank {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.time_kick_expire {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        for value in &self.role_ids {
            my_size += ::protobuf::rt::uint64_size(7, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.state {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.rank {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.time_kick_expire {
            os.write_uint32(6, v)?;
        }
        for v in &self.role_ids {
            os.write_uint64(7, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoomMember {
        CChatRoomMember::new()
    }

    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.state = ::std::option::Option::None;
        self.rank = ::std::option::Option::None;
        self.time_kick_expire = ::std::option::Option::None;
        self.role_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoomMember {
        static instance: CChatRoomMember = CChatRoomMember {
            accountid: ::std::option::Option::None,
            state: ::std::option::Option::None,
            rank: ::std::option::Option::None,
            time_kick_expire: ::std::option::Option::None,
            role_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoomState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoomState {
    // message fields
    // @@protoc_insertion_point(field:CChatRoomState.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoomState.chat_name)
    pub chat_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoomState.voice_allowed)
    pub voice_allowed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CChatRoomState.members_in_voice)
    pub members_in_voice: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CChatRoomState.time_last_message)
    pub time_last_message: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoomState.sort_order)
    pub sort_order: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoomState.last_message)
    pub last_message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoomState.accountid_last_message)
    pub accountid_last_message: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoomState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoomState {
    fn default() -> &'a CChatRoomState {
        <CChatRoomState as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoomState {
    pub fn new() -> CChatRoomState {
        ::std::default::Default::default()
    }

    // optional uint64 chat_id = 1;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional string chat_name = 2;

    pub fn chat_name(&self) -> &str {
        match self.chat_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_chat_name(&mut self) {
        self.chat_name = ::std::option::Option::None;
    }

    pub fn has_chat_name(&self) -> bool {
        self.chat_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_name(&mut self, v: ::std::string::String) {
        self.chat_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_name(&mut self) -> &mut ::std::string::String {
        if self.chat_name.is_none() {
            self.chat_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.chat_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_chat_name(&mut self) -> ::std::string::String {
        self.chat_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool voice_allowed = 3;

    pub fn voice_allowed(&self) -> bool {
        self.voice_allowed.unwrap_or(false)
    }

    pub fn clear_voice_allowed(&mut self) {
        self.voice_allowed = ::std::option::Option::None;
    }

    pub fn has_voice_allowed(&self) -> bool {
        self.voice_allowed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_allowed(&mut self, v: bool) {
        self.voice_allowed = ::std::option::Option::Some(v);
    }

    // optional uint32 time_last_message = 5;

    pub fn time_last_message(&self) -> u32 {
        self.time_last_message.unwrap_or(0)
    }

    pub fn clear_time_last_message(&mut self) {
        self.time_last_message = ::std::option::Option::None;
    }

    pub fn has_time_last_message(&self) -> bool {
        self.time_last_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_last_message(&mut self, v: u32) {
        self.time_last_message = ::std::option::Option::Some(v);
    }

    // optional uint32 sort_order = 6;

    pub fn sort_order(&self) -> u32 {
        self.sort_order.unwrap_or(0)
    }

    pub fn clear_sort_order(&mut self) {
        self.sort_order = ::std::option::Option::None;
    }

    pub fn has_sort_order(&self) -> bool {
        self.sort_order.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sort_order(&mut self, v: u32) {
        self.sort_order = ::std::option::Option::Some(v);
    }

    // optional string last_message = 7;

    pub fn last_message(&self) -> &str {
        match self.last_message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_last_message(&mut self) {
        self.last_message = ::std::option::Option::None;
    }

    pub fn has_last_message(&self) -> bool {
        self.last_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_message(&mut self, v: ::std::string::String) {
        self.last_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_message(&mut self) -> &mut ::std::string::String {
        if self.last_message.is_none() {
            self.last_message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.last_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_message(&mut self) -> ::std::string::String {
        self.last_message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 accountid_last_message = 8;

    pub fn accountid_last_message(&self) -> u32 {
        self.accountid_last_message.unwrap_or(0)
    }

    pub fn clear_accountid_last_message(&mut self) {
        self.accountid_last_message = ::std::option::Option::None;
    }

    pub fn has_accountid_last_message(&self) -> bool {
        self.accountid_last_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid_last_message(&mut self, v: u32) {
        self.accountid_last_message = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoomState {
    const NAME: &'static str = "CChatRoomState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.chat_name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.voice_allowed = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    is.read_repeated_packed_uint32_into(&mut self.members_in_voice)?;
                },
                32 => {
                    self.members_in_voice.push(is.read_uint32()?);
                },
                40 => {
                    self.time_last_message = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.sort_order = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.last_message = ::std::option::Option::Some(is.read_string()?);
                },
                64 => {
                    self.accountid_last_message = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.voice_allowed {
            my_size += 1 + 1;
        }
        for value in &self.members_in_voice {
            my_size += ::protobuf::rt::uint32_size(4, *value);
        };
        if let Some(v) = self.time_last_message {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.sort_order {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.last_message.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.accountid_last_message {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.voice_allowed {
            os.write_bool(3, v)?;
        }
        for v in &self.members_in_voice {
            os.write_uint32(4, *v)?;
        };
        if let Some(v) = self.time_last_message {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.sort_order {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.last_message.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.accountid_last_message {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoomState {
        CChatRoomState::new()
    }

    fn clear(&mut self) {
        self.chat_id = ::std::option::Option::None;
        self.chat_name = ::std::option::Option::None;
        self.voice_allowed = ::std::option::Option::None;
        self.members_in_voice.clear();
        self.time_last_message = ::std::option::Option::None;
        self.sort_order = ::std::option::Option::None;
        self.last_message = ::std::option::Option::None;
        self.accountid_last_message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoomState {
        static instance: CChatRoomState = CChatRoomState {
            chat_id: ::std::option::Option::None,
            chat_name: ::std::option::Option::None,
            voice_allowed: ::std::option::Option::None,
            members_in_voice: ::std::vec::Vec::new(),
            time_last_message: ::std::option::Option::None,
            sort_order: ::std::option::Option::None,
            last_message: ::std::option::Option::None,
            accountid_last_message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoomGroupState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoomGroupState {
    // message fields
    // @@protoc_insertion_point(field:CChatRoomGroupState.header_state)
    pub header_state: ::protobuf::MessageField<CChatRoomGroupHeaderState>,
    // @@protoc_insertion_point(field:CChatRoomGroupState.members)
    pub members: ::std::vec::Vec<CChatRoomMember>,
    // @@protoc_insertion_point(field:CChatRoomGroupState.default_chat_id)
    pub default_chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoomGroupState.chat_rooms)
    pub chat_rooms: ::std::vec::Vec<CChatRoomState>,
    // @@protoc_insertion_point(field:CChatRoomGroupState.kicked)
    pub kicked: ::std::vec::Vec<CChatRoomMember>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoomGroupState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoomGroupState {
    fn default() -> &'a CChatRoomGroupState {
        <CChatRoomGroupState as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoomGroupState {
    pub fn new() -> CChatRoomGroupState {
        ::std::default::Default::default()
    }

    // optional uint64 default_chat_id = 4;

    pub fn default_chat_id(&self) -> u64 {
        self.default_chat_id.unwrap_or(0)
    }

    pub fn clear_default_chat_id(&mut self) {
        self.default_chat_id = ::std::option::Option::None;
    }

    pub fn has_default_chat_id(&self) -> bool {
        self.default_chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_chat_id(&mut self, v: u64) {
        self.default_chat_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoomGroupState {
    const NAME: &'static str = "CChatRoomGroupState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header_state)?;
                },
                18 => {
                    self.members.push(is.read_message()?);
                },
                32 => {
                    self.default_chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                42 => {
                    self.chat_rooms.push(is.read_message()?);
                },
                58 => {
                    self.kicked.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.default_chat_id {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        for value in &self.chat_rooms {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.kicked {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header_state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.members {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.default_chat_id {
            os.write_uint64(4, v)?;
        }
        for v in &self.chat_rooms {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.kicked {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoomGroupState {
        CChatRoomGroupState::new()
    }

    fn clear(&mut self) {
        self.header_state.clear();
        self.members.clear();
        self.default_chat_id = ::std::option::Option::None;
        self.chat_rooms.clear();
        self.kicked.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoomGroupState {
        static instance: CChatRoomGroupState = CChatRoomGroupState {
            header_state: ::protobuf::MessageField::none(),
            members: ::std::vec::Vec::new(),
            default_chat_id: ::std::option::Option::None,
            chat_rooms: ::std::vec::Vec::new(),
            kicked: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CUserChatRoomState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserChatRoomState {
    // message fields
    // @@protoc_insertion_point(field:CUserChatRoomState.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CUserChatRoomState.time_joined)
    pub time_joined: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserChatRoomState.time_last_ack)
    pub time_last_ack: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserChatRoomState.desktop_notification_level)
    pub desktop_notification_level: ::std::option::Option<::protobuf::EnumOrUnknown<EChatRoomNotificationLevel>>,
    // @@protoc_insertion_point(field:CUserChatRoomState.mobile_notification_level)
    pub mobile_notification_level: ::std::option::Option<::protobuf::EnumOrUnknown<EChatRoomNotificationLevel>>,
    // @@protoc_insertion_point(field:CUserChatRoomState.time_last_mention)
    pub time_last_mention: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserChatRoomState.unread_indicator_muted)
    pub unread_indicator_muted: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CUserChatRoomState.time_first_unread)
    pub time_first_unread: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserChatRoomState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserChatRoomState {
    fn default() -> &'a CUserChatRoomState {
        <CUserChatRoomState as ::protobuf::Message>::default_instance()
    }
}

impl CUserChatRoomState {
    pub fn new() -> CUserChatRoomState {
        ::std::default::Default::default()
    }

    // optional uint64 chat_id = 1;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional uint32 time_joined = 2;

    pub fn time_joined(&self) -> u32 {
        self.time_joined.unwrap_or(0)
    }

    pub fn clear_time_joined(&mut self) {
        self.time_joined = ::std::option::Option::None;
    }

    pub fn has_time_joined(&self) -> bool {
        self.time_joined.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_joined(&mut self, v: u32) {
        self.time_joined = ::std::option::Option::Some(v);
    }

    // optional uint32 time_last_ack = 3;

    pub fn time_last_ack(&self) -> u32 {
        self.time_last_ack.unwrap_or(0)
    }

    pub fn clear_time_last_ack(&mut self) {
        self.time_last_ack = ::std::option::Option::None;
    }

    pub fn has_time_last_ack(&self) -> bool {
        self.time_last_ack.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_last_ack(&mut self, v: u32) {
        self.time_last_ack = ::std::option::Option::Some(v);
    }

    // optional .EChatRoomNotificationLevel desktop_notification_level = 4;

    pub fn desktop_notification_level(&self) -> EChatRoomNotificationLevel {
        match self.desktop_notification_level {
            Some(e) => e.enum_value_or(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid),
            None => EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid,
        }
    }

    pub fn clear_desktop_notification_level(&mut self) {
        self.desktop_notification_level = ::std::option::Option::None;
    }

    pub fn has_desktop_notification_level(&self) -> bool {
        self.desktop_notification_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desktop_notification_level(&mut self, v: EChatRoomNotificationLevel) {
        self.desktop_notification_level = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .EChatRoomNotificationLevel mobile_notification_level = 5;

    pub fn mobile_notification_level(&self) -> EChatRoomNotificationLevel {
        match self.mobile_notification_level {
            Some(e) => e.enum_value_or(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid),
            None => EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid,
        }
    }

    pub fn clear_mobile_notification_level(&mut self) {
        self.mobile_notification_level = ::std::option::Option::None;
    }

    pub fn has_mobile_notification_level(&self) -> bool {
        self.mobile_notification_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mobile_notification_level(&mut self, v: EChatRoomNotificationLevel) {
        self.mobile_notification_level = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 time_last_mention = 6;

    pub fn time_last_mention(&self) -> u32 {
        self.time_last_mention.unwrap_or(0)
    }

    pub fn clear_time_last_mention(&mut self) {
        self.time_last_mention = ::std::option::Option::None;
    }

    pub fn has_time_last_mention(&self) -> bool {
        self.time_last_mention.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_last_mention(&mut self, v: u32) {
        self.time_last_mention = ::std::option::Option::Some(v);
    }

    // optional bool unread_indicator_muted = 7;

    pub fn unread_indicator_muted(&self) -> bool {
        self.unread_indicator_muted.unwrap_or(false)
    }

    pub fn clear_unread_indicator_muted(&mut self) {
        self.unread_indicator_muted = ::std::option::Option::None;
    }

    pub fn has_unread_indicator_muted(&self) -> bool {
        self.unread_indicator_muted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unread_indicator_muted(&mut self, v: bool) {
        self.unread_indicator_muted = ::std::option::Option::Some(v);
    }

    // optional uint32 time_first_unread = 8;

    pub fn time_first_unread(&self) -> u32 {
        self.time_first_unread.unwrap_or(0)
    }

    pub fn clear_time_first_unread(&mut self) {
        self.time_first_unread = ::std::option::Option::None;
    }

    pub fn has_time_first_unread(&self) -> bool {
        self.time_first_unread.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_first_unread(&mut self, v: u32) {
        self.time_first_unread = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CUserChatRoomState {
    const NAME: &'static str = "CUserChatRoomState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.time_joined = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.time_last_ack = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.desktop_notification_level = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.mobile_notification_level = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                48 => {
                    self.time_last_mention = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.unread_indicator_muted = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.time_first_unread = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.time_joined {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.time_last_ack {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.desktop_notification_level {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.mobile_notification_level {
            my_size += ::protobuf::rt::int32_size(5, v.value());
        }
        if let Some(v) = self.time_last_mention {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.unread_indicator_muted {
            my_size += 1 + 1;
        }
        if let Some(v) = self.time_first_unread {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.time_joined {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.time_last_ack {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.desktop_notification_level {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.mobile_notification_level {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.time_last_mention {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.unread_indicator_muted {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.time_first_unread {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserChatRoomState {
        CUserChatRoomState::new()
    }

    fn clear(&mut self) {
        self.chat_id = ::std::option::Option::None;
        self.time_joined = ::std::option::Option::None;
        self.time_last_ack = ::std::option::Option::None;
        self.desktop_notification_level = ::std::option::Option::None;
        self.mobile_notification_level = ::std::option::Option::None;
        self.time_last_mention = ::std::option::Option::None;
        self.unread_indicator_muted = ::std::option::Option::None;
        self.time_first_unread = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserChatRoomState {
        static instance: CUserChatRoomState = CUserChatRoomState {
            chat_id: ::std::option::Option::None,
            time_joined: ::std::option::Option::None,
            time_last_ack: ::std::option::Option::None,
            desktop_notification_level: ::std::option::Option::None,
            mobile_notification_level: ::std::option::Option::None,
            time_last_mention: ::std::option::Option::None,
            unread_indicator_muted: ::std::option::Option::None,
            time_first_unread: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CUserChatRoomGroupState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserChatRoomGroupState {
    // message fields
    // @@protoc_insertion_point(field:CUserChatRoomGroupState.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CUserChatRoomGroupState.time_joined)
    pub time_joined: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserChatRoomGroupState.user_chat_room_state)
    pub user_chat_room_state: ::std::vec::Vec<CUserChatRoomState>,
    // @@protoc_insertion_point(field:CUserChatRoomGroupState.desktop_notification_level)
    pub desktop_notification_level: ::std::option::Option<::protobuf::EnumOrUnknown<EChatRoomNotificationLevel>>,
    // @@protoc_insertion_point(field:CUserChatRoomGroupState.mobile_notification_level)
    pub mobile_notification_level: ::std::option::Option<::protobuf::EnumOrUnknown<EChatRoomNotificationLevel>>,
    // @@protoc_insertion_point(field:CUserChatRoomGroupState.time_last_group_ack)
    pub time_last_group_ack: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserChatRoomGroupState.unread_indicator_muted)
    pub unread_indicator_muted: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserChatRoomGroupState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserChatRoomGroupState {
    fn default() -> &'a CUserChatRoomGroupState {
        <CUserChatRoomGroupState as ::protobuf::Message>::default_instance()
    }
}

impl CUserChatRoomGroupState {
    pub fn new() -> CUserChatRoomGroupState {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint32 time_joined = 2;

    pub fn time_joined(&self) -> u32 {
        self.time_joined.unwrap_or(0)
    }

    pub fn clear_time_joined(&mut self) {
        self.time_joined = ::std::option::Option::None;
    }

    pub fn has_time_joined(&self) -> bool {
        self.time_joined.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_joined(&mut self, v: u32) {
        self.time_joined = ::std::option::Option::Some(v);
    }

    // optional .EChatRoomNotificationLevel desktop_notification_level = 4;

    pub fn desktop_notification_level(&self) -> EChatRoomNotificationLevel {
        match self.desktop_notification_level {
            Some(e) => e.enum_value_or(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid),
            None => EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid,
        }
    }

    pub fn clear_desktop_notification_level(&mut self) {
        self.desktop_notification_level = ::std::option::Option::None;
    }

    pub fn has_desktop_notification_level(&self) -> bool {
        self.desktop_notification_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desktop_notification_level(&mut self, v: EChatRoomNotificationLevel) {
        self.desktop_notification_level = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .EChatRoomNotificationLevel mobile_notification_level = 5;

    pub fn mobile_notification_level(&self) -> EChatRoomNotificationLevel {
        match self.mobile_notification_level {
            Some(e) => e.enum_value_or(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid),
            None => EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid,
        }
    }

    pub fn clear_mobile_notification_level(&mut self) {
        self.mobile_notification_level = ::std::option::Option::None;
    }

    pub fn has_mobile_notification_level(&self) -> bool {
        self.mobile_notification_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mobile_notification_level(&mut self, v: EChatRoomNotificationLevel) {
        self.mobile_notification_level = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 time_last_group_ack = 6;

    pub fn time_last_group_ack(&self) -> u32 {
        self.time_last_group_ack.unwrap_or(0)
    }

    pub fn clear_time_last_group_ack(&mut self) {
        self.time_last_group_ack = ::std::option::Option::None;
    }

    pub fn has_time_last_group_ack(&self) -> bool {
        self.time_last_group_ack.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_last_group_ack(&mut self, v: u32) {
        self.time_last_group_ack = ::std::option::Option::Some(v);
    }

    // optional bool unread_indicator_muted = 7;

    pub fn unread_indicator_muted(&self) -> bool {
        self.unread_indicator_muted.unwrap_or(false)
    }

    pub fn clear_unread_indicator_muted(&mut self) {
        self.unread_indicator_muted = ::std::option::Option::None;
    }

    pub fn has_unread_indicator_muted(&self) -> bool {
        self.unread_indicator_muted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unread_indicator_muted(&mut self, v: bool) {
        self.unread_indicator_muted = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CUserChatRoomGroupState {
    const NAME: &'static str = "CUserChatRoomGroupState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.time_joined = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.user_chat_room_state.push(is.read_message()?);
                },
                32 => {
                    self.desktop_notification_level = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.mobile_notification_level = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                48 => {
                    self.time_last_group_ack = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.unread_indicator_muted = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.time_joined {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.user_chat_room_state {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.desktop_notification_level {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.mobile_notification_level {
            my_size += ::protobuf::rt::int32_size(5, v.value());
        }
        if let Some(v) = self.time_last_group_ack {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.unread_indicator_muted {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.time_joined {
            os.write_uint32(2, v)?;
        }
        for v in &self.user_chat_room_state {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.desktop_notification_level {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.mobile_notification_level {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.time_last_group_ack {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.unread_indicator_muted {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserChatRoomGroupState {
        CUserChatRoomGroupState::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.time_joined = ::std::option::Option::None;
        self.user_chat_room_state.clear();
        self.desktop_notification_level = ::std::option::Option::None;
        self.mobile_notification_level = ::std::option::Option::None;
        self.time_last_group_ack = ::std::option::Option::None;
        self.unread_indicator_muted = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserChatRoomGroupState {
        static instance: CUserChatRoomGroupState = CUserChatRoomGroupState {
            chat_group_id: ::std::option::Option::None,
            time_joined: ::std::option::Option::None,
            user_chat_room_state: ::std::vec::Vec::new(),
            desktop_notification_level: ::std::option::Option::None,
            mobile_notification_level: ::std::option::Option::None,
            time_last_group_ack: ::std::option::Option::None,
            unread_indicator_muted: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoom_CreateChatRoomGroup_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_CreateChatRoomGroup_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_CreateChatRoomGroup_Response.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_CreateChatRoomGroup_Response.state)
    pub state: ::protobuf::MessageField<CChatRoomGroupState>,
    // @@protoc_insertion_point(field:CChatRoom_CreateChatRoomGroup_Response.user_chat_state)
    pub user_chat_state: ::protobuf::MessageField<CUserChatRoomGroupState>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_CreateChatRoomGroup_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_CreateChatRoomGroup_Response {
    fn default() -> &'a CChatRoom_CreateChatRoomGroup_Response {
        <CChatRoom_CreateChatRoomGroup_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_CreateChatRoomGroup_Response {
    pub fn new() -> CChatRoom_CreateChatRoomGroup_Response {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_CreateChatRoomGroup_Response {
    const NAME: &'static str = "CChatRoom_CreateChatRoomGroup_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.state)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_chat_state)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.user_chat_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.user_chat_state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_CreateChatRoomGroup_Response {
        CChatRoom_CreateChatRoomGroup_Response::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.state.clear();
        self.user_chat_state.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_CreateChatRoomGroup_Response {
        static instance: CChatRoom_CreateChatRoomGroup_Response = CChatRoom_CreateChatRoomGroup_Response {
            chat_group_id: ::std::option::Option::None,
            state: ::protobuf::MessageField::none(),
            user_chat_state: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Saves's a chat group"]
// @@protoc_insertion_point(message:CChatRoom_SaveChatRoomGroup_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SaveChatRoomGroup_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_SaveChatRoomGroup_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_SaveChatRoomGroup_Request.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SaveChatRoomGroup_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SaveChatRoomGroup_Request {
    fn default() -> &'a CChatRoom_SaveChatRoomGroup_Request {
        <CChatRoom_SaveChatRoomGroup_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SaveChatRoomGroup_Request {
    pub fn new() -> CChatRoom_SaveChatRoomGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CChatRoom_SaveChatRoomGroup_Request {
    const NAME: &'static str = "CChatRoom_SaveChatRoomGroup_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SaveChatRoomGroup_Request {
        CChatRoom_SaveChatRoomGroup_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SaveChatRoomGroup_Request {
        static instance: CChatRoom_SaveChatRoomGroup_Request = CChatRoom_SaveChatRoomGroup_Request {
            chat_group_id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoom_SaveChatRoomGroup_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SaveChatRoomGroup_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SaveChatRoomGroup_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SaveChatRoomGroup_Response {
    fn default() -> &'a CChatRoom_SaveChatRoomGroup_Response {
        <CChatRoom_SaveChatRoomGroup_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SaveChatRoomGroup_Response {
    pub fn new() -> CChatRoom_SaveChatRoomGroup_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_SaveChatRoomGroup_Response {
    const NAME: &'static str = "CChatRoom_SaveChatRoomGroup_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SaveChatRoomGroup_Response {
        CChatRoom_SaveChatRoomGroup_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SaveChatRoomGroup_Response {
        static instance: CChatRoom_SaveChatRoomGroup_Response = CChatRoom_SaveChatRoomGroup_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Rename a chat room group"]
// @@protoc_insertion_point(message:CChatRoom_RenameChatRoomGroup_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_RenameChatRoomGroup_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_RenameChatRoomGroup_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_RenameChatRoomGroup_Request.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_RenameChatRoomGroup_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_RenameChatRoomGroup_Request {
    fn default() -> &'a CChatRoom_RenameChatRoomGroup_Request {
        <CChatRoom_RenameChatRoomGroup_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_RenameChatRoomGroup_Request {
    pub fn new() -> CChatRoom_RenameChatRoomGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CChatRoom_RenameChatRoomGroup_Request {
    const NAME: &'static str = "CChatRoom_RenameChatRoomGroup_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_RenameChatRoomGroup_Request {
        CChatRoom_RenameChatRoomGroup_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_RenameChatRoomGroup_Request {
        static instance: CChatRoom_RenameChatRoomGroup_Request = CChatRoom_RenameChatRoomGroup_Request {
            chat_group_id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoom_RenameChatRoomGroup_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_RenameChatRoomGroup_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_RenameChatRoomGroup_Response.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_RenameChatRoomGroup_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_RenameChatRoomGroup_Response {
    fn default() -> &'a CChatRoom_RenameChatRoomGroup_Response {
        <CChatRoom_RenameChatRoomGroup_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_RenameChatRoomGroup_Response {
    pub fn new() -> CChatRoom_RenameChatRoomGroup_Response {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CChatRoom_RenameChatRoomGroup_Response {
    const NAME: &'static str = "CChatRoom_RenameChatRoomGroup_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_RenameChatRoomGroup_Response {
        CChatRoom_RenameChatRoomGroup_Response::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_RenameChatRoomGroup_Response {
        static instance: CChatRoom_RenameChatRoomGroup_Response = CChatRoom_RenameChatRoomGroup_Response {
            name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Set tagline for a chat room group"]
// @@protoc_insertion_point(message:CChatRoom_SetChatRoomGroupTagline_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SetChatRoomGroupTagline_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_SetChatRoomGroupTagline_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_SetChatRoomGroupTagline_Request.tagline)
    pub tagline: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SetChatRoomGroupTagline_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetChatRoomGroupTagline_Request {
    fn default() -> &'a CChatRoom_SetChatRoomGroupTagline_Request {
        <CChatRoom_SetChatRoomGroupTagline_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetChatRoomGroupTagline_Request {
    pub fn new() -> CChatRoom_SetChatRoomGroupTagline_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional string tagline = 2;

    pub fn tagline(&self) -> &str {
        match self.tagline.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_tagline(&mut self) {
        self.tagline = ::std::option::Option::None;
    }

    pub fn has_tagline(&self) -> bool {
        self.tagline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tagline(&mut self, v: ::std::string::String) {
        self.tagline = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tagline(&mut self) -> &mut ::std::string::String {
        if self.tagline.is_none() {
            self.tagline = ::std::option::Option::Some(::std::string::String::new());
        }
        self.tagline.as_mut().unwrap()
    }

    // Take field
    pub fn take_tagline(&mut self) -> ::std::string::String {
        self.tagline.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CChatRoom_SetChatRoomGroupTagline_Request {
    const NAME: &'static str = "CChatRoom_SetChatRoomGroupTagline_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.tagline = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.tagline.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.tagline.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SetChatRoomGroupTagline_Request {
        CChatRoom_SetChatRoomGroupTagline_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.tagline = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SetChatRoomGroupTagline_Request {
        static instance: CChatRoom_SetChatRoomGroupTagline_Request = CChatRoom_SetChatRoomGroupTagline_Request {
            chat_group_id: ::std::option::Option::None,
            tagline: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoom_SetChatRoomGroupTagline_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SetChatRoomGroupTagline_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SetChatRoomGroupTagline_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetChatRoomGroupTagline_Response {
    fn default() -> &'a CChatRoom_SetChatRoomGroupTagline_Response {
        <CChatRoom_SetChatRoomGroupTagline_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetChatRoomGroupTagline_Response {
    pub fn new() -> CChatRoom_SetChatRoomGroupTagline_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_SetChatRoomGroupTagline_Response {
    const NAME: &'static str = "CChatRoom_SetChatRoomGroupTagline_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SetChatRoomGroupTagline_Response {
        CChatRoom_SetChatRoomGroupTagline_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SetChatRoomGroupTagline_Response {
        static instance: CChatRoom_SetChatRoomGroupTagline_Response = CChatRoom_SetChatRoomGroupTagline_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Set avatar SHA for a chat room group"]
// @@protoc_insertion_point(message:CChatRoom_SetChatRoomGroupAvatar_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SetChatRoomGroupAvatar_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_SetChatRoomGroupAvatar_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_SetChatRoomGroupAvatar_Request.avatar_sha)
    pub avatar_sha: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SetChatRoomGroupAvatar_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetChatRoomGroupAvatar_Request {
    fn default() -> &'a CChatRoom_SetChatRoomGroupAvatar_Request {
        <CChatRoom_SetChatRoomGroupAvatar_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetChatRoomGroupAvatar_Request {
    pub fn new() -> CChatRoom_SetChatRoomGroupAvatar_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional bytes avatar_sha = 2;

    pub fn avatar_sha(&self) -> &[u8] {
        match self.avatar_sha.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_avatar_sha(&mut self) {
        self.avatar_sha = ::std::option::Option::None;
    }

    pub fn has_avatar_sha(&self) -> bool {
        self.avatar_sha.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avatar_sha(&mut self, v: ::std::vec::Vec<u8>) {
        self.avatar_sha = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar_sha(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.avatar_sha.is_none() {
            self.avatar_sha = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.avatar_sha.as_mut().unwrap()
    }

    // Take field
    pub fn take_avatar_sha(&mut self) -> ::std::vec::Vec<u8> {
        self.avatar_sha.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CChatRoom_SetChatRoomGroupAvatar_Request {
    const NAME: &'static str = "CChatRoom_SetChatRoomGroupAvatar_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.avatar_sha = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.avatar_sha.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.avatar_sha.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SetChatRoomGroupAvatar_Request {
        CChatRoom_SetChatRoomGroupAvatar_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.avatar_sha = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SetChatRoomGroupAvatar_Request {
        static instance: CChatRoom_SetChatRoomGroupAvatar_Request = CChatRoom_SetChatRoomGroupAvatar_Request {
            chat_group_id: ::std::option::Option::None,
            avatar_sha: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoom_SetChatRoomGroupAvatar_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SetChatRoomGroupAvatar_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SetChatRoomGroupAvatar_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetChatRoomGroupAvatar_Response {
    fn default() -> &'a CChatRoom_SetChatRoomGroupAvatar_Response {
        <CChatRoom_SetChatRoomGroupAvatar_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetChatRoomGroupAvatar_Response {
    pub fn new() -> CChatRoom_SetChatRoomGroupAvatar_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_SetChatRoomGroupAvatar_Response {
    const NAME: &'static str = "CChatRoom_SetChatRoomGroupAvatar_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SetChatRoomGroupAvatar_Response {
        CChatRoom_SetChatRoomGroupAvatar_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SetChatRoomGroupAvatar_Response {
        static instance: CChatRoom_SetChatRoomGroupAvatar_Response = CChatRoom_SetChatRoomGroupAvatar_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Sets a broadcast that the chat room group is watching"]
// @@protoc_insertion_point(message:CChatRoom_SetChatRoomGroupWatchingBroadcast_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_SetChatRoomGroupWatchingBroadcast_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_SetChatRoomGroupWatchingBroadcast_Request.watching_broadcast_accountid)
    pub watching_broadcast_accountid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_SetChatRoomGroupWatchingBroadcast_Request.watching_broadcast_channel_id)
    pub watching_broadcast_channel_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SetChatRoomGroupWatchingBroadcast_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
    fn default() -> &'a CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
        <CChatRoom_SetChatRoomGroupWatchingBroadcast_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
    pub fn new() -> CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint32 watching_broadcast_accountid = 2;

    pub fn watching_broadcast_accountid(&self) -> u32 {
        self.watching_broadcast_accountid.unwrap_or(0)
    }

    pub fn clear_watching_broadcast_accountid(&mut self) {
        self.watching_broadcast_accountid = ::std::option::Option::None;
    }

    pub fn has_watching_broadcast_accountid(&self) -> bool {
        self.watching_broadcast_accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watching_broadcast_accountid(&mut self, v: u32) {
        self.watching_broadcast_accountid = ::std::option::Option::Some(v);
    }

    // optional uint64 watching_broadcast_channel_id = 3;

    pub fn watching_broadcast_channel_id(&self) -> u64 {
        self.watching_broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_watching_broadcast_channel_id(&mut self) {
        self.watching_broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_watching_broadcast_channel_id(&self) -> bool {
        self.watching_broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watching_broadcast_channel_id(&mut self, v: u64) {
        self.watching_broadcast_channel_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
    const NAME: &'static str = "CChatRoom_SetChatRoomGroupWatchingBroadcast_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.watching_broadcast_accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.watching_broadcast_channel_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.watching_broadcast_accountid {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.watching_broadcast_channel_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.watching_broadcast_accountid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.watching_broadcast_channel_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
        CChatRoom_SetChatRoomGroupWatchingBroadcast_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.watching_broadcast_accountid = ::std::option::Option::None;
        self.watching_broadcast_channel_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
        static instance: CChatRoom_SetChatRoomGroupWatchingBroadcast_Request = CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
            chat_group_id: ::std::option::Option::None,
            watching_broadcast_accountid: ::std::option::Option::None,
            watching_broadcast_channel_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoom_SetChatRoomGroupWatchingBroadcast_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SetChatRoomGroupWatchingBroadcast_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
    fn default() -> &'a CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
        <CChatRoom_SetChatRoomGroupWatchingBroadcast_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
    pub fn new() -> CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
    const NAME: &'static str = "CChatRoom_SetChatRoomGroupWatchingBroadcast_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
        CChatRoom_SetChatRoomGroupWatchingBroadcast_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
        static instance: CChatRoom_SetChatRoomGroupWatchingBroadcast_Response = CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Joins the minigame for the chat room group or starts a new one (Winter 2019 sale party game)"]
// @@protoc_insertion_point(message:CChatRoom_JoinMiniGameForChatRoomGroup_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_JoinMiniGameForChatRoomGroup_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_JoinMiniGameForChatRoomGroup_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_JoinMiniGameForChatRoomGroup_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_JoinMiniGameForChatRoomGroup_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_JoinMiniGameForChatRoomGroup_Request {
    fn default() -> &'a CChatRoom_JoinMiniGameForChatRoomGroup_Request {
        <CChatRoom_JoinMiniGameForChatRoomGroup_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_JoinMiniGameForChatRoomGroup_Request {
    pub fn new() -> CChatRoom_JoinMiniGameForChatRoomGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_JoinMiniGameForChatRoomGroup_Request {
    const NAME: &'static str = "CChatRoom_JoinMiniGameForChatRoomGroup_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_JoinMiniGameForChatRoomGroup_Request {
        CChatRoom_JoinMiniGameForChatRoomGroup_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_JoinMiniGameForChatRoomGroup_Request {
        static instance: CChatRoom_JoinMiniGameForChatRoomGroup_Request = CChatRoom_JoinMiniGameForChatRoomGroup_Request {
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoom_JoinMiniGameForChatRoomGroup_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_JoinMiniGameForChatRoomGroup_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_JoinMiniGameForChatRoomGroup_Response.minigame_id)
    pub minigame_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_JoinMiniGameForChatRoomGroup_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_JoinMiniGameForChatRoomGroup_Response {
    fn default() -> &'a CChatRoom_JoinMiniGameForChatRoomGroup_Response {
        <CChatRoom_JoinMiniGameForChatRoomGroup_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_JoinMiniGameForChatRoomGroup_Response {
    pub fn new() -> CChatRoom_JoinMiniGameForChatRoomGroup_Response {
        ::std::default::Default::default()
    }

    // optional uint64 minigame_id = 1;

    pub fn minigame_id(&self) -> u64 {
        self.minigame_id.unwrap_or(0)
    }

    pub fn clear_minigame_id(&mut self) {
        self.minigame_id = ::std::option::Option::None;
    }

    pub fn has_minigame_id(&self) -> bool {
        self.minigame_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minigame_id(&mut self, v: u64) {
        self.minigame_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_JoinMiniGameForChatRoomGroup_Response {
    const NAME: &'static str = "CChatRoom_JoinMiniGameForChatRoomGroup_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.minigame_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.minigame_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.minigame_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_JoinMiniGameForChatRoomGroup_Response {
        CChatRoom_JoinMiniGameForChatRoomGroup_Response::new()
    }

    fn clear(&mut self) {
        self.minigame_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_JoinMiniGameForChatRoomGroup_Response {
        static instance: CChatRoom_JoinMiniGameForChatRoomGroup_Response = CChatRoom_JoinMiniGameForChatRoomGroup_Response {
            minigame_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Ends the minigame in the chat room group"]
// @@protoc_insertion_point(message:CChatRoom_EndMiniGameForChatRoomGroup_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_EndMiniGameForChatRoomGroup_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_EndMiniGameForChatRoomGroup_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_EndMiniGameForChatRoomGroup_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_EndMiniGameForChatRoomGroup_Request.minigame_id)
    pub minigame_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_EndMiniGameForChatRoomGroup_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_EndMiniGameForChatRoomGroup_Request {
    fn default() -> &'a CChatRoom_EndMiniGameForChatRoomGroup_Request {
        <CChatRoom_EndMiniGameForChatRoomGroup_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_EndMiniGameForChatRoomGroup_Request {
    pub fn new() -> CChatRoom_EndMiniGameForChatRoomGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional uint64 minigame_id = 3;

    pub fn minigame_id(&self) -> u64 {
        self.minigame_id.unwrap_or(0)
    }

    pub fn clear_minigame_id(&mut self) {
        self.minigame_id = ::std::option::Option::None;
    }

    pub fn has_minigame_id(&self) -> bool {
        self.minigame_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minigame_id(&mut self, v: u64) {
        self.minigame_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_EndMiniGameForChatRoomGroup_Request {
    const NAME: &'static str = "CChatRoom_EndMiniGameForChatRoomGroup_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.minigame_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.minigame_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.minigame_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_EndMiniGameForChatRoomGroup_Request {
        CChatRoom_EndMiniGameForChatRoomGroup_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.minigame_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_EndMiniGameForChatRoomGroup_Request {
        static instance: CChatRoom_EndMiniGameForChatRoomGroup_Request = CChatRoom_EndMiniGameForChatRoomGroup_Request {
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            minigame_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoom_EndMiniGameForChatRoomGroup_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_EndMiniGameForChatRoomGroup_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_EndMiniGameForChatRoomGroup_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_EndMiniGameForChatRoomGroup_Response {
    fn default() -> &'a CChatRoom_EndMiniGameForChatRoomGroup_Response {
        <CChatRoom_EndMiniGameForChatRoomGroup_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_EndMiniGameForChatRoomGroup_Response {
    pub fn new() -> CChatRoom_EndMiniGameForChatRoomGroup_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_EndMiniGameForChatRoomGroup_Response {
    const NAME: &'static str = "CChatRoom_EndMiniGameForChatRoomGroup_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_EndMiniGameForChatRoomGroup_Response {
        CChatRoom_EndMiniGameForChatRoomGroup_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_EndMiniGameForChatRoomGroup_Response {
        static instance: CChatRoom_EndMiniGameForChatRoomGroup_Response = CChatRoom_EndMiniGameForChatRoomGroup_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Mute user in group"]
// @@protoc_insertion_point(message:CChatRoom_MuteUser_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_MuteUser_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_MuteUser_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_MuteUser_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_MuteUser_Request.expiration)
    pub expiration: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_MuteUser_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_MuteUser_Request {
    fn default() -> &'a CChatRoom_MuteUser_Request {
        <CChatRoom_MuteUser_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_MuteUser_Request {
    pub fn new() -> CChatRoom_MuteUser_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 2;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional int32 expiration = 3;

    pub fn expiration(&self) -> i32 {
        self.expiration.unwrap_or(0)
    }

    pub fn clear_expiration(&mut self) {
        self.expiration = ::std::option::Option::None;
    }

    pub fn has_expiration(&self) -> bool {
        self.expiration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration(&mut self, v: i32) {
        self.expiration = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_MuteUser_Request {
    const NAME: &'static str = "CChatRoom_MuteUser_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                17 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.expiration = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.expiration {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.expiration {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_MuteUser_Request {
        CChatRoom_MuteUser_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.expiration = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_MuteUser_Request {
        static instance: CChatRoom_MuteUser_Request = CChatRoom_MuteUser_Request {
            chat_group_id: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            expiration: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoom_MuteUser_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_MuteUser_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_MuteUser_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_MuteUser_Response {
    fn default() -> &'a CChatRoom_MuteUser_Response {
        <CChatRoom_MuteUser_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_MuteUser_Response {
    pub fn new() -> CChatRoom_MuteUser_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_MuteUser_Response {
    const NAME: &'static str = "CChatRoom_MuteUser_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_MuteUser_Response {
        CChatRoom_MuteUser_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_MuteUser_Response {
        static instance: CChatRoom_MuteUser_Response = CChatRoom_MuteUser_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Kick user from group"]
// @@protoc_insertion_point(message:CChatRoom_KickUser_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_KickUser_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_KickUser_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_KickUser_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_KickUser_Request.expiration)
    pub expiration: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_KickUser_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_KickUser_Request {
    fn default() -> &'a CChatRoom_KickUser_Request {
        <CChatRoom_KickUser_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_KickUser_Request {
    pub fn new() -> CChatRoom_KickUser_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 2;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional int32 expiration = 3;

    pub fn expiration(&self) -> i32 {
        self.expiration.unwrap_or(0)
    }

    pub fn clear_expiration(&mut self) {
        self.expiration = ::std::option::Option::None;
    }

    pub fn has_expiration(&self) -> bool {
        self.expiration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration(&mut self, v: i32) {
        self.expiration = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_KickUser_Request {
    const NAME: &'static str = "CChatRoom_KickUser_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                17 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.expiration = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.expiration {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.expiration {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_KickUser_Request {
        CChatRoom_KickUser_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.expiration = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_KickUser_Request {
        static instance: CChatRoom_KickUser_Request = CChatRoom_KickUser_Request {
            chat_group_id: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            expiration: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoom_KickUser_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_KickUser_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_KickUser_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_KickUser_Response {
    fn default() -> &'a CChatRoom_KickUser_Response {
        <CChatRoom_KickUser_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_KickUser_Response {
    pub fn new() -> CChatRoom_KickUser_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_KickUser_Response {
    const NAME: &'static str = "CChatRoom_KickUser_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_KickUser_Response {
        CChatRoom_KickUser_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_KickUser_Response {
        static instance: CChatRoom_KickUser_Response = CChatRoom_KickUser_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Ban/unban user from group"]
// @@protoc_insertion_point(message:CChatRoom_SetUserBanState_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SetUserBanState_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_SetUserBanState_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_SetUserBanState_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_SetUserBanState_Request.ban_state)
    pub ban_state: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SetUserBanState_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetUserBanState_Request {
    fn default() -> &'a CChatRoom_SetUserBanState_Request {
        <CChatRoom_SetUserBanState_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetUserBanState_Request {
    pub fn new() -> CChatRoom_SetUserBanState_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 2;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional bool ban_state = 3;

    pub fn ban_state(&self) -> bool {
        self.ban_state.unwrap_or(false)
    }

    pub fn clear_ban_state(&mut self) {
        self.ban_state = ::std::option::Option::None;
    }

    pub fn has_ban_state(&self) -> bool {
        self.ban_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ban_state(&mut self, v: bool) {
        self.ban_state = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_SetUserBanState_Request {
    const NAME: &'static str = "CChatRoom_SetUserBanState_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                17 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.ban_state = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.ban_state {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.ban_state {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SetUserBanState_Request {
        CChatRoom_SetUserBanState_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.ban_state = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SetUserBanState_Request {
        static instance: CChatRoom_SetUserBanState_Request = CChatRoom_SetUserBanState_Request {
            chat_group_id: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            ban_state: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoom_SetUserBanState_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SetUserBanState_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SetUserBanState_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetUserBanState_Response {
    fn default() -> &'a CChatRoom_SetUserBanState_Response {
        <CChatRoom_SetUserBanState_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetUserBanState_Response {
    pub fn new() -> CChatRoom_SetUserBanState_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_SetUserBanState_Response {
    const NAME: &'static str = "CChatRoom_SetUserBanState_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SetUserBanState_Response {
        CChatRoom_SetUserBanState_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SetUserBanState_Response {
        static instance: CChatRoom_SetUserBanState_Response = CChatRoom_SetUserBanState_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Revoke a direct invitation of a user"]
// @@protoc_insertion_point(message:CChatRoom_RevokeInvite_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_RevokeInvite_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_RevokeInvite_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_RevokeInvite_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_RevokeInvite_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_RevokeInvite_Request {
    fn default() -> &'a CChatRoom_RevokeInvite_Request {
        <CChatRoom_RevokeInvite_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_RevokeInvite_Request {
    pub fn new() -> CChatRoom_RevokeInvite_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 2;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_RevokeInvite_Request {
    const NAME: &'static str = "CChatRoom_RevokeInvite_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                17 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_RevokeInvite_Request {
        CChatRoom_RevokeInvite_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_RevokeInvite_Request {
        static instance: CChatRoom_RevokeInvite_Request = CChatRoom_RevokeInvite_Request {
            chat_group_id: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoom_RevokeInvite_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_RevokeInvite_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_RevokeInvite_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_RevokeInvite_Response {
    fn default() -> &'a CChatRoom_RevokeInvite_Response {
        <CChatRoom_RevokeInvite_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_RevokeInvite_Response {
    pub fn new() -> CChatRoom_RevokeInvite_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_RevokeInvite_Response {
    const NAME: &'static str = "CChatRoom_RevokeInvite_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_RevokeInvite_Response {
        CChatRoom_RevokeInvite_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_RevokeInvite_Response {
        static instance: CChatRoom_RevokeInvite_Response = CChatRoom_RevokeInvite_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Create role for goup"]
// @@protoc_insertion_point(message:CChatRoom_CreateRole_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_CreateRole_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_CreateRole_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_CreateRole_Request.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_CreateRole_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_CreateRole_Request {
    fn default() -> &'a CChatRoom_CreateRole_Request {
        <CChatRoom_CreateRole_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_CreateRole_Request {
    pub fn new() -> CChatRoom_CreateRole_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CChatRoom_CreateRole_Request {
    const NAME: &'static str = "CChatRoom_CreateRole_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_CreateRole_Request {
        CChatRoom_CreateRole_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_CreateRole_Request {
        static instance: CChatRoom_CreateRole_Request = CChatRoom_CreateRole_Request {
            chat_group_id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoom_CreateRole_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_CreateRole_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_CreateRole_Response.actions)
    pub actions: ::protobuf::MessageField<CChatRoleActions>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_CreateRole_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_CreateRole_Response {
    fn default() -> &'a CChatRoom_CreateRole_Response {
        <CChatRoom_CreateRole_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_CreateRole_Response {
    pub fn new() -> CChatRoom_CreateRole_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_CreateRole_Response {
    const NAME: &'static str = "CChatRoom_CreateRole_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.actions)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.actions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.actions.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_CreateRole_Response {
        CChatRoom_CreateRole_Response::new()
    }

    fn clear(&mut self) {
        self.actions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_CreateRole_Response {
        static instance: CChatRoom_CreateRole_Response = CChatRoom_CreateRole_Response {
            actions: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Get all roles in group"]
// @@protoc_insertion_point(message:CChatRoom_GetRoles_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetRoles_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetRoles_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetRoles_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetRoles_Request {
    fn default() -> &'a CChatRoom_GetRoles_Request {
        <CChatRoom_GetRoles_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetRoles_Request {
    pub fn new() -> CChatRoom_GetRoles_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_GetRoles_Request {
    const NAME: &'static str = "CChatRoom_GetRoles_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetRoles_Request {
        CChatRoom_GetRoles_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetRoles_Request {
        static instance: CChatRoom_GetRoles_Request = CChatRoom_GetRoles_Request {
            chat_group_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoom_GetRoles_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetRoles_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetRoles_Response.roles)
    pub roles: ::std::vec::Vec<CChatRole>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetRoles_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetRoles_Response {
    fn default() -> &'a CChatRoom_GetRoles_Response {
        <CChatRoom_GetRoles_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetRoles_Response {
    pub fn new() -> CChatRoom_GetRoles_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_GetRoles_Response {
    const NAME: &'static str = "CChatRoom_GetRoles_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.roles.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.roles {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.roles {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetRoles_Response {
        CChatRoom_GetRoles_Response::new()
    }

    fn clear(&mut self) {
        self.roles.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetRoles_Response {
        static instance: CChatRoom_GetRoles_Response = CChatRoom_GetRoles_Response {
            roles: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Rename role for goup"]
// @@protoc_insertion_point(message:CChatRoom_RenameRole_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_RenameRole_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_RenameRole_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_RenameRole_Request.role_id)
    pub role_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_RenameRole_Request.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_RenameRole_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_RenameRole_Request {
    fn default() -> &'a CChatRoom_RenameRole_Request {
        <CChatRoom_RenameRole_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_RenameRole_Request {
    pub fn new() -> CChatRoom_RenameRole_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 role_id = 2;

    pub fn role_id(&self) -> u64 {
        self.role_id.unwrap_or(0)
    }

    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u64) {
        self.role_id = ::std::option::Option::Some(v);
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CChatRoom_RenameRole_Request {
    const NAME: &'static str = "CChatRoom_RenameRole_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.role_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.role_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.role_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_RenameRole_Request {
        CChatRoom_RenameRole_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.role_id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_RenameRole_Request {
        static instance: CChatRoom_RenameRole_Request = CChatRoom_RenameRole_Request {
            chat_group_id: ::std::option::Option::None,
            role_id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoom_RenameRole_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_RenameRole_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_RenameRole_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_RenameRole_Response {
    fn default() -> &'a CChatRoom_RenameRole_Response {
        <CChatRoom_RenameRole_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_RenameRole_Response {
    pub fn new() -> CChatRoom_RenameRole_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_RenameRole_Response {
    const NAME: &'static str = "CChatRoom_RenameRole_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_RenameRole_Response {
        CChatRoom_RenameRole_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_RenameRole_Response {
        static instance: CChatRoom_RenameRole_Response = CChatRoom_RenameRole_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Reorder role with a goup"]
// @@protoc_insertion_point(message:CChatRoom_ReorderRole_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_ReorderRole_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_ReorderRole_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_ReorderRole_Request.role_id)
    pub role_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_ReorderRole_Request.ordinal)
    pub ordinal: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_ReorderRole_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_ReorderRole_Request {
    fn default() -> &'a CChatRoom_ReorderRole_Request {
        <CChatRoom_ReorderRole_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_ReorderRole_Request {
    pub fn new() -> CChatRoom_ReorderRole_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 role_id = 2;

    pub fn role_id(&self) -> u64 {
        self.role_id.unwrap_or(0)
    }

    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u64) {
        self.role_id = ::std::option::Option::Some(v);
    }

    // optional uint32 ordinal = 3;

    pub fn ordinal(&self) -> u32 {
        self.ordinal.unwrap_or(0)
    }

    pub fn clear_ordinal(&mut self) {
        self.ordinal = ::std::option::Option::None;
    }

    pub fn has_ordinal(&self) -> bool {
        self.ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordinal(&mut self, v: u32) {
        self.ordinal = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_ReorderRole_Request {
    const NAME: &'static str = "CChatRoom_ReorderRole_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.role_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.ordinal = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.role_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.ordinal {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.role_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.ordinal {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_ReorderRole_Request {
        CChatRoom_ReorderRole_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.role_id = ::std::option::Option::None;
        self.ordinal = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_ReorderRole_Request {
        static instance: CChatRoom_ReorderRole_Request = CChatRoom_ReorderRole_Request {
            chat_group_id: ::std::option::Option::None,
            role_id: ::std::option::Option::None,
            ordinal: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoom_ReorderRole_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_ReorderRole_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_ReorderRole_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_ReorderRole_Response {
    fn default() -> &'a CChatRoom_ReorderRole_Response {
        <CChatRoom_ReorderRole_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_ReorderRole_Response {
    pub fn new() -> CChatRoom_ReorderRole_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_ReorderRole_Response {
    const NAME: &'static str = "CChatRoom_ReorderRole_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_ReorderRole_Response {
        CChatRoom_ReorderRole_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_ReorderRole_Response {
        static instance: CChatRoom_ReorderRole_Response = CChatRoom_ReorderRole_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Delete role from group"]
// @@protoc_insertion_point(message:CChatRoom_DeleteRole_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_DeleteRole_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_DeleteRole_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_DeleteRole_Request.role_id)
    pub role_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_DeleteRole_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteRole_Request {
    fn default() -> &'a CChatRoom_DeleteRole_Request {
        <CChatRoom_DeleteRole_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_DeleteRole_Request {
    pub fn new() -> CChatRoom_DeleteRole_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 role_id = 2;

    pub fn role_id(&self) -> u64 {
        self.role_id.unwrap_or(0)
    }

    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u64) {
        self.role_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_DeleteRole_Request {
    const NAME: &'static str = "CChatRoom_DeleteRole_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.role_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.role_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.role_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_DeleteRole_Request {
        CChatRoom_DeleteRole_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.role_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_DeleteRole_Request {
        static instance: CChatRoom_DeleteRole_Request = CChatRoom_DeleteRole_Request {
            chat_group_id: ::std::option::Option::None,
            role_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoom_DeleteRole_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_DeleteRole_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_DeleteRole_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteRole_Response {
    fn default() -> &'a CChatRoom_DeleteRole_Response {
        <CChatRoom_DeleteRole_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_DeleteRole_Response {
    pub fn new() -> CChatRoom_DeleteRole_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_DeleteRole_Response {
    const NAME: &'static str = "CChatRoom_DeleteRole_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_DeleteRole_Response {
        CChatRoom_DeleteRole_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_DeleteRole_Response {
        static instance: CChatRoom_DeleteRole_Response = CChatRoom_DeleteRole_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Get all defined roles and actions in group"]
// @@protoc_insertion_point(message:CChatRoom_GetRoleActions_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetRoleActions_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetRoleActions_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetRoleActions_Request.role_id)
    pub role_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetRoleActions_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetRoleActions_Request {
    fn default() -> &'a CChatRoom_GetRoleActions_Request {
        <CChatRoom_GetRoleActions_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetRoleActions_Request {
    pub fn new() -> CChatRoom_GetRoleActions_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 role_id = 2;

    pub fn role_id(&self) -> u64 {
        self.role_id.unwrap_or(0)
    }

    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u64) {
        self.role_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_GetRoleActions_Request {
    const NAME: &'static str = "CChatRoom_GetRoleActions_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.role_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.role_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.role_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetRoleActions_Request {
        CChatRoom_GetRoleActions_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.role_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetRoleActions_Request {
        static instance: CChatRoom_GetRoleActions_Request = CChatRoom_GetRoleActions_Request {
            chat_group_id: ::std::option::Option::None,
            role_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoom_GetRoleActions_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetRoleActions_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetRoleActions_Response.actions)
    pub actions: ::std::vec::Vec<CChatRoleActions>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetRoleActions_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetRoleActions_Response {
    fn default() -> &'a CChatRoom_GetRoleActions_Response {
        <CChatRoom_GetRoleActions_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetRoleActions_Response {
    pub fn new() -> CChatRoom_GetRoleActions_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_GetRoleActions_Response {
    const NAME: &'static str = "CChatRoom_GetRoleActions_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.actions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.actions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.actions {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetRoleActions_Response {
        CChatRoom_GetRoleActions_Response::new()
    }

    fn clear(&mut self) {
        self.actions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetRoleActions_Response {
        static instance: CChatRoom_GetRoleActions_Response = CChatRoom_GetRoleActions_Response {
            actions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Replace role actions in group"]
// @@protoc_insertion_point(message:CChatRoom_ReplaceRoleActions_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_ReplaceRoleActions_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_ReplaceRoleActions_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_ReplaceRoleActions_Request.role_id)
    pub role_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_ReplaceRoleActions_Request.actions)
    pub actions: ::protobuf::MessageField<CChatRoleActions>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_ReplaceRoleActions_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_ReplaceRoleActions_Request {
    fn default() -> &'a CChatRoom_ReplaceRoleActions_Request {
        <CChatRoom_ReplaceRoleActions_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_ReplaceRoleActions_Request {
    pub fn new() -> CChatRoom_ReplaceRoleActions_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 role_id = 2;

    pub fn role_id(&self) -> u64 {
        self.role_id.unwrap_or(0)
    }

    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u64) {
        self.role_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_ReplaceRoleActions_Request {
    const NAME: &'static str = "CChatRoom_ReplaceRoleActions_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.role_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.actions)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.role_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.actions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.role_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.actions.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_ReplaceRoleActions_Request {
        CChatRoom_ReplaceRoleActions_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.role_id = ::std::option::Option::None;
        self.actions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_ReplaceRoleActions_Request {
        static instance: CChatRoom_ReplaceRoleActions_Request = CChatRoom_ReplaceRoleActions_Request {
            chat_group_id: ::std::option::Option::None,
            role_id: ::std::option::Option::None,
            actions: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoom_ReplaceRoleActions_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_ReplaceRoleActions_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_ReplaceRoleActions_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_ReplaceRoleActions_Response {
    fn default() -> &'a CChatRoom_ReplaceRoleActions_Response {
        <CChatRoom_ReplaceRoleActions_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_ReplaceRoleActions_Response {
    pub fn new() -> CChatRoom_ReplaceRoleActions_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_ReplaceRoleActions_Response {
    const NAME: &'static str = "CChatRoom_ReplaceRoleActions_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_ReplaceRoleActions_Response {
        CChatRoom_ReplaceRoleActions_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_ReplaceRoleActions_Response {
        static instance: CChatRoom_ReplaceRoleActions_Response = CChatRoom_ReplaceRoleActions_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Add role to user in group"]
// @@protoc_insertion_point(message:CChatRoom_AddRoleToUser_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_AddRoleToUser_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_AddRoleToUser_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_AddRoleToUser_Request.role_id)
    pub role_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_AddRoleToUser_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_AddRoleToUser_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_AddRoleToUser_Request {
    fn default() -> &'a CChatRoom_AddRoleToUser_Request {
        <CChatRoom_AddRoleToUser_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_AddRoleToUser_Request {
    pub fn new() -> CChatRoom_AddRoleToUser_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 role_id = 3;

    pub fn role_id(&self) -> u64 {
        self.role_id.unwrap_or(0)
    }

    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u64) {
        self.role_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 4;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_AddRoleToUser_Request {
    const NAME: &'static str = "CChatRoom_AddRoleToUser_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.role_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                33 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.role_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.role_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_AddRoleToUser_Request {
        CChatRoom_AddRoleToUser_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.role_id = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_AddRoleToUser_Request {
        static instance: CChatRoom_AddRoleToUser_Request = CChatRoom_AddRoleToUser_Request {
            chat_group_id: ::std::option::Option::None,
            role_id: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoom_AddRoleToUser_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_AddRoleToUser_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_AddRoleToUser_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_AddRoleToUser_Response {
    fn default() -> &'a CChatRoom_AddRoleToUser_Response {
        <CChatRoom_AddRoleToUser_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_AddRoleToUser_Response {
    pub fn new() -> CChatRoom_AddRoleToUser_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_AddRoleToUser_Response {
    const NAME: &'static str = "CChatRoom_AddRoleToUser_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_AddRoleToUser_Response {
        CChatRoom_AddRoleToUser_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_AddRoleToUser_Response {
        static instance: CChatRoom_AddRoleToUser_Response = CChatRoom_AddRoleToUser_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Get all roles assigned to user in group"]
// @@protoc_insertion_point(message:CChatRoom_GetRolesForUser_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetRolesForUser_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetRolesForUser_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetRolesForUser_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetRolesForUser_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetRolesForUser_Request {
    fn default() -> &'a CChatRoom_GetRolesForUser_Request {
        <CChatRoom_GetRolesForUser_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetRolesForUser_Request {
    pub fn new() -> CChatRoom_GetRolesForUser_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 3;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_GetRolesForUser_Request {
    const NAME: &'static str = "CChatRoom_GetRolesForUser_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                25 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetRolesForUser_Request {
        CChatRoom_GetRolesForUser_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetRolesForUser_Request {
        static instance: CChatRoom_GetRolesForUser_Request = CChatRoom_GetRolesForUser_Request {
            chat_group_id: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoom_GetRolesForUser_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetRolesForUser_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetRolesForUser_Response.role_ids)
    pub role_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetRolesForUser_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetRolesForUser_Response {
    fn default() -> &'a CChatRoom_GetRolesForUser_Response {
        <CChatRoom_GetRolesForUser_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetRolesForUser_Response {
    pub fn new() -> CChatRoom_GetRolesForUser_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_GetRolesForUser_Response {
    const NAME: &'static str = "CChatRoom_GetRolesForUser_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.role_ids)?;
                },
                8 => {
                    self.role_ids.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.role_ids {
            my_size += ::protobuf::rt::uint64_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.role_ids {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetRolesForUser_Response {
        CChatRoom_GetRolesForUser_Response::new()
    }

    fn clear(&mut self) {
        self.role_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetRolesForUser_Response {
        static instance: CChatRoom_GetRolesForUser_Response = CChatRoom_GetRolesForUser_Response {
            role_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Delete role from user in group"]
// @@protoc_insertion_point(message:CChatRoom_DeleteRoleFromUser_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_DeleteRoleFromUser_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_DeleteRoleFromUser_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_DeleteRoleFromUser_Request.role_id)
    pub role_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_DeleteRoleFromUser_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_DeleteRoleFromUser_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteRoleFromUser_Request {
    fn default() -> &'a CChatRoom_DeleteRoleFromUser_Request {
        <CChatRoom_DeleteRoleFromUser_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_DeleteRoleFromUser_Request {
    pub fn new() -> CChatRoom_DeleteRoleFromUser_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 role_id = 3;

    pub fn role_id(&self) -> u64 {
        self.role_id.unwrap_or(0)
    }

    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u64) {
        self.role_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 4;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_DeleteRoleFromUser_Request {
    const NAME: &'static str = "CChatRoom_DeleteRoleFromUser_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.role_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                33 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.role_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.role_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_DeleteRoleFromUser_Request {
        CChatRoom_DeleteRoleFromUser_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.role_id = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_DeleteRoleFromUser_Request {
        static instance: CChatRoom_DeleteRoleFromUser_Request = CChatRoom_DeleteRoleFromUser_Request {
            chat_group_id: ::std::option::Option::None,
            role_id: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoom_DeleteRoleFromUser_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_DeleteRoleFromUser_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_DeleteRoleFromUser_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteRoleFromUser_Response {
    fn default() -> &'a CChatRoom_DeleteRoleFromUser_Response {
        <CChatRoom_DeleteRoleFromUser_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_DeleteRoleFromUser_Response {
    pub fn new() -> CChatRoom_DeleteRoleFromUser_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_DeleteRoleFromUser_Response {
    const NAME: &'static str = "CChatRoom_DeleteRoleFromUser_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_DeleteRoleFromUser_Response {
        CChatRoom_DeleteRoleFromUser_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_DeleteRoleFromUser_Response {
        static instance: CChatRoom_DeleteRoleFromUser_Response = CChatRoom_DeleteRoleFromUser_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Join a multi-user chat room"]
// @@protoc_insertion_point(message:CChatRoom_JoinChatRoomGroup_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_JoinChatRoomGroup_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_JoinChatRoomGroup_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_JoinChatRoomGroup_Request.invite_code)
    pub invite_code: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoom_JoinChatRoomGroup_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_JoinChatRoomGroup_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_JoinChatRoomGroup_Request {
    fn default() -> &'a CChatRoom_JoinChatRoomGroup_Request {
        <CChatRoom_JoinChatRoomGroup_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_JoinChatRoomGroup_Request {
    pub fn new() -> CChatRoom_JoinChatRoomGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional string invite_code = 2;

    pub fn invite_code(&self) -> &str {
        match self.invite_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_invite_code(&mut self) {
        self.invite_code = ::std::option::Option::None;
    }

    pub fn has_invite_code(&self) -> bool {
        self.invite_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invite_code(&mut self, v: ::std::string::String) {
        self.invite_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_invite_code(&mut self) -> &mut ::std::string::String {
        if self.invite_code.is_none() {
            self.invite_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.invite_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_invite_code(&mut self) -> ::std::string::String {
        self.invite_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 chat_id = 3;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_JoinChatRoomGroup_Request {
    const NAME: &'static str = "CChatRoom_JoinChatRoomGroup_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.invite_code = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.invite_code.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.invite_code.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_JoinChatRoomGroup_Request {
        CChatRoom_JoinChatRoomGroup_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.invite_code = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_JoinChatRoomGroup_Request {
        static instance: CChatRoom_JoinChatRoomGroup_Request = CChatRoom_JoinChatRoomGroup_Request {
            chat_group_id: ::std::option::Option::None,
            invite_code: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoom_JoinChatRoomGroup_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_JoinChatRoomGroup_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_JoinChatRoomGroup_Response.state)
    pub state: ::protobuf::MessageField<CChatRoomGroupState>,
    // @@protoc_insertion_point(field:CChatRoom_JoinChatRoomGroup_Response.user_chat_state)
    pub user_chat_state: ::protobuf::MessageField<CUserChatRoomGroupState>,
    // @@protoc_insertion_point(field:CChatRoom_JoinChatRoomGroup_Response.join_chat_id)
    pub join_chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_JoinChatRoomGroup_Response.time_expire)
    pub time_expire: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_JoinChatRoomGroup_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_JoinChatRoomGroup_Response {
    fn default() -> &'a CChatRoom_JoinChatRoomGroup_Response {
        <CChatRoom_JoinChatRoomGroup_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_JoinChatRoomGroup_Response {
    pub fn new() -> CChatRoom_JoinChatRoomGroup_Response {
        ::std::default::Default::default()
    }

    // optional uint64 join_chat_id = 4;

    pub fn join_chat_id(&self) -> u64 {
        self.join_chat_id.unwrap_or(0)
    }

    pub fn clear_join_chat_id(&mut self) {
        self.join_chat_id = ::std::option::Option::None;
    }

    pub fn has_join_chat_id(&self) -> bool {
        self.join_chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_join_chat_id(&mut self, v: u64) {
        self.join_chat_id = ::std::option::Option::Some(v);
    }

    // optional uint32 time_expire = 5;

    pub fn time_expire(&self) -> u32 {
        self.time_expire.unwrap_or(0)
    }

    pub fn clear_time_expire(&mut self) {
        self.time_expire = ::std::option::Option::None;
    }

    pub fn has_time_expire(&self) -> bool {
        self.time_expire.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_expire(&mut self, v: u32) {
        self.time_expire = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_JoinChatRoomGroup_Response {
    const NAME: &'static str = "CChatRoom_JoinChatRoomGroup_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.state)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_chat_state)?;
                },
                32 => {
                    self.join_chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.time_expire = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.user_chat_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.join_chat_id {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.time_expire {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.user_chat_state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.join_chat_id {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.time_expire {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_JoinChatRoomGroup_Response {
        CChatRoom_JoinChatRoomGroup_Response::new()
    }

    fn clear(&mut self) {
        self.state.clear();
        self.user_chat_state.clear();
        self.join_chat_id = ::std::option::Option::None;
        self.time_expire = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_JoinChatRoomGroup_Response {
        static instance: CChatRoom_JoinChatRoomGroup_Response = CChatRoom_JoinChatRoomGroup_Response {
            state: ::protobuf::MessageField::none(),
            user_chat_state: ::protobuf::MessageField::none(),
            join_chat_id: ::std::option::Option::None,
            time_expire: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Invite a friend to a multi-user chat room"]
// @@protoc_insertion_point(message:CChatRoom_InviteFriendToChatRoomGroup_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_InviteFriendToChatRoomGroup_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_InviteFriendToChatRoomGroup_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_InviteFriendToChatRoomGroup_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_InviteFriendToChatRoomGroup_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_InviteFriendToChatRoomGroup_Request.skip_friendsui_check)
    pub skip_friendsui_check: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_InviteFriendToChatRoomGroup_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_InviteFriendToChatRoomGroup_Request {
    fn default() -> &'a CChatRoom_InviteFriendToChatRoomGroup_Request {
        <CChatRoom_InviteFriendToChatRoomGroup_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_InviteFriendToChatRoomGroup_Request {
    pub fn new() -> CChatRoom_InviteFriendToChatRoomGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 2;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 3;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional bool skip_friendsui_check = 4;

    pub fn skip_friendsui_check(&self) -> bool {
        self.skip_friendsui_check.unwrap_or(false)
    }

    pub fn clear_skip_friendsui_check(&mut self) {
        self.skip_friendsui_check = ::std::option::Option::None;
    }

    pub fn has_skip_friendsui_check(&self) -> bool {
        self.skip_friendsui_check.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skip_friendsui_check(&mut self, v: bool) {
        self.skip_friendsui_check = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_InviteFriendToChatRoomGroup_Request {
    const NAME: &'static str = "CChatRoom_InviteFriendToChatRoomGroup_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                17 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.skip_friendsui_check = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.skip_friendsui_check {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.skip_friendsui_check {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_InviteFriendToChatRoomGroup_Request {
        CChatRoom_InviteFriendToChatRoomGroup_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.skip_friendsui_check = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_InviteFriendToChatRoomGroup_Request {
        static instance: CChatRoom_InviteFriendToChatRoomGroup_Request = CChatRoom_InviteFriendToChatRoomGroup_Request {
            chat_group_id: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            skip_friendsui_check: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoom_InviteFriendToChatRoomGroup_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_InviteFriendToChatRoomGroup_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_InviteFriendToChatRoomGroup_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_InviteFriendToChatRoomGroup_Response {
    fn default() -> &'a CChatRoom_InviteFriendToChatRoomGroup_Response {
        <CChatRoom_InviteFriendToChatRoomGroup_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_InviteFriendToChatRoomGroup_Response {
    pub fn new() -> CChatRoom_InviteFriendToChatRoomGroup_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_InviteFriendToChatRoomGroup_Response {
    const NAME: &'static str = "CChatRoom_InviteFriendToChatRoomGroup_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_InviteFriendToChatRoomGroup_Response {
        CChatRoom_InviteFriendToChatRoomGroup_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_InviteFriendToChatRoomGroup_Response {
        static instance: CChatRoom_InviteFriendToChatRoomGroup_Response = CChatRoom_InviteFriendToChatRoomGroup_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Leaves a chat room group and all related chats"]
// @@protoc_insertion_point(message:CChatRoom_LeaveChatRoomGroup_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_LeaveChatRoomGroup_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_LeaveChatRoomGroup_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_LeaveChatRoomGroup_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_LeaveChatRoomGroup_Request {
    fn default() -> &'a CChatRoom_LeaveChatRoomGroup_Request {
        <CChatRoom_LeaveChatRoomGroup_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_LeaveChatRoomGroup_Request {
    pub fn new() -> CChatRoom_LeaveChatRoomGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_LeaveChatRoomGroup_Request {
    const NAME: &'static str = "CChatRoom_LeaveChatRoomGroup_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_LeaveChatRoomGroup_Request {
        CChatRoom_LeaveChatRoomGroup_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_LeaveChatRoomGroup_Request {
        static instance: CChatRoom_LeaveChatRoomGroup_Request = CChatRoom_LeaveChatRoomGroup_Request {
            chat_group_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoom_LeaveChatRoomGroup_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_LeaveChatRoomGroup_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_LeaveChatRoomGroup_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_LeaveChatRoomGroup_Response {
    fn default() -> &'a CChatRoom_LeaveChatRoomGroup_Response {
        <CChatRoom_LeaveChatRoomGroup_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_LeaveChatRoomGroup_Response {
    pub fn new() -> CChatRoom_LeaveChatRoomGroup_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_LeaveChatRoomGroup_Response {
    const NAME: &'static str = "CChatRoom_LeaveChatRoomGroup_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_LeaveChatRoomGroup_Response {
        CChatRoom_LeaveChatRoomGroup_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_LeaveChatRoomGroup_Response {
        static instance: CChatRoom_LeaveChatRoomGroup_Response = CChatRoom_LeaveChatRoomGroup_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Creates a chat room inside a chat room group"]
// @@protoc_insertion_point(message:CChatRoom_CreateChatRoom_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_CreateChatRoom_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_CreateChatRoom_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_CreateChatRoom_Request.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoom_CreateChatRoom_Request.allow_voice)
    pub allow_voice: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_CreateChatRoom_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_CreateChatRoom_Request {
    fn default() -> &'a CChatRoom_CreateChatRoom_Request {
        <CChatRoom_CreateChatRoom_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_CreateChatRoom_Request {
    pub fn new() -> CChatRoom_CreateChatRoom_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool allow_voice = 3;

    pub fn allow_voice(&self) -> bool {
        self.allow_voice.unwrap_or(false)
    }

    pub fn clear_allow_voice(&mut self) {
        self.allow_voice = ::std::option::Option::None;
    }

    pub fn has_allow_voice(&self) -> bool {
        self.allow_voice.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_voice(&mut self, v: bool) {
        self.allow_voice = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_CreateChatRoom_Request {
    const NAME: &'static str = "CChatRoom_CreateChatRoom_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.allow_voice = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.allow_voice {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.allow_voice {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_CreateChatRoom_Request {
        CChatRoom_CreateChatRoom_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.allow_voice = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_CreateChatRoom_Request {
        static instance: CChatRoom_CreateChatRoom_Request = CChatRoom_CreateChatRoom_Request {
            chat_group_id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            allow_voice: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoom_CreateChatRoom_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_CreateChatRoom_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_CreateChatRoom_Response.chat_room)
    pub chat_room: ::protobuf::MessageField<CChatRoomState>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_CreateChatRoom_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_CreateChatRoom_Response {
    fn default() -> &'a CChatRoom_CreateChatRoom_Response {
        <CChatRoom_CreateChatRoom_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_CreateChatRoom_Response {
    pub fn new() -> CChatRoom_CreateChatRoom_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_CreateChatRoom_Response {
    const NAME: &'static str = "CChatRoom_CreateChatRoom_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.chat_room)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_room.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_room.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_CreateChatRoom_Response {
        CChatRoom_CreateChatRoom_Response::new()
    }

    fn clear(&mut self) {
        self.chat_room.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_CreateChatRoom_Response {
        static instance: CChatRoom_CreateChatRoom_Response = CChatRoom_CreateChatRoom_Response {
            chat_room: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Deletes a chat room inside a chat room group"]
// @@protoc_insertion_point(message:CChatRoom_DeleteChatRoom_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_DeleteChatRoom_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_DeleteChatRoom_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_DeleteChatRoom_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_DeleteChatRoom_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteChatRoom_Request {
    fn default() -> &'a CChatRoom_DeleteChatRoom_Request {
        <CChatRoom_DeleteChatRoom_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_DeleteChatRoom_Request {
    pub fn new() -> CChatRoom_DeleteChatRoom_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_DeleteChatRoom_Request {
    const NAME: &'static str = "CChatRoom_DeleteChatRoom_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_DeleteChatRoom_Request {
        CChatRoom_DeleteChatRoom_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_DeleteChatRoom_Request {
        static instance: CChatRoom_DeleteChatRoom_Request = CChatRoom_DeleteChatRoom_Request {
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoom_DeleteChatRoom_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_DeleteChatRoom_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_DeleteChatRoom_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteChatRoom_Response {
    fn default() -> &'a CChatRoom_DeleteChatRoom_Response {
        <CChatRoom_DeleteChatRoom_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_DeleteChatRoom_Response {
    pub fn new() -> CChatRoom_DeleteChatRoom_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_DeleteChatRoom_Response {
    const NAME: &'static str = "CChatRoom_DeleteChatRoom_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_DeleteChatRoom_Response {
        CChatRoom_DeleteChatRoom_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_DeleteChatRoom_Response {
        static instance: CChatRoom_DeleteChatRoom_Response = CChatRoom_DeleteChatRoom_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Renames a chat room inside a chat room group"]
// @@protoc_insertion_point(message:CChatRoom_RenameChatRoom_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_RenameChatRoom_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_RenameChatRoom_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_RenameChatRoom_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_RenameChatRoom_Request.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_RenameChatRoom_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_RenameChatRoom_Request {
    fn default() -> &'a CChatRoom_RenameChatRoom_Request {
        <CChatRoom_RenameChatRoom_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_RenameChatRoom_Request {
    pub fn new() -> CChatRoom_RenameChatRoom_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CChatRoom_RenameChatRoom_Request {
    const NAME: &'static str = "CChatRoom_RenameChatRoom_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_RenameChatRoom_Request {
        CChatRoom_RenameChatRoom_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_RenameChatRoom_Request {
        static instance: CChatRoom_RenameChatRoom_Request = CChatRoom_RenameChatRoom_Request {
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoom_RenameChatRoom_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_RenameChatRoom_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_RenameChatRoom_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_RenameChatRoom_Response {
    fn default() -> &'a CChatRoom_RenameChatRoom_Response {
        <CChatRoom_RenameChatRoom_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_RenameChatRoom_Response {
    pub fn new() -> CChatRoom_RenameChatRoom_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_RenameChatRoom_Response {
    const NAME: &'static str = "CChatRoom_RenameChatRoom_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_RenameChatRoom_Response {
        CChatRoom_RenameChatRoom_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_RenameChatRoom_Response {
        static instance: CChatRoom_RenameChatRoom_Response = CChatRoom_RenameChatRoom_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Reorders a chat room inside a chat room group"]
// @@protoc_insertion_point(message:CChatRoom_ReorderChatRoom_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_ReorderChatRoom_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_ReorderChatRoom_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_ReorderChatRoom_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_ReorderChatRoom_Request.move_after_chat_id)
    pub move_after_chat_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_ReorderChatRoom_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_ReorderChatRoom_Request {
    fn default() -> &'a CChatRoom_ReorderChatRoom_Request {
        <CChatRoom_ReorderChatRoom_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_ReorderChatRoom_Request {
    pub fn new() -> CChatRoom_ReorderChatRoom_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional uint64 move_after_chat_id = 3;

    pub fn move_after_chat_id(&self) -> u64 {
        self.move_after_chat_id.unwrap_or(0)
    }

    pub fn clear_move_after_chat_id(&mut self) {
        self.move_after_chat_id = ::std::option::Option::None;
    }

    pub fn has_move_after_chat_id(&self) -> bool {
        self.move_after_chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_move_after_chat_id(&mut self, v: u64) {
        self.move_after_chat_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_ReorderChatRoom_Request {
    const NAME: &'static str = "CChatRoom_ReorderChatRoom_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.move_after_chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.move_after_chat_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.move_after_chat_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_ReorderChatRoom_Request {
        CChatRoom_ReorderChatRoom_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.move_after_chat_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_ReorderChatRoom_Request {
        static instance: CChatRoom_ReorderChatRoom_Request = CChatRoom_ReorderChatRoom_Request {
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            move_after_chat_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoom_ReorderChatRoom_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_ReorderChatRoom_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_ReorderChatRoom_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_ReorderChatRoom_Response {
    fn default() -> &'a CChatRoom_ReorderChatRoom_Response {
        <CChatRoom_ReorderChatRoom_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_ReorderChatRoom_Response {
    pub fn new() -> CChatRoom_ReorderChatRoom_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_ReorderChatRoom_Response {
    const NAME: &'static str = "CChatRoom_ReorderChatRoom_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_ReorderChatRoom_Response {
        CChatRoom_ReorderChatRoom_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_ReorderChatRoom_Response {
        static instance: CChatRoom_ReorderChatRoom_Response = CChatRoom_ReorderChatRoom_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Send a chat message to a multi-user chat room"]
// @@protoc_insertion_point(message:CChatRoom_SendChatMessage_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SendChatMessage_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_SendChatMessage_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_SendChatMessage_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_SendChatMessage_Request.message)
    pub message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoom_SendChatMessage_Request.echo_to_sender)
    pub echo_to_sender: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SendChatMessage_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SendChatMessage_Request {
    fn default() -> &'a CChatRoom_SendChatMessage_Request {
        <CChatRoom_SendChatMessage_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SendChatMessage_Request {
    pub fn new() -> CChatRoom_SendChatMessage_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional string message = 3;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool echo_to_sender = 4;

    pub fn echo_to_sender(&self) -> bool {
        self.echo_to_sender.unwrap_or(false)
    }

    pub fn clear_echo_to_sender(&mut self) {
        self.echo_to_sender = ::std::option::Option::None;
    }

    pub fn has_echo_to_sender(&self) -> bool {
        self.echo_to_sender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_echo_to_sender(&mut self, v: bool) {
        self.echo_to_sender = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_SendChatMessage_Request {
    const NAME: &'static str = "CChatRoom_SendChatMessage_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.echo_to_sender = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.echo_to_sender {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.echo_to_sender {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SendChatMessage_Request {
        CChatRoom_SendChatMessage_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.echo_to_sender = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SendChatMessage_Request {
        static instance: CChatRoom_SendChatMessage_Request = CChatRoom_SendChatMessage_Request {
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            message: ::std::option::Option::None,
            echo_to_sender: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoom_SendChatMessage_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SendChatMessage_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_SendChatMessage_Response.modified_message)
    pub modified_message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoom_SendChatMessage_Response.server_timestamp)
    pub server_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_SendChatMessage_Response.ordinal)
    pub ordinal: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_SendChatMessage_Response.message_without_bb_code)
    pub message_without_bb_code: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SendChatMessage_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SendChatMessage_Response {
    fn default() -> &'a CChatRoom_SendChatMessage_Response {
        <CChatRoom_SendChatMessage_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SendChatMessage_Response {
    pub fn new() -> CChatRoom_SendChatMessage_Response {
        ::std::default::Default::default()
    }

    // optional string modified_message = 1;

    pub fn modified_message(&self) -> &str {
        match self.modified_message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_modified_message(&mut self) {
        self.modified_message = ::std::option::Option::None;
    }

    pub fn has_modified_message(&self) -> bool {
        self.modified_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modified_message(&mut self, v: ::std::string::String) {
        self.modified_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_modified_message(&mut self) -> &mut ::std::string::String {
        if self.modified_message.is_none() {
            self.modified_message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.modified_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_modified_message(&mut self) -> ::std::string::String {
        self.modified_message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 server_timestamp = 2;

    pub fn server_timestamp(&self) -> u32 {
        self.server_timestamp.unwrap_or(0)
    }

    pub fn clear_server_timestamp(&mut self) {
        self.server_timestamp = ::std::option::Option::None;
    }

    pub fn has_server_timestamp(&self) -> bool {
        self.server_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_timestamp(&mut self, v: u32) {
        self.server_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 ordinal = 3;

    pub fn ordinal(&self) -> u32 {
        self.ordinal.unwrap_or(0)
    }

    pub fn clear_ordinal(&mut self) {
        self.ordinal = ::std::option::Option::None;
    }

    pub fn has_ordinal(&self) -> bool {
        self.ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordinal(&mut self, v: u32) {
        self.ordinal = ::std::option::Option::Some(v);
    }

    // optional string message_without_bb_code = 4;

    pub fn message_without_bb_code(&self) -> &str {
        match self.message_without_bb_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message_without_bb_code(&mut self) {
        self.message_without_bb_code = ::std::option::Option::None;
    }

    pub fn has_message_without_bb_code(&self) -> bool {
        self.message_without_bb_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_without_bb_code(&mut self, v: ::std::string::String) {
        self.message_without_bb_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_without_bb_code(&mut self) -> &mut ::std::string::String {
        if self.message_without_bb_code.is_none() {
            self.message_without_bb_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message_without_bb_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_without_bb_code(&mut self) -> ::std::string::String {
        self.message_without_bb_code.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CChatRoom_SendChatMessage_Response {
    const NAME: &'static str = "CChatRoom_SendChatMessage_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.modified_message = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.server_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.ordinal = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.message_without_bb_code = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.modified_message.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.server_timestamp {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.ordinal {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.message_without_bb_code.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.modified_message.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.server_timestamp {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.ordinal {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.message_without_bb_code.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SendChatMessage_Response {
        CChatRoom_SendChatMessage_Response::new()
    }

    fn clear(&mut self) {
        self.modified_message = ::std::option::Option::None;
        self.server_timestamp = ::std::option::Option::None;
        self.ordinal = ::std::option::Option::None;
        self.message_without_bb_code = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SendChatMessage_Response {
        static instance: CChatRoom_SendChatMessage_Response = CChatRoom_SendChatMessage_Response {
            modified_message: ::std::option::Option::None,
            server_timestamp: ::std::option::Option::None,
            ordinal: ::std::option::Option::None,
            message_without_bb_code: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Join the voice chat in a multi-room chat (should already be in the chat room)"]
// @@protoc_insertion_point(message:CChatRoom_JoinVoiceChat_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_JoinVoiceChat_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_JoinVoiceChat_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_JoinVoiceChat_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_JoinVoiceChat_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_JoinVoiceChat_Request {
    fn default() -> &'a CChatRoom_JoinVoiceChat_Request {
        <CChatRoom_JoinVoiceChat_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_JoinVoiceChat_Request {
    pub fn new() -> CChatRoom_JoinVoiceChat_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_JoinVoiceChat_Request {
    const NAME: &'static str = "CChatRoom_JoinVoiceChat_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_JoinVoiceChat_Request {
        CChatRoom_JoinVoiceChat_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_JoinVoiceChat_Request {
        static instance: CChatRoom_JoinVoiceChat_Request = CChatRoom_JoinVoiceChat_Request {
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoom_JoinVoiceChat_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_JoinVoiceChat_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_JoinVoiceChat_Response.voice_chatid)
    pub voice_chatid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_JoinVoiceChat_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_JoinVoiceChat_Response {
    fn default() -> &'a CChatRoom_JoinVoiceChat_Response {
        <CChatRoom_JoinVoiceChat_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_JoinVoiceChat_Response {
    pub fn new() -> CChatRoom_JoinVoiceChat_Response {
        ::std::default::Default::default()
    }

    // optional uint64 voice_chatid = 1;

    pub fn voice_chatid(&self) -> u64 {
        self.voice_chatid.unwrap_or(0)
    }

    pub fn clear_voice_chatid(&mut self) {
        self.voice_chatid = ::std::option::Option::None;
    }

    pub fn has_voice_chatid(&self) -> bool {
        self.voice_chatid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_chatid(&mut self, v: u64) {
        self.voice_chatid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_JoinVoiceChat_Response {
    const NAME: &'static str = "CChatRoom_JoinVoiceChat_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.voice_chatid = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.voice_chatid {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.voice_chatid {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_JoinVoiceChat_Response {
        CChatRoom_JoinVoiceChat_Response::new()
    }

    fn clear(&mut self) {
        self.voice_chatid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_JoinVoiceChat_Response {
        static instance: CChatRoom_JoinVoiceChat_Response = CChatRoom_JoinVoiceChat_Response {
            voice_chatid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Leave the voice chat in a multi-room chat"]
// @@protoc_insertion_point(message:CChatRoom_LeaveVoiceChat_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_LeaveVoiceChat_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_LeaveVoiceChat_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_LeaveVoiceChat_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_LeaveVoiceChat_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_LeaveVoiceChat_Request {
    fn default() -> &'a CChatRoom_LeaveVoiceChat_Request {
        <CChatRoom_LeaveVoiceChat_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_LeaveVoiceChat_Request {
    pub fn new() -> CChatRoom_LeaveVoiceChat_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_LeaveVoiceChat_Request {
    const NAME: &'static str = "CChatRoom_LeaveVoiceChat_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_LeaveVoiceChat_Request {
        CChatRoom_LeaveVoiceChat_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_LeaveVoiceChat_Request {
        static instance: CChatRoom_LeaveVoiceChat_Request = CChatRoom_LeaveVoiceChat_Request {
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoom_LeaveVoiceChat_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_LeaveVoiceChat_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_LeaveVoiceChat_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_LeaveVoiceChat_Response {
    fn default() -> &'a CChatRoom_LeaveVoiceChat_Response {
        <CChatRoom_LeaveVoiceChat_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_LeaveVoiceChat_Response {
    pub fn new() -> CChatRoom_LeaveVoiceChat_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_LeaveVoiceChat_Response {
    const NAME: &'static str = "CChatRoom_LeaveVoiceChat_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_LeaveVoiceChat_Response {
        CChatRoom_LeaveVoiceChat_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_LeaveVoiceChat_Response {
        static instance: CChatRoom_LeaveVoiceChat_Response = CChatRoom_LeaveVoiceChat_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Get the history of messages in a chat room.  You must currently be a member of the chat room."]
// @@protoc_insertion_point(message:CChatRoom_GetMessageHistory_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetMessageHistory_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Request.last_time)
    pub last_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Request.last_ordinal)
    pub last_ordinal: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Request.start_time)
    pub start_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Request.start_ordinal)
    pub start_ordinal: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Request.max_count)
    pub max_count: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetMessageHistory_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetMessageHistory_Request {
    fn default() -> &'a CChatRoom_GetMessageHistory_Request {
        <CChatRoom_GetMessageHistory_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetMessageHistory_Request {
    pub fn new() -> CChatRoom_GetMessageHistory_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional uint32 last_time = 3;

    pub fn last_time(&self) -> u32 {
        self.last_time.unwrap_or(0)
    }

    pub fn clear_last_time(&mut self) {
        self.last_time = ::std::option::Option::None;
    }

    pub fn has_last_time(&self) -> bool {
        self.last_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_time(&mut self, v: u32) {
        self.last_time = ::std::option::Option::Some(v);
    }

    // optional uint32 last_ordinal = 4;

    pub fn last_ordinal(&self) -> u32 {
        self.last_ordinal.unwrap_or(0)
    }

    pub fn clear_last_ordinal(&mut self) {
        self.last_ordinal = ::std::option::Option::None;
    }

    pub fn has_last_ordinal(&self) -> bool {
        self.last_ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_ordinal(&mut self, v: u32) {
        self.last_ordinal = ::std::option::Option::Some(v);
    }

    // optional uint32 start_time = 5;

    pub fn start_time(&self) -> u32 {
        self.start_time.unwrap_or(0)
    }

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: u32) {
        self.start_time = ::std::option::Option::Some(v);
    }

    // optional uint32 start_ordinal = 6;

    pub fn start_ordinal(&self) -> u32 {
        self.start_ordinal.unwrap_or(0)
    }

    pub fn clear_start_ordinal(&mut self) {
        self.start_ordinal = ::std::option::Option::None;
    }

    pub fn has_start_ordinal(&self) -> bool {
        self.start_ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_ordinal(&mut self, v: u32) {
        self.start_ordinal = ::std::option::Option::Some(v);
    }

    // optional uint32 max_count = 7;

    pub fn max_count(&self) -> u32 {
        self.max_count.unwrap_or(0)
    }

    pub fn clear_max_count(&mut self) {
        self.max_count = ::std::option::Option::None;
    }

    pub fn has_max_count(&self) -> bool {
        self.max_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_count(&mut self, v: u32) {
        self.max_count = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_GetMessageHistory_Request {
    const NAME: &'static str = "CChatRoom_GetMessageHistory_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.last_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.last_ordinal = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.start_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.start_ordinal = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.max_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.last_time {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.last_ordinal {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.start_time {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.start_ordinal {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.max_count {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.last_time {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.last_ordinal {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.start_time {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.start_ordinal {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.max_count {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetMessageHistory_Request {
        CChatRoom_GetMessageHistory_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.last_time = ::std::option::Option::None;
        self.last_ordinal = ::std::option::Option::None;
        self.start_time = ::std::option::Option::None;
        self.start_ordinal = ::std::option::Option::None;
        self.max_count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetMessageHistory_Request {
        static instance: CChatRoom_GetMessageHistory_Request = CChatRoom_GetMessageHistory_Request {
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            last_time: ::std::option::Option::None,
            last_ordinal: ::std::option::Option::None,
            start_time: ::std::option::Option::None,
            start_ordinal: ::std::option::Option::None,
            max_count: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:ServerMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ServerMessage {
    // message fields
    // @@protoc_insertion_point(field:ServerMessage.message)
    pub message: ::std::option::Option<::protobuf::EnumOrUnknown<EChatRoomServerMessage>>,
    // @@protoc_insertion_point(field:ServerMessage.string_param)
    pub string_param: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ServerMessage.accountid_param)
    pub accountid_param: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:ServerMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServerMessage {
    fn default() -> &'a ServerMessage {
        <ServerMessage as ::protobuf::Message>::default_instance()
    }
}

impl ServerMessage {
    pub fn new() -> ServerMessage {
        ::std::default::Default::default()
    }

    // optional .EChatRoomServerMessage message = 1;

    pub fn message(&self) -> EChatRoomServerMessage {
        match self.message {
            Some(e) => e.enum_value_or(EChatRoomServerMessage::k_EChatRoomServerMsg_Invalid),
            None => EChatRoomServerMessage::k_EChatRoomServerMsg_Invalid,
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: EChatRoomServerMessage) {
        self.message = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string string_param = 2;

    pub fn string_param(&self) -> &str {
        match self.string_param.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_string_param(&mut self) {
        self.string_param = ::std::option::Option::None;
    }

    pub fn has_string_param(&self) -> bool {
        self.string_param.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_param(&mut self, v: ::std::string::String) {
        self.string_param = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_param(&mut self) -> &mut ::std::string::String {
        if self.string_param.is_none() {
            self.string_param = ::std::option::Option::Some(::std::string::String::new());
        }
        self.string_param.as_mut().unwrap()
    }

    // Take field
    pub fn take_string_param(&mut self) -> ::std::string::String {
        self.string_param.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 accountid_param = 3;

    pub fn accountid_param(&self) -> u32 {
        self.accountid_param.unwrap_or(0)
    }

    pub fn clear_accountid_param(&mut self) {
        self.accountid_param = ::std::option::Option::None;
    }

    pub fn has_accountid_param(&self) -> bool {
        self.accountid_param.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid_param(&mut self, v: u32) {
        self.accountid_param = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ServerMessage {
    const NAME: &'static str = "ServerMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.message = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.string_param = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.accountid_param = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.string_param.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.accountid_param {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.message {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.string_param.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.accountid_param {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServerMessage {
        ServerMessage::new()
    }

    fn clear(&mut self) {
        self.message = ::std::option::Option::None;
        self.string_param = ::std::option::Option::None;
        self.accountid_param = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServerMessage {
        static instance: ServerMessage = ServerMessage {
            message: ::std::option::Option::None,
            string_param: ::std::option::Option::None,
            accountid_param: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoom_GetMessageHistory_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetMessageHistory_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Response.messages)
    pub messages: ::std::vec::Vec<cchat_room_get_message_history_response::ChatMessage>,
    // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Response.more_available)
    pub more_available: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetMessageHistory_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetMessageHistory_Response {
    fn default() -> &'a CChatRoom_GetMessageHistory_Response {
        <CChatRoom_GetMessageHistory_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetMessageHistory_Response {
    pub fn new() -> CChatRoom_GetMessageHistory_Response {
        ::std::default::Default::default()
    }

    // optional bool more_available = 4;

    pub fn more_available(&self) -> bool {
        self.more_available.unwrap_or(false)
    }

    pub fn clear_more_available(&mut self) {
        self.more_available = ::std::option::Option::None;
    }

    pub fn has_more_available(&self) -> bool {
        self.more_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_more_available(&mut self, v: bool) {
        self.more_available = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_GetMessageHistory_Response {
    const NAME: &'static str = "CChatRoom_GetMessageHistory_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.messages.push(is.read_message()?);
                },
                32 => {
                    self.more_available = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.more_available {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.messages {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.more_available {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetMessageHistory_Response {
        CChatRoom_GetMessageHistory_Response::new()
    }

    fn clear(&mut self) {
        self.messages.clear();
        self.more_available = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetMessageHistory_Response {
        static instance: CChatRoom_GetMessageHistory_Response = CChatRoom_GetMessageHistory_Response {
            messages: ::std::vec::Vec::new(),
            more_available: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CChatRoom_GetMessageHistory_Response`
pub mod cchat_room_get_message_history_response {
    // @@protoc_insertion_point(message:CChatRoom_GetMessageHistory_Response.ChatMessage)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ChatMessage {
        // message fields
        // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Response.ChatMessage.sender)
        pub sender: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Response.ChatMessage.server_timestamp)
        pub server_timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Response.ChatMessage.message)
        pub message: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Response.ChatMessage.ordinal)
        pub ordinal: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Response.ChatMessage.server_message)
        pub server_message: ::protobuf::MessageField<super::ServerMessage>,
        // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Response.ChatMessage.deleted)
        pub deleted: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Response.ChatMessage.reactions)
        pub reactions: ::std::vec::Vec<chat_message::MessageReaction>,
        // special fields
        // @@protoc_insertion_point(special_field:CChatRoom_GetMessageHistory_Response.ChatMessage.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ChatMessage {
        fn default() -> &'a ChatMessage {
            <ChatMessage as ::protobuf::Message>::default_instance()
        }
    }

    impl ChatMessage {
        pub fn new() -> ChatMessage {
            ::std::default::Default::default()
        }

        // optional uint32 sender = 1;

        pub fn sender(&self) -> u32 {
            self.sender.unwrap_or(0)
        }

        pub fn clear_sender(&mut self) {
            self.sender = ::std::option::Option::None;
        }

        pub fn has_sender(&self) -> bool {
            self.sender.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sender(&mut self, v: u32) {
            self.sender = ::std::option::Option::Some(v);
        }

        // optional uint32 server_timestamp = 2;

        pub fn server_timestamp(&self) -> u32 {
            self.server_timestamp.unwrap_or(0)
        }

        pub fn clear_server_timestamp(&mut self) {
            self.server_timestamp = ::std::option::Option::None;
        }

        pub fn has_server_timestamp(&self) -> bool {
            self.server_timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_server_timestamp(&mut self, v: u32) {
            self.server_timestamp = ::std::option::Option::Some(v);
        }

        // optional string message = 3;

        pub fn message(&self) -> &str {
            match self.message.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_message(&mut self) {
            self.message = ::std::option::Option::None;
        }

        pub fn has_message(&self) -> bool {
            self.message.is_some()
        }

        // Param is passed by value, moved
        pub fn set_message(&mut self, v: ::std::string::String) {
            self.message = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_message(&mut self) -> &mut ::std::string::String {
            if self.message.is_none() {
                self.message = ::std::option::Option::Some(::std::string::String::new());
            }
            self.message.as_mut().unwrap()
        }

        // Take field
        pub fn take_message(&mut self) -> ::std::string::String {
            self.message.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 ordinal = 4;

        pub fn ordinal(&self) -> u32 {
            self.ordinal.unwrap_or(0)
        }

        pub fn clear_ordinal(&mut self) {
            self.ordinal = ::std::option::Option::None;
        }

        pub fn has_ordinal(&self) -> bool {
            self.ordinal.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ordinal(&mut self, v: u32) {
            self.ordinal = ::std::option::Option::Some(v);
        }

        // optional bool deleted = 6;

        pub fn deleted(&self) -> bool {
            self.deleted.unwrap_or(false)
        }

        pub fn clear_deleted(&mut self) {
            self.deleted = ::std::option::Option::None;
        }

        pub fn has_deleted(&self) -> bool {
            self.deleted.is_some()
        }

        // Param is passed by value, moved
        pub fn set_deleted(&mut self, v: bool) {
            self.deleted = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for ChatMessage {
        const NAME: &'static str = "ChatMessage";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.sender = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.server_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.message = ::std::option::Option::Some(is.read_string()?);
                    },
                    32 => {
                        self.ordinal = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    42 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.server_message)?;
                    },
                    48 => {
                        self.deleted = ::std::option::Option::Some(is.read_bool()?);
                    },
                    58 => {
                        self.reactions.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.sender {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.server_timestamp {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.message.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.ordinal {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.server_message.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.deleted {
                my_size += 1 + 1;
            }
            for value in &self.reactions {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.sender {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.server_timestamp {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.message.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.ordinal {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.server_message.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
            }
            if let Some(v) = self.deleted {
                os.write_bool(6, v)?;
            }
            for v in &self.reactions {
                ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ChatMessage {
            ChatMessage::new()
        }

        fn clear(&mut self) {
            self.sender = ::std::option::Option::None;
            self.server_timestamp = ::std::option::Option::None;
            self.message = ::std::option::Option::None;
            self.ordinal = ::std::option::Option::None;
            self.server_message.clear();
            self.deleted = ::std::option::Option::None;
            self.reactions.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ChatMessage {
            static instance: ChatMessage = ChatMessage {
                sender: ::std::option::Option::None,
                server_timestamp: ::std::option::Option::None,
                message: ::std::option::Option::None,
                ordinal: ::std::option::Option::None,
                server_message: ::protobuf::MessageField::none(),
                deleted: ::std::option::Option::None,
                reactions: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `ChatMessage`
    pub mod chat_message {
        // @@protoc_insertion_point(message:CChatRoom_GetMessageHistory_Response.ChatMessage.MessageReaction)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct MessageReaction {
            // message fields
            // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Response.ChatMessage.MessageReaction.reaction_type)
            pub reaction_type: ::std::option::Option<::protobuf::EnumOrUnknown<super::super::EChatRoomMessageReactionType>>,
            // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Response.ChatMessage.MessageReaction.reaction)
            pub reaction: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Response.ChatMessage.MessageReaction.num_reactors)
            pub num_reactors: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Response.ChatMessage.MessageReaction.has_user_reacted)
            pub has_user_reacted: ::std::option::Option<bool>,
            // special fields
            // @@protoc_insertion_point(special_field:CChatRoom_GetMessageHistory_Response.ChatMessage.MessageReaction.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a MessageReaction {
            fn default() -> &'a MessageReaction {
                <MessageReaction as ::protobuf::Message>::default_instance()
            }
        }

        impl MessageReaction {
            pub fn new() -> MessageReaction {
                ::std::default::Default::default()
            }

            // optional .EChatRoomMessageReactionType reaction_type = 1;

            pub fn reaction_type(&self) -> super::super::EChatRoomMessageReactionType {
                match self.reaction_type {
                    Some(e) => e.enum_value_or(super::super::EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Invalid),
                    None => super::super::EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Invalid,
                }
            }

            pub fn clear_reaction_type(&mut self) {
                self.reaction_type = ::std::option::Option::None;
            }

            pub fn has_reaction_type(&self) -> bool {
                self.reaction_type.is_some()
            }

            // Param is passed by value, moved
            pub fn set_reaction_type(&mut self, v: super::super::EChatRoomMessageReactionType) {
                self.reaction_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
            }

            // optional string reaction = 2;

            pub fn reaction(&self) -> &str {
                match self.reaction.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_reaction(&mut self) {
                self.reaction = ::std::option::Option::None;
            }

            pub fn has_reaction(&self) -> bool {
                self.reaction.is_some()
            }

            // Param is passed by value, moved
            pub fn set_reaction(&mut self, v: ::std::string::String) {
                self.reaction = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_reaction(&mut self) -> &mut ::std::string::String {
                if self.reaction.is_none() {
                    self.reaction = ::std::option::Option::Some(::std::string::String::new());
                }
                self.reaction.as_mut().unwrap()
            }

            // Take field
            pub fn take_reaction(&mut self) -> ::std::string::String {
                self.reaction.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional uint32 num_reactors = 3;

            pub fn num_reactors(&self) -> u32 {
                self.num_reactors.unwrap_or(0)
            }

            pub fn clear_num_reactors(&mut self) {
                self.num_reactors = ::std::option::Option::None;
            }

            pub fn has_num_reactors(&self) -> bool {
                self.num_reactors.is_some()
            }

            // Param is passed by value, moved
            pub fn set_num_reactors(&mut self, v: u32) {
                self.num_reactors = ::std::option::Option::Some(v);
            }

            // optional bool has_user_reacted = 4;

            pub fn has_user_reacted(&self) -> bool {
                self.has_user_reacted.unwrap_or(false)
            }

            pub fn clear_has_user_reacted(&mut self) {
                self.has_user_reacted = ::std::option::Option::None;
            }

            pub fn has_has_user_reacted(&self) -> bool {
                self.has_user_reacted.is_some()
            }

            // Param is passed by value, moved
            pub fn set_has_user_reacted(&mut self, v: bool) {
                self.has_user_reacted = ::std::option::Option::Some(v);
            }
        }

        impl ::protobuf::Message for MessageReaction {
            const NAME: &'static str = "MessageReaction";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.reaction_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                        },
                        18 => {
                            self.reaction = ::std::option::Option::Some(is.read_string()?);
                        },
                        24 => {
                            self.num_reactors = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        32 => {
                            self.has_user_reacted = ::std::option::Option::Some(is.read_bool()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.reaction_type {
                    my_size += ::protobuf::rt::int32_size(1, v.value());
                }
                if let Some(v) = self.reaction.as_ref() {
                    my_size += ::protobuf::rt::string_size(2, &v);
                }
                if let Some(v) = self.num_reactors {
                    my_size += ::protobuf::rt::uint32_size(3, v);
                }
                if let Some(v) = self.has_user_reacted {
                    my_size += 1 + 1;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.reaction_type {
                    os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
                }
                if let Some(v) = self.reaction.as_ref() {
                    os.write_string(2, v)?;
                }
                if let Some(v) = self.num_reactors {
                    os.write_uint32(3, v)?;
                }
                if let Some(v) = self.has_user_reacted {
                    os.write_bool(4, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> MessageReaction {
                MessageReaction::new()
            }

            fn clear(&mut self) {
                self.reaction_type = ::std::option::Option::None;
                self.reaction = ::std::option::Option::None;
                self.num_reactors = ::std::option::Option::None;
                self.has_user_reacted = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static MessageReaction {
                static instance: MessageReaction = MessageReaction {
                    reaction_type: ::std::option::Option::None,
                    reaction: ::std::option::Option::None,
                    num_reactors: ::std::option::Option::None,
                    has_user_reacted: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }
    }
}

#[doc = "Get a list of our chat rooms"]
// @@protoc_insertion_point(message:CChatRoom_GetMyChatRoomGroups_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetMyChatRoomGroups_Request {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetMyChatRoomGroups_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetMyChatRoomGroups_Request {
    fn default() -> &'a CChatRoom_GetMyChatRoomGroups_Request {
        <CChatRoom_GetMyChatRoomGroups_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetMyChatRoomGroups_Request {
    pub fn new() -> CChatRoom_GetMyChatRoomGroups_Request {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_GetMyChatRoomGroups_Request {
    const NAME: &'static str = "CChatRoom_GetMyChatRoomGroups_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetMyChatRoomGroups_Request {
        CChatRoom_GetMyChatRoomGroups_Request::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetMyChatRoomGroups_Request {
        static instance: CChatRoom_GetMyChatRoomGroups_Request = CChatRoom_GetMyChatRoomGroups_Request {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoom_GetChatRoomGroupSummary_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetChatRoomGroupSummary_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.chat_group_name)
    pub chat_group_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.active_member_count)
    pub active_member_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.active_voice_member_count)
    pub active_voice_member_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.default_chat_id)
    pub default_chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.chat_rooms)
    pub chat_rooms: ::std::vec::Vec<CChatRoomState>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.clanid)
    pub clanid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.chat_group_tagline)
    pub chat_group_tagline: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.accountid_owner)
    pub accountid_owner: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.top_members)
    pub top_members: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.chat_group_avatar_sha)
    pub chat_group_avatar_sha: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.rank)
    pub rank: ::std::option::Option<::protobuf::EnumOrUnknown<EChatRoomGroupRank>>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.default_role_id)
    pub default_role_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.role_ids)
    pub role_ids: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.role_actions)
    pub role_actions: ::std::vec::Vec<CChatRoleActions>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.watching_broadcast_accountid)
    pub watching_broadcast_accountid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.party_beacons)
    pub party_beacons: ::std::vec::Vec<CChatPartyBeacon>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.watching_broadcast_channel_id)
    pub watching_broadcast_channel_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.active_minigame_id)
    pub active_minigame_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.avatar_ugc_url)
    pub avatar_ugc_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.disabled)
    pub disabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetChatRoomGroupSummary_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetChatRoomGroupSummary_Response {
    fn default() -> &'a CChatRoom_GetChatRoomGroupSummary_Response {
        <CChatRoom_GetChatRoomGroupSummary_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetChatRoomGroupSummary_Response {
    pub fn new() -> CChatRoom_GetChatRoomGroupSummary_Response {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional string chat_group_name = 2;

    pub fn chat_group_name(&self) -> &str {
        match self.chat_group_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_chat_group_name(&mut self) {
        self.chat_group_name = ::std::option::Option::None;
    }

    pub fn has_chat_group_name(&self) -> bool {
        self.chat_group_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_name(&mut self, v: ::std::string::String) {
        self.chat_group_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_group_name(&mut self) -> &mut ::std::string::String {
        if self.chat_group_name.is_none() {
            self.chat_group_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.chat_group_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_chat_group_name(&mut self) -> ::std::string::String {
        self.chat_group_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 active_member_count = 3;

    pub fn active_member_count(&self) -> u32 {
        self.active_member_count.unwrap_or(0)
    }

    pub fn clear_active_member_count(&mut self) {
        self.active_member_count = ::std::option::Option::None;
    }

    pub fn has_active_member_count(&self) -> bool {
        self.active_member_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_member_count(&mut self, v: u32) {
        self.active_member_count = ::std::option::Option::Some(v);
    }

    // optional uint32 active_voice_member_count = 4;

    pub fn active_voice_member_count(&self) -> u32 {
        self.active_voice_member_count.unwrap_or(0)
    }

    pub fn clear_active_voice_member_count(&mut self) {
        self.active_voice_member_count = ::std::option::Option::None;
    }

    pub fn has_active_voice_member_count(&self) -> bool {
        self.active_voice_member_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_voice_member_count(&mut self, v: u32) {
        self.active_voice_member_count = ::std::option::Option::Some(v);
    }

    // optional uint64 default_chat_id = 5;

    pub fn default_chat_id(&self) -> u64 {
        self.default_chat_id.unwrap_or(0)
    }

    pub fn clear_default_chat_id(&mut self) {
        self.default_chat_id = ::std::option::Option::None;
    }

    pub fn has_default_chat_id(&self) -> bool {
        self.default_chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_chat_id(&mut self, v: u64) {
        self.default_chat_id = ::std::option::Option::Some(v);
    }

    // optional uint32 clanid = 7;

    pub fn clanid(&self) -> u32 {
        self.clanid.unwrap_or(0)
    }

    pub fn clear_clanid(&mut self) {
        self.clanid = ::std::option::Option::None;
    }

    pub fn has_clanid(&self) -> bool {
        self.clanid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clanid(&mut self, v: u32) {
        self.clanid = ::std::option::Option::Some(v);
    }

    // optional string chat_group_tagline = 8;

    pub fn chat_group_tagline(&self) -> &str {
        match self.chat_group_tagline.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_chat_group_tagline(&mut self) {
        self.chat_group_tagline = ::std::option::Option::None;
    }

    pub fn has_chat_group_tagline(&self) -> bool {
        self.chat_group_tagline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_tagline(&mut self, v: ::std::string::String) {
        self.chat_group_tagline = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_group_tagline(&mut self) -> &mut ::std::string::String {
        if self.chat_group_tagline.is_none() {
            self.chat_group_tagline = ::std::option::Option::Some(::std::string::String::new());
        }
        self.chat_group_tagline.as_mut().unwrap()
    }

    // Take field
    pub fn take_chat_group_tagline(&mut self) -> ::std::string::String {
        self.chat_group_tagline.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 accountid_owner = 9;

    pub fn accountid_owner(&self) -> u32 {
        self.accountid_owner.unwrap_or(0)
    }

    pub fn clear_accountid_owner(&mut self) {
        self.accountid_owner = ::std::option::Option::None;
    }

    pub fn has_accountid_owner(&self) -> bool {
        self.accountid_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid_owner(&mut self, v: u32) {
        self.accountid_owner = ::std::option::Option::Some(v);
    }

    // optional bytes chat_group_avatar_sha = 11;

    pub fn chat_group_avatar_sha(&self) -> &[u8] {
        match self.chat_group_avatar_sha.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_chat_group_avatar_sha(&mut self) {
        self.chat_group_avatar_sha = ::std::option::Option::None;
    }

    pub fn has_chat_group_avatar_sha(&self) -> bool {
        self.chat_group_avatar_sha.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_avatar_sha(&mut self, v: ::std::vec::Vec<u8>) {
        self.chat_group_avatar_sha = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_group_avatar_sha(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.chat_group_avatar_sha.is_none() {
            self.chat_group_avatar_sha = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.chat_group_avatar_sha.as_mut().unwrap()
    }

    // Take field
    pub fn take_chat_group_avatar_sha(&mut self) -> ::std::vec::Vec<u8> {
        self.chat_group_avatar_sha.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .EChatRoomGroupRank rank = 12;

    pub fn rank(&self) -> EChatRoomGroupRank {
        match self.rank {
            Some(e) => e.enum_value_or(EChatRoomGroupRank::k_EChatRoomGroupRank_Default),
            None => EChatRoomGroupRank::k_EChatRoomGroupRank_Default,
        }
    }

    pub fn clear_rank(&mut self) {
        self.rank = ::std::option::Option::None;
    }

    pub fn has_rank(&self) -> bool {
        self.rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank(&mut self, v: EChatRoomGroupRank) {
        self.rank = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 default_role_id = 13;

    pub fn default_role_id(&self) -> u64 {
        self.default_role_id.unwrap_or(0)
    }

    pub fn clear_default_role_id(&mut self) {
        self.default_role_id = ::std::option::Option::None;
    }

    pub fn has_default_role_id(&self) -> bool {
        self.default_role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_role_id(&mut self, v: u64) {
        self.default_role_id = ::std::option::Option::Some(v);
    }

    // optional uint32 watching_broadcast_accountid = 16;

    pub fn watching_broadcast_accountid(&self) -> u32 {
        self.watching_broadcast_accountid.unwrap_or(0)
    }

    pub fn clear_watching_broadcast_accountid(&mut self) {
        self.watching_broadcast_accountid = ::std::option::Option::None;
    }

    pub fn has_watching_broadcast_accountid(&self) -> bool {
        self.watching_broadcast_accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watching_broadcast_accountid(&mut self, v: u32) {
        self.watching_broadcast_accountid = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 17;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint64 watching_broadcast_channel_id = 19;

    pub fn watching_broadcast_channel_id(&self) -> u64 {
        self.watching_broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_watching_broadcast_channel_id(&mut self) {
        self.watching_broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_watching_broadcast_channel_id(&self) -> bool {
        self.watching_broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watching_broadcast_channel_id(&mut self, v: u64) {
        self.watching_broadcast_channel_id = ::std::option::Option::Some(v);
    }

    // optional uint64 active_minigame_id = 20;

    pub fn active_minigame_id(&self) -> u64 {
        self.active_minigame_id.unwrap_or(0)
    }

    pub fn clear_active_minigame_id(&mut self) {
        self.active_minigame_id = ::std::option::Option::None;
    }

    pub fn has_active_minigame_id(&self) -> bool {
        self.active_minigame_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_minigame_id(&mut self, v: u64) {
        self.active_minigame_id = ::std::option::Option::Some(v);
    }

    // optional string avatar_ugc_url = 21;

    pub fn avatar_ugc_url(&self) -> &str {
        match self.avatar_ugc_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_avatar_ugc_url(&mut self) {
        self.avatar_ugc_url = ::std::option::Option::None;
    }

    pub fn has_avatar_ugc_url(&self) -> bool {
        self.avatar_ugc_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avatar_ugc_url(&mut self, v: ::std::string::String) {
        self.avatar_ugc_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar_ugc_url(&mut self) -> &mut ::std::string::String {
        if self.avatar_ugc_url.is_none() {
            self.avatar_ugc_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.avatar_ugc_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_avatar_ugc_url(&mut self) -> ::std::string::String {
        self.avatar_ugc_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool disabled = 22;

    pub fn disabled(&self) -> bool {
        self.disabled.unwrap_or(false)
    }

    pub fn clear_disabled(&mut self) {
        self.disabled = ::std::option::Option::None;
    }

    pub fn has_disabled(&self) -> bool {
        self.disabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disabled(&mut self, v: bool) {
        self.disabled = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_GetChatRoomGroupSummary_Response {
    const NAME: &'static str = "CChatRoom_GetChatRoomGroupSummary_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.chat_group_name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.active_member_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.active_voice_member_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.default_chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                50 => {
                    self.chat_rooms.push(is.read_message()?);
                },
                56 => {
                    self.clanid = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.chat_group_tagline = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.accountid_owner = ::std::option::Option::Some(is.read_uint32()?);
                },
                82 => {
                    is.read_repeated_packed_uint32_into(&mut self.top_members)?;
                },
                80 => {
                    self.top_members.push(is.read_uint32()?);
                },
                90 => {
                    self.chat_group_avatar_sha = ::std::option::Option::Some(is.read_bytes()?);
                },
                96 => {
                    self.rank = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                104 => {
                    self.default_role_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                114 => {
                    is.read_repeated_packed_uint64_into(&mut self.role_ids)?;
                },
                112 => {
                    self.role_ids.push(is.read_uint64()?);
                },
                122 => {
                    self.role_actions.push(is.read_message()?);
                },
                128 => {
                    self.watching_broadcast_accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                146 => {
                    self.party_beacons.push(is.read_message()?);
                },
                152 => {
                    self.watching_broadcast_channel_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                160 => {
                    self.active_minigame_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                170 => {
                    self.avatar_ugc_url = ::std::option::Option::Some(is.read_string()?);
                },
                176 => {
                    self.disabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_group_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.active_member_count {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.active_voice_member_count {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.default_chat_id {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        for value in &self.chat_rooms {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.clanid {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.chat_group_tagline.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.accountid_owner {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        for value in &self.top_members {
            my_size += ::protobuf::rt::uint32_size(10, *value);
        };
        if let Some(v) = self.chat_group_avatar_sha.as_ref() {
            my_size += ::protobuf::rt::bytes_size(11, &v);
        }
        if let Some(v) = self.rank {
            my_size += ::protobuf::rt::int32_size(12, v.value());
        }
        if let Some(v) = self.default_role_id {
            my_size += ::protobuf::rt::uint64_size(13, v);
        }
        for value in &self.role_ids {
            my_size += ::protobuf::rt::uint64_size(14, *value);
        };
        for value in &self.role_actions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.watching_broadcast_accountid {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(17, v);
        }
        for value in &self.party_beacons {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.watching_broadcast_channel_id {
            my_size += ::protobuf::rt::uint64_size(19, v);
        }
        if let Some(v) = self.active_minigame_id {
            my_size += ::protobuf::rt::uint64_size(20, v);
        }
        if let Some(v) = self.avatar_ugc_url.as_ref() {
            my_size += ::protobuf::rt::string_size(21, &v);
        }
        if let Some(v) = self.disabled {
            my_size += 2 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_group_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.active_member_count {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.active_voice_member_count {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.default_chat_id {
            os.write_uint64(5, v)?;
        }
        for v in &self.chat_rooms {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if let Some(v) = self.clanid {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.chat_group_tagline.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.accountid_owner {
            os.write_uint32(9, v)?;
        }
        for v in &self.top_members {
            os.write_uint32(10, *v)?;
        };
        if let Some(v) = self.chat_group_avatar_sha.as_ref() {
            os.write_bytes(11, v)?;
        }
        if let Some(v) = self.rank {
            os.write_enum(12, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.default_role_id {
            os.write_uint64(13, v)?;
        }
        for v in &self.role_ids {
            os.write_uint64(14, *v)?;
        };
        for v in &self.role_actions {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        };
        if let Some(v) = self.watching_broadcast_accountid {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(17, v)?;
        }
        for v in &self.party_beacons {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        };
        if let Some(v) = self.watching_broadcast_channel_id {
            os.write_uint64(19, v)?;
        }
        if let Some(v) = self.active_minigame_id {
            os.write_uint64(20, v)?;
        }
        if let Some(v) = self.avatar_ugc_url.as_ref() {
            os.write_string(21, v)?;
        }
        if let Some(v) = self.disabled {
            os.write_bool(22, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetChatRoomGroupSummary_Response {
        CChatRoom_GetChatRoomGroupSummary_Response::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_group_name = ::std::option::Option::None;
        self.active_member_count = ::std::option::Option::None;
        self.active_voice_member_count = ::std::option::Option::None;
        self.default_chat_id = ::std::option::Option::None;
        self.chat_rooms.clear();
        self.clanid = ::std::option::Option::None;
        self.chat_group_tagline = ::std::option::Option::None;
        self.accountid_owner = ::std::option::Option::None;
        self.top_members.clear();
        self.chat_group_avatar_sha = ::std::option::Option::None;
        self.rank = ::std::option::Option::None;
        self.default_role_id = ::std::option::Option::None;
        self.role_ids.clear();
        self.role_actions.clear();
        self.watching_broadcast_accountid = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.party_beacons.clear();
        self.watching_broadcast_channel_id = ::std::option::Option::None;
        self.active_minigame_id = ::std::option::Option::None;
        self.avatar_ugc_url = ::std::option::Option::None;
        self.disabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetChatRoomGroupSummary_Response {
        static instance: CChatRoom_GetChatRoomGroupSummary_Response = CChatRoom_GetChatRoomGroupSummary_Response {
            chat_group_id: ::std::option::Option::None,
            chat_group_name: ::std::option::Option::None,
            active_member_count: ::std::option::Option::None,
            active_voice_member_count: ::std::option::Option::None,
            default_chat_id: ::std::option::Option::None,
            chat_rooms: ::std::vec::Vec::new(),
            clanid: ::std::option::Option::None,
            chat_group_tagline: ::std::option::Option::None,
            accountid_owner: ::std::option::Option::None,
            top_members: ::std::vec::Vec::new(),
            chat_group_avatar_sha: ::std::option::Option::None,
            rank: ::std::option::Option::None,
            default_role_id: ::std::option::Option::None,
            role_ids: ::std::vec::Vec::new(),
            role_actions: ::std::vec::Vec::new(),
            watching_broadcast_accountid: ::std::option::Option::None,
            appid: ::std::option::Option::None,
            party_beacons: ::std::vec::Vec::new(),
            watching_broadcast_channel_id: ::std::option::Option::None,
            active_minigame_id: ::std::option::Option::None,
            avatar_ugc_url: ::std::option::Option::None,
            disabled: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoomSummaryPair)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoomSummaryPair {
    // message fields
    // @@protoc_insertion_point(field:CChatRoomSummaryPair.user_chat_group_state)
    pub user_chat_group_state: ::protobuf::MessageField<CUserChatRoomGroupState>,
    // @@protoc_insertion_point(field:CChatRoomSummaryPair.group_summary)
    pub group_summary: ::protobuf::MessageField<CChatRoom_GetChatRoomGroupSummary_Response>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoomSummaryPair.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoomSummaryPair {
    fn default() -> &'a CChatRoomSummaryPair {
        <CChatRoomSummaryPair as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoomSummaryPair {
    pub fn new() -> CChatRoomSummaryPair {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoomSummaryPair {
    const NAME: &'static str = "CChatRoomSummaryPair";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_chat_group_state)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.group_summary)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_chat_group_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.group_summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_chat_group_state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.group_summary.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoomSummaryPair {
        CChatRoomSummaryPair::new()
    }

    fn clear(&mut self) {
        self.user_chat_group_state.clear();
        self.group_summary.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoomSummaryPair {
        static instance: CChatRoomSummaryPair = CChatRoomSummaryPair {
            user_chat_group_state: ::protobuf::MessageField::none(),
            group_summary: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoom_GetMyChatRoomGroups_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetMyChatRoomGroups_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetMyChatRoomGroups_Response.chat_room_groups)
    pub chat_room_groups: ::std::vec::Vec<CChatRoomSummaryPair>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetMyChatRoomGroups_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetMyChatRoomGroups_Response {
    fn default() -> &'a CChatRoom_GetMyChatRoomGroups_Response {
        <CChatRoom_GetMyChatRoomGroups_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetMyChatRoomGroups_Response {
    pub fn new() -> CChatRoom_GetMyChatRoomGroups_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_GetMyChatRoomGroups_Response {
    const NAME: &'static str = "CChatRoom_GetMyChatRoomGroups_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.chat_room_groups.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.chat_room_groups {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.chat_room_groups {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetMyChatRoomGroups_Response {
        CChatRoom_GetMyChatRoomGroups_Response::new()
    }

    fn clear(&mut self) {
        self.chat_room_groups.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetMyChatRoomGroups_Response {
        static instance: CChatRoom_GetMyChatRoomGroups_Response = CChatRoom_GetMyChatRoomGroups_Response {
            chat_room_groups: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Get information about a single chat room"]
// @@protoc_insertion_point(message:CChatRoom_GetChatRoomGroupState_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetChatRoomGroupState_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupState_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetChatRoomGroupState_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetChatRoomGroupState_Request {
    fn default() -> &'a CChatRoom_GetChatRoomGroupState_Request {
        <CChatRoom_GetChatRoomGroupState_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetChatRoomGroupState_Request {
    pub fn new() -> CChatRoom_GetChatRoomGroupState_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_GetChatRoomGroupState_Request {
    const NAME: &'static str = "CChatRoom_GetChatRoomGroupState_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetChatRoomGroupState_Request {
        CChatRoom_GetChatRoomGroupState_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetChatRoomGroupState_Request {
        static instance: CChatRoom_GetChatRoomGroupState_Request = CChatRoom_GetChatRoomGroupState_Request {
            chat_group_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoom_GetChatRoomGroupState_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetChatRoomGroupState_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupState_Response.state)
    pub state: ::protobuf::MessageField<CChatRoomGroupState>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetChatRoomGroupState_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetChatRoomGroupState_Response {
    fn default() -> &'a CChatRoom_GetChatRoomGroupState_Response {
        <CChatRoom_GetChatRoomGroupState_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetChatRoomGroupState_Response {
    pub fn new() -> CChatRoom_GetChatRoomGroupState_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_GetChatRoomGroupState_Response {
    const NAME: &'static str = "CChatRoom_GetChatRoomGroupState_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.state)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetChatRoomGroupState_Response {
        CChatRoom_GetChatRoomGroupState_Response::new()
    }

    fn clear(&mut self) {
        self.state.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetChatRoomGroupState_Response {
        static instance: CChatRoom_GetChatRoomGroupState_Response = CChatRoom_GetChatRoomGroupState_Response {
            state: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Get basic information about a chat room group"]
// @@protoc_insertion_point(message:CChatRoom_GetChatRoomGroupSummary_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetChatRoomGroupSummary_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetChatRoomGroupSummary_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetChatRoomGroupSummary_Request {
    fn default() -> &'a CChatRoom_GetChatRoomGroupSummary_Request {
        <CChatRoom_GetChatRoomGroupSummary_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetChatRoomGroupSummary_Request {
    pub fn new() -> CChatRoom_GetChatRoomGroupSummary_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_GetChatRoomGroupSummary_Request {
    const NAME: &'static str = "CChatRoom_GetChatRoomGroupSummary_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetChatRoomGroupSummary_Request {
        CChatRoom_GetChatRoomGroupSummary_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetChatRoomGroupSummary_Request {
        static instance: CChatRoom_GetChatRoomGroupSummary_Request = CChatRoom_GetChatRoomGroupSummary_Request {
            chat_group_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Force a group chat to be considered active on the server for this user"]
// @@protoc_insertion_point(message:CChatRoom_SetAppChatRoomGroupForceActive_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SetAppChatRoomGroupForceActive_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_SetAppChatRoomGroupForceActive_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_SetAppChatRoomGroupForceActive_Request.requesting_app_id)
    pub requesting_app_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SetAppChatRoomGroupForceActive_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetAppChatRoomGroupForceActive_Request {
    fn default() -> &'a CChatRoom_SetAppChatRoomGroupForceActive_Request {
        <CChatRoom_SetAppChatRoomGroupForceActive_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetAppChatRoomGroupForceActive_Request {
    pub fn new() -> CChatRoom_SetAppChatRoomGroupForceActive_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint32 requesting_app_id = 2;

    pub fn requesting_app_id(&self) -> u32 {
        self.requesting_app_id.unwrap_or(0)
    }

    pub fn clear_requesting_app_id(&mut self) {
        self.requesting_app_id = ::std::option::Option::None;
    }

    pub fn has_requesting_app_id(&self) -> bool {
        self.requesting_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requesting_app_id(&mut self, v: u32) {
        self.requesting_app_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_SetAppChatRoomGroupForceActive_Request {
    const NAME: &'static str = "CChatRoom_SetAppChatRoomGroupForceActive_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.requesting_app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.requesting_app_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.requesting_app_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SetAppChatRoomGroupForceActive_Request {
        CChatRoom_SetAppChatRoomGroupForceActive_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.requesting_app_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SetAppChatRoomGroupForceActive_Request {
        static instance: CChatRoom_SetAppChatRoomGroupForceActive_Request = CChatRoom_SetAppChatRoomGroupForceActive_Request {
            chat_group_id: ::std::option::Option::None,
            requesting_app_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoom_SetAppChatRoomGroupForceActive_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SetAppChatRoomGroupForceActive_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_SetAppChatRoomGroupForceActive_Response.result)
    pub result: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_SetAppChatRoomGroupForceActive_Response.accounts_in_channel)
    pub accounts_in_channel: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SetAppChatRoomGroupForceActive_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetAppChatRoomGroupForceActive_Response {
    fn default() -> &'a CChatRoom_SetAppChatRoomGroupForceActive_Response {
        <CChatRoom_SetAppChatRoomGroupForceActive_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetAppChatRoomGroupForceActive_Response {
    pub fn new() -> CChatRoom_SetAppChatRoomGroupForceActive_Response {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_SetAppChatRoomGroupForceActive_Response {
    const NAME: &'static str = "CChatRoom_SetAppChatRoomGroupForceActive_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.accounts_in_channel)?;
                },
                16 => {
                    self.accounts_in_channel.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.accounts_in_channel {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        for v in &self.accounts_in_channel {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SetAppChatRoomGroupForceActive_Response {
        CChatRoom_SetAppChatRoomGroupForceActive_Response::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.accounts_in_channel.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SetAppChatRoomGroupForceActive_Response {
        static instance: CChatRoom_SetAppChatRoomGroupForceActive_Response = CChatRoom_SetAppChatRoomGroupForceActive_Response {
            result: ::std::option::Option::None,
            accounts_in_channel: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "If a group chat is forced active (see SetAppChatRoomGroupForceActive), decrement the force count"]
// @@protoc_insertion_point(message:CChatRoom_SetAppChatRoomGroupStopForceActive_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_SetAppChatRoomGroupStopForceActive_Notification.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_SetAppChatRoomGroupStopForceActive_Notification.requesting_app_id)
    pub requesting_app_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SetAppChatRoomGroupStopForceActive_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
    fn default() -> &'a CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
        <CChatRoom_SetAppChatRoomGroupStopForceActive_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
    pub fn new() -> CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint32 requesting_app_id = 2;

    pub fn requesting_app_id(&self) -> u32 {
        self.requesting_app_id.unwrap_or(0)
    }

    pub fn clear_requesting_app_id(&mut self) {
        self.requesting_app_id = ::std::option::Option::None;
    }

    pub fn has_requesting_app_id(&self) -> bool {
        self.requesting_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requesting_app_id(&mut self, v: u32) {
        self.requesting_app_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
    const NAME: &'static str = "CChatRoom_SetAppChatRoomGroupStopForceActive_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.requesting_app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.requesting_app_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.requesting_app_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
        CChatRoom_SetAppChatRoomGroupStopForceActive_Notification::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.requesting_app_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
        static instance: CChatRoom_SetAppChatRoomGroupStopForceActive_Notification = CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
            chat_group_id: ::std::option::Option::None,
            requesting_app_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "A session acked an unread message, echo to other sessions."]
// @@protoc_insertion_point(message:CChatRoom_AckChatMessage_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_AckChatMessage_Notification {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_AckChatMessage_Notification.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_AckChatMessage_Notification.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_AckChatMessage_Notification.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_AckChatMessage_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_AckChatMessage_Notification {
    fn default() -> &'a CChatRoom_AckChatMessage_Notification {
        <CChatRoom_AckChatMessage_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_AckChatMessage_Notification {
    pub fn new() -> CChatRoom_AckChatMessage_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp = 3;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_AckChatMessage_Notification {
    const NAME: &'static str = "CChatRoom_AckChatMessage_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_AckChatMessage_Notification {
        CChatRoom_AckChatMessage_Notification::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_AckChatMessage_Notification {
        static instance: CChatRoom_AckChatMessage_Notification = CChatRoom_AckChatMessage_Notification {
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Creates a chatroom invite link"]
// @@protoc_insertion_point(message:CChatRoom_CreateInviteLink_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_CreateInviteLink_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_CreateInviteLink_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_CreateInviteLink_Request.seconds_valid)
    pub seconds_valid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_CreateInviteLink_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_CreateInviteLink_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_CreateInviteLink_Request {
    fn default() -> &'a CChatRoom_CreateInviteLink_Request {
        <CChatRoom_CreateInviteLink_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_CreateInviteLink_Request {
    pub fn new() -> CChatRoom_CreateInviteLink_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_valid = 2;

    pub fn seconds_valid(&self) -> u32 {
        self.seconds_valid.unwrap_or(0)
    }

    pub fn clear_seconds_valid(&mut self) {
        self.seconds_valid = ::std::option::Option::None;
    }

    pub fn has_seconds_valid(&self) -> bool {
        self.seconds_valid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_valid(&mut self, v: u32) {
        self.seconds_valid = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 3;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_CreateInviteLink_Request {
    const NAME: &'static str = "CChatRoom_CreateInviteLink_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.seconds_valid = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.seconds_valid {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.seconds_valid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_CreateInviteLink_Request {
        CChatRoom_CreateInviteLink_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.seconds_valid = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_CreateInviteLink_Request {
        static instance: CChatRoom_CreateInviteLink_Request = CChatRoom_CreateInviteLink_Request {
            chat_group_id: ::std::option::Option::None,
            seconds_valid: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoom_CreateInviteLink_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_CreateInviteLink_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_CreateInviteLink_Response.invite_code)
    pub invite_code: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoom_CreateInviteLink_Response.seconds_valid)
    pub seconds_valid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_CreateInviteLink_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_CreateInviteLink_Response {
    fn default() -> &'a CChatRoom_CreateInviteLink_Response {
        <CChatRoom_CreateInviteLink_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_CreateInviteLink_Response {
    pub fn new() -> CChatRoom_CreateInviteLink_Response {
        ::std::default::Default::default()
    }

    // optional string invite_code = 1;

    pub fn invite_code(&self) -> &str {
        match self.invite_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_invite_code(&mut self) {
        self.invite_code = ::std::option::Option::None;
    }

    pub fn has_invite_code(&self) -> bool {
        self.invite_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invite_code(&mut self, v: ::std::string::String) {
        self.invite_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_invite_code(&mut self) -> &mut ::std::string::String {
        if self.invite_code.is_none() {
            self.invite_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.invite_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_invite_code(&mut self) -> ::std::string::String {
        self.invite_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 seconds_valid = 2;

    pub fn seconds_valid(&self) -> u32 {
        self.seconds_valid.unwrap_or(0)
    }

    pub fn clear_seconds_valid(&mut self) {
        self.seconds_valid = ::std::option::Option::None;
    }

    pub fn has_seconds_valid(&self) -> bool {
        self.seconds_valid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_valid(&mut self, v: u32) {
        self.seconds_valid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_CreateInviteLink_Response {
    const NAME: &'static str = "CChatRoom_CreateInviteLink_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.invite_code = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.seconds_valid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.invite_code.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.seconds_valid {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.invite_code.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.seconds_valid {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_CreateInviteLink_Response {
        CChatRoom_CreateInviteLink_Response::new()
    }

    fn clear(&mut self) {
        self.invite_code = ::std::option::Option::None;
        self.seconds_valid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_CreateInviteLink_Response {
        static instance: CChatRoom_CreateInviteLink_Response = CChatRoom_CreateInviteLink_Response {
            invite_code: ::std::option::Option::None,
            seconds_valid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Returns chat room info about provided link"]
// @@protoc_insertion_point(message:CChatRoom_GetInviteLinkInfo_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetInviteLinkInfo_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetInviteLinkInfo_Request.invite_code)
    pub invite_code: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetInviteLinkInfo_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetInviteLinkInfo_Request {
    fn default() -> &'a CChatRoom_GetInviteLinkInfo_Request {
        <CChatRoom_GetInviteLinkInfo_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetInviteLinkInfo_Request {
    pub fn new() -> CChatRoom_GetInviteLinkInfo_Request {
        ::std::default::Default::default()
    }

    // optional string invite_code = 1;

    pub fn invite_code(&self) -> &str {
        match self.invite_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_invite_code(&mut self) {
        self.invite_code = ::std::option::Option::None;
    }

    pub fn has_invite_code(&self) -> bool {
        self.invite_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invite_code(&mut self, v: ::std::string::String) {
        self.invite_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_invite_code(&mut self) -> &mut ::std::string::String {
        if self.invite_code.is_none() {
            self.invite_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.invite_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_invite_code(&mut self) -> ::std::string::String {
        self.invite_code.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CChatRoom_GetInviteLinkInfo_Request {
    const NAME: &'static str = "CChatRoom_GetInviteLinkInfo_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.invite_code = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.invite_code.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.invite_code.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetInviteLinkInfo_Request {
        CChatRoom_GetInviteLinkInfo_Request::new()
    }

    fn clear(&mut self) {
        self.invite_code = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetInviteLinkInfo_Request {
        static instance: CChatRoom_GetInviteLinkInfo_Request = CChatRoom_GetInviteLinkInfo_Request {
            invite_code: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoom_GetInviteLinkInfo_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetInviteLinkInfo_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetInviteLinkInfo_Response.steamid_sender)
    pub steamid_sender: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetInviteLinkInfo_Response.time_expires)
    pub time_expires: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_GetInviteLinkInfo_Response.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetInviteLinkInfo_Response.group_summary)
    pub group_summary: ::protobuf::MessageField<CChatRoom_GetChatRoomGroupSummary_Response>,
    // @@protoc_insertion_point(field:CChatRoom_GetInviteLinkInfo_Response.user_chat_group_state)
    pub user_chat_group_state: ::protobuf::MessageField<CUserChatRoomGroupState>,
    // @@protoc_insertion_point(field:CChatRoom_GetInviteLinkInfo_Response.time_kick_expire)
    pub time_kick_expire: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_GetInviteLinkInfo_Response.banned)
    pub banned: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetInviteLinkInfo_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetInviteLinkInfo_Response {
    fn default() -> &'a CChatRoom_GetInviteLinkInfo_Response {
        <CChatRoom_GetInviteLinkInfo_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetInviteLinkInfo_Response {
    pub fn new() -> CChatRoom_GetInviteLinkInfo_Response {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_sender = 3;

    pub fn steamid_sender(&self) -> u64 {
        self.steamid_sender.unwrap_or(0)
    }

    pub fn clear_steamid_sender(&mut self) {
        self.steamid_sender = ::std::option::Option::None;
    }

    pub fn has_steamid_sender(&self) -> bool {
        self.steamid_sender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_sender(&mut self, v: u64) {
        self.steamid_sender = ::std::option::Option::Some(v);
    }

    // optional uint32 time_expires = 4;

    pub fn time_expires(&self) -> u32 {
        self.time_expires.unwrap_or(0)
    }

    pub fn clear_time_expires(&mut self) {
        self.time_expires = ::std::option::Option::None;
    }

    pub fn has_time_expires(&self) -> bool {
        self.time_expires.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_expires(&mut self, v: u32) {
        self.time_expires = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 6;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional uint32 time_kick_expire = 10;

    pub fn time_kick_expire(&self) -> u32 {
        self.time_kick_expire.unwrap_or(0)
    }

    pub fn clear_time_kick_expire(&mut self) {
        self.time_kick_expire = ::std::option::Option::None;
    }

    pub fn has_time_kick_expire(&self) -> bool {
        self.time_kick_expire.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_kick_expire(&mut self, v: u32) {
        self.time_kick_expire = ::std::option::Option::Some(v);
    }

    // optional bool banned = 11;

    pub fn banned(&self) -> bool {
        self.banned.unwrap_or(false)
    }

    pub fn clear_banned(&mut self) {
        self.banned = ::std::option::Option::None;
    }

    pub fn has_banned(&self) -> bool {
        self.banned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_banned(&mut self, v: bool) {
        self.banned = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_GetInviteLinkInfo_Response {
    const NAME: &'static str = "CChatRoom_GetInviteLinkInfo_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                25 => {
                    self.steamid_sender = ::std::option::Option::Some(is.read_fixed64()?);
                },
                32 => {
                    self.time_expires = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.group_summary)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_chat_group_state)?;
                },
                80 => {
                    self.time_kick_expire = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.banned = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_sender {
            my_size += 1 + 8;
        }
        if let Some(v) = self.time_expires {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::uint64_size(6, v);
        }
        if let Some(v) = self.group_summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.user_chat_group_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.time_kick_expire {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.banned {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid_sender {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.time_expires {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.group_summary.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.user_chat_group_state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.time_kick_expire {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.banned {
            os.write_bool(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetInviteLinkInfo_Response {
        CChatRoom_GetInviteLinkInfo_Response::new()
    }

    fn clear(&mut self) {
        self.steamid_sender = ::std::option::Option::None;
        self.time_expires = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.group_summary.clear();
        self.user_chat_group_state.clear();
        self.time_kick_expire = ::std::option::Option::None;
        self.banned = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetInviteLinkInfo_Response {
        static instance: CChatRoom_GetInviteLinkInfo_Response = CChatRoom_GetInviteLinkInfo_Response {
            steamid_sender: ::std::option::Option::None,
            time_expires: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            group_summary: ::protobuf::MessageField::none(),
            user_chat_group_state: ::protobuf::MessageField::none(),
            time_kick_expire: ::std::option::Option::None,
            banned: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Returns chat room info about any invite involving the sender and passed group id"]
// @@protoc_insertion_point(message:CChatRoom_GetInviteInfo_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetInviteInfo_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetInviteInfo_Request.steamid_invitee)
    pub steamid_invitee: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetInviteInfo_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetInviteInfo_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetInviteInfo_Request.invite_code)
    pub invite_code: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetInviteInfo_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetInviteInfo_Request {
    fn default() -> &'a CChatRoom_GetInviteInfo_Request {
        <CChatRoom_GetInviteInfo_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetInviteInfo_Request {
    pub fn new() -> CChatRoom_GetInviteInfo_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_invitee = 1;

    pub fn steamid_invitee(&self) -> u64 {
        self.steamid_invitee.unwrap_or(0)
    }

    pub fn clear_steamid_invitee(&mut self) {
        self.steamid_invitee = ::std::option::Option::None;
    }

    pub fn has_steamid_invitee(&self) -> bool {
        self.steamid_invitee.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_invitee(&mut self, v: u64) {
        self.steamid_invitee = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_group_id = 2;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 3;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional string invite_code = 4;

    pub fn invite_code(&self) -> &str {
        match self.invite_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_invite_code(&mut self) {
        self.invite_code = ::std::option::Option::None;
    }

    pub fn has_invite_code(&self) -> bool {
        self.invite_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invite_code(&mut self, v: ::std::string::String) {
        self.invite_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_invite_code(&mut self) -> &mut ::std::string::String {
        if self.invite_code.is_none() {
            self.invite_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.invite_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_invite_code(&mut self) -> ::std::string::String {
        self.invite_code.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CChatRoom_GetInviteInfo_Request {
    const NAME: &'static str = "CChatRoom_GetInviteInfo_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid_invitee = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                34 => {
                    self.invite_code = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_invitee {
            my_size += 1 + 8;
        }
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.invite_code.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid_invitee {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.chat_group_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.invite_code.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetInviteInfo_Request {
        CChatRoom_GetInviteInfo_Request::new()
    }

    fn clear(&mut self) {
        self.steamid_invitee = ::std::option::Option::None;
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.invite_code = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetInviteInfo_Request {
        static instance: CChatRoom_GetInviteInfo_Request = CChatRoom_GetInviteInfo_Request {
            steamid_invitee: ::std::option::Option::None,
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            invite_code: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoom_GetInviteInfo_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetInviteInfo_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetInviteInfo_Response.group_summary)
    pub group_summary: ::protobuf::MessageField<CChatRoom_GetChatRoomGroupSummary_Response>,
    // @@protoc_insertion_point(field:CChatRoom_GetInviteInfo_Response.time_kick_expire)
    pub time_kick_expire: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_GetInviteInfo_Response.banned)
    pub banned: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetInviteInfo_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetInviteInfo_Response {
    fn default() -> &'a CChatRoom_GetInviteInfo_Response {
        <CChatRoom_GetInviteInfo_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetInviteInfo_Response {
    pub fn new() -> CChatRoom_GetInviteInfo_Response {
        ::std::default::Default::default()
    }

    // optional uint32 time_kick_expire = 2;

    pub fn time_kick_expire(&self) -> u32 {
        self.time_kick_expire.unwrap_or(0)
    }

    pub fn clear_time_kick_expire(&mut self) {
        self.time_kick_expire = ::std::option::Option::None;
    }

    pub fn has_time_kick_expire(&self) -> bool {
        self.time_kick_expire.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_kick_expire(&mut self, v: u32) {
        self.time_kick_expire = ::std::option::Option::Some(v);
    }

    // optional bool banned = 3;

    pub fn banned(&self) -> bool {
        self.banned.unwrap_or(false)
    }

    pub fn clear_banned(&mut self) {
        self.banned = ::std::option::Option::None;
    }

    pub fn has_banned(&self) -> bool {
        self.banned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_banned(&mut self, v: bool) {
        self.banned = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_GetInviteInfo_Response {
    const NAME: &'static str = "CChatRoom_GetInviteInfo_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.group_summary)?;
                },
                16 => {
                    self.time_kick_expire = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.banned = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.group_summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.time_kick_expire {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.banned {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.group_summary.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.time_kick_expire {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.banned {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetInviteInfo_Response {
        CChatRoom_GetInviteInfo_Response::new()
    }

    fn clear(&mut self) {
        self.group_summary.clear();
        self.time_kick_expire = ::std::option::Option::None;
        self.banned = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetInviteInfo_Response {
        static instance: CChatRoom_GetInviteInfo_Response = CChatRoom_GetInviteInfo_Response {
            group_summary: ::protobuf::MessageField::none(),
            time_kick_expire: ::std::option::Option::None,
            banned: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Returns all invite links for the specified group"]
// @@protoc_insertion_point(message:CChatRoom_GetInviteLinksForGroup_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetInviteLinksForGroup_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetInviteLinksForGroup_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetInviteLinksForGroup_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetInviteLinksForGroup_Request {
    fn default() -> &'a CChatRoom_GetInviteLinksForGroup_Request {
        <CChatRoom_GetInviteLinksForGroup_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetInviteLinksForGroup_Request {
    pub fn new() -> CChatRoom_GetInviteLinksForGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_GetInviteLinksForGroup_Request {
    const NAME: &'static str = "CChatRoom_GetInviteLinksForGroup_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetInviteLinksForGroup_Request {
        CChatRoom_GetInviteLinksForGroup_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetInviteLinksForGroup_Request {
        static instance: CChatRoom_GetInviteLinksForGroup_Request = CChatRoom_GetInviteLinksForGroup_Request {
            chat_group_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoom_GetInviteLinksForGroup_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetInviteLinksForGroup_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetInviteLinksForGroup_Response.invite_links)
    pub invite_links: ::std::vec::Vec<cchat_room_get_invite_links_for_group_response::LinkInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetInviteLinksForGroup_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetInviteLinksForGroup_Response {
    fn default() -> &'a CChatRoom_GetInviteLinksForGroup_Response {
        <CChatRoom_GetInviteLinksForGroup_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetInviteLinksForGroup_Response {
    pub fn new() -> CChatRoom_GetInviteLinksForGroup_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_GetInviteLinksForGroup_Response {
    const NAME: &'static str = "CChatRoom_GetInviteLinksForGroup_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.invite_links.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.invite_links {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.invite_links {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetInviteLinksForGroup_Response {
        CChatRoom_GetInviteLinksForGroup_Response::new()
    }

    fn clear(&mut self) {
        self.invite_links.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetInviteLinksForGroup_Response {
        static instance: CChatRoom_GetInviteLinksForGroup_Response = CChatRoom_GetInviteLinksForGroup_Response {
            invite_links: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CChatRoom_GetInviteLinksForGroup_Response`
pub mod cchat_room_get_invite_links_for_group_response {
    // @@protoc_insertion_point(message:CChatRoom_GetInviteLinksForGroup_Response.LinkInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LinkInfo {
        // message fields
        // @@protoc_insertion_point(field:CChatRoom_GetInviteLinksForGroup_Response.LinkInfo.invite_code)
        pub invite_code: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CChatRoom_GetInviteLinksForGroup_Response.LinkInfo.steamid_creator)
        pub steamid_creator: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CChatRoom_GetInviteLinksForGroup_Response.LinkInfo.time_expires)
        pub time_expires: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CChatRoom_GetInviteLinksForGroup_Response.LinkInfo.chat_id)
        pub chat_id: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CChatRoom_GetInviteLinksForGroup_Response.LinkInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LinkInfo {
        fn default() -> &'a LinkInfo {
            <LinkInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl LinkInfo {
        pub fn new() -> LinkInfo {
            ::std::default::Default::default()
        }

        // optional string invite_code = 1;

        pub fn invite_code(&self) -> &str {
            match self.invite_code.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_invite_code(&mut self) {
            self.invite_code = ::std::option::Option::None;
        }

        pub fn has_invite_code(&self) -> bool {
            self.invite_code.is_some()
        }

        // Param is passed by value, moved
        pub fn set_invite_code(&mut self, v: ::std::string::String) {
            self.invite_code = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_invite_code(&mut self) -> &mut ::std::string::String {
            if self.invite_code.is_none() {
                self.invite_code = ::std::option::Option::Some(::std::string::String::new());
            }
            self.invite_code.as_mut().unwrap()
        }

        // Take field
        pub fn take_invite_code(&mut self) -> ::std::string::String {
            self.invite_code.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional fixed64 steamid_creator = 2;

        pub fn steamid_creator(&self) -> u64 {
            self.steamid_creator.unwrap_or(0)
        }

        pub fn clear_steamid_creator(&mut self) {
            self.steamid_creator = ::std::option::Option::None;
        }

        pub fn has_steamid_creator(&self) -> bool {
            self.steamid_creator.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steamid_creator(&mut self, v: u64) {
            self.steamid_creator = ::std::option::Option::Some(v);
        }

        // optional uint32 time_expires = 3;

        pub fn time_expires(&self) -> u32 {
            self.time_expires.unwrap_or(0)
        }

        pub fn clear_time_expires(&mut self) {
            self.time_expires = ::std::option::Option::None;
        }

        pub fn has_time_expires(&self) -> bool {
            self.time_expires.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_expires(&mut self, v: u32) {
            self.time_expires = ::std::option::Option::Some(v);
        }

        // optional uint64 chat_id = 4;

        pub fn chat_id(&self) -> u64 {
            self.chat_id.unwrap_or(0)
        }

        pub fn clear_chat_id(&mut self) {
            self.chat_id = ::std::option::Option::None;
        }

        pub fn has_chat_id(&self) -> bool {
            self.chat_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_chat_id(&mut self, v: u64) {
            self.chat_id = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for LinkInfo {
        const NAME: &'static str = "LinkInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.invite_code = ::std::option::Option::Some(is.read_string()?);
                    },
                    17 => {
                        self.steamid_creator = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    24 => {
                        self.time_expires = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.invite_code.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.steamid_creator {
                my_size += 1 + 8;
            }
            if let Some(v) = self.time_expires {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.chat_id {
                my_size += ::protobuf::rt::uint64_size(4, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.invite_code.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.steamid_creator {
                os.write_fixed64(2, v)?;
            }
            if let Some(v) = self.time_expires {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.chat_id {
                os.write_uint64(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LinkInfo {
            LinkInfo::new()
        }

        fn clear(&mut self) {
            self.invite_code = ::std::option::Option::None;
            self.steamid_creator = ::std::option::Option::None;
            self.time_expires = ::std::option::Option::None;
            self.chat_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LinkInfo {
            static instance: LinkInfo = LinkInfo {
                invite_code: ::std::option::Option::None,
                steamid_creator: ::std::option::Option::None,
                time_expires: ::std::option::Option::None,
                chat_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

#[doc = "Gets a list of users who have been banned from a chat room"]
// @@protoc_insertion_point(message:CChatRoom_GetBanList_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetBanList_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetBanList_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetBanList_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetBanList_Request {
    fn default() -> &'a CChatRoom_GetBanList_Request {
        <CChatRoom_GetBanList_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetBanList_Request {
    pub fn new() -> CChatRoom_GetBanList_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_GetBanList_Request {
    const NAME: &'static str = "CChatRoom_GetBanList_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetBanList_Request {
        CChatRoom_GetBanList_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetBanList_Request {
        static instance: CChatRoom_GetBanList_Request = CChatRoom_GetBanList_Request {
            chat_group_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoom_GetBanList_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetBanList_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetBanList_Response.bans)
    pub bans: ::std::vec::Vec<cchat_room_get_ban_list_response::BanInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetBanList_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetBanList_Response {
    fn default() -> &'a CChatRoom_GetBanList_Response {
        <CChatRoom_GetBanList_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetBanList_Response {
    pub fn new() -> CChatRoom_GetBanList_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_GetBanList_Response {
    const NAME: &'static str = "CChatRoom_GetBanList_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.bans.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.bans {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.bans {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetBanList_Response {
        CChatRoom_GetBanList_Response::new()
    }

    fn clear(&mut self) {
        self.bans.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetBanList_Response {
        static instance: CChatRoom_GetBanList_Response = CChatRoom_GetBanList_Response {
            bans: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CChatRoom_GetBanList_Response`
pub mod cchat_room_get_ban_list_response {
    // @@protoc_insertion_point(message:CChatRoom_GetBanList_Response.BanInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct BanInfo {
        // message fields
        // @@protoc_insertion_point(field:CChatRoom_GetBanList_Response.BanInfo.accountid)
        pub accountid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CChatRoom_GetBanList_Response.BanInfo.accountid_actor)
        pub accountid_actor: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CChatRoom_GetBanList_Response.BanInfo.time_banned)
        pub time_banned: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CChatRoom_GetBanList_Response.BanInfo.ban_reason)
        pub ban_reason: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CChatRoom_GetBanList_Response.BanInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BanInfo {
        fn default() -> &'a BanInfo {
            <BanInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl BanInfo {
        pub fn new() -> BanInfo {
            ::std::default::Default::default()
        }

        // optional uint32 accountid = 1;

        pub fn accountid(&self) -> u32 {
            self.accountid.unwrap_or(0)
        }

        pub fn clear_accountid(&mut self) {
            self.accountid = ::std::option::Option::None;
        }

        pub fn has_accountid(&self) -> bool {
            self.accountid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_accountid(&mut self, v: u32) {
            self.accountid = ::std::option::Option::Some(v);
        }

        // optional uint32 accountid_actor = 2;

        pub fn accountid_actor(&self) -> u32 {
            self.accountid_actor.unwrap_or(0)
        }

        pub fn clear_accountid_actor(&mut self) {
            self.accountid_actor = ::std::option::Option::None;
        }

        pub fn has_accountid_actor(&self) -> bool {
            self.accountid_actor.is_some()
        }

        // Param is passed by value, moved
        pub fn set_accountid_actor(&mut self, v: u32) {
            self.accountid_actor = ::std::option::Option::Some(v);
        }

        // optional uint32 time_banned = 3;

        pub fn time_banned(&self) -> u32 {
            self.time_banned.unwrap_or(0)
        }

        pub fn clear_time_banned(&mut self) {
            self.time_banned = ::std::option::Option::None;
        }

        pub fn has_time_banned(&self) -> bool {
            self.time_banned.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_banned(&mut self, v: u32) {
            self.time_banned = ::std::option::Option::Some(v);
        }

        // optional string ban_reason = 4;

        pub fn ban_reason(&self) -> &str {
            match self.ban_reason.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_ban_reason(&mut self) {
            self.ban_reason = ::std::option::Option::None;
        }

        pub fn has_ban_reason(&self) -> bool {
            self.ban_reason.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ban_reason(&mut self, v: ::std::string::String) {
            self.ban_reason = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_ban_reason(&mut self) -> &mut ::std::string::String {
            if self.ban_reason.is_none() {
                self.ban_reason = ::std::option::Option::Some(::std::string::String::new());
            }
            self.ban_reason.as_mut().unwrap()
        }

        // Take field
        pub fn take_ban_reason(&mut self) -> ::std::string::String {
            self.ban_reason.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::protobuf::Message for BanInfo {
        const NAME: &'static str = "BanInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.accountid_actor = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.time_banned = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    34 => {
                        self.ban_reason = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.accountid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.accountid_actor {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.time_banned {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.ban_reason.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.accountid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.accountid_actor {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.time_banned {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.ban_reason.as_ref() {
                os.write_string(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BanInfo {
            BanInfo::new()
        }

        fn clear(&mut self) {
            self.accountid = ::std::option::Option::None;
            self.accountid_actor = ::std::option::Option::None;
            self.time_banned = ::std::option::Option::None;
            self.ban_reason = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BanInfo {
            static instance: BanInfo = BanInfo {
                accountid: ::std::option::Option::None,
                accountid_actor: ::std::option::Option::None,
                time_banned: ::std::option::Option::None,
                ban_reason: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

#[doc = "Gets a list of users who have been invited to a chat room"]
// @@protoc_insertion_point(message:CChatRoom_GetInviteList_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetInviteList_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetInviteList_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetInviteList_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetInviteList_Request {
    fn default() -> &'a CChatRoom_GetInviteList_Request {
        <CChatRoom_GetInviteList_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetInviteList_Request {
    pub fn new() -> CChatRoom_GetInviteList_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_GetInviteList_Request {
    const NAME: &'static str = "CChatRoom_GetInviteList_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetInviteList_Request {
        CChatRoom_GetInviteList_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetInviteList_Request {
        static instance: CChatRoom_GetInviteList_Request = CChatRoom_GetInviteList_Request {
            chat_group_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoomGroupInvite)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoomGroupInvite {
    // message fields
    // @@protoc_insertion_point(field:CChatRoomGroupInvite.accountid)
    pub accountid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoomGroupInvite.accountid_actor)
    pub accountid_actor: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoomGroupInvite.time_invited)
    pub time_invited: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoomGroupInvite.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoomGroupInvite {
    fn default() -> &'a CChatRoomGroupInvite {
        <CChatRoomGroupInvite as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoomGroupInvite {
    pub fn new() -> CChatRoomGroupInvite {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;

    pub fn accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional uint32 accountid_actor = 2;

    pub fn accountid_actor(&self) -> u32 {
        self.accountid_actor.unwrap_or(0)
    }

    pub fn clear_accountid_actor(&mut self) {
        self.accountid_actor = ::std::option::Option::None;
    }

    pub fn has_accountid_actor(&self) -> bool {
        self.accountid_actor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid_actor(&mut self, v: u32) {
        self.accountid_actor = ::std::option::Option::Some(v);
    }

    // optional uint32 time_invited = 3;

    pub fn time_invited(&self) -> u32 {
        self.time_invited.unwrap_or(0)
    }

    pub fn clear_time_invited(&mut self) {
        self.time_invited = ::std::option::Option::None;
    }

    pub fn has_time_invited(&self) -> bool {
        self.time_invited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_invited(&mut self, v: u32) {
        self.time_invited = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoomGroupInvite {
    const NAME: &'static str = "CChatRoomGroupInvite";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.accountid_actor = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.time_invited = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.accountid_actor {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.time_invited {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.accountid_actor {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.time_invited {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoomGroupInvite {
        CChatRoomGroupInvite::new()
    }

    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.accountid_actor = ::std::option::Option::None;
        self.time_invited = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoomGroupInvite {
        static instance: CChatRoomGroupInvite = CChatRoomGroupInvite {
            accountid: ::std::option::Option::None,
            accountid_actor: ::std::option::Option::None,
            time_invited: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoom_GetInviteList_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetInviteList_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetInviteList_Response.invites)
    pub invites: ::std::vec::Vec<CChatRoomGroupInvite>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetInviteList_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetInviteList_Response {
    fn default() -> &'a CChatRoom_GetInviteList_Response {
        <CChatRoom_GetInviteList_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetInviteList_Response {
    pub fn new() -> CChatRoom_GetInviteList_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_GetInviteList_Response {
    const NAME: &'static str = "CChatRoom_GetInviteList_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.invites.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.invites {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.invites {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetInviteList_Response {
        CChatRoom_GetInviteList_Response::new()
    }

    fn clear(&mut self) {
        self.invites.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetInviteList_Response {
        static instance: CChatRoom_GetInviteList_Response = CChatRoom_GetInviteList_Response {
            invites: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Deletes specified invite link"]
// @@protoc_insertion_point(message:CChatRoom_DeleteInviteLink_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_DeleteInviteLink_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_DeleteInviteLink_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_DeleteInviteLink_Request.invite_code)
    pub invite_code: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_DeleteInviteLink_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteInviteLink_Request {
    fn default() -> &'a CChatRoom_DeleteInviteLink_Request {
        <CChatRoom_DeleteInviteLink_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_DeleteInviteLink_Request {
    pub fn new() -> CChatRoom_DeleteInviteLink_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional string invite_code = 2;

    pub fn invite_code(&self) -> &str {
        match self.invite_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_invite_code(&mut self) {
        self.invite_code = ::std::option::Option::None;
    }

    pub fn has_invite_code(&self) -> bool {
        self.invite_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invite_code(&mut self, v: ::std::string::String) {
        self.invite_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_invite_code(&mut self) -> &mut ::std::string::String {
        if self.invite_code.is_none() {
            self.invite_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.invite_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_invite_code(&mut self) -> ::std::string::String {
        self.invite_code.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CChatRoom_DeleteInviteLink_Request {
    const NAME: &'static str = "CChatRoom_DeleteInviteLink_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.invite_code = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.invite_code.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.invite_code.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_DeleteInviteLink_Request {
        CChatRoom_DeleteInviteLink_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.invite_code = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_DeleteInviteLink_Request {
        static instance: CChatRoom_DeleteInviteLink_Request = CChatRoom_DeleteInviteLink_Request {
            chat_group_id: ::std::option::Option::None,
            invite_code: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoom_DeleteInviteLink_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_DeleteInviteLink_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_DeleteInviteLink_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteInviteLink_Response {
    fn default() -> &'a CChatRoom_DeleteInviteLink_Response {
        <CChatRoom_DeleteInviteLink_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_DeleteInviteLink_Response {
    pub fn new() -> CChatRoom_DeleteInviteLink_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_DeleteInviteLink_Response {
    const NAME: &'static str = "CChatRoom_DeleteInviteLink_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_DeleteInviteLink_Response {
        CChatRoom_DeleteInviteLink_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_DeleteInviteLink_Response {
        static instance: CChatRoom_DeleteInviteLink_Response = CChatRoom_DeleteInviteLink_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Set which chat rooms we are using in the active session"]
// @@protoc_insertion_point(message:CChatRoom_SetSessionActiveChatRoomGroups_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SetSessionActiveChatRoomGroups_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_SetSessionActiveChatRoomGroups_Request.chat_group_ids)
    pub chat_group_ids: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CChatRoom_SetSessionActiveChatRoomGroups_Request.chat_groups_data_requested)
    pub chat_groups_data_requested: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CChatRoom_SetSessionActiveChatRoomGroups_Request.virtualize_members_threshold)
    pub virtualize_members_threshold: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SetSessionActiveChatRoomGroups_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetSessionActiveChatRoomGroups_Request {
    fn default() -> &'a CChatRoom_SetSessionActiveChatRoomGroups_Request {
        <CChatRoom_SetSessionActiveChatRoomGroups_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetSessionActiveChatRoomGroups_Request {
    pub fn new() -> CChatRoom_SetSessionActiveChatRoomGroups_Request {
        ::std::default::Default::default()
    }

    // optional int32 virtualize_members_threshold = 3;

    pub fn virtualize_members_threshold(&self) -> i32 {
        self.virtualize_members_threshold.unwrap_or(0)
    }

    pub fn clear_virtualize_members_threshold(&mut self) {
        self.virtualize_members_threshold = ::std::option::Option::None;
    }

    pub fn has_virtualize_members_threshold(&self) -> bool {
        self.virtualize_members_threshold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_virtualize_members_threshold(&mut self, v: i32) {
        self.virtualize_members_threshold = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_SetSessionActiveChatRoomGroups_Request {
    const NAME: &'static str = "CChatRoom_SetSessionActiveChatRoomGroups_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.chat_group_ids)?;
                },
                8 => {
                    self.chat_group_ids.push(is.read_uint64()?);
                },
                18 => {
                    is.read_repeated_packed_uint64_into(&mut self.chat_groups_data_requested)?;
                },
                16 => {
                    self.chat_groups_data_requested.push(is.read_uint64()?);
                },
                24 => {
                    self.virtualize_members_threshold = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.chat_group_ids {
            my_size += ::protobuf::rt::uint64_size(1, *value);
        };
        for value in &self.chat_groups_data_requested {
            my_size += ::protobuf::rt::uint64_size(2, *value);
        };
        if let Some(v) = self.virtualize_members_threshold {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.chat_group_ids {
            os.write_uint64(1, *v)?;
        };
        for v in &self.chat_groups_data_requested {
            os.write_uint64(2, *v)?;
        };
        if let Some(v) = self.virtualize_members_threshold {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SetSessionActiveChatRoomGroups_Request {
        CChatRoom_SetSessionActiveChatRoomGroups_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_ids.clear();
        self.chat_groups_data_requested.clear();
        self.virtualize_members_threshold = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SetSessionActiveChatRoomGroups_Request {
        static instance: CChatRoom_SetSessionActiveChatRoomGroups_Request = CChatRoom_SetSessionActiveChatRoomGroups_Request {
            chat_group_ids: ::std::vec::Vec::new(),
            chat_groups_data_requested: ::std::vec::Vec::new(),
            virtualize_members_threshold: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoom_SetSessionActiveChatRoomGroups_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SetSessionActiveChatRoomGroups_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_SetSessionActiveChatRoomGroups_Response.chat_states)
    pub chat_states: ::std::vec::Vec<CChatRoomGroupState>,
    // @@protoc_insertion_point(field:CChatRoom_SetSessionActiveChatRoomGroups_Response.virtualize_members_chat_group_ids)
    pub virtualize_members_chat_group_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SetSessionActiveChatRoomGroups_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetSessionActiveChatRoomGroups_Response {
    fn default() -> &'a CChatRoom_SetSessionActiveChatRoomGroups_Response {
        <CChatRoom_SetSessionActiveChatRoomGroups_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetSessionActiveChatRoomGroups_Response {
    pub fn new() -> CChatRoom_SetSessionActiveChatRoomGroups_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_SetSessionActiveChatRoomGroups_Response {
    const NAME: &'static str = "CChatRoom_SetSessionActiveChatRoomGroups_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.chat_states.push(is.read_message()?);
                },
                18 => {
                    is.read_repeated_packed_uint64_into(&mut self.virtualize_members_chat_group_ids)?;
                },
                16 => {
                    self.virtualize_members_chat_group_ids.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.chat_states {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.virtualize_members_chat_group_ids {
            my_size += ::protobuf::rt::uint64_size(2, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.chat_states {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.virtualize_members_chat_group_ids {
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SetSessionActiveChatRoomGroups_Response {
        CChatRoom_SetSessionActiveChatRoomGroups_Response::new()
    }

    fn clear(&mut self) {
        self.chat_states.clear();
        self.virtualize_members_chat_group_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SetSessionActiveChatRoomGroups_Response {
        static instance: CChatRoom_SetSessionActiveChatRoomGroups_Response = CChatRoom_SetSessionActiveChatRoomGroups_Response {
            chat_states: ::std::vec::Vec::new(),
            virtualize_members_chat_group_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Set preferences around chat notifications for a group"]
// @@protoc_insertion_point(message:CChatRoom_SetUserChatGroupPreferences_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SetUserChatGroupPreferences_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_SetUserChatGroupPreferences_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_SetUserChatGroupPreferences_Request.chat_group_preferences)
    pub chat_group_preferences: ::protobuf::MessageField<cchat_room_set_user_chat_group_preferences_request::ChatGroupPreferences>,
    // @@protoc_insertion_point(field:CChatRoom_SetUserChatGroupPreferences_Request.chat_room_preferences)
    pub chat_room_preferences: ::std::vec::Vec<cchat_room_set_user_chat_group_preferences_request::ChatRoomPreferences>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SetUserChatGroupPreferences_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetUserChatGroupPreferences_Request {
    fn default() -> &'a CChatRoom_SetUserChatGroupPreferences_Request {
        <CChatRoom_SetUserChatGroupPreferences_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetUserChatGroupPreferences_Request {
    pub fn new() -> CChatRoom_SetUserChatGroupPreferences_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_SetUserChatGroupPreferences_Request {
    const NAME: &'static str = "CChatRoom_SetUserChatGroupPreferences_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.chat_group_preferences)?;
                },
                26 => {
                    self.chat_room_preferences.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_group_preferences.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.chat_room_preferences {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_group_preferences.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.chat_room_preferences {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SetUserChatGroupPreferences_Request {
        CChatRoom_SetUserChatGroupPreferences_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_group_preferences.clear();
        self.chat_room_preferences.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SetUserChatGroupPreferences_Request {
        static instance: CChatRoom_SetUserChatGroupPreferences_Request = CChatRoom_SetUserChatGroupPreferences_Request {
            chat_group_id: ::std::option::Option::None,
            chat_group_preferences: ::protobuf::MessageField::none(),
            chat_room_preferences: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CChatRoom_SetUserChatGroupPreferences_Request`
pub mod cchat_room_set_user_chat_group_preferences_request {
    // @@protoc_insertion_point(message:CChatRoom_SetUserChatGroupPreferences_Request.ChatGroupPreferences)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ChatGroupPreferences {
        // message fields
        // @@protoc_insertion_point(field:CChatRoom_SetUserChatGroupPreferences_Request.ChatGroupPreferences.desktop_notification_level)
        pub desktop_notification_level: ::std::option::Option<::protobuf::EnumOrUnknown<super::EChatRoomNotificationLevel>>,
        // @@protoc_insertion_point(field:CChatRoom_SetUserChatGroupPreferences_Request.ChatGroupPreferences.mobile_notification_level)
        pub mobile_notification_level: ::std::option::Option<::protobuf::EnumOrUnknown<super::EChatRoomNotificationLevel>>,
        // @@protoc_insertion_point(field:CChatRoom_SetUserChatGroupPreferences_Request.ChatGroupPreferences.unread_indicator_muted)
        pub unread_indicator_muted: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CChatRoom_SetUserChatGroupPreferences_Request.ChatGroupPreferences.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ChatGroupPreferences {
        fn default() -> &'a ChatGroupPreferences {
            <ChatGroupPreferences as ::protobuf::Message>::default_instance()
        }
    }

    impl ChatGroupPreferences {
        pub fn new() -> ChatGroupPreferences {
            ::std::default::Default::default()
        }

        // optional .EChatRoomNotificationLevel desktop_notification_level = 1;

        pub fn desktop_notification_level(&self) -> super::EChatRoomNotificationLevel {
            match self.desktop_notification_level {
                Some(e) => e.enum_value_or(super::EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid),
                None => super::EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid,
            }
        }

        pub fn clear_desktop_notification_level(&mut self) {
            self.desktop_notification_level = ::std::option::Option::None;
        }

        pub fn has_desktop_notification_level(&self) -> bool {
            self.desktop_notification_level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_desktop_notification_level(&mut self, v: super::EChatRoomNotificationLevel) {
            self.desktop_notification_level = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional .EChatRoomNotificationLevel mobile_notification_level = 2;

        pub fn mobile_notification_level(&self) -> super::EChatRoomNotificationLevel {
            match self.mobile_notification_level {
                Some(e) => e.enum_value_or(super::EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid),
                None => super::EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid,
            }
        }

        pub fn clear_mobile_notification_level(&mut self) {
            self.mobile_notification_level = ::std::option::Option::None;
        }

        pub fn has_mobile_notification_level(&self) -> bool {
            self.mobile_notification_level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_mobile_notification_level(&mut self, v: super::EChatRoomNotificationLevel) {
            self.mobile_notification_level = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional bool unread_indicator_muted = 3;

        pub fn unread_indicator_muted(&self) -> bool {
            self.unread_indicator_muted.unwrap_or(false)
        }

        pub fn clear_unread_indicator_muted(&mut self) {
            self.unread_indicator_muted = ::std::option::Option::None;
        }

        pub fn has_unread_indicator_muted(&self) -> bool {
            self.unread_indicator_muted.is_some()
        }

        // Param is passed by value, moved
        pub fn set_unread_indicator_muted(&mut self, v: bool) {
            self.unread_indicator_muted = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for ChatGroupPreferences {
        const NAME: &'static str = "ChatGroupPreferences";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.desktop_notification_level = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    16 => {
                        self.mobile_notification_level = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    24 => {
                        self.unread_indicator_muted = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.desktop_notification_level {
                my_size += ::protobuf::rt::int32_size(1, v.value());
            }
            if let Some(v) = self.mobile_notification_level {
                my_size += ::protobuf::rt::int32_size(2, v.value());
            }
            if let Some(v) = self.unread_indicator_muted {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.desktop_notification_level {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.mobile_notification_level {
                os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.unread_indicator_muted {
                os.write_bool(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ChatGroupPreferences {
            ChatGroupPreferences::new()
        }

        fn clear(&mut self) {
            self.desktop_notification_level = ::std::option::Option::None;
            self.mobile_notification_level = ::std::option::Option::None;
            self.unread_indicator_muted = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ChatGroupPreferences {
            static instance: ChatGroupPreferences = ChatGroupPreferences {
                desktop_notification_level: ::std::option::Option::None,
                mobile_notification_level: ::std::option::Option::None,
                unread_indicator_muted: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CChatRoom_SetUserChatGroupPreferences_Request.ChatRoomPreferences)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ChatRoomPreferences {
        // message fields
        // @@protoc_insertion_point(field:CChatRoom_SetUserChatGroupPreferences_Request.ChatRoomPreferences.chat_id)
        pub chat_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CChatRoom_SetUserChatGroupPreferences_Request.ChatRoomPreferences.desktop_notification_level)
        pub desktop_notification_level: ::std::option::Option<::protobuf::EnumOrUnknown<super::EChatRoomNotificationLevel>>,
        // @@protoc_insertion_point(field:CChatRoom_SetUserChatGroupPreferences_Request.ChatRoomPreferences.mobile_notification_level)
        pub mobile_notification_level: ::std::option::Option<::protobuf::EnumOrUnknown<super::EChatRoomNotificationLevel>>,
        // @@protoc_insertion_point(field:CChatRoom_SetUserChatGroupPreferences_Request.ChatRoomPreferences.unread_indicator_muted)
        pub unread_indicator_muted: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CChatRoom_SetUserChatGroupPreferences_Request.ChatRoomPreferences.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ChatRoomPreferences {
        fn default() -> &'a ChatRoomPreferences {
            <ChatRoomPreferences as ::protobuf::Message>::default_instance()
        }
    }

    impl ChatRoomPreferences {
        pub fn new() -> ChatRoomPreferences {
            ::std::default::Default::default()
        }

        // optional uint64 chat_id = 1;

        pub fn chat_id(&self) -> u64 {
            self.chat_id.unwrap_or(0)
        }

        pub fn clear_chat_id(&mut self) {
            self.chat_id = ::std::option::Option::None;
        }

        pub fn has_chat_id(&self) -> bool {
            self.chat_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_chat_id(&mut self, v: u64) {
            self.chat_id = ::std::option::Option::Some(v);
        }

        // optional .EChatRoomNotificationLevel desktop_notification_level = 2;

        pub fn desktop_notification_level(&self) -> super::EChatRoomNotificationLevel {
            match self.desktop_notification_level {
                Some(e) => e.enum_value_or(super::EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid),
                None => super::EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid,
            }
        }

        pub fn clear_desktop_notification_level(&mut self) {
            self.desktop_notification_level = ::std::option::Option::None;
        }

        pub fn has_desktop_notification_level(&self) -> bool {
            self.desktop_notification_level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_desktop_notification_level(&mut self, v: super::EChatRoomNotificationLevel) {
            self.desktop_notification_level = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional .EChatRoomNotificationLevel mobile_notification_level = 3;

        pub fn mobile_notification_level(&self) -> super::EChatRoomNotificationLevel {
            match self.mobile_notification_level {
                Some(e) => e.enum_value_or(super::EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid),
                None => super::EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid,
            }
        }

        pub fn clear_mobile_notification_level(&mut self) {
            self.mobile_notification_level = ::std::option::Option::None;
        }

        pub fn has_mobile_notification_level(&self) -> bool {
            self.mobile_notification_level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_mobile_notification_level(&mut self, v: super::EChatRoomNotificationLevel) {
            self.mobile_notification_level = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional bool unread_indicator_muted = 4;

        pub fn unread_indicator_muted(&self) -> bool {
            self.unread_indicator_muted.unwrap_or(false)
        }

        pub fn clear_unread_indicator_muted(&mut self) {
            self.unread_indicator_muted = ::std::option::Option::None;
        }

        pub fn has_unread_indicator_muted(&self) -> bool {
            self.unread_indicator_muted.is_some()
        }

        // Param is passed by value, moved
        pub fn set_unread_indicator_muted(&mut self, v: bool) {
            self.unread_indicator_muted = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for ChatRoomPreferences {
        const NAME: &'static str = "ChatRoomPreferences";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        self.desktop_notification_level = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    24 => {
                        self.mobile_notification_level = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    32 => {
                        self.unread_indicator_muted = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.chat_id {
                my_size += ::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.desktop_notification_level {
                my_size += ::protobuf::rt::int32_size(2, v.value());
            }
            if let Some(v) = self.mobile_notification_level {
                my_size += ::protobuf::rt::int32_size(3, v.value());
            }
            if let Some(v) = self.unread_indicator_muted {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.chat_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.desktop_notification_level {
                os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.mobile_notification_level {
                os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.unread_indicator_muted {
                os.write_bool(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ChatRoomPreferences {
            ChatRoomPreferences::new()
        }

        fn clear(&mut self) {
            self.chat_id = ::std::option::Option::None;
            self.desktop_notification_level = ::std::option::Option::None;
            self.mobile_notification_level = ::std::option::Option::None;
            self.unread_indicator_muted = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ChatRoomPreferences {
            static instance: ChatRoomPreferences = ChatRoomPreferences {
                chat_id: ::std::option::Option::None,
                desktop_notification_level: ::std::option::Option::None,
                mobile_notification_level: ::std::option::Option::None,
                unread_indicator_muted: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CChatRoom_SetUserChatGroupPreferences_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SetUserChatGroupPreferences_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SetUserChatGroupPreferences_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetUserChatGroupPreferences_Response {
    fn default() -> &'a CChatRoom_SetUserChatGroupPreferences_Response {
        <CChatRoom_SetUserChatGroupPreferences_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetUserChatGroupPreferences_Response {
    pub fn new() -> CChatRoom_SetUserChatGroupPreferences_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_SetUserChatGroupPreferences_Response {
    const NAME: &'static str = "CChatRoom_SetUserChatGroupPreferences_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SetUserChatGroupPreferences_Response {
        CChatRoom_SetUserChatGroupPreferences_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SetUserChatGroupPreferences_Response {
        static instance: CChatRoom_SetUserChatGroupPreferences_Response = CChatRoom_SetUserChatGroupPreferences_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Deletes specified chat messages"]
// @@protoc_insertion_point(message:CChatRoom_DeleteChatMessages_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_DeleteChatMessages_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_DeleteChatMessages_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_DeleteChatMessages_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_DeleteChatMessages_Request.messages)
    pub messages: ::std::vec::Vec<cchat_room_delete_chat_messages_request::Message>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_DeleteChatMessages_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteChatMessages_Request {
    fn default() -> &'a CChatRoom_DeleteChatMessages_Request {
        <CChatRoom_DeleteChatMessages_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_DeleteChatMessages_Request {
    pub fn new() -> CChatRoom_DeleteChatMessages_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_DeleteChatMessages_Request {
    const NAME: &'static str = "CChatRoom_DeleteChatMessages_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    self.messages.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        for v in &self.messages {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_DeleteChatMessages_Request {
        CChatRoom_DeleteChatMessages_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.messages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_DeleteChatMessages_Request {
        static instance: CChatRoom_DeleteChatMessages_Request = CChatRoom_DeleteChatMessages_Request {
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            messages: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CChatRoom_DeleteChatMessages_Request`
pub mod cchat_room_delete_chat_messages_request {
    // @@protoc_insertion_point(message:CChatRoom_DeleteChatMessages_Request.Message)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Message {
        // message fields
        // @@protoc_insertion_point(field:CChatRoom_DeleteChatMessages_Request.Message.server_timestamp)
        pub server_timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CChatRoom_DeleteChatMessages_Request.Message.ordinal)
        pub ordinal: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CChatRoom_DeleteChatMessages_Request.Message.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Message {
        fn default() -> &'a Message {
            <Message as ::protobuf::Message>::default_instance()
        }
    }

    impl Message {
        pub fn new() -> Message {
            ::std::default::Default::default()
        }

        // optional uint32 server_timestamp = 1;

        pub fn server_timestamp(&self) -> u32 {
            self.server_timestamp.unwrap_or(0)
        }

        pub fn clear_server_timestamp(&mut self) {
            self.server_timestamp = ::std::option::Option::None;
        }

        pub fn has_server_timestamp(&self) -> bool {
            self.server_timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_server_timestamp(&mut self, v: u32) {
            self.server_timestamp = ::std::option::Option::Some(v);
        }

        // optional uint32 ordinal = 2;

        pub fn ordinal(&self) -> u32 {
            self.ordinal.unwrap_or(0)
        }

        pub fn clear_ordinal(&mut self) {
            self.ordinal = ::std::option::Option::None;
        }

        pub fn has_ordinal(&self) -> bool {
            self.ordinal.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ordinal(&mut self, v: u32) {
            self.ordinal = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Message {
        const NAME: &'static str = "Message";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.server_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.ordinal = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.server_timestamp {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.ordinal {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.server_timestamp {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.ordinal {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Message {
            Message::new()
        }

        fn clear(&mut self) {
            self.server_timestamp = ::std::option::Option::None;
            self.ordinal = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Message {
            static instance: Message = Message {
                server_timestamp: ::std::option::Option::None,
                ordinal: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CChatRoom_DeleteChatMessages_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_DeleteChatMessages_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_DeleteChatMessages_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteChatMessages_Response {
    fn default() -> &'a CChatRoom_DeleteChatMessages_Response {
        <CChatRoom_DeleteChatMessages_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_DeleteChatMessages_Response {
    pub fn new() -> CChatRoom_DeleteChatMessages_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_DeleteChatMessages_Response {
    const NAME: &'static str = "CChatRoom_DeleteChatMessages_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_DeleteChatMessages_Response {
        CChatRoom_DeleteChatMessages_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_DeleteChatMessages_Response {
        static instance: CChatRoom_DeleteChatMessages_Response = CChatRoom_DeleteChatMessages_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "A client is indicating it has an active view into the members list."]
// @@protoc_insertion_point(message:CChatRoom_UpdateMemberListView_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_UpdateMemberListView_Notification {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_UpdateMemberListView_Notification.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_UpdateMemberListView_Notification.view_id)
    pub view_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_UpdateMemberListView_Notification.start)
    pub start: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CChatRoom_UpdateMemberListView_Notification.end)
    pub end: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CChatRoom_UpdateMemberListView_Notification.client_changenumber)
    pub client_changenumber: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CChatRoom_UpdateMemberListView_Notification.delete_view)
    pub delete_view: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CChatRoom_UpdateMemberListView_Notification.persona_subscribe_accountids)
    pub persona_subscribe_accountids: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CChatRoom_UpdateMemberListView_Notification.persona_unsubscribe_accountids)
    pub persona_unsubscribe_accountids: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_UpdateMemberListView_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_UpdateMemberListView_Notification {
    fn default() -> &'a CChatRoom_UpdateMemberListView_Notification {
        <CChatRoom_UpdateMemberListView_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_UpdateMemberListView_Notification {
    pub fn new() -> CChatRoom_UpdateMemberListView_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 view_id = 2;

    pub fn view_id(&self) -> u64 {
        self.view_id.unwrap_or(0)
    }

    pub fn clear_view_id(&mut self) {
        self.view_id = ::std::option::Option::None;
    }

    pub fn has_view_id(&self) -> bool {
        self.view_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_view_id(&mut self, v: u64) {
        self.view_id = ::std::option::Option::Some(v);
    }

    // optional int32 start = 3;

    pub fn start(&self) -> i32 {
        self.start.unwrap_or(0)
    }

    pub fn clear_start(&mut self) {
        self.start = ::std::option::Option::None;
    }

    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: i32) {
        self.start = ::std::option::Option::Some(v);
    }

    // optional int32 end = 4;

    pub fn end(&self) -> i32 {
        self.end.unwrap_or(0)
    }

    pub fn clear_end(&mut self) {
        self.end = ::std::option::Option::None;
    }

    pub fn has_end(&self) -> bool {
        self.end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end(&mut self, v: i32) {
        self.end = ::std::option::Option::Some(v);
    }

    // optional int32 client_changenumber = 5;

    pub fn client_changenumber(&self) -> i32 {
        self.client_changenumber.unwrap_or(0)
    }

    pub fn clear_client_changenumber(&mut self) {
        self.client_changenumber = ::std::option::Option::None;
    }

    pub fn has_client_changenumber(&self) -> bool {
        self.client_changenumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_changenumber(&mut self, v: i32) {
        self.client_changenumber = ::std::option::Option::Some(v);
    }

    // optional bool delete_view = 6;

    pub fn delete_view(&self) -> bool {
        self.delete_view.unwrap_or(false)
    }

    pub fn clear_delete_view(&mut self) {
        self.delete_view = ::std::option::Option::None;
    }

    pub fn has_delete_view(&self) -> bool {
        self.delete_view.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delete_view(&mut self, v: bool) {
        self.delete_view = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_UpdateMemberListView_Notification {
    const NAME: &'static str = "CChatRoom_UpdateMemberListView_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.view_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.start = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.end = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.client_changenumber = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.delete_view = ::std::option::Option::Some(is.read_bool()?);
                },
                58 => {
                    is.read_repeated_packed_int32_into(&mut self.persona_subscribe_accountids)?;
                },
                56 => {
                    self.persona_subscribe_accountids.push(is.read_int32()?);
                },
                66 => {
                    is.read_repeated_packed_int32_into(&mut self.persona_unsubscribe_accountids)?;
                },
                64 => {
                    self.persona_unsubscribe_accountids.push(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.view_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.start {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.end {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.client_changenumber {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.delete_view {
            my_size += 1 + 1;
        }
        for value in &self.persona_subscribe_accountids {
            my_size += ::protobuf::rt::int32_size(7, *value);
        };
        for value in &self.persona_unsubscribe_accountids {
            my_size += ::protobuf::rt::int32_size(8, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.view_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.start {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.end {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.client_changenumber {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.delete_view {
            os.write_bool(6, v)?;
        }
        for v in &self.persona_subscribe_accountids {
            os.write_int32(7, *v)?;
        };
        for v in &self.persona_unsubscribe_accountids {
            os.write_int32(8, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_UpdateMemberListView_Notification {
        CChatRoom_UpdateMemberListView_Notification::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.view_id = ::std::option::Option::None;
        self.start = ::std::option::Option::None;
        self.end = ::std::option::Option::None;
        self.client_changenumber = ::std::option::Option::None;
        self.delete_view = ::std::option::Option::None;
        self.persona_subscribe_accountids.clear();
        self.persona_unsubscribe_accountids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_UpdateMemberListView_Notification {
        static instance: CChatRoom_UpdateMemberListView_Notification = CChatRoom_UpdateMemberListView_Notification {
            chat_group_id: ::std::option::Option::None,
            view_id: ::std::option::Option::None,
            start: ::std::option::Option::None,
            end: ::std::option::Option::None,
            client_changenumber: ::std::option::Option::None,
            delete_view: ::std::option::Option::None,
            persona_subscribe_accountids: ::std::vec::Vec::new(),
            persona_unsubscribe_accountids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Search chat room members by name."]
// @@protoc_insertion_point(message:CChatRoom_SearchMembers_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SearchMembers_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_SearchMembers_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_SearchMembers_Request.search_id)
    pub search_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_SearchMembers_Request.search_text)
    pub search_text: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoom_SearchMembers_Request.max_results)
    pub max_results: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SearchMembers_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SearchMembers_Request {
    fn default() -> &'a CChatRoom_SearchMembers_Request {
        <CChatRoom_SearchMembers_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SearchMembers_Request {
    pub fn new() -> CChatRoom_SearchMembers_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 search_id = 2;

    pub fn search_id(&self) -> u64 {
        self.search_id.unwrap_or(0)
    }

    pub fn clear_search_id(&mut self) {
        self.search_id = ::std::option::Option::None;
    }

    pub fn has_search_id(&self) -> bool {
        self.search_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_search_id(&mut self, v: u64) {
        self.search_id = ::std::option::Option::Some(v);
    }

    // optional string search_text = 3;

    pub fn search_text(&self) -> &str {
        match self.search_text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_search_text(&mut self) {
        self.search_text = ::std::option::Option::None;
    }

    pub fn has_search_text(&self) -> bool {
        self.search_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_search_text(&mut self, v: ::std::string::String) {
        self.search_text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_search_text(&mut self) -> &mut ::std::string::String {
        if self.search_text.is_none() {
            self.search_text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.search_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_search_text(&mut self) -> ::std::string::String {
        self.search_text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 max_results = 4;

    pub fn max_results(&self) -> i32 {
        self.max_results.unwrap_or(0)
    }

    pub fn clear_max_results(&mut self) {
        self.max_results = ::std::option::Option::None;
    }

    pub fn has_max_results(&self) -> bool {
        self.max_results.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_results(&mut self, v: i32) {
        self.max_results = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_SearchMembers_Request {
    const NAME: &'static str = "CChatRoom_SearchMembers_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.search_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    self.search_text = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.max_results = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.search_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.search_text.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.max_results {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.search_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.search_text.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.max_results {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SearchMembers_Request {
        CChatRoom_SearchMembers_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.search_id = ::std::option::Option::None;
        self.search_text = ::std::option::Option::None;
        self.max_results = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SearchMembers_Request {
        static instance: CChatRoom_SearchMembers_Request = CChatRoom_SearchMembers_Request {
            chat_group_id: ::std::option::Option::None,
            search_id: ::std::option::Option::None,
            search_text: ::std::option::Option::None,
            max_results: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoom_SearchMembers_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SearchMembers_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_SearchMembers_Response.matching_members)
    pub matching_members: ::std::vec::Vec<cchat_room_search_members_response::MemberMatch>,
    // @@protoc_insertion_point(field:CChatRoom_SearchMembers_Response.status_flags)
    pub status_flags: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SearchMembers_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SearchMembers_Response {
    fn default() -> &'a CChatRoom_SearchMembers_Response {
        <CChatRoom_SearchMembers_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SearchMembers_Response {
    pub fn new() -> CChatRoom_SearchMembers_Response {
        ::std::default::Default::default()
    }

    // optional uint32 status_flags = 2;

    pub fn status_flags(&self) -> u32 {
        self.status_flags.unwrap_or(0)
    }

    pub fn clear_status_flags(&mut self) {
        self.status_flags = ::std::option::Option::None;
    }

    pub fn has_status_flags(&self) -> bool {
        self.status_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status_flags(&mut self, v: u32) {
        self.status_flags = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_SearchMembers_Response {
    const NAME: &'static str = "CChatRoom_SearchMembers_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.matching_members.push(is.read_message()?);
                },
                16 => {
                    self.status_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.matching_members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.status_flags {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.matching_members {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.status_flags {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SearchMembers_Response {
        CChatRoom_SearchMembers_Response::new()
    }

    fn clear(&mut self) {
        self.matching_members.clear();
        self.status_flags = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SearchMembers_Response {
        static instance: CChatRoom_SearchMembers_Response = CChatRoom_SearchMembers_Response {
            matching_members: ::std::vec::Vec::new(),
            status_flags: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CChatRoom_SearchMembers_Response`
pub mod cchat_room_search_members_response {
    // @@protoc_insertion_point(message:CChatRoom_SearchMembers_Response.MemberMatch)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct MemberMatch {
        // message fields
        // @@protoc_insertion_point(field:CChatRoom_SearchMembers_Response.MemberMatch.accountid)
        pub accountid: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatRoom_SearchMembers_Response.MemberMatch.persona)
        pub persona: ::protobuf::MessageField<super::super::steammessages_clientserver_friends::cmsg_client_persona_state::Friend>,
        // special fields
        // @@protoc_insertion_point(special_field:CChatRoom_SearchMembers_Response.MemberMatch.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MemberMatch {
        fn default() -> &'a MemberMatch {
            <MemberMatch as ::protobuf::Message>::default_instance()
        }
    }

    impl MemberMatch {
        pub fn new() -> MemberMatch {
            ::std::default::Default::default()
        }

        // optional int32 accountid = 1;

        pub fn accountid(&self) -> i32 {
            self.accountid.unwrap_or(0)
        }

        pub fn clear_accountid(&mut self) {
            self.accountid = ::std::option::Option::None;
        }

        pub fn has_accountid(&self) -> bool {
            self.accountid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_accountid(&mut self, v: i32) {
            self.accountid = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for MemberMatch {
        const NAME: &'static str = "MemberMatch";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.accountid = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.persona)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.accountid {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.persona.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.accountid {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.persona.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MemberMatch {
            MemberMatch::new()
        }

        fn clear(&mut self) {
            self.accountid = ::std::option::Option::None;
            self.persona.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MemberMatch {
            static instance: MemberMatch = MemberMatch {
                accountid: ::std::option::Option::None,
                persona: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

#[doc = "Adds/removes a reaction to/from a chat room message"]
// @@protoc_insertion_point(message:CChatRoom_UpdateMessageReaction_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_UpdateMessageReaction_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_UpdateMessageReaction_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_UpdateMessageReaction_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_UpdateMessageReaction_Request.server_timestamp)
    pub server_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_UpdateMessageReaction_Request.ordinal)
    pub ordinal: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_UpdateMessageReaction_Request.reaction_type)
    pub reaction_type: ::std::option::Option<::protobuf::EnumOrUnknown<EChatRoomMessageReactionType>>,
    // @@protoc_insertion_point(field:CChatRoom_UpdateMessageReaction_Request.reaction)
    pub reaction: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoom_UpdateMessageReaction_Request.is_add)
    pub is_add: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_UpdateMessageReaction_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_UpdateMessageReaction_Request {
    fn default() -> &'a CChatRoom_UpdateMessageReaction_Request {
        <CChatRoom_UpdateMessageReaction_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_UpdateMessageReaction_Request {
    pub fn new() -> CChatRoom_UpdateMessageReaction_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional uint32 server_timestamp = 3;

    pub fn server_timestamp(&self) -> u32 {
        self.server_timestamp.unwrap_or(0)
    }

    pub fn clear_server_timestamp(&mut self) {
        self.server_timestamp = ::std::option::Option::None;
    }

    pub fn has_server_timestamp(&self) -> bool {
        self.server_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_timestamp(&mut self, v: u32) {
        self.server_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 ordinal = 4;

    pub fn ordinal(&self) -> u32 {
        self.ordinal.unwrap_or(0)
    }

    pub fn clear_ordinal(&mut self) {
        self.ordinal = ::std::option::Option::None;
    }

    pub fn has_ordinal(&self) -> bool {
        self.ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordinal(&mut self, v: u32) {
        self.ordinal = ::std::option::Option::Some(v);
    }

    // optional .EChatRoomMessageReactionType reaction_type = 5;

    pub fn reaction_type(&self) -> EChatRoomMessageReactionType {
        match self.reaction_type {
            Some(e) => e.enum_value_or(EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Invalid),
            None => EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Invalid,
        }
    }

    pub fn clear_reaction_type(&mut self) {
        self.reaction_type = ::std::option::Option::None;
    }

    pub fn has_reaction_type(&self) -> bool {
        self.reaction_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reaction_type(&mut self, v: EChatRoomMessageReactionType) {
        self.reaction_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string reaction = 6;

    pub fn reaction(&self) -> &str {
        match self.reaction.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reaction(&mut self) {
        self.reaction = ::std::option::Option::None;
    }

    pub fn has_reaction(&self) -> bool {
        self.reaction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reaction(&mut self, v: ::std::string::String) {
        self.reaction = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reaction(&mut self) -> &mut ::std::string::String {
        if self.reaction.is_none() {
            self.reaction = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reaction.as_mut().unwrap()
    }

    // Take field
    pub fn take_reaction(&mut self) -> ::std::string::String {
        self.reaction.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_add = 7;

    pub fn is_add(&self) -> bool {
        self.is_add.unwrap_or(false)
    }

    pub fn clear_is_add(&mut self) {
        self.is_add = ::std::option::Option::None;
    }

    pub fn has_is_add(&self) -> bool {
        self.is_add.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_add(&mut self, v: bool) {
        self.is_add = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_UpdateMessageReaction_Request {
    const NAME: &'static str = "CChatRoom_UpdateMessageReaction_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.server_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.ordinal = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.reaction_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                50 => {
                    self.reaction = ::std::option::Option::Some(is.read_string()?);
                },
                56 => {
                    self.is_add = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.server_timestamp {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.ordinal {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.reaction_type {
            my_size += ::protobuf::rt::int32_size(5, v.value());
        }
        if let Some(v) = self.reaction.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.is_add {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.server_timestamp {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.ordinal {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.reaction_type {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.reaction.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.is_add {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_UpdateMessageReaction_Request {
        CChatRoom_UpdateMessageReaction_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.server_timestamp = ::std::option::Option::None;
        self.ordinal = ::std::option::Option::None;
        self.reaction_type = ::std::option::Option::None;
        self.reaction = ::std::option::Option::None;
        self.is_add = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_UpdateMessageReaction_Request {
        static instance: CChatRoom_UpdateMessageReaction_Request = CChatRoom_UpdateMessageReaction_Request {
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            server_timestamp: ::std::option::Option::None,
            ordinal: ::std::option::Option::None,
            reaction_type: ::std::option::Option::None,
            reaction: ::std::option::Option::None,
            is_add: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoom_UpdateMessageReaction_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_UpdateMessageReaction_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_UpdateMessageReaction_Response.num_reactors)
    pub num_reactors: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_UpdateMessageReaction_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_UpdateMessageReaction_Response {
    fn default() -> &'a CChatRoom_UpdateMessageReaction_Response {
        <CChatRoom_UpdateMessageReaction_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_UpdateMessageReaction_Response {
    pub fn new() -> CChatRoom_UpdateMessageReaction_Response {
        ::std::default::Default::default()
    }

    // optional uint32 num_reactors = 1;

    pub fn num_reactors(&self) -> u32 {
        self.num_reactors.unwrap_or(0)
    }

    pub fn clear_num_reactors(&mut self) {
        self.num_reactors = ::std::option::Option::None;
    }

    pub fn has_num_reactors(&self) -> bool {
        self.num_reactors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_reactors(&mut self, v: u32) {
        self.num_reactors = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_UpdateMessageReaction_Response {
    const NAME: &'static str = "CChatRoom_UpdateMessageReaction_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.num_reactors = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.num_reactors {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.num_reactors {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_UpdateMessageReaction_Response {
        CChatRoom_UpdateMessageReaction_Response::new()
    }

    fn clear(&mut self) {
        self.num_reactors = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_UpdateMessageReaction_Response {
        static instance: CChatRoom_UpdateMessageReaction_Response = CChatRoom_UpdateMessageReaction_Response {
            num_reactors: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Fetches a list of reactors for a specified reaction"]
// @@protoc_insertion_point(message:CChatRoom_GetMessageReactionReactors_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetMessageReactionReactors_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetMessageReactionReactors_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetMessageReactionReactors_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetMessageReactionReactors_Request.server_timestamp)
    pub server_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_GetMessageReactionReactors_Request.ordinal)
    pub ordinal: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_GetMessageReactionReactors_Request.reaction_type)
    pub reaction_type: ::std::option::Option<::protobuf::EnumOrUnknown<EChatRoomMessageReactionType>>,
    // @@protoc_insertion_point(field:CChatRoom_GetMessageReactionReactors_Request.reaction)
    pub reaction: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoom_GetMessageReactionReactors_Request.limit)
    pub limit: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetMessageReactionReactors_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetMessageReactionReactors_Request {
    fn default() -> &'a CChatRoom_GetMessageReactionReactors_Request {
        <CChatRoom_GetMessageReactionReactors_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetMessageReactionReactors_Request {
    pub fn new() -> CChatRoom_GetMessageReactionReactors_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional uint32 server_timestamp = 3;

    pub fn server_timestamp(&self) -> u32 {
        self.server_timestamp.unwrap_or(0)
    }

    pub fn clear_server_timestamp(&mut self) {
        self.server_timestamp = ::std::option::Option::None;
    }

    pub fn has_server_timestamp(&self) -> bool {
        self.server_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_timestamp(&mut self, v: u32) {
        self.server_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 ordinal = 4;

    pub fn ordinal(&self) -> u32 {
        self.ordinal.unwrap_or(0)
    }

    pub fn clear_ordinal(&mut self) {
        self.ordinal = ::std::option::Option::None;
    }

    pub fn has_ordinal(&self) -> bool {
        self.ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordinal(&mut self, v: u32) {
        self.ordinal = ::std::option::Option::Some(v);
    }

    // optional .EChatRoomMessageReactionType reaction_type = 5;

    pub fn reaction_type(&self) -> EChatRoomMessageReactionType {
        match self.reaction_type {
            Some(e) => e.enum_value_or(EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Invalid),
            None => EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Invalid,
        }
    }

    pub fn clear_reaction_type(&mut self) {
        self.reaction_type = ::std::option::Option::None;
    }

    pub fn has_reaction_type(&self) -> bool {
        self.reaction_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reaction_type(&mut self, v: EChatRoomMessageReactionType) {
        self.reaction_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string reaction = 6;

    pub fn reaction(&self) -> &str {
        match self.reaction.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reaction(&mut self) {
        self.reaction = ::std::option::Option::None;
    }

    pub fn has_reaction(&self) -> bool {
        self.reaction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reaction(&mut self, v: ::std::string::String) {
        self.reaction = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reaction(&mut self) -> &mut ::std::string::String {
        if self.reaction.is_none() {
            self.reaction = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reaction.as_mut().unwrap()
    }

    // Take field
    pub fn take_reaction(&mut self) -> ::std::string::String {
        self.reaction.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 limit = 7;

    pub fn limit(&self) -> u32 {
        self.limit.unwrap_or(0)
    }

    pub fn clear_limit(&mut self) {
        self.limit = ::std::option::Option::None;
    }

    pub fn has_limit(&self) -> bool {
        self.limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: u32) {
        self.limit = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_GetMessageReactionReactors_Request {
    const NAME: &'static str = "CChatRoom_GetMessageReactionReactors_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.server_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.ordinal = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.reaction_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                50 => {
                    self.reaction = ::std::option::Option::Some(is.read_string()?);
                },
                56 => {
                    self.limit = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.server_timestamp {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.ordinal {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.reaction_type {
            my_size += ::protobuf::rt::int32_size(5, v.value());
        }
        if let Some(v) = self.reaction.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.limit {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.server_timestamp {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.ordinal {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.reaction_type {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.reaction.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.limit {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetMessageReactionReactors_Request {
        CChatRoom_GetMessageReactionReactors_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.server_timestamp = ::std::option::Option::None;
        self.ordinal = ::std::option::Option::None;
        self.reaction_type = ::std::option::Option::None;
        self.reaction = ::std::option::Option::None;
        self.limit = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetMessageReactionReactors_Request {
        static instance: CChatRoom_GetMessageReactionReactors_Request = CChatRoom_GetMessageReactionReactors_Request {
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            server_timestamp: ::std::option::Option::None,
            ordinal: ::std::option::Option::None,
            reaction_type: ::std::option::Option::None,
            reaction: ::std::option::Option::None,
            limit: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoom_GetMessageReactionReactors_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetMessageReactionReactors_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetMessageReactionReactors_Response.reactors)
    pub reactors: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetMessageReactionReactors_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetMessageReactionReactors_Response {
    fn default() -> &'a CChatRoom_GetMessageReactionReactors_Response {
        <CChatRoom_GetMessageReactionReactors_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetMessageReactionReactors_Response {
    pub fn new() -> CChatRoom_GetMessageReactionReactors_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_GetMessageReactionReactors_Response {
    const NAME: &'static str = "CChatRoom_GetMessageReactionReactors_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.reactors)?;
                },
                8 => {
                    self.reactors.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.reactors {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.reactors {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetMessageReactionReactors_Response {
        CChatRoom_GetMessageReactionReactors_Response::new()
    }

    fn clear(&mut self) {
        self.reactors.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetMessageReactionReactors_Response {
        static instance: CChatRoom_GetMessageReactionReactors_Response = CChatRoom_GetMessageReactionReactors_Response {
            reactors: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Get a list of chat rooms for a clan, optionally creating a new one"]
// @@protoc_insertion_point(message:CClanChatRooms_GetClanChatRoomInfo_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClanChatRooms_GetClanChatRoomInfo_Request {
    // message fields
    // @@protoc_insertion_point(field:CClanChatRooms_GetClanChatRoomInfo_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClanChatRooms_GetClanChatRoomInfo_Request.autocreate)
    pub autocreate: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CClanChatRooms_GetClanChatRoomInfo_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClanChatRooms_GetClanChatRoomInfo_Request {
    fn default() -> &'a CClanChatRooms_GetClanChatRoomInfo_Request {
        <CClanChatRooms_GetClanChatRoomInfo_Request as ::protobuf::Message>::default_instance()
    }
}

impl CClanChatRooms_GetClanChatRoomInfo_Request {
    pub fn new() -> CClanChatRooms_GetClanChatRoomInfo_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional bool autocreate = 2;

    pub fn autocreate(&self) -> bool {
        self.autocreate.unwrap_or(true)
    }

    pub fn clear_autocreate(&mut self) {
        self.autocreate = ::std::option::Option::None;
    }

    pub fn has_autocreate(&self) -> bool {
        self.autocreate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_autocreate(&mut self, v: bool) {
        self.autocreate = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClanChatRooms_GetClanChatRoomInfo_Request {
    const NAME: &'static str = "CClanChatRooms_GetClanChatRoomInfo_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.autocreate = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.autocreate {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.autocreate {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClanChatRooms_GetClanChatRoomInfo_Request {
        CClanChatRooms_GetClanChatRoomInfo_Request::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.autocreate = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClanChatRooms_GetClanChatRoomInfo_Request {
        static instance: CClanChatRooms_GetClanChatRoomInfo_Request = CClanChatRooms_GetClanChatRoomInfo_Request {
            steamid: ::std::option::Option::None,
            autocreate: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CClanChatRooms_GetClanChatRoomInfo_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClanChatRooms_GetClanChatRoomInfo_Response {
    // message fields
    // @@protoc_insertion_point(field:CClanChatRooms_GetClanChatRoomInfo_Response.chat_group_summary)
    pub chat_group_summary: ::protobuf::MessageField<CChatRoom_GetChatRoomGroupSummary_Response>,
    // special fields
    // @@protoc_insertion_point(special_field:CClanChatRooms_GetClanChatRoomInfo_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClanChatRooms_GetClanChatRoomInfo_Response {
    fn default() -> &'a CClanChatRooms_GetClanChatRoomInfo_Response {
        <CClanChatRooms_GetClanChatRoomInfo_Response as ::protobuf::Message>::default_instance()
    }
}

impl CClanChatRooms_GetClanChatRoomInfo_Response {
    pub fn new() -> CClanChatRooms_GetClanChatRoomInfo_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CClanChatRooms_GetClanChatRoomInfo_Response {
    const NAME: &'static str = "CClanChatRooms_GetClanChatRoomInfo_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.chat_group_summary)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_summary.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClanChatRooms_GetClanChatRoomInfo_Response {
        CClanChatRooms_GetClanChatRoomInfo_Response::new()
    }

    fn clear(&mut self) {
        self.chat_group_summary.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClanChatRooms_GetClanChatRoomInfo_Response {
        static instance: CClanChatRooms_GetClanChatRoomInfo_Response = CClanChatRooms_GetClanChatRoomInfo_Response {
            chat_group_summary: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Set a clan chat room to be members only (or public)"]
// @@protoc_insertion_point(message:CClanChatRooms_SetClanChatRoomPrivate_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClanChatRooms_SetClanChatRoomPrivate_Request {
    // message fields
    // @@protoc_insertion_point(field:CClanChatRooms_SetClanChatRoomPrivate_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClanChatRooms_SetClanChatRoomPrivate_Request.chat_room_private)
    pub chat_room_private: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CClanChatRooms_SetClanChatRoomPrivate_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClanChatRooms_SetClanChatRoomPrivate_Request {
    fn default() -> &'a CClanChatRooms_SetClanChatRoomPrivate_Request {
        <CClanChatRooms_SetClanChatRoomPrivate_Request as ::protobuf::Message>::default_instance()
    }
}

impl CClanChatRooms_SetClanChatRoomPrivate_Request {
    pub fn new() -> CClanChatRooms_SetClanChatRoomPrivate_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional bool chat_room_private = 2;

    pub fn chat_room_private(&self) -> bool {
        self.chat_room_private.unwrap_or(false)
    }

    pub fn clear_chat_room_private(&mut self) {
        self.chat_room_private = ::std::option::Option::None;
    }

    pub fn has_chat_room_private(&self) -> bool {
        self.chat_room_private.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_room_private(&mut self, v: bool) {
        self.chat_room_private = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClanChatRooms_SetClanChatRoomPrivate_Request {
    const NAME: &'static str = "CClanChatRooms_SetClanChatRoomPrivate_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.chat_room_private = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.chat_room_private {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.chat_room_private {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClanChatRooms_SetClanChatRoomPrivate_Request {
        CClanChatRooms_SetClanChatRoomPrivate_Request::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.chat_room_private = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClanChatRooms_SetClanChatRoomPrivate_Request {
        static instance: CClanChatRooms_SetClanChatRoomPrivate_Request = CClanChatRooms_SetClanChatRoomPrivate_Request {
            steamid: ::std::option::Option::None,
            chat_room_private: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CClanChatRooms_SetClanChatRoomPrivate_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClanChatRooms_SetClanChatRoomPrivate_Response {
    // message fields
    // @@protoc_insertion_point(field:CClanChatRooms_SetClanChatRoomPrivate_Response.chat_room_private)
    pub chat_room_private: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CClanChatRooms_SetClanChatRoomPrivate_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClanChatRooms_SetClanChatRoomPrivate_Response {
    fn default() -> &'a CClanChatRooms_SetClanChatRoomPrivate_Response {
        <CClanChatRooms_SetClanChatRoomPrivate_Response as ::protobuf::Message>::default_instance()
    }
}

impl CClanChatRooms_SetClanChatRoomPrivate_Response {
    pub fn new() -> CClanChatRooms_SetClanChatRoomPrivate_Response {
        ::std::default::Default::default()
    }

    // optional bool chat_room_private = 1;

    pub fn chat_room_private(&self) -> bool {
        self.chat_room_private.unwrap_or(false)
    }

    pub fn clear_chat_room_private(&mut self) {
        self.chat_room_private = ::std::option::Option::None;
    }

    pub fn has_chat_room_private(&self) -> bool {
        self.chat_room_private.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_room_private(&mut self, v: bool) {
        self.chat_room_private = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClanChatRooms_SetClanChatRoomPrivate_Response {
    const NAME: &'static str = "CClanChatRooms_SetClanChatRoomPrivate_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_room_private = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_room_private {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_room_private {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClanChatRooms_SetClanChatRoomPrivate_Response {
        CClanChatRooms_SetClanChatRoomPrivate_Response::new()
    }

    fn clear(&mut self) {
        self.chat_room_private = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClanChatRooms_SetClanChatRoomPrivate_Response {
        static instance: CClanChatRooms_SetClanChatRoomPrivate_Response = CClanChatRooms_SetClanChatRoomPrivate_Response {
            chat_room_private: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatMentions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatMentions {
    // message fields
    // @@protoc_insertion_point(field:CChatMentions.mention_all)
    pub mention_all: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CChatMentions.mention_here)
    pub mention_here: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CChatMentions.mention_accountids)
    pub mention_accountids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatMentions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatMentions {
    fn default() -> &'a CChatMentions {
        <CChatMentions as ::protobuf::Message>::default_instance()
    }
}

impl CChatMentions {
    pub fn new() -> CChatMentions {
        ::std::default::Default::default()
    }

    // optional bool mention_all = 1;

    pub fn mention_all(&self) -> bool {
        self.mention_all.unwrap_or(false)
    }

    pub fn clear_mention_all(&mut self) {
        self.mention_all = ::std::option::Option::None;
    }

    pub fn has_mention_all(&self) -> bool {
        self.mention_all.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mention_all(&mut self, v: bool) {
        self.mention_all = ::std::option::Option::Some(v);
    }

    // optional bool mention_here = 2;

    pub fn mention_here(&self) -> bool {
        self.mention_here.unwrap_or(false)
    }

    pub fn clear_mention_here(&mut self) {
        self.mention_here = ::std::option::Option::None;
    }

    pub fn has_mention_here(&self) -> bool {
        self.mention_here.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mention_here(&mut self, v: bool) {
        self.mention_here = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatMentions {
    const NAME: &'static str = "CChatMentions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.mention_all = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.mention_here = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.mention_accountids)?;
                },
                24 => {
                    self.mention_accountids.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mention_all {
            my_size += 1 + 1;
        }
        if let Some(v) = self.mention_here {
            my_size += 1 + 1;
        }
        for value in &self.mention_accountids {
            my_size += ::protobuf::rt::uint32_size(3, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.mention_all {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.mention_here {
            os.write_bool(2, v)?;
        }
        for v in &self.mention_accountids {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatMentions {
        CChatMentions::new()
    }

    fn clear(&mut self) {
        self.mention_all = ::std::option::Option::None;
        self.mention_here = ::std::option::Option::None;
        self.mention_accountids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatMentions {
        static instance: CChatMentions = CChatMentions {
            mention_all: ::std::option::Option::None,
            mention_here: ::std::option::Option::None,
            mention_accountids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "New chat message for a chat room"]
// @@protoc_insertion_point(message:CChatRoom_IncomingChatMessage_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_IncomingChatMessage_Notification {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_IncomingChatMessage_Notification.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_IncomingChatMessage_Notification.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_IncomingChatMessage_Notification.steamid_sender)
    pub steamid_sender: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_IncomingChatMessage_Notification.message)
    pub message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoom_IncomingChatMessage_Notification.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_IncomingChatMessage_Notification.mentions)
    pub mentions: ::protobuf::MessageField<CChatMentions>,
    // @@protoc_insertion_point(field:CChatRoom_IncomingChatMessage_Notification.ordinal)
    pub ordinal: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_IncomingChatMessage_Notification.server_message)
    pub server_message: ::protobuf::MessageField<ServerMessage>,
    // @@protoc_insertion_point(field:CChatRoom_IncomingChatMessage_Notification.message_no_bbcode)
    pub message_no_bbcode: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoom_IncomingChatMessage_Notification.chat_name)
    pub chat_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_IncomingChatMessage_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_IncomingChatMessage_Notification {
    fn default() -> &'a CChatRoom_IncomingChatMessage_Notification {
        <CChatRoom_IncomingChatMessage_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_IncomingChatMessage_Notification {
    pub fn new() -> CChatRoom_IncomingChatMessage_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid_sender = 3;

    pub fn steamid_sender(&self) -> u64 {
        self.steamid_sender.unwrap_or(0)
    }

    pub fn clear_steamid_sender(&mut self) {
        self.steamid_sender = ::std::option::Option::None;
    }

    pub fn has_steamid_sender(&self) -> bool {
        self.steamid_sender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_sender(&mut self, v: u64) {
        self.steamid_sender = ::std::option::Option::Some(v);
    }

    // optional string message = 4;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 timestamp = 5;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 ordinal = 7;

    pub fn ordinal(&self) -> u32 {
        self.ordinal.unwrap_or(0)
    }

    pub fn clear_ordinal(&mut self) {
        self.ordinal = ::std::option::Option::None;
    }

    pub fn has_ordinal(&self) -> bool {
        self.ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordinal(&mut self, v: u32) {
        self.ordinal = ::std::option::Option::Some(v);
    }

    // optional string message_no_bbcode = 9;

    pub fn message_no_bbcode(&self) -> &str {
        match self.message_no_bbcode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message_no_bbcode(&mut self) {
        self.message_no_bbcode = ::std::option::Option::None;
    }

    pub fn has_message_no_bbcode(&self) -> bool {
        self.message_no_bbcode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_no_bbcode(&mut self, v: ::std::string::String) {
        self.message_no_bbcode = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_no_bbcode(&mut self) -> &mut ::std::string::String {
        if self.message_no_bbcode.is_none() {
            self.message_no_bbcode = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message_no_bbcode.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_no_bbcode(&mut self) -> ::std::string::String {
        self.message_no_bbcode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string chat_name = 10;

    pub fn chat_name(&self) -> &str {
        match self.chat_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_chat_name(&mut self) {
        self.chat_name = ::std::option::Option::None;
    }

    pub fn has_chat_name(&self) -> bool {
        self.chat_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_name(&mut self, v: ::std::string::String) {
        self.chat_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_name(&mut self) -> &mut ::std::string::String {
        if self.chat_name.is_none() {
            self.chat_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.chat_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_chat_name(&mut self) -> ::std::string::String {
        self.chat_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CChatRoom_IncomingChatMessage_Notification {
    const NAME: &'static str = "CChatRoom_IncomingChatMessage_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                25 => {
                    self.steamid_sender = ::std::option::Option::Some(is.read_fixed64()?);
                },
                34 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.mentions)?;
                },
                56 => {
                    self.ordinal = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.server_message)?;
                },
                74 => {
                    self.message_no_bbcode = ::std::option::Option::Some(is.read_string()?);
                },
                82 => {
                    self.chat_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.steamid_sender {
            my_size += 1 + 8;
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.mentions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ordinal {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.server_message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.message_no_bbcode.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.chat_name.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.steamid_sender {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.mentions.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.ordinal {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.server_message.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.message_no_bbcode.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.chat_name.as_ref() {
            os.write_string(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_IncomingChatMessage_Notification {
        CChatRoom_IncomingChatMessage_Notification::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.steamid_sender = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.mentions.clear();
        self.ordinal = ::std::option::Option::None;
        self.server_message.clear();
        self.message_no_bbcode = ::std::option::Option::None;
        self.chat_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_IncomingChatMessage_Notification {
        static instance: CChatRoom_IncomingChatMessage_Notification = CChatRoom_IncomingChatMessage_Notification {
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            steamid_sender: ::std::option::Option::None,
            message: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            mentions: ::protobuf::MessageField::none(),
            ordinal: ::std::option::Option::None,
            server_message: ::protobuf::MessageField::none(),
            message_no_bbcode: ::std::option::Option::None,
            chat_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "An existing chat message has been modified on the backend"]
// @@protoc_insertion_point(message:CChatRoom_ChatMessageModified_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_ChatMessageModified_Notification {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_ChatMessageModified_Notification.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_ChatMessageModified_Notification.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_ChatMessageModified_Notification.messages)
    pub messages: ::std::vec::Vec<cchat_room_chat_message_modified_notification::ChatMessage>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_ChatMessageModified_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_ChatMessageModified_Notification {
    fn default() -> &'a CChatRoom_ChatMessageModified_Notification {
        <CChatRoom_ChatMessageModified_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_ChatMessageModified_Notification {
    pub fn new() -> CChatRoom_ChatMessageModified_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_ChatMessageModified_Notification {
    const NAME: &'static str = "CChatRoom_ChatMessageModified_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    self.messages.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        for v in &self.messages {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_ChatMessageModified_Notification {
        CChatRoom_ChatMessageModified_Notification::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.messages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_ChatMessageModified_Notification {
        static instance: CChatRoom_ChatMessageModified_Notification = CChatRoom_ChatMessageModified_Notification {
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            messages: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CChatRoom_ChatMessageModified_Notification`
pub mod cchat_room_chat_message_modified_notification {
    // @@protoc_insertion_point(message:CChatRoom_ChatMessageModified_Notification.ChatMessage)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ChatMessage {
        // message fields
        // @@protoc_insertion_point(field:CChatRoom_ChatMessageModified_Notification.ChatMessage.server_timestamp)
        pub server_timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CChatRoom_ChatMessageModified_Notification.ChatMessage.ordinal)
        pub ordinal: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CChatRoom_ChatMessageModified_Notification.ChatMessage.deleted)
        pub deleted: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CChatRoom_ChatMessageModified_Notification.ChatMessage.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ChatMessage {
        fn default() -> &'a ChatMessage {
            <ChatMessage as ::protobuf::Message>::default_instance()
        }
    }

    impl ChatMessage {
        pub fn new() -> ChatMessage {
            ::std::default::Default::default()
        }

        // optional uint32 server_timestamp = 1;

        pub fn server_timestamp(&self) -> u32 {
            self.server_timestamp.unwrap_or(0)
        }

        pub fn clear_server_timestamp(&mut self) {
            self.server_timestamp = ::std::option::Option::None;
        }

        pub fn has_server_timestamp(&self) -> bool {
            self.server_timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_server_timestamp(&mut self, v: u32) {
            self.server_timestamp = ::std::option::Option::Some(v);
        }

        // optional uint32 ordinal = 2;

        pub fn ordinal(&self) -> u32 {
            self.ordinal.unwrap_or(0)
        }

        pub fn clear_ordinal(&mut self) {
            self.ordinal = ::std::option::Option::None;
        }

        pub fn has_ordinal(&self) -> bool {
            self.ordinal.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ordinal(&mut self, v: u32) {
            self.ordinal = ::std::option::Option::Some(v);
        }

        // optional bool deleted = 3;

        pub fn deleted(&self) -> bool {
            self.deleted.unwrap_or(false)
        }

        pub fn clear_deleted(&mut self) {
            self.deleted = ::std::option::Option::None;
        }

        pub fn has_deleted(&self) -> bool {
            self.deleted.is_some()
        }

        // Param is passed by value, moved
        pub fn set_deleted(&mut self, v: bool) {
            self.deleted = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for ChatMessage {
        const NAME: &'static str = "ChatMessage";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.server_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.ordinal = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.deleted = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.server_timestamp {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.ordinal {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.deleted {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.server_timestamp {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.ordinal {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.deleted {
                os.write_bool(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ChatMessage {
            ChatMessage::new()
        }

        fn clear(&mut self) {
            self.server_timestamp = ::std::option::Option::None;
            self.ordinal = ::std::option::Option::None;
            self.deleted = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ChatMessage {
            static instance: ChatMessage = ChatMessage {
                server_timestamp: ::std::option::Option::None,
                ordinal: ::std::option::Option::None,
                deleted: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

#[doc = "A chat room member's state has changed (join/part/permissions)"]
// @@protoc_insertion_point(message:CChatRoom_MemberStateChange_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_MemberStateChange_Notification {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_MemberStateChange_Notification.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_MemberStateChange_Notification.member)
    pub member: ::protobuf::MessageField<CChatRoomMember>,
    // @@protoc_insertion_point(field:CChatRoom_MemberStateChange_Notification.change)
    pub change: ::std::option::Option<::protobuf::EnumOrUnknown<EChatRoomMemberStateChange>>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_MemberStateChange_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_MemberStateChange_Notification {
    fn default() -> &'a CChatRoom_MemberStateChange_Notification {
        <CChatRoom_MemberStateChange_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_MemberStateChange_Notification {
    pub fn new() -> CChatRoom_MemberStateChange_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional .EChatRoomMemberStateChange change = 3;

    pub fn change(&self) -> EChatRoomMemberStateChange {
        match self.change {
            Some(e) => e.enum_value_or(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invalid),
            None => EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invalid,
        }
    }

    pub fn clear_change(&mut self) {
        self.change = ::std::option::Option::None;
    }

    pub fn has_change(&self) -> bool {
        self.change.is_some()
    }

    // Param is passed by value, moved
    pub fn set_change(&mut self, v: EChatRoomMemberStateChange) {
        self.change = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::protobuf::Message for CChatRoom_MemberStateChange_Notification {
    const NAME: &'static str = "CChatRoom_MemberStateChange_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.member)?;
                },
                24 => {
                    self.change = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.member.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.change {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.member.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.change {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_MemberStateChange_Notification {
        CChatRoom_MemberStateChange_Notification::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.member.clear();
        self.change = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_MemberStateChange_Notification {
        static instance: CChatRoom_MemberStateChange_Notification = CChatRoom_MemberStateChange_Notification {
            chat_group_id: ::std::option::Option::None,
            member: ::protobuf::MessageField::none(),
            change: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Chat Room header / metadata has changed"]
// @@protoc_insertion_point(message:CChatRoom_ChatRoomHeaderState_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_ChatRoomHeaderState_Notification {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_ChatRoomHeaderState_Notification.header_state)
    pub header_state: ::protobuf::MessageField<CChatRoomGroupHeaderState>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_ChatRoomHeaderState_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_ChatRoomHeaderState_Notification {
    fn default() -> &'a CChatRoom_ChatRoomHeaderState_Notification {
        <CChatRoom_ChatRoomHeaderState_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_ChatRoomHeaderState_Notification {
    pub fn new() -> CChatRoom_ChatRoomHeaderState_Notification {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_ChatRoomHeaderState_Notification {
    const NAME: &'static str = "CChatRoom_ChatRoomHeaderState_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header_state)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header_state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_ChatRoomHeaderState_Notification {
        CChatRoom_ChatRoomHeaderState_Notification::new()
    }

    fn clear(&mut self) {
        self.header_state.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_ChatRoomHeaderState_Notification {
        static instance: CChatRoom_ChatRoomHeaderState_Notification = CChatRoom_ChatRoomHeaderState_Notification {
            header_state: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Something about a chatroom group changed (created, deleted, etc.)"]
// @@protoc_insertion_point(message:CChatRoom_ChatRoomGroupRoomsChange_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_ChatRoomGroupRoomsChange_Notification {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_ChatRoomGroupRoomsChange_Notification.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_ChatRoomGroupRoomsChange_Notification.default_chat_id)
    pub default_chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_ChatRoomGroupRoomsChange_Notification.chat_rooms)
    pub chat_rooms: ::std::vec::Vec<CChatRoomState>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_ChatRoomGroupRoomsChange_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_ChatRoomGroupRoomsChange_Notification {
    fn default() -> &'a CChatRoom_ChatRoomGroupRoomsChange_Notification {
        <CChatRoom_ChatRoomGroupRoomsChange_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_ChatRoomGroupRoomsChange_Notification {
    pub fn new() -> CChatRoom_ChatRoomGroupRoomsChange_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 default_chat_id = 2;

    pub fn default_chat_id(&self) -> u64 {
        self.default_chat_id.unwrap_or(0)
    }

    pub fn clear_default_chat_id(&mut self) {
        self.default_chat_id = ::std::option::Option::None;
    }

    pub fn has_default_chat_id(&self) -> bool {
        self.default_chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_chat_id(&mut self, v: u64) {
        self.default_chat_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_ChatRoomGroupRoomsChange_Notification {
    const NAME: &'static str = "CChatRoom_ChatRoomGroupRoomsChange_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.default_chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    self.chat_rooms.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.default_chat_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        for value in &self.chat_rooms {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.default_chat_id {
            os.write_uint64(2, v)?;
        }
        for v in &self.chat_rooms {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_ChatRoomGroupRoomsChange_Notification {
        CChatRoom_ChatRoomGroupRoomsChange_Notification::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.default_chat_id = ::std::option::Option::None;
        self.chat_rooms.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_ChatRoomGroupRoomsChange_Notification {
        static instance: CChatRoom_ChatRoomGroupRoomsChange_Notification = CChatRoom_ChatRoomGroupRoomsChange_Notification {
            chat_group_id: ::std::option::Option::None,
            default_chat_id: ::std::option::Option::None,
            chat_rooms: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Voice chat was recreated or dropped on the backend and client needs to rejoin to remain in chat."]
// @@protoc_insertion_point(message:CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
    fn default() -> &'a CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
        <CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
    pub fn new() -> CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_id = 1;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_group_id = 2;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
    const NAME: &'static str = "CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_group_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
        CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification::new()
    }

    fn clear(&mut self) {
        self.chat_id = ::std::option::Option::None;
        self.chat_group_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
        static instance: CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification = CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
            chat_id: ::std::option::Option::None,
            chat_group_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "User chat group state (preferences, ack state, etc) have changed."]
// @@protoc_insertion_point(message:ChatRoomClient_NotifyChatGroupUserStateChanged_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
    // message fields
    // @@protoc_insertion_point(field:ChatRoomClient_NotifyChatGroupUserStateChanged_Notification.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:ChatRoomClient_NotifyChatGroupUserStateChanged_Notification.user_chat_group_state)
    pub user_chat_group_state: ::protobuf::MessageField<CUserChatRoomGroupState>,
    // @@protoc_insertion_point(field:ChatRoomClient_NotifyChatGroupUserStateChanged_Notification.group_summary)
    pub group_summary: ::protobuf::MessageField<CChatRoom_GetChatRoomGroupSummary_Response>,
    // @@protoc_insertion_point(field:ChatRoomClient_NotifyChatGroupUserStateChanged_Notification.user_action)
    pub user_action: ::std::option::Option<::protobuf::EnumOrUnknown<EChatRoomMemberStateChange>>,
    // special fields
    // @@protoc_insertion_point(special_field:ChatRoomClient_NotifyChatGroupUserStateChanged_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
    fn default() -> &'a ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
        <ChatRoomClient_NotifyChatGroupUserStateChanged_Notification as ::protobuf::Message>::default_instance()
    }
}

impl ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
    pub fn new() -> ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional .EChatRoomMemberStateChange user_action = 4;

    pub fn user_action(&self) -> EChatRoomMemberStateChange {
        match self.user_action {
            Some(e) => e.enum_value_or(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invalid),
            None => EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invalid,
        }
    }

    pub fn clear_user_action(&mut self) {
        self.user_action = ::std::option::Option::None;
    }

    pub fn has_user_action(&self) -> bool {
        self.user_action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_action(&mut self, v: EChatRoomMemberStateChange) {
        self.user_action = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::protobuf::Message for ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
    const NAME: &'static str = "ChatRoomClient_NotifyChatGroupUserStateChanged_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_chat_group_state)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.group_summary)?;
                },
                32 => {
                    self.user_action = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.user_chat_group_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.group_summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.user_action {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.user_chat_group_state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.group_summary.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.user_action {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
        ChatRoomClient_NotifyChatGroupUserStateChanged_Notification::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.user_chat_group_state.clear();
        self.group_summary.clear();
        self.user_action = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
        static instance: ChatRoomClient_NotifyChatGroupUserStateChanged_Notification = ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
            chat_group_id: ::std::option::Option::None,
            user_chat_group_state: ::protobuf::MessageField::none(),
            group_summary: ::protobuf::MessageField::none(),
            user_action: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "The ChatRoom server hosting the chat rooms has reconnected to the user's Chat server (may have restarted), client should refresh state."]
// @@protoc_insertion_point(message:ChatRoomClient_NotifyChatRoomDisconnect_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ChatRoomClient_NotifyChatRoomDisconnect_Notification {
    // message fields
    // @@protoc_insertion_point(field:ChatRoomClient_NotifyChatRoomDisconnect_Notification.chat_group_ids)
    pub chat_group_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:ChatRoomClient_NotifyChatRoomDisconnect_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ChatRoomClient_NotifyChatRoomDisconnect_Notification {
    fn default() -> &'a ChatRoomClient_NotifyChatRoomDisconnect_Notification {
        <ChatRoomClient_NotifyChatRoomDisconnect_Notification as ::protobuf::Message>::default_instance()
    }
}

impl ChatRoomClient_NotifyChatRoomDisconnect_Notification {
    pub fn new() -> ChatRoomClient_NotifyChatRoomDisconnect_Notification {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ChatRoomClient_NotifyChatRoomDisconnect_Notification {
    const NAME: &'static str = "ChatRoomClient_NotifyChatRoomDisconnect_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.chat_group_ids)?;
                },
                8 => {
                    self.chat_group_ids.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.chat_group_ids {
            my_size += ::protobuf::rt::uint64_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.chat_group_ids {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ChatRoomClient_NotifyChatRoomDisconnect_Notification {
        ChatRoomClient_NotifyChatRoomDisconnect_Notification::new()
    }

    fn clear(&mut self) {
        self.chat_group_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ChatRoomClient_NotifyChatRoomDisconnect_Notification {
        static instance: ChatRoomClient_NotifyChatRoomDisconnect_Notification = ChatRoomClient_NotifyChatRoomDisconnect_Notification {
            chat_group_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoomMemberListView)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoomMemberListView {
    // message fields
    // @@protoc_insertion_point(field:CChatRoomMemberListView.start)
    pub start: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CChatRoomMemberListView.end)
    pub end: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CChatRoomMemberListView.total_count)
    pub total_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CChatRoomMemberListView.client_changenumber)
    pub client_changenumber: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CChatRoomMemberListView.server_changenumber)
    pub server_changenumber: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoomMemberListView.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoomMemberListView {
    fn default() -> &'a CChatRoomMemberListView {
        <CChatRoomMemberListView as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoomMemberListView {
    pub fn new() -> CChatRoomMemberListView {
        ::std::default::Default::default()
    }

    // optional int32 start = 3;

    pub fn start(&self) -> i32 {
        self.start.unwrap_or(0)
    }

    pub fn clear_start(&mut self) {
        self.start = ::std::option::Option::None;
    }

    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: i32) {
        self.start = ::std::option::Option::Some(v);
    }

    // optional int32 end = 4;

    pub fn end(&self) -> i32 {
        self.end.unwrap_or(0)
    }

    pub fn clear_end(&mut self) {
        self.end = ::std::option::Option::None;
    }

    pub fn has_end(&self) -> bool {
        self.end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end(&mut self, v: i32) {
        self.end = ::std::option::Option::Some(v);
    }

    // optional int32 total_count = 5;

    pub fn total_count(&self) -> i32 {
        self.total_count.unwrap_or(0)
    }

    pub fn clear_total_count(&mut self) {
        self.total_count = ::std::option::Option::None;
    }

    pub fn has_total_count(&self) -> bool {
        self.total_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_count(&mut self, v: i32) {
        self.total_count = ::std::option::Option::Some(v);
    }

    // optional int32 client_changenumber = 6;

    pub fn client_changenumber(&self) -> i32 {
        self.client_changenumber.unwrap_or(0)
    }

    pub fn clear_client_changenumber(&mut self) {
        self.client_changenumber = ::std::option::Option::None;
    }

    pub fn has_client_changenumber(&self) -> bool {
        self.client_changenumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_changenumber(&mut self, v: i32) {
        self.client_changenumber = ::std::option::Option::Some(v);
    }

    // optional int32 server_changenumber = 7;

    pub fn server_changenumber(&self) -> i32 {
        self.server_changenumber.unwrap_or(0)
    }

    pub fn clear_server_changenumber(&mut self) {
        self.server_changenumber = ::std::option::Option::None;
    }

    pub fn has_server_changenumber(&self) -> bool {
        self.server_changenumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_changenumber(&mut self, v: i32) {
        self.server_changenumber = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoomMemberListView {
    const NAME: &'static str = "CChatRoomMemberListView";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                24 => {
                    self.start = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.end = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.total_count = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.client_changenumber = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.server_changenumber = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.start {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.end {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.total_count {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.client_changenumber {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.server_changenumber {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.start {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.end {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.total_count {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.client_changenumber {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.server_changenumber {
            os.write_int32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoomMemberListView {
        CChatRoomMemberListView::new()
    }

    fn clear(&mut self) {
        self.start = ::std::option::Option::None;
        self.end = ::std::option::Option::None;
        self.total_count = ::std::option::Option::None;
        self.client_changenumber = ::std::option::Option::None;
        self.server_changenumber = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoomMemberListView {
        static instance: CChatRoomMemberListView = CChatRoomMemberListView {
            start: ::std::option::Option::None,
            end: ::std::option::Option::None,
            total_count: ::std::option::Option::None,
            client_changenumber: ::std::option::Option::None,
            server_changenumber: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CChatRoomMemberSummaryCounts)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoomMemberSummaryCounts {
    // message fields
    // @@protoc_insertion_point(field:CChatRoomMemberSummaryCounts.ingame)
    pub ingame: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CChatRoomMemberSummaryCounts.online)
    pub online: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CChatRoomMemberSummaryCounts.offline)
    pub offline: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoomMemberSummaryCounts.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoomMemberSummaryCounts {
    fn default() -> &'a CChatRoomMemberSummaryCounts {
        <CChatRoomMemberSummaryCounts as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoomMemberSummaryCounts {
    pub fn new() -> CChatRoomMemberSummaryCounts {
        ::std::default::Default::default()
    }

    // optional int32 ingame = 1;

    pub fn ingame(&self) -> i32 {
        self.ingame.unwrap_or(0)
    }

    pub fn clear_ingame(&mut self) {
        self.ingame = ::std::option::Option::None;
    }

    pub fn has_ingame(&self) -> bool {
        self.ingame.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ingame(&mut self, v: i32) {
        self.ingame = ::std::option::Option::Some(v);
    }

    // optional int32 online = 2;

    pub fn online(&self) -> i32 {
        self.online.unwrap_or(0)
    }

    pub fn clear_online(&mut self) {
        self.online = ::std::option::Option::None;
    }

    pub fn has_online(&self) -> bool {
        self.online.is_some()
    }

    // Param is passed by value, moved
    pub fn set_online(&mut self, v: i32) {
        self.online = ::std::option::Option::Some(v);
    }

    // optional int32 offline = 3;

    pub fn offline(&self) -> i32 {
        self.offline.unwrap_or(0)
    }

    pub fn clear_offline(&mut self) {
        self.offline = ::std::option::Option::None;
    }

    pub fn has_offline(&self) -> bool {
        self.offline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offline(&mut self, v: i32) {
        self.offline = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoomMemberSummaryCounts {
    const NAME: &'static str = "CChatRoomMemberSummaryCounts";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ingame = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.online = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.offline = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ingame {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.online {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.offline {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ingame {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.online {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.offline {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoomMemberSummaryCounts {
        CChatRoomMemberSummaryCounts::new()
    }

    fn clear(&mut self) {
        self.ingame = ::std::option::Option::None;
        self.online = ::std::option::Option::None;
        self.offline = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoomMemberSummaryCounts {
        static instance: CChatRoomMemberSummaryCounts = CChatRoomMemberSummaryCounts {
            ingame: ::std::option::Option::None,
            online: ::std::option::Option::None,
            offline: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "The list of members for a chat room with virtualized member list has changed on the server (or client requested)"]
// @@protoc_insertion_point(message:CChatRoomClient_MemberListViewUpdated_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoomClient_MemberListViewUpdated_Notification {
    // message fields
    // @@protoc_insertion_point(field:CChatRoomClient_MemberListViewUpdated_Notification.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoomClient_MemberListViewUpdated_Notification.view_id)
    pub view_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoomClient_MemberListViewUpdated_Notification.view)
    pub view: ::protobuf::MessageField<CChatRoomMemberListView>,
    // @@protoc_insertion_point(field:CChatRoomClient_MemberListViewUpdated_Notification.members)
    pub members: ::std::vec::Vec<cchat_room_client_member_list_view_updated_notification::MemberListViewEntry>,
    // @@protoc_insertion_point(field:CChatRoomClient_MemberListViewUpdated_Notification.status_flags)
    pub status_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoomClient_MemberListViewUpdated_Notification.member_summary)
    pub member_summary: ::protobuf::MessageField<CChatRoomMemberSummaryCounts>,
    // @@protoc_insertion_point(field:CChatRoomClient_MemberListViewUpdated_Notification.subscribed_personas)
    pub subscribed_personas: ::std::vec::Vec<super::steammessages_clientserver_friends::cmsg_client_persona_state::Friend>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoomClient_MemberListViewUpdated_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoomClient_MemberListViewUpdated_Notification {
    fn default() -> &'a CChatRoomClient_MemberListViewUpdated_Notification {
        <CChatRoomClient_MemberListViewUpdated_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoomClient_MemberListViewUpdated_Notification {
    pub fn new() -> CChatRoomClient_MemberListViewUpdated_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 view_id = 2;

    pub fn view_id(&self) -> u64 {
        self.view_id.unwrap_or(0)
    }

    pub fn clear_view_id(&mut self) {
        self.view_id = ::std::option::Option::None;
    }

    pub fn has_view_id(&self) -> bool {
        self.view_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_view_id(&mut self, v: u64) {
        self.view_id = ::std::option::Option::Some(v);
    }

    // optional uint32 status_flags = 5;

    pub fn status_flags(&self) -> u32 {
        self.status_flags.unwrap_or(0)
    }

    pub fn clear_status_flags(&mut self) {
        self.status_flags = ::std::option::Option::None;
    }

    pub fn has_status_flags(&self) -> bool {
        self.status_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status_flags(&mut self, v: u32) {
        self.status_flags = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoomClient_MemberListViewUpdated_Notification {
    const NAME: &'static str = "CChatRoomClient_MemberListViewUpdated_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.view_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.view)?;
                },
                34 => {
                    self.members.push(is.read_message()?);
                },
                40 => {
                    self.status_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.member_summary)?;
                },
                58 => {
                    self.subscribed_personas.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.view_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.view.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.status_flags {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.member_summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.subscribed_personas {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.view_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.view.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.members {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.status_flags {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.member_summary.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        for v in &self.subscribed_personas {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoomClient_MemberListViewUpdated_Notification {
        CChatRoomClient_MemberListViewUpdated_Notification::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.view_id = ::std::option::Option::None;
        self.view.clear();
        self.members.clear();
        self.status_flags = ::std::option::Option::None;
        self.member_summary.clear();
        self.subscribed_personas.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoomClient_MemberListViewUpdated_Notification {
        static instance: CChatRoomClient_MemberListViewUpdated_Notification = CChatRoomClient_MemberListViewUpdated_Notification {
            chat_group_id: ::std::option::Option::None,
            view_id: ::std::option::Option::None,
            view: ::protobuf::MessageField::none(),
            members: ::std::vec::Vec::new(),
            status_flags: ::std::option::Option::None,
            member_summary: ::protobuf::MessageField::none(),
            subscribed_personas: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CChatRoomClient_MemberListViewUpdated_Notification`
pub mod cchat_room_client_member_list_view_updated_notification {
    // @@protoc_insertion_point(message:CChatRoomClient_MemberListViewUpdated_Notification.MemberListViewEntry)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct MemberListViewEntry {
        // message fields
        // @@protoc_insertion_point(field:CChatRoomClient_MemberListViewUpdated_Notification.MemberListViewEntry.rank)
        pub rank: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatRoomClient_MemberListViewUpdated_Notification.MemberListViewEntry.accountid)
        pub accountid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CChatRoomClient_MemberListViewUpdated_Notification.MemberListViewEntry.persona)
        pub persona: ::protobuf::MessageField<super::super::steammessages_clientserver_friends::cmsg_client_persona_state::Friend>,
        // special fields
        // @@protoc_insertion_point(special_field:CChatRoomClient_MemberListViewUpdated_Notification.MemberListViewEntry.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MemberListViewEntry {
        fn default() -> &'a MemberListViewEntry {
            <MemberListViewEntry as ::protobuf::Message>::default_instance()
        }
    }

    impl MemberListViewEntry {
        pub fn new() -> MemberListViewEntry {
            ::std::default::Default::default()
        }

        // optional int32 rank = 1;

        pub fn rank(&self) -> i32 {
            self.rank.unwrap_or(0)
        }

        pub fn clear_rank(&mut self) {
            self.rank = ::std::option::Option::None;
        }

        pub fn has_rank(&self) -> bool {
            self.rank.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rank(&mut self, v: i32) {
            self.rank = ::std::option::Option::Some(v);
        }

        // optional uint32 accountid = 2;

        pub fn accountid(&self) -> u32 {
            self.accountid.unwrap_or(0)
        }

        pub fn clear_accountid(&mut self) {
            self.accountid = ::std::option::Option::None;
        }

        pub fn has_accountid(&self) -> bool {
            self.accountid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_accountid(&mut self, v: u32) {
            self.accountid = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for MemberListViewEntry {
        const NAME: &'static str = "MemberListViewEntry";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.rank = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.persona)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.rank {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.accountid {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.persona.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.rank {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.accountid {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.persona.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MemberListViewEntry {
            MemberListViewEntry::new()
        }

        fn clear(&mut self) {
            self.rank = ::std::option::Option::None;
            self.accountid = ::std::option::Option::None;
            self.persona.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MemberListViewEntry {
            static instance: MemberListViewEntry = MemberListViewEntry {
                rank: ::std::option::Option::None,
                accountid: ::std::option::Option::None,
                persona: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

#[doc = "New message reaction"]
// @@protoc_insertion_point(message:CChatRoom_MessageReaction_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_MessageReaction_Notification {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_MessageReaction_Notification.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_MessageReaction_Notification.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_MessageReaction_Notification.server_timestamp)
    pub server_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_MessageReaction_Notification.ordinal)
    pub ordinal: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_MessageReaction_Notification.reactor)
    pub reactor: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_MessageReaction_Notification.reaction_type)
    pub reaction_type: ::std::option::Option<::protobuf::EnumOrUnknown<EChatRoomMessageReactionType>>,
    // @@protoc_insertion_point(field:CChatRoom_MessageReaction_Notification.reaction)
    pub reaction: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoom_MessageReaction_Notification.is_add)
    pub is_add: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_MessageReaction_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_MessageReaction_Notification {
    fn default() -> &'a CChatRoom_MessageReaction_Notification {
        <CChatRoom_MessageReaction_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_MessageReaction_Notification {
    pub fn new() -> CChatRoom_MessageReaction_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional uint32 server_timestamp = 3;

    pub fn server_timestamp(&self) -> u32 {
        self.server_timestamp.unwrap_or(0)
    }

    pub fn clear_server_timestamp(&mut self) {
        self.server_timestamp = ::std::option::Option::None;
    }

    pub fn has_server_timestamp(&self) -> bool {
        self.server_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_timestamp(&mut self, v: u32) {
        self.server_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 ordinal = 4;

    pub fn ordinal(&self) -> u32 {
        self.ordinal.unwrap_or(0)
    }

    pub fn clear_ordinal(&mut self) {
        self.ordinal = ::std::option::Option::None;
    }

    pub fn has_ordinal(&self) -> bool {
        self.ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordinal(&mut self, v: u32) {
        self.ordinal = ::std::option::Option::Some(v);
    }

    // optional fixed64 reactor = 5;

    pub fn reactor(&self) -> u64 {
        self.reactor.unwrap_or(0)
    }

    pub fn clear_reactor(&mut self) {
        self.reactor = ::std::option::Option::None;
    }

    pub fn has_reactor(&self) -> bool {
        self.reactor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reactor(&mut self, v: u64) {
        self.reactor = ::std::option::Option::Some(v);
    }

    // optional .EChatRoomMessageReactionType reaction_type = 6;

    pub fn reaction_type(&self) -> EChatRoomMessageReactionType {
        match self.reaction_type {
            Some(e) => e.enum_value_or(EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Invalid),
            None => EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Invalid,
        }
    }

    pub fn clear_reaction_type(&mut self) {
        self.reaction_type = ::std::option::Option::None;
    }

    pub fn has_reaction_type(&self) -> bool {
        self.reaction_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reaction_type(&mut self, v: EChatRoomMessageReactionType) {
        self.reaction_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string reaction = 7;

    pub fn reaction(&self) -> &str {
        match self.reaction.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reaction(&mut self) {
        self.reaction = ::std::option::Option::None;
    }

    pub fn has_reaction(&self) -> bool {
        self.reaction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reaction(&mut self, v: ::std::string::String) {
        self.reaction = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reaction(&mut self) -> &mut ::std::string::String {
        if self.reaction.is_none() {
            self.reaction = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reaction.as_mut().unwrap()
    }

    // Take field
    pub fn take_reaction(&mut self) -> ::std::string::String {
        self.reaction.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_add = 8;

    pub fn is_add(&self) -> bool {
        self.is_add.unwrap_or(false)
    }

    pub fn clear_is_add(&mut self) {
        self.is_add = ::std::option::Option::None;
    }

    pub fn has_is_add(&self) -> bool {
        self.is_add.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_add(&mut self, v: bool) {
        self.is_add = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_MessageReaction_Notification {
    const NAME: &'static str = "CChatRoom_MessageReaction_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.server_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.ordinal = ::std::option::Option::Some(is.read_uint32()?);
                },
                41 => {
                    self.reactor = ::std::option::Option::Some(is.read_fixed64()?);
                },
                48 => {
                    self.reaction_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                58 => {
                    self.reaction = ::std::option::Option::Some(is.read_string()?);
                },
                64 => {
                    self.is_add = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.server_timestamp {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.ordinal {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.reactor {
            my_size += 1 + 8;
        }
        if let Some(v) = self.reaction_type {
            my_size += ::protobuf::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.reaction.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.is_add {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.server_timestamp {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.ordinal {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.reactor {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.reaction_type {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.reaction.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.is_add {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_MessageReaction_Notification {
        CChatRoom_MessageReaction_Notification::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.server_timestamp = ::std::option::Option::None;
        self.ordinal = ::std::option::Option::None;
        self.reactor = ::std::option::Option::None;
        self.reaction_type = ::std::option::Option::None;
        self.reaction = ::std::option::Option::None;
        self.is_add = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_MessageReaction_Notification {
        static instance: CChatRoom_MessageReaction_Notification = CChatRoom_MessageReaction_Notification {
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            server_timestamp: ::std::option::Option::None,
            ordinal: ::std::option::Option::None,
            reactor: ::std::option::Option::None,
            reaction_type: ::std::option::Option::None,
            reaction: ::std::option::Option::None,
            is_add: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Incoming metrics from the client"]
// @@protoc_insertion_point(message:CChatUsability_ClientUsabilityMetrics_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatUsability_ClientUsabilityMetrics_Notification {
    // message fields
    // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.metrics_run_id)
    pub metrics_run_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.client_build)
    pub client_build: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.metrics_version)
    pub metrics_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.in_web)
    pub in_web: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.settings)
    pub settings: ::protobuf::MessageField<cchat_usability_client_usability_metrics_notification::Settings>,
    // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.voice_settings)
    pub voice_settings: ::protobuf::MessageField<cchat_usability_client_usability_metrics_notification::VoiceSettings>,
    // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.ui_state)
    pub ui_state: ::protobuf::MessageField<cchat_usability_client_usability_metrics_notification::UIState>,
    // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.metrics)
    pub metrics: ::protobuf::MessageField<cchat_usability_client_usability_metrics_notification::Metrics>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatUsability_ClientUsabilityMetrics_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatUsability_ClientUsabilityMetrics_Notification {
    fn default() -> &'a CChatUsability_ClientUsabilityMetrics_Notification {
        <CChatUsability_ClientUsabilityMetrics_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CChatUsability_ClientUsabilityMetrics_Notification {
    pub fn new() -> CChatUsability_ClientUsabilityMetrics_Notification {
        ::std::default::Default::default()
    }

    // optional uint32 metrics_run_id = 1;

    pub fn metrics_run_id(&self) -> u32 {
        self.metrics_run_id.unwrap_or(0)
    }

    pub fn clear_metrics_run_id(&mut self) {
        self.metrics_run_id = ::std::option::Option::None;
    }

    pub fn has_metrics_run_id(&self) -> bool {
        self.metrics_run_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metrics_run_id(&mut self, v: u32) {
        self.metrics_run_id = ::std::option::Option::Some(v);
    }

    // optional uint32 client_build = 2;

    pub fn client_build(&self) -> u32 {
        self.client_build.unwrap_or(0)
    }

    pub fn clear_client_build(&mut self) {
        self.client_build = ::std::option::Option::None;
    }

    pub fn has_client_build(&self) -> bool {
        self.client_build.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_build(&mut self, v: u32) {
        self.client_build = ::std::option::Option::Some(v);
    }

    // optional uint32 metrics_version = 3;

    pub fn metrics_version(&self) -> u32 {
        self.metrics_version.unwrap_or(0)
    }

    pub fn clear_metrics_version(&mut self) {
        self.metrics_version = ::std::option::Option::None;
    }

    pub fn has_metrics_version(&self) -> bool {
        self.metrics_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metrics_version(&mut self, v: u32) {
        self.metrics_version = ::std::option::Option::Some(v);
    }

    // optional bool in_web = 4;

    pub fn in_web(&self) -> bool {
        self.in_web.unwrap_or(false)
    }

    pub fn clear_in_web(&mut self) {
        self.in_web = ::std::option::Option::None;
    }

    pub fn has_in_web(&self) -> bool {
        self.in_web.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_web(&mut self, v: bool) {
        self.in_web = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatUsability_ClientUsabilityMetrics_Notification {
    const NAME: &'static str = "CChatUsability_ClientUsabilityMetrics_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.metrics_run_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.client_build = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.metrics_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.in_web = ::std::option::Option::Some(is.read_bool()?);
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.settings)?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.voice_settings)?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ui_state)?;
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metrics)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metrics_run_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.client_build {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.metrics_version {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.in_web {
            my_size += 1 + 1;
        }
        if let Some(v) = self.settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.voice_settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ui_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.metrics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metrics_run_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.client_build {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.metrics_version {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.in_web {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.settings.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.voice_settings.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.ui_state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.metrics.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatUsability_ClientUsabilityMetrics_Notification {
        CChatUsability_ClientUsabilityMetrics_Notification::new()
    }

    fn clear(&mut self) {
        self.metrics_run_id = ::std::option::Option::None;
        self.client_build = ::std::option::Option::None;
        self.metrics_version = ::std::option::Option::None;
        self.in_web = ::std::option::Option::None;
        self.settings.clear();
        self.voice_settings.clear();
        self.ui_state.clear();
        self.metrics.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatUsability_ClientUsabilityMetrics_Notification {
        static instance: CChatUsability_ClientUsabilityMetrics_Notification = CChatUsability_ClientUsabilityMetrics_Notification {
            metrics_run_id: ::std::option::Option::None,
            client_build: ::std::option::Option::None,
            metrics_version: ::std::option::Option::None,
            in_web: ::std::option::Option::None,
            settings: ::protobuf::MessageField::none(),
            voice_settings: ::protobuf::MessageField::none(),
            ui_state: ::protobuf::MessageField::none(),
            metrics: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CChatUsability_ClientUsabilityMetrics_Notification`
pub mod cchat_usability_client_usability_metrics_notification {
    // @@protoc_insertion_point(message:CChatUsability_ClientUsabilityMetrics_Notification.Settings)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Settings {
        // message fields
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.notifications_show_ingame)
        pub notifications_show_ingame: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.notifications_show_online)
        pub notifications_show_online: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.notifications_show_message)
        pub notifications_show_message: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.notifications_events_and_announcements)
        pub notifications_events_and_announcements: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.sounds_play_ingame)
        pub sounds_play_ingame: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.sounds_play_online)
        pub sounds_play_online: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.sounds_play_message)
        pub sounds_play_message: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.sounds_events_and_announcements)
        pub sounds_events_and_announcements: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.always_new_chat_window)
        pub always_new_chat_window: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.force_alphabetic_friend_sorting)
        pub force_alphabetic_friend_sorting: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.chat_flash_mode)
        pub chat_flash_mode: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.remember_open_chats)
        pub remember_open_chats: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.compact_quick_access)
        pub compact_quick_access: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.compact_friends_list)
        pub compact_friends_list: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.notifications_show_chat_room_notification)
        pub notifications_show_chat_room_notification: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.sounds_play_chat_room_notification)
        pub sounds_play_chat_room_notification: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.hide_offline_friends_in_tag_groups)
        pub hide_offline_friends_in_tag_groups: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.hide_categorized_friends)
        pub hide_categorized_friends: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.categorize_in_game_friends_by_game)
        pub categorize_in_game_friends_by_game: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.chat_font_size)
        pub chat_font_size: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.use24hour_clock)
        pub use24hour_clock: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.do_not_disturb_mode)
        pub do_not_disturb_mode: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.disable_embed_inlining)
        pub disable_embed_inlining: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.sign_into_friends)
        pub sign_into_friends: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.animated_avatars)
        pub animated_avatars: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Settings {
        fn default() -> &'a Settings {
            <Settings as ::protobuf::Message>::default_instance()
        }
    }

    impl Settings {
        pub fn new() -> Settings {
            ::std::default::Default::default()
        }

        // optional bool notifications_show_ingame = 1;

        pub fn notifications_show_ingame(&self) -> bool {
            self.notifications_show_ingame.unwrap_or(false)
        }

        pub fn clear_notifications_show_ingame(&mut self) {
            self.notifications_show_ingame = ::std::option::Option::None;
        }

        pub fn has_notifications_show_ingame(&self) -> bool {
            self.notifications_show_ingame.is_some()
        }

        // Param is passed by value, moved
        pub fn set_notifications_show_ingame(&mut self, v: bool) {
            self.notifications_show_ingame = ::std::option::Option::Some(v);
        }

        // optional bool notifications_show_online = 2;

        pub fn notifications_show_online(&self) -> bool {
            self.notifications_show_online.unwrap_or(false)
        }

        pub fn clear_notifications_show_online(&mut self) {
            self.notifications_show_online = ::std::option::Option::None;
        }

        pub fn has_notifications_show_online(&self) -> bool {
            self.notifications_show_online.is_some()
        }

        // Param is passed by value, moved
        pub fn set_notifications_show_online(&mut self, v: bool) {
            self.notifications_show_online = ::std::option::Option::Some(v);
        }

        // optional bool notifications_show_message = 3;

        pub fn notifications_show_message(&self) -> bool {
            self.notifications_show_message.unwrap_or(false)
        }

        pub fn clear_notifications_show_message(&mut self) {
            self.notifications_show_message = ::std::option::Option::None;
        }

        pub fn has_notifications_show_message(&self) -> bool {
            self.notifications_show_message.is_some()
        }

        // Param is passed by value, moved
        pub fn set_notifications_show_message(&mut self, v: bool) {
            self.notifications_show_message = ::std::option::Option::Some(v);
        }

        // optional bool notifications_events_and_announcements = 4;

        pub fn notifications_events_and_announcements(&self) -> bool {
            self.notifications_events_and_announcements.unwrap_or(false)
        }

        pub fn clear_notifications_events_and_announcements(&mut self) {
            self.notifications_events_and_announcements = ::std::option::Option::None;
        }

        pub fn has_notifications_events_and_announcements(&self) -> bool {
            self.notifications_events_and_announcements.is_some()
        }

        // Param is passed by value, moved
        pub fn set_notifications_events_and_announcements(&mut self, v: bool) {
            self.notifications_events_and_announcements = ::std::option::Option::Some(v);
        }

        // optional bool sounds_play_ingame = 5;

        pub fn sounds_play_ingame(&self) -> bool {
            self.sounds_play_ingame.unwrap_or(false)
        }

        pub fn clear_sounds_play_ingame(&mut self) {
            self.sounds_play_ingame = ::std::option::Option::None;
        }

        pub fn has_sounds_play_ingame(&self) -> bool {
            self.sounds_play_ingame.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sounds_play_ingame(&mut self, v: bool) {
            self.sounds_play_ingame = ::std::option::Option::Some(v);
        }

        // optional bool sounds_play_online = 6;

        pub fn sounds_play_online(&self) -> bool {
            self.sounds_play_online.unwrap_or(false)
        }

        pub fn clear_sounds_play_online(&mut self) {
            self.sounds_play_online = ::std::option::Option::None;
        }

        pub fn has_sounds_play_online(&self) -> bool {
            self.sounds_play_online.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sounds_play_online(&mut self, v: bool) {
            self.sounds_play_online = ::std::option::Option::Some(v);
        }

        // optional bool sounds_play_message = 7;

        pub fn sounds_play_message(&self) -> bool {
            self.sounds_play_message.unwrap_or(false)
        }

        pub fn clear_sounds_play_message(&mut self) {
            self.sounds_play_message = ::std::option::Option::None;
        }

        pub fn has_sounds_play_message(&self) -> bool {
            self.sounds_play_message.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sounds_play_message(&mut self, v: bool) {
            self.sounds_play_message = ::std::option::Option::Some(v);
        }

        // optional bool sounds_events_and_announcements = 8;

        pub fn sounds_events_and_announcements(&self) -> bool {
            self.sounds_events_and_announcements.unwrap_or(false)
        }

        pub fn clear_sounds_events_and_announcements(&mut self) {
            self.sounds_events_and_announcements = ::std::option::Option::None;
        }

        pub fn has_sounds_events_and_announcements(&self) -> bool {
            self.sounds_events_and_announcements.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sounds_events_and_announcements(&mut self, v: bool) {
            self.sounds_events_and_announcements = ::std::option::Option::Some(v);
        }

        // optional bool always_new_chat_window = 9;

        pub fn always_new_chat_window(&self) -> bool {
            self.always_new_chat_window.unwrap_or(false)
        }

        pub fn clear_always_new_chat_window(&mut self) {
            self.always_new_chat_window = ::std::option::Option::None;
        }

        pub fn has_always_new_chat_window(&self) -> bool {
            self.always_new_chat_window.is_some()
        }

        // Param is passed by value, moved
        pub fn set_always_new_chat_window(&mut self, v: bool) {
            self.always_new_chat_window = ::std::option::Option::Some(v);
        }

        // optional bool force_alphabetic_friend_sorting = 10;

        pub fn force_alphabetic_friend_sorting(&self) -> bool {
            self.force_alphabetic_friend_sorting.unwrap_or(false)
        }

        pub fn clear_force_alphabetic_friend_sorting(&mut self) {
            self.force_alphabetic_friend_sorting = ::std::option::Option::None;
        }

        pub fn has_force_alphabetic_friend_sorting(&self) -> bool {
            self.force_alphabetic_friend_sorting.is_some()
        }

        // Param is passed by value, moved
        pub fn set_force_alphabetic_friend_sorting(&mut self, v: bool) {
            self.force_alphabetic_friend_sorting = ::std::option::Option::Some(v);
        }

        // optional int32 chat_flash_mode = 11;

        pub fn chat_flash_mode(&self) -> i32 {
            self.chat_flash_mode.unwrap_or(0)
        }

        pub fn clear_chat_flash_mode(&mut self) {
            self.chat_flash_mode = ::std::option::Option::None;
        }

        pub fn has_chat_flash_mode(&self) -> bool {
            self.chat_flash_mode.is_some()
        }

        // Param is passed by value, moved
        pub fn set_chat_flash_mode(&mut self, v: i32) {
            self.chat_flash_mode = ::std::option::Option::Some(v);
        }

        // optional bool remember_open_chats = 12;

        pub fn remember_open_chats(&self) -> bool {
            self.remember_open_chats.unwrap_or(false)
        }

        pub fn clear_remember_open_chats(&mut self) {
            self.remember_open_chats = ::std::option::Option::None;
        }

        pub fn has_remember_open_chats(&self) -> bool {
            self.remember_open_chats.is_some()
        }

        // Param is passed by value, moved
        pub fn set_remember_open_chats(&mut self, v: bool) {
            self.remember_open_chats = ::std::option::Option::Some(v);
        }

        // optional bool compact_quick_access = 13;

        pub fn compact_quick_access(&self) -> bool {
            self.compact_quick_access.unwrap_or(false)
        }

        pub fn clear_compact_quick_access(&mut self) {
            self.compact_quick_access = ::std::option::Option::None;
        }

        pub fn has_compact_quick_access(&self) -> bool {
            self.compact_quick_access.is_some()
        }

        // Param is passed by value, moved
        pub fn set_compact_quick_access(&mut self, v: bool) {
            self.compact_quick_access = ::std::option::Option::Some(v);
        }

        // optional bool compact_friends_list = 14;

        pub fn compact_friends_list(&self) -> bool {
            self.compact_friends_list.unwrap_or(false)
        }

        pub fn clear_compact_friends_list(&mut self) {
            self.compact_friends_list = ::std::option::Option::None;
        }

        pub fn has_compact_friends_list(&self) -> bool {
            self.compact_friends_list.is_some()
        }

        // Param is passed by value, moved
        pub fn set_compact_friends_list(&mut self, v: bool) {
            self.compact_friends_list = ::std::option::Option::Some(v);
        }

        // optional bool notifications_show_chat_room_notification = 15;

        pub fn notifications_show_chat_room_notification(&self) -> bool {
            self.notifications_show_chat_room_notification.unwrap_or(false)
        }

        pub fn clear_notifications_show_chat_room_notification(&mut self) {
            self.notifications_show_chat_room_notification = ::std::option::Option::None;
        }

        pub fn has_notifications_show_chat_room_notification(&self) -> bool {
            self.notifications_show_chat_room_notification.is_some()
        }

        // Param is passed by value, moved
        pub fn set_notifications_show_chat_room_notification(&mut self, v: bool) {
            self.notifications_show_chat_room_notification = ::std::option::Option::Some(v);
        }

        // optional bool sounds_play_chat_room_notification = 16;

        pub fn sounds_play_chat_room_notification(&self) -> bool {
            self.sounds_play_chat_room_notification.unwrap_or(false)
        }

        pub fn clear_sounds_play_chat_room_notification(&mut self) {
            self.sounds_play_chat_room_notification = ::std::option::Option::None;
        }

        pub fn has_sounds_play_chat_room_notification(&self) -> bool {
            self.sounds_play_chat_room_notification.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sounds_play_chat_room_notification(&mut self, v: bool) {
            self.sounds_play_chat_room_notification = ::std::option::Option::Some(v);
        }

        // optional bool hide_offline_friends_in_tag_groups = 17;

        pub fn hide_offline_friends_in_tag_groups(&self) -> bool {
            self.hide_offline_friends_in_tag_groups.unwrap_or(false)
        }

        pub fn clear_hide_offline_friends_in_tag_groups(&mut self) {
            self.hide_offline_friends_in_tag_groups = ::std::option::Option::None;
        }

        pub fn has_hide_offline_friends_in_tag_groups(&self) -> bool {
            self.hide_offline_friends_in_tag_groups.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hide_offline_friends_in_tag_groups(&mut self, v: bool) {
            self.hide_offline_friends_in_tag_groups = ::std::option::Option::Some(v);
        }

        // optional bool hide_categorized_friends = 18;

        pub fn hide_categorized_friends(&self) -> bool {
            self.hide_categorized_friends.unwrap_or(false)
        }

        pub fn clear_hide_categorized_friends(&mut self) {
            self.hide_categorized_friends = ::std::option::Option::None;
        }

        pub fn has_hide_categorized_friends(&self) -> bool {
            self.hide_categorized_friends.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hide_categorized_friends(&mut self, v: bool) {
            self.hide_categorized_friends = ::std::option::Option::Some(v);
        }

        // optional bool categorize_in_game_friends_by_game = 19;

        pub fn categorize_in_game_friends_by_game(&self) -> bool {
            self.categorize_in_game_friends_by_game.unwrap_or(false)
        }

        pub fn clear_categorize_in_game_friends_by_game(&mut self) {
            self.categorize_in_game_friends_by_game = ::std::option::Option::None;
        }

        pub fn has_categorize_in_game_friends_by_game(&self) -> bool {
            self.categorize_in_game_friends_by_game.is_some()
        }

        // Param is passed by value, moved
        pub fn set_categorize_in_game_friends_by_game(&mut self, v: bool) {
            self.categorize_in_game_friends_by_game = ::std::option::Option::Some(v);
        }

        // optional int32 chat_font_size = 20;

        pub fn chat_font_size(&self) -> i32 {
            self.chat_font_size.unwrap_or(0)
        }

        pub fn clear_chat_font_size(&mut self) {
            self.chat_font_size = ::std::option::Option::None;
        }

        pub fn has_chat_font_size(&self) -> bool {
            self.chat_font_size.is_some()
        }

        // Param is passed by value, moved
        pub fn set_chat_font_size(&mut self, v: i32) {
            self.chat_font_size = ::std::option::Option::Some(v);
        }

        // optional bool use24hour_clock = 21;

        pub fn use24hour_clock(&self) -> bool {
            self.use24hour_clock.unwrap_or(false)
        }

        pub fn clear_use24hour_clock(&mut self) {
            self.use24hour_clock = ::std::option::Option::None;
        }

        pub fn has_use24hour_clock(&self) -> bool {
            self.use24hour_clock.is_some()
        }

        // Param is passed by value, moved
        pub fn set_use24hour_clock(&mut self, v: bool) {
            self.use24hour_clock = ::std::option::Option::Some(v);
        }

        // optional bool do_not_disturb_mode = 22;

        pub fn do_not_disturb_mode(&self) -> bool {
            self.do_not_disturb_mode.unwrap_or(false)
        }

        pub fn clear_do_not_disturb_mode(&mut self) {
            self.do_not_disturb_mode = ::std::option::Option::None;
        }

        pub fn has_do_not_disturb_mode(&self) -> bool {
            self.do_not_disturb_mode.is_some()
        }

        // Param is passed by value, moved
        pub fn set_do_not_disturb_mode(&mut self, v: bool) {
            self.do_not_disturb_mode = ::std::option::Option::Some(v);
        }

        // optional bool disable_embed_inlining = 23;

        pub fn disable_embed_inlining(&self) -> bool {
            self.disable_embed_inlining.unwrap_or(false)
        }

        pub fn clear_disable_embed_inlining(&mut self) {
            self.disable_embed_inlining = ::std::option::Option::None;
        }

        pub fn has_disable_embed_inlining(&self) -> bool {
            self.disable_embed_inlining.is_some()
        }

        // Param is passed by value, moved
        pub fn set_disable_embed_inlining(&mut self, v: bool) {
            self.disable_embed_inlining = ::std::option::Option::Some(v);
        }

        // optional bool sign_into_friends = 24;

        pub fn sign_into_friends(&self) -> bool {
            self.sign_into_friends.unwrap_or(false)
        }

        pub fn clear_sign_into_friends(&mut self) {
            self.sign_into_friends = ::std::option::Option::None;
        }

        pub fn has_sign_into_friends(&self) -> bool {
            self.sign_into_friends.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sign_into_friends(&mut self, v: bool) {
            self.sign_into_friends = ::std::option::Option::Some(v);
        }

        // optional bool animated_avatars = 25;

        pub fn animated_avatars(&self) -> bool {
            self.animated_avatars.unwrap_or(false)
        }

        pub fn clear_animated_avatars(&mut self) {
            self.animated_avatars = ::std::option::Option::None;
        }

        pub fn has_animated_avatars(&self) -> bool {
            self.animated_avatars.is_some()
        }

        // Param is passed by value, moved
        pub fn set_animated_avatars(&mut self, v: bool) {
            self.animated_avatars = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Settings {
        const NAME: &'static str = "Settings";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.notifications_show_ingame = ::std::option::Option::Some(is.read_bool()?);
                    },
                    16 => {
                        self.notifications_show_online = ::std::option::Option::Some(is.read_bool()?);
                    },
                    24 => {
                        self.notifications_show_message = ::std::option::Option::Some(is.read_bool()?);
                    },
                    32 => {
                        self.notifications_events_and_announcements = ::std::option::Option::Some(is.read_bool()?);
                    },
                    40 => {
                        self.sounds_play_ingame = ::std::option::Option::Some(is.read_bool()?);
                    },
                    48 => {
                        self.sounds_play_online = ::std::option::Option::Some(is.read_bool()?);
                    },
                    56 => {
                        self.sounds_play_message = ::std::option::Option::Some(is.read_bool()?);
                    },
                    64 => {
                        self.sounds_events_and_announcements = ::std::option::Option::Some(is.read_bool()?);
                    },
                    72 => {
                        self.always_new_chat_window = ::std::option::Option::Some(is.read_bool()?);
                    },
                    80 => {
                        self.force_alphabetic_friend_sorting = ::std::option::Option::Some(is.read_bool()?);
                    },
                    88 => {
                        self.chat_flash_mode = ::std::option::Option::Some(is.read_int32()?);
                    },
                    96 => {
                        self.remember_open_chats = ::std::option::Option::Some(is.read_bool()?);
                    },
                    104 => {
                        self.compact_quick_access = ::std::option::Option::Some(is.read_bool()?);
                    },
                    112 => {
                        self.compact_friends_list = ::std::option::Option::Some(is.read_bool()?);
                    },
                    120 => {
                        self.notifications_show_chat_room_notification = ::std::option::Option::Some(is.read_bool()?);
                    },
                    128 => {
                        self.sounds_play_chat_room_notification = ::std::option::Option::Some(is.read_bool()?);
                    },
                    136 => {
                        self.hide_offline_friends_in_tag_groups = ::std::option::Option::Some(is.read_bool()?);
                    },
                    144 => {
                        self.hide_categorized_friends = ::std::option::Option::Some(is.read_bool()?);
                    },
                    152 => {
                        self.categorize_in_game_friends_by_game = ::std::option::Option::Some(is.read_bool()?);
                    },
                    160 => {
                        self.chat_font_size = ::std::option::Option::Some(is.read_int32()?);
                    },
                    168 => {
                        self.use24hour_clock = ::std::option::Option::Some(is.read_bool()?);
                    },
                    176 => {
                        self.do_not_disturb_mode = ::std::option::Option::Some(is.read_bool()?);
                    },
                    184 => {
                        self.disable_embed_inlining = ::std::option::Option::Some(is.read_bool()?);
                    },
                    192 => {
                        self.sign_into_friends = ::std::option::Option::Some(is.read_bool()?);
                    },
                    200 => {
                        self.animated_avatars = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.notifications_show_ingame {
                my_size += 1 + 1;
            }
            if let Some(v) = self.notifications_show_online {
                my_size += 1 + 1;
            }
            if let Some(v) = self.notifications_show_message {
                my_size += 1 + 1;
            }
            if let Some(v) = self.notifications_events_and_announcements {
                my_size += 1 + 1;
            }
            if let Some(v) = self.sounds_play_ingame {
                my_size += 1 + 1;
            }
            if let Some(v) = self.sounds_play_online {
                my_size += 1 + 1;
            }
            if let Some(v) = self.sounds_play_message {
                my_size += 1 + 1;
            }
            if let Some(v) = self.sounds_events_and_announcements {
                my_size += 1 + 1;
            }
            if let Some(v) = self.always_new_chat_window {
                my_size += 1 + 1;
            }
            if let Some(v) = self.force_alphabetic_friend_sorting {
                my_size += 1 + 1;
            }
            if let Some(v) = self.chat_flash_mode {
                my_size += ::protobuf::rt::int32_size(11, v);
            }
            if let Some(v) = self.remember_open_chats {
                my_size += 1 + 1;
            }
            if let Some(v) = self.compact_quick_access {
                my_size += 1 + 1;
            }
            if let Some(v) = self.compact_friends_list {
                my_size += 1 + 1;
            }
            if let Some(v) = self.notifications_show_chat_room_notification {
                my_size += 1 + 1;
            }
            if let Some(v) = self.sounds_play_chat_room_notification {
                my_size += 2 + 1;
            }
            if let Some(v) = self.hide_offline_friends_in_tag_groups {
                my_size += 2 + 1;
            }
            if let Some(v) = self.hide_categorized_friends {
                my_size += 2 + 1;
            }
            if let Some(v) = self.categorize_in_game_friends_by_game {
                my_size += 2 + 1;
            }
            if let Some(v) = self.chat_font_size {
                my_size += ::protobuf::rt::int32_size(20, v);
            }
            if let Some(v) = self.use24hour_clock {
                my_size += 2 + 1;
            }
            if let Some(v) = self.do_not_disturb_mode {
                my_size += 2 + 1;
            }
            if let Some(v) = self.disable_embed_inlining {
                my_size += 2 + 1;
            }
            if let Some(v) = self.sign_into_friends {
                my_size += 2 + 1;
            }
            if let Some(v) = self.animated_avatars {
                my_size += 2 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.notifications_show_ingame {
                os.write_bool(1, v)?;
            }
            if let Some(v) = self.notifications_show_online {
                os.write_bool(2, v)?;
            }
            if let Some(v) = self.notifications_show_message {
                os.write_bool(3, v)?;
            }
            if let Some(v) = self.notifications_events_and_announcements {
                os.write_bool(4, v)?;
            }
            if let Some(v) = self.sounds_play_ingame {
                os.write_bool(5, v)?;
            }
            if let Some(v) = self.sounds_play_online {
                os.write_bool(6, v)?;
            }
            if let Some(v) = self.sounds_play_message {
                os.write_bool(7, v)?;
            }
            if let Some(v) = self.sounds_events_and_announcements {
                os.write_bool(8, v)?;
            }
            if let Some(v) = self.always_new_chat_window {
                os.write_bool(9, v)?;
            }
            if let Some(v) = self.force_alphabetic_friend_sorting {
                os.write_bool(10, v)?;
            }
            if let Some(v) = self.chat_flash_mode {
                os.write_int32(11, v)?;
            }
            if let Some(v) = self.remember_open_chats {
                os.write_bool(12, v)?;
            }
            if let Some(v) = self.compact_quick_access {
                os.write_bool(13, v)?;
            }
            if let Some(v) = self.compact_friends_list {
                os.write_bool(14, v)?;
            }
            if let Some(v) = self.notifications_show_chat_room_notification {
                os.write_bool(15, v)?;
            }
            if let Some(v) = self.sounds_play_chat_room_notification {
                os.write_bool(16, v)?;
            }
            if let Some(v) = self.hide_offline_friends_in_tag_groups {
                os.write_bool(17, v)?;
            }
            if let Some(v) = self.hide_categorized_friends {
                os.write_bool(18, v)?;
            }
            if let Some(v) = self.categorize_in_game_friends_by_game {
                os.write_bool(19, v)?;
            }
            if let Some(v) = self.chat_font_size {
                os.write_int32(20, v)?;
            }
            if let Some(v) = self.use24hour_clock {
                os.write_bool(21, v)?;
            }
            if let Some(v) = self.do_not_disturb_mode {
                os.write_bool(22, v)?;
            }
            if let Some(v) = self.disable_embed_inlining {
                os.write_bool(23, v)?;
            }
            if let Some(v) = self.sign_into_friends {
                os.write_bool(24, v)?;
            }
            if let Some(v) = self.animated_avatars {
                os.write_bool(25, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Settings {
            Settings::new()
        }

        fn clear(&mut self) {
            self.notifications_show_ingame = ::std::option::Option::None;
            self.notifications_show_online = ::std::option::Option::None;
            self.notifications_show_message = ::std::option::Option::None;
            self.notifications_events_and_announcements = ::std::option::Option::None;
            self.sounds_play_ingame = ::std::option::Option::None;
            self.sounds_play_online = ::std::option::Option::None;
            self.sounds_play_message = ::std::option::Option::None;
            self.sounds_events_and_announcements = ::std::option::Option::None;
            self.always_new_chat_window = ::std::option::Option::None;
            self.force_alphabetic_friend_sorting = ::std::option::Option::None;
            self.chat_flash_mode = ::std::option::Option::None;
            self.remember_open_chats = ::std::option::Option::None;
            self.compact_quick_access = ::std::option::Option::None;
            self.compact_friends_list = ::std::option::Option::None;
            self.notifications_show_chat_room_notification = ::std::option::Option::None;
            self.sounds_play_chat_room_notification = ::std::option::Option::None;
            self.hide_offline_friends_in_tag_groups = ::std::option::Option::None;
            self.hide_categorized_friends = ::std::option::Option::None;
            self.categorize_in_game_friends_by_game = ::std::option::Option::None;
            self.chat_font_size = ::std::option::Option::None;
            self.use24hour_clock = ::std::option::Option::None;
            self.do_not_disturb_mode = ::std::option::Option::None;
            self.disable_embed_inlining = ::std::option::Option::None;
            self.sign_into_friends = ::std::option::Option::None;
            self.animated_avatars = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Settings {
            static instance: Settings = Settings {
                notifications_show_ingame: ::std::option::Option::None,
                notifications_show_online: ::std::option::Option::None,
                notifications_show_message: ::std::option::Option::None,
                notifications_events_and_announcements: ::std::option::Option::None,
                sounds_play_ingame: ::std::option::Option::None,
                sounds_play_online: ::std::option::Option::None,
                sounds_play_message: ::std::option::Option::None,
                sounds_events_and_announcements: ::std::option::Option::None,
                always_new_chat_window: ::std::option::Option::None,
                force_alphabetic_friend_sorting: ::std::option::Option::None,
                chat_flash_mode: ::std::option::Option::None,
                remember_open_chats: ::std::option::Option::None,
                compact_quick_access: ::std::option::Option::None,
                compact_friends_list: ::std::option::Option::None,
                notifications_show_chat_room_notification: ::std::option::Option::None,
                sounds_play_chat_room_notification: ::std::option::Option::None,
                hide_offline_friends_in_tag_groups: ::std::option::Option::None,
                hide_categorized_friends: ::std::option::Option::None,
                categorize_in_game_friends_by_game: ::std::option::Option::None,
                chat_font_size: ::std::option::Option::None,
                use24hour_clock: ::std::option::Option::None,
                do_not_disturb_mode: ::std::option::Option::None,
                disable_embed_inlining: ::std::option::Option::None,
                sign_into_friends: ::std::option::Option::None,
                animated_avatars: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettings)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct VoiceSettings {
        // message fields
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettings.voice_input_gain)
        pub voice_input_gain: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettings.voice_output_gain)
        pub voice_output_gain: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettings.noise_gate_level)
        pub noise_gate_level: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettings.voice_use_echo_cancellation)
        pub voice_use_echo_cancellation: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettings.voice_use_noise_cancellation)
        pub voice_use_noise_cancellation: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettings.voice_use_auto_gain_control)
        pub voice_use_auto_gain_control: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettings.selected_non_default_mic)
        pub selected_non_default_mic: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettings.selected_non_default_output)
        pub selected_non_default_output: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettings.push_to_talk_enabled)
        pub push_to_talk_enabled: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettings.push_to_mute_enabled)
        pub push_to_mute_enabled: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettings.play_ptt_sounds)
        pub play_ptt_sounds: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettings.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a VoiceSettings {
        fn default() -> &'a VoiceSettings {
            <VoiceSettings as ::protobuf::Message>::default_instance()
        }
    }

    impl VoiceSettings {
        pub fn new() -> VoiceSettings {
            ::std::default::Default::default()
        }

        // optional float voice_input_gain = 1;

        pub fn voice_input_gain(&self) -> f32 {
            self.voice_input_gain.unwrap_or(0.)
        }

        pub fn clear_voice_input_gain(&mut self) {
            self.voice_input_gain = ::std::option::Option::None;
        }

        pub fn has_voice_input_gain(&self) -> bool {
            self.voice_input_gain.is_some()
        }

        // Param is passed by value, moved
        pub fn set_voice_input_gain(&mut self, v: f32) {
            self.voice_input_gain = ::std::option::Option::Some(v);
        }

        // optional float voice_output_gain = 2;

        pub fn voice_output_gain(&self) -> f32 {
            self.voice_output_gain.unwrap_or(0.)
        }

        pub fn clear_voice_output_gain(&mut self) {
            self.voice_output_gain = ::std::option::Option::None;
        }

        pub fn has_voice_output_gain(&self) -> bool {
            self.voice_output_gain.is_some()
        }

        // Param is passed by value, moved
        pub fn set_voice_output_gain(&mut self, v: f32) {
            self.voice_output_gain = ::std::option::Option::Some(v);
        }

        // optional int32 noise_gate_level = 3;

        pub fn noise_gate_level(&self) -> i32 {
            self.noise_gate_level.unwrap_or(0)
        }

        pub fn clear_noise_gate_level(&mut self) {
            self.noise_gate_level = ::std::option::Option::None;
        }

        pub fn has_noise_gate_level(&self) -> bool {
            self.noise_gate_level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_noise_gate_level(&mut self, v: i32) {
            self.noise_gate_level = ::std::option::Option::Some(v);
        }

        // optional bool voice_use_echo_cancellation = 4;

        pub fn voice_use_echo_cancellation(&self) -> bool {
            self.voice_use_echo_cancellation.unwrap_or(false)
        }

        pub fn clear_voice_use_echo_cancellation(&mut self) {
            self.voice_use_echo_cancellation = ::std::option::Option::None;
        }

        pub fn has_voice_use_echo_cancellation(&self) -> bool {
            self.voice_use_echo_cancellation.is_some()
        }

        // Param is passed by value, moved
        pub fn set_voice_use_echo_cancellation(&mut self, v: bool) {
            self.voice_use_echo_cancellation = ::std::option::Option::Some(v);
        }

        // optional bool voice_use_noise_cancellation = 5;

        pub fn voice_use_noise_cancellation(&self) -> bool {
            self.voice_use_noise_cancellation.unwrap_or(false)
        }

        pub fn clear_voice_use_noise_cancellation(&mut self) {
            self.voice_use_noise_cancellation = ::std::option::Option::None;
        }

        pub fn has_voice_use_noise_cancellation(&self) -> bool {
            self.voice_use_noise_cancellation.is_some()
        }

        // Param is passed by value, moved
        pub fn set_voice_use_noise_cancellation(&mut self, v: bool) {
            self.voice_use_noise_cancellation = ::std::option::Option::Some(v);
        }

        // optional bool voice_use_auto_gain_control = 6;

        pub fn voice_use_auto_gain_control(&self) -> bool {
            self.voice_use_auto_gain_control.unwrap_or(false)
        }

        pub fn clear_voice_use_auto_gain_control(&mut self) {
            self.voice_use_auto_gain_control = ::std::option::Option::None;
        }

        pub fn has_voice_use_auto_gain_control(&self) -> bool {
            self.voice_use_auto_gain_control.is_some()
        }

        // Param is passed by value, moved
        pub fn set_voice_use_auto_gain_control(&mut self, v: bool) {
            self.voice_use_auto_gain_control = ::std::option::Option::Some(v);
        }

        // optional bool selected_non_default_mic = 7;

        pub fn selected_non_default_mic(&self) -> bool {
            self.selected_non_default_mic.unwrap_or(false)
        }

        pub fn clear_selected_non_default_mic(&mut self) {
            self.selected_non_default_mic = ::std::option::Option::None;
        }

        pub fn has_selected_non_default_mic(&self) -> bool {
            self.selected_non_default_mic.is_some()
        }

        // Param is passed by value, moved
        pub fn set_selected_non_default_mic(&mut self, v: bool) {
            self.selected_non_default_mic = ::std::option::Option::Some(v);
        }

        // optional bool selected_non_default_output = 8;

        pub fn selected_non_default_output(&self) -> bool {
            self.selected_non_default_output.unwrap_or(false)
        }

        pub fn clear_selected_non_default_output(&mut self) {
            self.selected_non_default_output = ::std::option::Option::None;
        }

        pub fn has_selected_non_default_output(&self) -> bool {
            self.selected_non_default_output.is_some()
        }

        // Param is passed by value, moved
        pub fn set_selected_non_default_output(&mut self, v: bool) {
            self.selected_non_default_output = ::std::option::Option::Some(v);
        }

        // optional bool push_to_talk_enabled = 9;

        pub fn push_to_talk_enabled(&self) -> bool {
            self.push_to_talk_enabled.unwrap_or(false)
        }

        pub fn clear_push_to_talk_enabled(&mut self) {
            self.push_to_talk_enabled = ::std::option::Option::None;
        }

        pub fn has_push_to_talk_enabled(&self) -> bool {
            self.push_to_talk_enabled.is_some()
        }

        // Param is passed by value, moved
        pub fn set_push_to_talk_enabled(&mut self, v: bool) {
            self.push_to_talk_enabled = ::std::option::Option::Some(v);
        }

        // optional bool push_to_mute_enabled = 10;

        pub fn push_to_mute_enabled(&self) -> bool {
            self.push_to_mute_enabled.unwrap_or(false)
        }

        pub fn clear_push_to_mute_enabled(&mut self) {
            self.push_to_mute_enabled = ::std::option::Option::None;
        }

        pub fn has_push_to_mute_enabled(&self) -> bool {
            self.push_to_mute_enabled.is_some()
        }

        // Param is passed by value, moved
        pub fn set_push_to_mute_enabled(&mut self, v: bool) {
            self.push_to_mute_enabled = ::std::option::Option::Some(v);
        }

        // optional bool play_ptt_sounds = 11;

        pub fn play_ptt_sounds(&self) -> bool {
            self.play_ptt_sounds.unwrap_or(false)
        }

        pub fn clear_play_ptt_sounds(&mut self) {
            self.play_ptt_sounds = ::std::option::Option::None;
        }

        pub fn has_play_ptt_sounds(&self) -> bool {
            self.play_ptt_sounds.is_some()
        }

        // Param is passed by value, moved
        pub fn set_play_ptt_sounds(&mut self, v: bool) {
            self.play_ptt_sounds = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for VoiceSettings {
        const NAME: &'static str = "VoiceSettings";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.voice_input_gain = ::std::option::Option::Some(is.read_float()?);
                    },
                    21 => {
                        self.voice_output_gain = ::std::option::Option::Some(is.read_float()?);
                    },
                    24 => {
                        self.noise_gate_level = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.voice_use_echo_cancellation = ::std::option::Option::Some(is.read_bool()?);
                    },
                    40 => {
                        self.voice_use_noise_cancellation = ::std::option::Option::Some(is.read_bool()?);
                    },
                    48 => {
                        self.voice_use_auto_gain_control = ::std::option::Option::Some(is.read_bool()?);
                    },
                    56 => {
                        self.selected_non_default_mic = ::std::option::Option::Some(is.read_bool()?);
                    },
                    64 => {
                        self.selected_non_default_output = ::std::option::Option::Some(is.read_bool()?);
                    },
                    72 => {
                        self.push_to_talk_enabled = ::std::option::Option::Some(is.read_bool()?);
                    },
                    80 => {
                        self.push_to_mute_enabled = ::std::option::Option::Some(is.read_bool()?);
                    },
                    88 => {
                        self.play_ptt_sounds = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.voice_input_gain {
                my_size += 1 + 4;
            }
            if let Some(v) = self.voice_output_gain {
                my_size += 1 + 4;
            }
            if let Some(v) = self.noise_gate_level {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.voice_use_echo_cancellation {
                my_size += 1 + 1;
            }
            if let Some(v) = self.voice_use_noise_cancellation {
                my_size += 1 + 1;
            }
            if let Some(v) = self.voice_use_auto_gain_control {
                my_size += 1 + 1;
            }
            if let Some(v) = self.selected_non_default_mic {
                my_size += 1 + 1;
            }
            if let Some(v) = self.selected_non_default_output {
                my_size += 1 + 1;
            }
            if let Some(v) = self.push_to_talk_enabled {
                my_size += 1 + 1;
            }
            if let Some(v) = self.push_to_mute_enabled {
                my_size += 1 + 1;
            }
            if let Some(v) = self.play_ptt_sounds {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.voice_input_gain {
                os.write_float(1, v)?;
            }
            if let Some(v) = self.voice_output_gain {
                os.write_float(2, v)?;
            }
            if let Some(v) = self.noise_gate_level {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.voice_use_echo_cancellation {
                os.write_bool(4, v)?;
            }
            if let Some(v) = self.voice_use_noise_cancellation {
                os.write_bool(5, v)?;
            }
            if let Some(v) = self.voice_use_auto_gain_control {
                os.write_bool(6, v)?;
            }
            if let Some(v) = self.selected_non_default_mic {
                os.write_bool(7, v)?;
            }
            if let Some(v) = self.selected_non_default_output {
                os.write_bool(8, v)?;
            }
            if let Some(v) = self.push_to_talk_enabled {
                os.write_bool(9, v)?;
            }
            if let Some(v) = self.push_to_mute_enabled {
                os.write_bool(10, v)?;
            }
            if let Some(v) = self.play_ptt_sounds {
                os.write_bool(11, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> VoiceSettings {
            VoiceSettings::new()
        }

        fn clear(&mut self) {
            self.voice_input_gain = ::std::option::Option::None;
            self.voice_output_gain = ::std::option::Option::None;
            self.noise_gate_level = ::std::option::Option::None;
            self.voice_use_echo_cancellation = ::std::option::Option::None;
            self.voice_use_noise_cancellation = ::std::option::Option::None;
            self.voice_use_auto_gain_control = ::std::option::Option::None;
            self.selected_non_default_mic = ::std::option::Option::None;
            self.selected_non_default_output = ::std::option::Option::None;
            self.push_to_talk_enabled = ::std::option::Option::None;
            self.push_to_mute_enabled = ::std::option::Option::None;
            self.play_ptt_sounds = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static VoiceSettings {
            static instance: VoiceSettings = VoiceSettings {
                voice_input_gain: ::std::option::Option::None,
                voice_output_gain: ::std::option::Option::None,
                noise_gate_level: ::std::option::Option::None,
                voice_use_echo_cancellation: ::std::option::Option::None,
                voice_use_noise_cancellation: ::std::option::Option::None,
                voice_use_auto_gain_control: ::std::option::Option::None,
                selected_non_default_mic: ::std::option::Option::None,
                selected_non_default_output: ::std::option::Option::None,
                push_to_talk_enabled: ::std::option::Option::None,
                push_to_mute_enabled: ::std::option::Option::None,
                play_ptt_sounds: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CChatUsability_ClientUsabilityMetrics_Notification.UIState)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct UIState {
        // message fields
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.friends_list_height)
        pub friends_list_height: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.friends_list_width)
        pub friends_list_width: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.friends_list_docked)
        pub friends_list_docked: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.friends_list_collapsed)
        pub friends_list_collapsed: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.friends_list_group_chats_height)
        pub friends_list_group_chats_height: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.friends_list_visible)
        pub friends_list_visible: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.chat_popups_opened)
        pub chat_popups_opened: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.group_chat_tabs_opened)
        pub group_chat_tabs_opened: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.friend_chat_tabs_opened)
        pub friend_chat_tabs_opened: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.chat_window_width)
        pub chat_window_width: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.chat_window_height)
        pub chat_window_height: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.category_collapse)
        pub category_collapse: ::protobuf::MessageField<uistate::CategoryCollapseState>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.group_chat_left_col_collapsed)
        pub group_chat_left_col_collapsed: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.group_chat_right_col_collapsed)
        pub group_chat_right_col_collapsed: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.in_one_on_one_voice_chat)
        pub in_one_on_one_voice_chat: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.in_group_voice_chat)
        pub in_group_voice_chat: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a UIState {
        fn default() -> &'a UIState {
            <UIState as ::protobuf::Message>::default_instance()
        }
    }

    impl UIState {
        pub fn new() -> UIState {
            ::std::default::Default::default()
        }

        // optional int32 friends_list_height = 1;

        pub fn friends_list_height(&self) -> i32 {
            self.friends_list_height.unwrap_or(0)
        }

        pub fn clear_friends_list_height(&mut self) {
            self.friends_list_height = ::std::option::Option::None;
        }

        pub fn has_friends_list_height(&self) -> bool {
            self.friends_list_height.is_some()
        }

        // Param is passed by value, moved
        pub fn set_friends_list_height(&mut self, v: i32) {
            self.friends_list_height = ::std::option::Option::Some(v);
        }

        // optional int32 friends_list_width = 2;

        pub fn friends_list_width(&self) -> i32 {
            self.friends_list_width.unwrap_or(0)
        }

        pub fn clear_friends_list_width(&mut self) {
            self.friends_list_width = ::std::option::Option::None;
        }

        pub fn has_friends_list_width(&self) -> bool {
            self.friends_list_width.is_some()
        }

        // Param is passed by value, moved
        pub fn set_friends_list_width(&mut self, v: i32) {
            self.friends_list_width = ::std::option::Option::Some(v);
        }

        // optional bool friends_list_docked = 3;

        pub fn friends_list_docked(&self) -> bool {
            self.friends_list_docked.unwrap_or(false)
        }

        pub fn clear_friends_list_docked(&mut self) {
            self.friends_list_docked = ::std::option::Option::None;
        }

        pub fn has_friends_list_docked(&self) -> bool {
            self.friends_list_docked.is_some()
        }

        // Param is passed by value, moved
        pub fn set_friends_list_docked(&mut self, v: bool) {
            self.friends_list_docked = ::std::option::Option::Some(v);
        }

        // optional bool friends_list_collapsed = 4;

        pub fn friends_list_collapsed(&self) -> bool {
            self.friends_list_collapsed.unwrap_or(false)
        }

        pub fn clear_friends_list_collapsed(&mut self) {
            self.friends_list_collapsed = ::std::option::Option::None;
        }

        pub fn has_friends_list_collapsed(&self) -> bool {
            self.friends_list_collapsed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_friends_list_collapsed(&mut self, v: bool) {
            self.friends_list_collapsed = ::std::option::Option::Some(v);
        }

        // optional int32 friends_list_group_chats_height = 5;

        pub fn friends_list_group_chats_height(&self) -> i32 {
            self.friends_list_group_chats_height.unwrap_or(0)
        }

        pub fn clear_friends_list_group_chats_height(&mut self) {
            self.friends_list_group_chats_height = ::std::option::Option::None;
        }

        pub fn has_friends_list_group_chats_height(&self) -> bool {
            self.friends_list_group_chats_height.is_some()
        }

        // Param is passed by value, moved
        pub fn set_friends_list_group_chats_height(&mut self, v: i32) {
            self.friends_list_group_chats_height = ::std::option::Option::Some(v);
        }

        // optional bool friends_list_visible = 6;

        pub fn friends_list_visible(&self) -> bool {
            self.friends_list_visible.unwrap_or(false)
        }

        pub fn clear_friends_list_visible(&mut self) {
            self.friends_list_visible = ::std::option::Option::None;
        }

        pub fn has_friends_list_visible(&self) -> bool {
            self.friends_list_visible.is_some()
        }

        // Param is passed by value, moved
        pub fn set_friends_list_visible(&mut self, v: bool) {
            self.friends_list_visible = ::std::option::Option::Some(v);
        }

        // optional int32 chat_popups_opened = 7;

        pub fn chat_popups_opened(&self) -> i32 {
            self.chat_popups_opened.unwrap_or(0)
        }

        pub fn clear_chat_popups_opened(&mut self) {
            self.chat_popups_opened = ::std::option::Option::None;
        }

        pub fn has_chat_popups_opened(&self) -> bool {
            self.chat_popups_opened.is_some()
        }

        // Param is passed by value, moved
        pub fn set_chat_popups_opened(&mut self, v: i32) {
            self.chat_popups_opened = ::std::option::Option::Some(v);
        }

        // optional int32 group_chat_tabs_opened = 8;

        pub fn group_chat_tabs_opened(&self) -> i32 {
            self.group_chat_tabs_opened.unwrap_or(0)
        }

        pub fn clear_group_chat_tabs_opened(&mut self) {
            self.group_chat_tabs_opened = ::std::option::Option::None;
        }

        pub fn has_group_chat_tabs_opened(&self) -> bool {
            self.group_chat_tabs_opened.is_some()
        }

        // Param is passed by value, moved
        pub fn set_group_chat_tabs_opened(&mut self, v: i32) {
            self.group_chat_tabs_opened = ::std::option::Option::Some(v);
        }

        // optional int32 friend_chat_tabs_opened = 9;

        pub fn friend_chat_tabs_opened(&self) -> i32 {
            self.friend_chat_tabs_opened.unwrap_or(0)
        }

        pub fn clear_friend_chat_tabs_opened(&mut self) {
            self.friend_chat_tabs_opened = ::std::option::Option::None;
        }

        pub fn has_friend_chat_tabs_opened(&self) -> bool {
            self.friend_chat_tabs_opened.is_some()
        }

        // Param is passed by value, moved
        pub fn set_friend_chat_tabs_opened(&mut self, v: i32) {
            self.friend_chat_tabs_opened = ::std::option::Option::Some(v);
        }

        // optional int32 chat_window_width = 10;

        pub fn chat_window_width(&self) -> i32 {
            self.chat_window_width.unwrap_or(0)
        }

        pub fn clear_chat_window_width(&mut self) {
            self.chat_window_width = ::std::option::Option::None;
        }

        pub fn has_chat_window_width(&self) -> bool {
            self.chat_window_width.is_some()
        }

        // Param is passed by value, moved
        pub fn set_chat_window_width(&mut self, v: i32) {
            self.chat_window_width = ::std::option::Option::Some(v);
        }

        // optional int32 chat_window_height = 11;

        pub fn chat_window_height(&self) -> i32 {
            self.chat_window_height.unwrap_or(0)
        }

        pub fn clear_chat_window_height(&mut self) {
            self.chat_window_height = ::std::option::Option::None;
        }

        pub fn has_chat_window_height(&self) -> bool {
            self.chat_window_height.is_some()
        }

        // Param is passed by value, moved
        pub fn set_chat_window_height(&mut self, v: i32) {
            self.chat_window_height = ::std::option::Option::Some(v);
        }

        // optional int32 group_chat_left_col_collapsed = 13;

        pub fn group_chat_left_col_collapsed(&self) -> i32 {
            self.group_chat_left_col_collapsed.unwrap_or(0)
        }

        pub fn clear_group_chat_left_col_collapsed(&mut self) {
            self.group_chat_left_col_collapsed = ::std::option::Option::None;
        }

        pub fn has_group_chat_left_col_collapsed(&self) -> bool {
            self.group_chat_left_col_collapsed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_group_chat_left_col_collapsed(&mut self, v: i32) {
            self.group_chat_left_col_collapsed = ::std::option::Option::Some(v);
        }

        // optional int32 group_chat_right_col_collapsed = 14;

        pub fn group_chat_right_col_collapsed(&self) -> i32 {
            self.group_chat_right_col_collapsed.unwrap_or(0)
        }

        pub fn clear_group_chat_right_col_collapsed(&mut self) {
            self.group_chat_right_col_collapsed = ::std::option::Option::None;
        }

        pub fn has_group_chat_right_col_collapsed(&self) -> bool {
            self.group_chat_right_col_collapsed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_group_chat_right_col_collapsed(&mut self, v: i32) {
            self.group_chat_right_col_collapsed = ::std::option::Option::Some(v);
        }

        // optional bool in_one_on_one_voice_chat = 15;

        pub fn in_one_on_one_voice_chat(&self) -> bool {
            self.in_one_on_one_voice_chat.unwrap_or(false)
        }

        pub fn clear_in_one_on_one_voice_chat(&mut self) {
            self.in_one_on_one_voice_chat = ::std::option::Option::None;
        }

        pub fn has_in_one_on_one_voice_chat(&self) -> bool {
            self.in_one_on_one_voice_chat.is_some()
        }

        // Param is passed by value, moved
        pub fn set_in_one_on_one_voice_chat(&mut self, v: bool) {
            self.in_one_on_one_voice_chat = ::std::option::Option::Some(v);
        }

        // optional bool in_group_voice_chat = 16;

        pub fn in_group_voice_chat(&self) -> bool {
            self.in_group_voice_chat.unwrap_or(false)
        }

        pub fn clear_in_group_voice_chat(&mut self) {
            self.in_group_voice_chat = ::std::option::Option::None;
        }

        pub fn has_in_group_voice_chat(&self) -> bool {
            self.in_group_voice_chat.is_some()
        }

        // Param is passed by value, moved
        pub fn set_in_group_voice_chat(&mut self, v: bool) {
            self.in_group_voice_chat = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for UIState {
        const NAME: &'static str = "UIState";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.friends_list_height = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.friends_list_width = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.friends_list_docked = ::std::option::Option::Some(is.read_bool()?);
                    },
                    32 => {
                        self.friends_list_collapsed = ::std::option::Option::Some(is.read_bool()?);
                    },
                    40 => {
                        self.friends_list_group_chats_height = ::std::option::Option::Some(is.read_int32()?);
                    },
                    48 => {
                        self.friends_list_visible = ::std::option::Option::Some(is.read_bool()?);
                    },
                    56 => {
                        self.chat_popups_opened = ::std::option::Option::Some(is.read_int32()?);
                    },
                    64 => {
                        self.group_chat_tabs_opened = ::std::option::Option::Some(is.read_int32()?);
                    },
                    72 => {
                        self.friend_chat_tabs_opened = ::std::option::Option::Some(is.read_int32()?);
                    },
                    80 => {
                        self.chat_window_width = ::std::option::Option::Some(is.read_int32()?);
                    },
                    88 => {
                        self.chat_window_height = ::std::option::Option::Some(is.read_int32()?);
                    },
                    98 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.category_collapse)?;
                    },
                    104 => {
                        self.group_chat_left_col_collapsed = ::std::option::Option::Some(is.read_int32()?);
                    },
                    112 => {
                        self.group_chat_right_col_collapsed = ::std::option::Option::Some(is.read_int32()?);
                    },
                    120 => {
                        self.in_one_on_one_voice_chat = ::std::option::Option::Some(is.read_bool()?);
                    },
                    128 => {
                        self.in_group_voice_chat = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.friends_list_height {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.friends_list_width {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.friends_list_docked {
                my_size += 1 + 1;
            }
            if let Some(v) = self.friends_list_collapsed {
                my_size += 1 + 1;
            }
            if let Some(v) = self.friends_list_group_chats_height {
                my_size += ::protobuf::rt::int32_size(5, v);
            }
            if let Some(v) = self.friends_list_visible {
                my_size += 1 + 1;
            }
            if let Some(v) = self.chat_popups_opened {
                my_size += ::protobuf::rt::int32_size(7, v);
            }
            if let Some(v) = self.group_chat_tabs_opened {
                my_size += ::protobuf::rt::int32_size(8, v);
            }
            if let Some(v) = self.friend_chat_tabs_opened {
                my_size += ::protobuf::rt::int32_size(9, v);
            }
            if let Some(v) = self.chat_window_width {
                my_size += ::protobuf::rt::int32_size(10, v);
            }
            if let Some(v) = self.chat_window_height {
                my_size += ::protobuf::rt::int32_size(11, v);
            }
            if let Some(v) = self.category_collapse.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.group_chat_left_col_collapsed {
                my_size += ::protobuf::rt::int32_size(13, v);
            }
            if let Some(v) = self.group_chat_right_col_collapsed {
                my_size += ::protobuf::rt::int32_size(14, v);
            }
            if let Some(v) = self.in_one_on_one_voice_chat {
                my_size += 1 + 1;
            }
            if let Some(v) = self.in_group_voice_chat {
                my_size += 2 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.friends_list_height {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.friends_list_width {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.friends_list_docked {
                os.write_bool(3, v)?;
            }
            if let Some(v) = self.friends_list_collapsed {
                os.write_bool(4, v)?;
            }
            if let Some(v) = self.friends_list_group_chats_height {
                os.write_int32(5, v)?;
            }
            if let Some(v) = self.friends_list_visible {
                os.write_bool(6, v)?;
            }
            if let Some(v) = self.chat_popups_opened {
                os.write_int32(7, v)?;
            }
            if let Some(v) = self.group_chat_tabs_opened {
                os.write_int32(8, v)?;
            }
            if let Some(v) = self.friend_chat_tabs_opened {
                os.write_int32(9, v)?;
            }
            if let Some(v) = self.chat_window_width {
                os.write_int32(10, v)?;
            }
            if let Some(v) = self.chat_window_height {
                os.write_int32(11, v)?;
            }
            if let Some(v) = self.category_collapse.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
            }
            if let Some(v) = self.group_chat_left_col_collapsed {
                os.write_int32(13, v)?;
            }
            if let Some(v) = self.group_chat_right_col_collapsed {
                os.write_int32(14, v)?;
            }
            if let Some(v) = self.in_one_on_one_voice_chat {
                os.write_bool(15, v)?;
            }
            if let Some(v) = self.in_group_voice_chat {
                os.write_bool(16, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> UIState {
            UIState::new()
        }

        fn clear(&mut self) {
            self.friends_list_height = ::std::option::Option::None;
            self.friends_list_width = ::std::option::Option::None;
            self.friends_list_docked = ::std::option::Option::None;
            self.friends_list_collapsed = ::std::option::Option::None;
            self.friends_list_group_chats_height = ::std::option::Option::None;
            self.friends_list_visible = ::std::option::Option::None;
            self.chat_popups_opened = ::std::option::Option::None;
            self.group_chat_tabs_opened = ::std::option::Option::None;
            self.friend_chat_tabs_opened = ::std::option::Option::None;
            self.chat_window_width = ::std::option::Option::None;
            self.chat_window_height = ::std::option::Option::None;
            self.category_collapse.clear();
            self.group_chat_left_col_collapsed = ::std::option::Option::None;
            self.group_chat_right_col_collapsed = ::std::option::Option::None;
            self.in_one_on_one_voice_chat = ::std::option::Option::None;
            self.in_group_voice_chat = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static UIState {
            static instance: UIState = UIState {
                friends_list_height: ::std::option::Option::None,
                friends_list_width: ::std::option::Option::None,
                friends_list_docked: ::std::option::Option::None,
                friends_list_collapsed: ::std::option::Option::None,
                friends_list_group_chats_height: ::std::option::Option::None,
                friends_list_visible: ::std::option::Option::None,
                chat_popups_opened: ::std::option::Option::None,
                group_chat_tabs_opened: ::std::option::Option::None,
                friend_chat_tabs_opened: ::std::option::Option::None,
                chat_window_width: ::std::option::Option::None,
                chat_window_height: ::std::option::Option::None,
                category_collapse: ::protobuf::MessageField::none(),
                group_chat_left_col_collapsed: ::std::option::Option::None,
                group_chat_right_col_collapsed: ::std::option::Option::None,
                in_one_on_one_voice_chat: ::std::option::Option::None,
                in_group_voice_chat: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `UIState`
    pub mod uistate {
        // @@protoc_insertion_point(message:CChatUsability_ClientUsabilityMetrics_Notification.UIState.CategoryCollapseState)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct CategoryCollapseState {
            // message fields
            // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.CategoryCollapseState.in_game_collapsed)
            pub in_game_collapsed: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.CategoryCollapseState.online_collapsed)
            pub online_collapsed: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.CategoryCollapseState.offline_collapsed)
            pub offline_collapsed: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.CategoryCollapseState.game_groups_collapsed)
            pub game_groups_collapsed: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.CategoryCollapseState.categories_collapsed)
            pub categories_collapsed: ::std::option::Option<i32>,
            // special fields
            // @@protoc_insertion_point(special_field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.CategoryCollapseState.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a CategoryCollapseState {
            fn default() -> &'a CategoryCollapseState {
                <CategoryCollapseState as ::protobuf::Message>::default_instance()
            }
        }

        impl CategoryCollapseState {
            pub fn new() -> CategoryCollapseState {
                ::std::default::Default::default()
            }

            // optional bool in_game_collapsed = 1;

            pub fn in_game_collapsed(&self) -> bool {
                self.in_game_collapsed.unwrap_or(false)
            }

            pub fn clear_in_game_collapsed(&mut self) {
                self.in_game_collapsed = ::std::option::Option::None;
            }

            pub fn has_in_game_collapsed(&self) -> bool {
                self.in_game_collapsed.is_some()
            }

            // Param is passed by value, moved
            pub fn set_in_game_collapsed(&mut self, v: bool) {
                self.in_game_collapsed = ::std::option::Option::Some(v);
            }

            // optional bool online_collapsed = 2;

            pub fn online_collapsed(&self) -> bool {
                self.online_collapsed.unwrap_or(false)
            }

            pub fn clear_online_collapsed(&mut self) {
                self.online_collapsed = ::std::option::Option::None;
            }

            pub fn has_online_collapsed(&self) -> bool {
                self.online_collapsed.is_some()
            }

            // Param is passed by value, moved
            pub fn set_online_collapsed(&mut self, v: bool) {
                self.online_collapsed = ::std::option::Option::Some(v);
            }

            // optional bool offline_collapsed = 3;

            pub fn offline_collapsed(&self) -> bool {
                self.offline_collapsed.unwrap_or(false)
            }

            pub fn clear_offline_collapsed(&mut self) {
                self.offline_collapsed = ::std::option::Option::None;
            }

            pub fn has_offline_collapsed(&self) -> bool {
                self.offline_collapsed.is_some()
            }

            // Param is passed by value, moved
            pub fn set_offline_collapsed(&mut self, v: bool) {
                self.offline_collapsed = ::std::option::Option::Some(v);
            }

            // optional int32 game_groups_collapsed = 4;

            pub fn game_groups_collapsed(&self) -> i32 {
                self.game_groups_collapsed.unwrap_or(0)
            }

            pub fn clear_game_groups_collapsed(&mut self) {
                self.game_groups_collapsed = ::std::option::Option::None;
            }

            pub fn has_game_groups_collapsed(&self) -> bool {
                self.game_groups_collapsed.is_some()
            }

            // Param is passed by value, moved
            pub fn set_game_groups_collapsed(&mut self, v: i32) {
                self.game_groups_collapsed = ::std::option::Option::Some(v);
            }

            // optional int32 categories_collapsed = 5;

            pub fn categories_collapsed(&self) -> i32 {
                self.categories_collapsed.unwrap_or(0)
            }

            pub fn clear_categories_collapsed(&mut self) {
                self.categories_collapsed = ::std::option::Option::None;
            }

            pub fn has_categories_collapsed(&self) -> bool {
                self.categories_collapsed.is_some()
            }

            // Param is passed by value, moved
            pub fn set_categories_collapsed(&mut self, v: i32) {
                self.categories_collapsed = ::std::option::Option::Some(v);
            }
        }

        impl ::protobuf::Message for CategoryCollapseState {
            const NAME: &'static str = "CategoryCollapseState";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.in_game_collapsed = ::std::option::Option::Some(is.read_bool()?);
                        },
                        16 => {
                            self.online_collapsed = ::std::option::Option::Some(is.read_bool()?);
                        },
                        24 => {
                            self.offline_collapsed = ::std::option::Option::Some(is.read_bool()?);
                        },
                        32 => {
                            self.game_groups_collapsed = ::std::option::Option::Some(is.read_int32()?);
                        },
                        40 => {
                            self.categories_collapsed = ::std::option::Option::Some(is.read_int32()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.in_game_collapsed {
                    my_size += 1 + 1;
                }
                if let Some(v) = self.online_collapsed {
                    my_size += 1 + 1;
                }
                if let Some(v) = self.offline_collapsed {
                    my_size += 1 + 1;
                }
                if let Some(v) = self.game_groups_collapsed {
                    my_size += ::protobuf::rt::int32_size(4, v);
                }
                if let Some(v) = self.categories_collapsed {
                    my_size += ::protobuf::rt::int32_size(5, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.in_game_collapsed {
                    os.write_bool(1, v)?;
                }
                if let Some(v) = self.online_collapsed {
                    os.write_bool(2, v)?;
                }
                if let Some(v) = self.offline_collapsed {
                    os.write_bool(3, v)?;
                }
                if let Some(v) = self.game_groups_collapsed {
                    os.write_int32(4, v)?;
                }
                if let Some(v) = self.categories_collapsed {
                    os.write_int32(5, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> CategoryCollapseState {
                CategoryCollapseState::new()
            }

            fn clear(&mut self) {
                self.in_game_collapsed = ::std::option::Option::None;
                self.online_collapsed = ::std::option::Option::None;
                self.offline_collapsed = ::std::option::Option::None;
                self.game_groups_collapsed = ::std::option::Option::None;
                self.categories_collapsed = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static CategoryCollapseState {
                static instance: CategoryCollapseState = CategoryCollapseState {
                    in_game_collapsed: ::std::option::Option::None,
                    online_collapsed: ::std::option::Option::None,
                    offline_collapsed: ::std::option::Option::None,
                    game_groups_collapsed: ::std::option::Option::None,
                    categories_collapsed: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }
    }

    // @@protoc_insertion_point(message:CChatUsability_ClientUsabilityMetrics_Notification.Metrics)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Metrics {
        // message fields
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Metrics.friends_count)
        pub friends_count: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Metrics.friends_category_count)
        pub friends_category_count: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Metrics.friends_categorized_count)
        pub friends_categorized_count: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Metrics.friends_online_count)
        pub friends_online_count: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Metrics.friends_in_game_count)
        pub friends_in_game_count: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Metrics.friends_in_game_singleton_count)
        pub friends_in_game_singleton_count: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Metrics.game_group_count)
        pub game_group_count: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Metrics.friends_favorite_count)
        pub friends_favorite_count: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Metrics.group_chat_count)
        pub group_chat_count: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Metrics.group_chat_favorite_count)
        pub group_chat_favorite_count: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CChatUsability_ClientUsabilityMetrics_Notification.Metrics.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Metrics {
        fn default() -> &'a Metrics {
            <Metrics as ::protobuf::Message>::default_instance()
        }
    }

    impl Metrics {
        pub fn new() -> Metrics {
            ::std::default::Default::default()
        }

        // optional int32 friends_count = 1;

        pub fn friends_count(&self) -> i32 {
            self.friends_count.unwrap_or(0)
        }

        pub fn clear_friends_count(&mut self) {
            self.friends_count = ::std::option::Option::None;
        }

        pub fn has_friends_count(&self) -> bool {
            self.friends_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_friends_count(&mut self, v: i32) {
            self.friends_count = ::std::option::Option::Some(v);
        }

        // optional int32 friends_category_count = 2;

        pub fn friends_category_count(&self) -> i32 {
            self.friends_category_count.unwrap_or(0)
        }

        pub fn clear_friends_category_count(&mut self) {
            self.friends_category_count = ::std::option::Option::None;
        }

        pub fn has_friends_category_count(&self) -> bool {
            self.friends_category_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_friends_category_count(&mut self, v: i32) {
            self.friends_category_count = ::std::option::Option::Some(v);
        }

        // optional int32 friends_categorized_count = 3;

        pub fn friends_categorized_count(&self) -> i32 {
            self.friends_categorized_count.unwrap_or(0)
        }

        pub fn clear_friends_categorized_count(&mut self) {
            self.friends_categorized_count = ::std::option::Option::None;
        }

        pub fn has_friends_categorized_count(&self) -> bool {
            self.friends_categorized_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_friends_categorized_count(&mut self, v: i32) {
            self.friends_categorized_count = ::std::option::Option::Some(v);
        }

        // optional int32 friends_online_count = 4;

        pub fn friends_online_count(&self) -> i32 {
            self.friends_online_count.unwrap_or(0)
        }

        pub fn clear_friends_online_count(&mut self) {
            self.friends_online_count = ::std::option::Option::None;
        }

        pub fn has_friends_online_count(&self) -> bool {
            self.friends_online_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_friends_online_count(&mut self, v: i32) {
            self.friends_online_count = ::std::option::Option::Some(v);
        }

        // optional int32 friends_in_game_count = 5;

        pub fn friends_in_game_count(&self) -> i32 {
            self.friends_in_game_count.unwrap_or(0)
        }

        pub fn clear_friends_in_game_count(&mut self) {
            self.friends_in_game_count = ::std::option::Option::None;
        }

        pub fn has_friends_in_game_count(&self) -> bool {
            self.friends_in_game_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_friends_in_game_count(&mut self, v: i32) {
            self.friends_in_game_count = ::std::option::Option::Some(v);
        }

        // optional int32 friends_in_game_singleton_count = 6;

        pub fn friends_in_game_singleton_count(&self) -> i32 {
            self.friends_in_game_singleton_count.unwrap_or(0)
        }

        pub fn clear_friends_in_game_singleton_count(&mut self) {
            self.friends_in_game_singleton_count = ::std::option::Option::None;
        }

        pub fn has_friends_in_game_singleton_count(&self) -> bool {
            self.friends_in_game_singleton_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_friends_in_game_singleton_count(&mut self, v: i32) {
            self.friends_in_game_singleton_count = ::std::option::Option::Some(v);
        }

        // optional int32 game_group_count = 7;

        pub fn game_group_count(&self) -> i32 {
            self.game_group_count.unwrap_or(0)
        }

        pub fn clear_game_group_count(&mut self) {
            self.game_group_count = ::std::option::Option::None;
        }

        pub fn has_game_group_count(&self) -> bool {
            self.game_group_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_group_count(&mut self, v: i32) {
            self.game_group_count = ::std::option::Option::Some(v);
        }

        // optional int32 friends_favorite_count = 8;

        pub fn friends_favorite_count(&self) -> i32 {
            self.friends_favorite_count.unwrap_or(0)
        }

        pub fn clear_friends_favorite_count(&mut self) {
            self.friends_favorite_count = ::std::option::Option::None;
        }

        pub fn has_friends_favorite_count(&self) -> bool {
            self.friends_favorite_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_friends_favorite_count(&mut self, v: i32) {
            self.friends_favorite_count = ::std::option::Option::Some(v);
        }

        // optional int32 group_chat_count = 9;

        pub fn group_chat_count(&self) -> i32 {
            self.group_chat_count.unwrap_or(0)
        }

        pub fn clear_group_chat_count(&mut self) {
            self.group_chat_count = ::std::option::Option::None;
        }

        pub fn has_group_chat_count(&self) -> bool {
            self.group_chat_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_group_chat_count(&mut self, v: i32) {
            self.group_chat_count = ::std::option::Option::Some(v);
        }

        // optional int32 group_chat_favorite_count = 10;

        pub fn group_chat_favorite_count(&self) -> i32 {
            self.group_chat_favorite_count.unwrap_or(0)
        }

        pub fn clear_group_chat_favorite_count(&mut self) {
            self.group_chat_favorite_count = ::std::option::Option::None;
        }

        pub fn has_group_chat_favorite_count(&self) -> bool {
            self.group_chat_favorite_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_group_chat_favorite_count(&mut self, v: i32) {
            self.group_chat_favorite_count = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Metrics {
        const NAME: &'static str = "Metrics";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.friends_count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.friends_category_count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.friends_categorized_count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.friends_online_count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    40 => {
                        self.friends_in_game_count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    48 => {
                        self.friends_in_game_singleton_count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    56 => {
                        self.game_group_count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    64 => {
                        self.friends_favorite_count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    72 => {
                        self.group_chat_count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    80 => {
                        self.group_chat_favorite_count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.friends_count {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.friends_category_count {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.friends_categorized_count {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.friends_online_count {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.friends_in_game_count {
                my_size += ::protobuf::rt::int32_size(5, v);
            }
            if let Some(v) = self.friends_in_game_singleton_count {
                my_size += ::protobuf::rt::int32_size(6, v);
            }
            if let Some(v) = self.game_group_count {
                my_size += ::protobuf::rt::int32_size(7, v);
            }
            if let Some(v) = self.friends_favorite_count {
                my_size += ::protobuf::rt::int32_size(8, v);
            }
            if let Some(v) = self.group_chat_count {
                my_size += ::protobuf::rt::int32_size(9, v);
            }
            if let Some(v) = self.group_chat_favorite_count {
                my_size += ::protobuf::rt::int32_size(10, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.friends_count {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.friends_category_count {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.friends_categorized_count {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.friends_online_count {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.friends_in_game_count {
                os.write_int32(5, v)?;
            }
            if let Some(v) = self.friends_in_game_singleton_count {
                os.write_int32(6, v)?;
            }
            if let Some(v) = self.game_group_count {
                os.write_int32(7, v)?;
            }
            if let Some(v) = self.friends_favorite_count {
                os.write_int32(8, v)?;
            }
            if let Some(v) = self.group_chat_count {
                os.write_int32(9, v)?;
            }
            if let Some(v) = self.group_chat_favorite_count {
                os.write_int32(10, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Metrics {
            Metrics::new()
        }

        fn clear(&mut self) {
            self.friends_count = ::std::option::Option::None;
            self.friends_category_count = ::std::option::Option::None;
            self.friends_categorized_count = ::std::option::Option::None;
            self.friends_online_count = ::std::option::Option::None;
            self.friends_in_game_count = ::std::option::Option::None;
            self.friends_in_game_singleton_count = ::std::option::Option::None;
            self.game_group_count = ::std::option::Option::None;
            self.friends_favorite_count = ::std::option::Option::None;
            self.group_chat_count = ::std::option::Option::None;
            self.group_chat_favorite_count = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Metrics {
            static instance: Metrics = Metrics {
                friends_count: ::std::option::Option::None,
                friends_category_count: ::std::option::Option::None,
                friends_categorized_count: ::std::option::Option::None,
                friends_online_count: ::std::option::Option::None,
                friends_in_game_count: ::std::option::Option::None,
                friends_in_game_singleton_count: ::std::option::Option::None,
                game_group_count: ::std::option::Option::None,
                friends_favorite_count: ::std::option::Option::None,
                group_chat_count: ::std::option::Option::None,
                group_chat_favorite_count: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

#[doc = "Request client send usability metrics"]
// @@protoc_insertion_point(message:CChatUsability_RequestClientUsabilityMetrics_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatUsability_RequestClientUsabilityMetrics_Notification {
    // message fields
    // @@protoc_insertion_point(field:CChatUsability_RequestClientUsabilityMetrics_Notification.metrics_run_id)
    pub metrics_run_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatUsability_RequestClientUsabilityMetrics_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatUsability_RequestClientUsabilityMetrics_Notification {
    fn default() -> &'a CChatUsability_RequestClientUsabilityMetrics_Notification {
        <CChatUsability_RequestClientUsabilityMetrics_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CChatUsability_RequestClientUsabilityMetrics_Notification {
    pub fn new() -> CChatUsability_RequestClientUsabilityMetrics_Notification {
        ::std::default::Default::default()
    }

    // optional uint32 metrics_run_id = 1;

    pub fn metrics_run_id(&self) -> u32 {
        self.metrics_run_id.unwrap_or(0)
    }

    pub fn clear_metrics_run_id(&mut self) {
        self.metrics_run_id = ::std::option::Option::None;
    }

    pub fn has_metrics_run_id(&self) -> bool {
        self.metrics_run_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metrics_run_id(&mut self, v: u32) {
        self.metrics_run_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatUsability_RequestClientUsabilityMetrics_Notification {
    const NAME: &'static str = "CChatUsability_RequestClientUsabilityMetrics_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.metrics_run_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metrics_run_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metrics_run_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatUsability_RequestClientUsabilityMetrics_Notification {
        CChatUsability_RequestClientUsabilityMetrics_Notification::new()
    }

    fn clear(&mut self) {
        self.metrics_run_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatUsability_RequestClientUsabilityMetrics_Notification {
        static instance: CChatUsability_RequestClientUsabilityMetrics_Notification = CChatUsability_RequestClientUsabilityMetrics_Notification {
            metrics_run_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EChatRoomJoinState)
pub enum EChatRoomJoinState {
    // @@protoc_insertion_point(enum_value:EChatRoomJoinState.k_EChatRoomJoinState_Default)
    k_EChatRoomJoinState_Default = 0,
    // @@protoc_insertion_point(enum_value:EChatRoomJoinState.k_EChatRoomJoinState_None)
    k_EChatRoomJoinState_None = 1,
    // @@protoc_insertion_point(enum_value:EChatRoomJoinState.k_EChatRoomJoinState_Joined)
    k_EChatRoomJoinState_Joined = 2,
    // @@protoc_insertion_point(enum_value:EChatRoomJoinState.k_EChatRoomJoinState_TestInvalid)
    k_EChatRoomJoinState_TestInvalid = 99,
}

impl ::protobuf::Enum for EChatRoomJoinState {
    const NAME: &'static str = "EChatRoomJoinState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EChatRoomJoinState> {
        match value {
            0 => ::std::option::Option::Some(EChatRoomJoinState::k_EChatRoomJoinState_Default),
            1 => ::std::option::Option::Some(EChatRoomJoinState::k_EChatRoomJoinState_None),
            2 => ::std::option::Option::Some(EChatRoomJoinState::k_EChatRoomJoinState_Joined),
            99 => ::std::option::Option::Some(EChatRoomJoinState::k_EChatRoomJoinState_TestInvalid),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EChatRoomJoinState> {
        match str {
            "k_EChatRoomJoinState_Default" => ::std::option::Option::Some(EChatRoomJoinState::k_EChatRoomJoinState_Default),
            "k_EChatRoomJoinState_None" => ::std::option::Option::Some(EChatRoomJoinState::k_EChatRoomJoinState_None),
            "k_EChatRoomJoinState_Joined" => ::std::option::Option::Some(EChatRoomJoinState::k_EChatRoomJoinState_Joined),
            "k_EChatRoomJoinState_TestInvalid" => ::std::option::Option::Some(EChatRoomJoinState::k_EChatRoomJoinState_TestInvalid),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EChatRoomJoinState] = &[
        EChatRoomJoinState::k_EChatRoomJoinState_Default,
        EChatRoomJoinState::k_EChatRoomJoinState_None,
        EChatRoomJoinState::k_EChatRoomJoinState_Joined,
        EChatRoomJoinState::k_EChatRoomJoinState_TestInvalid,
    ];
}

impl ::std::default::Default for EChatRoomJoinState {
    fn default() -> Self {
        EChatRoomJoinState::k_EChatRoomJoinState_Default
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EChatRoomGroupRank)
pub enum EChatRoomGroupRank {
    // @@protoc_insertion_point(enum_value:EChatRoomGroupRank.k_EChatRoomGroupRank_Default)
    k_EChatRoomGroupRank_Default = 0,
    // @@protoc_insertion_point(enum_value:EChatRoomGroupRank.k_EChatRoomGroupRank_Viewer)
    k_EChatRoomGroupRank_Viewer = 10,
    // @@protoc_insertion_point(enum_value:EChatRoomGroupRank.k_EChatRoomGroupRank_Guest)
    k_EChatRoomGroupRank_Guest = 15,
    // @@protoc_insertion_point(enum_value:EChatRoomGroupRank.k_EChatRoomGroupRank_Member)
    k_EChatRoomGroupRank_Member = 20,
    // @@protoc_insertion_point(enum_value:EChatRoomGroupRank.k_EChatRoomGroupRank_Moderator)
    k_EChatRoomGroupRank_Moderator = 30,
    // @@protoc_insertion_point(enum_value:EChatRoomGroupRank.k_EChatRoomGroupRank_Officer)
    k_EChatRoomGroupRank_Officer = 40,
    // @@protoc_insertion_point(enum_value:EChatRoomGroupRank.k_EChatRoomGroupRank_Owner)
    k_EChatRoomGroupRank_Owner = 50,
    // @@protoc_insertion_point(enum_value:EChatRoomGroupRank.k_EChatRoomGroupRank_TestInvalid)
    k_EChatRoomGroupRank_TestInvalid = 99,
}

impl ::protobuf::Enum for EChatRoomGroupRank {
    const NAME: &'static str = "EChatRoomGroupRank";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EChatRoomGroupRank> {
        match value {
            0 => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Default),
            10 => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Viewer),
            15 => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Guest),
            20 => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Member),
            30 => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Moderator),
            40 => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Officer),
            50 => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Owner),
            99 => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_TestInvalid),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EChatRoomGroupRank> {
        match str {
            "k_EChatRoomGroupRank_Default" => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Default),
            "k_EChatRoomGroupRank_Viewer" => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Viewer),
            "k_EChatRoomGroupRank_Guest" => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Guest),
            "k_EChatRoomGroupRank_Member" => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Member),
            "k_EChatRoomGroupRank_Moderator" => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Moderator),
            "k_EChatRoomGroupRank_Officer" => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Officer),
            "k_EChatRoomGroupRank_Owner" => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Owner),
            "k_EChatRoomGroupRank_TestInvalid" => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_TestInvalid),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EChatRoomGroupRank] = &[
        EChatRoomGroupRank::k_EChatRoomGroupRank_Default,
        EChatRoomGroupRank::k_EChatRoomGroupRank_Viewer,
        EChatRoomGroupRank::k_EChatRoomGroupRank_Guest,
        EChatRoomGroupRank::k_EChatRoomGroupRank_Member,
        EChatRoomGroupRank::k_EChatRoomGroupRank_Moderator,
        EChatRoomGroupRank::k_EChatRoomGroupRank_Officer,
        EChatRoomGroupRank::k_EChatRoomGroupRank_Owner,
        EChatRoomGroupRank::k_EChatRoomGroupRank_TestInvalid,
    ];
}

impl ::std::default::Default for EChatRoomGroupRank {
    fn default() -> Self {
        EChatRoomGroupRank::k_EChatRoomGroupRank_Default
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EChatRoomNotificationLevel)
pub enum EChatRoomNotificationLevel {
    // @@protoc_insertion_point(enum_value:EChatRoomNotificationLevel.k_EChatroomNotificationLevel_Invalid)
    k_EChatroomNotificationLevel_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EChatRoomNotificationLevel.k_EChatroomNotificationLevel_None)
    k_EChatroomNotificationLevel_None = 1,
    // @@protoc_insertion_point(enum_value:EChatRoomNotificationLevel.k_EChatroomNotificationLevel_MentionMe)
    k_EChatroomNotificationLevel_MentionMe = 2,
    // @@protoc_insertion_point(enum_value:EChatRoomNotificationLevel.k_EChatroomNotificationLevel_MentionAll)
    k_EChatroomNotificationLevel_MentionAll = 3,
    // @@protoc_insertion_point(enum_value:EChatRoomNotificationLevel.k_EChatroomNotificationLevel_AllMessages)
    k_EChatroomNotificationLevel_AllMessages = 4,
}

impl ::protobuf::Enum for EChatRoomNotificationLevel {
    const NAME: &'static str = "EChatRoomNotificationLevel";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EChatRoomNotificationLevel> {
        match value {
            0 => ::std::option::Option::Some(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid),
            1 => ::std::option::Option::Some(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_None),
            2 => ::std::option::Option::Some(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_MentionMe),
            3 => ::std::option::Option::Some(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_MentionAll),
            4 => ::std::option::Option::Some(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_AllMessages),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EChatRoomNotificationLevel> {
        match str {
            "k_EChatroomNotificationLevel_Invalid" => ::std::option::Option::Some(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid),
            "k_EChatroomNotificationLevel_None" => ::std::option::Option::Some(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_None),
            "k_EChatroomNotificationLevel_MentionMe" => ::std::option::Option::Some(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_MentionMe),
            "k_EChatroomNotificationLevel_MentionAll" => ::std::option::Option::Some(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_MentionAll),
            "k_EChatroomNotificationLevel_AllMessages" => ::std::option::Option::Some(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_AllMessages),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EChatRoomNotificationLevel] = &[
        EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid,
        EChatRoomNotificationLevel::k_EChatroomNotificationLevel_None,
        EChatRoomNotificationLevel::k_EChatroomNotificationLevel_MentionMe,
        EChatRoomNotificationLevel::k_EChatroomNotificationLevel_MentionAll,
        EChatRoomNotificationLevel::k_EChatroomNotificationLevel_AllMessages,
    ];
}

impl ::std::default::Default for EChatRoomNotificationLevel {
    fn default() -> Self {
        EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EChatRoomServerMessage)
pub enum EChatRoomServerMessage {
    // @@protoc_insertion_point(enum_value:EChatRoomServerMessage.k_EChatRoomServerMsg_Invalid)
    k_EChatRoomServerMsg_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EChatRoomServerMessage.k_EChatRoomServerMsg_RenameChatRoom)
    k_EChatRoomServerMsg_RenameChatRoom = 1,
    // @@protoc_insertion_point(enum_value:EChatRoomServerMessage.k_EChatRoomServerMsg_Joined)
    k_EChatRoomServerMsg_Joined = 2,
    // @@protoc_insertion_point(enum_value:EChatRoomServerMessage.k_EChatRoomServerMsg_Parted)
    k_EChatRoomServerMsg_Parted = 3,
    // @@protoc_insertion_point(enum_value:EChatRoomServerMessage.k_EChatRoomServerMsg_Kicked)
    k_EChatRoomServerMsg_Kicked = 4,
    // @@protoc_insertion_point(enum_value:EChatRoomServerMessage.k_EChatRoomServerMsg_Invited)
    k_EChatRoomServerMsg_Invited = 5,
    // @@protoc_insertion_point(enum_value:EChatRoomServerMessage.k_EChatRoomServerMsg_InviteDismissed)
    k_EChatRoomServerMsg_InviteDismissed = 8,
    // @@protoc_insertion_point(enum_value:EChatRoomServerMessage.k_EChatRoomServerMsg_ChatRoomTaglineChanged)
    k_EChatRoomServerMsg_ChatRoomTaglineChanged = 9,
    // @@protoc_insertion_point(enum_value:EChatRoomServerMessage.k_EChatRoomServerMsg_ChatRoomAvatarChanged)
    k_EChatRoomServerMsg_ChatRoomAvatarChanged = 10,
    // @@protoc_insertion_point(enum_value:EChatRoomServerMessage.k_EChatRoomServerMsg_AppCustom)
    k_EChatRoomServerMsg_AppCustom = 11,
}

impl ::protobuf::Enum for EChatRoomServerMessage {
    const NAME: &'static str = "EChatRoomServerMessage";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EChatRoomServerMessage> {
        match value {
            0 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_Invalid),
            1 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_RenameChatRoom),
            2 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_Joined),
            3 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_Parted),
            4 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_Kicked),
            5 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_Invited),
            8 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_InviteDismissed),
            9 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_ChatRoomTaglineChanged),
            10 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_ChatRoomAvatarChanged),
            11 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_AppCustom),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EChatRoomServerMessage> {
        match str {
            "k_EChatRoomServerMsg_Invalid" => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_Invalid),
            "k_EChatRoomServerMsg_RenameChatRoom" => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_RenameChatRoom),
            "k_EChatRoomServerMsg_Joined" => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_Joined),
            "k_EChatRoomServerMsg_Parted" => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_Parted),
            "k_EChatRoomServerMsg_Kicked" => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_Kicked),
            "k_EChatRoomServerMsg_Invited" => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_Invited),
            "k_EChatRoomServerMsg_InviteDismissed" => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_InviteDismissed),
            "k_EChatRoomServerMsg_ChatRoomTaglineChanged" => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_ChatRoomTaglineChanged),
            "k_EChatRoomServerMsg_ChatRoomAvatarChanged" => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_ChatRoomAvatarChanged),
            "k_EChatRoomServerMsg_AppCustom" => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_AppCustom),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EChatRoomServerMessage] = &[
        EChatRoomServerMessage::k_EChatRoomServerMsg_Invalid,
        EChatRoomServerMessage::k_EChatRoomServerMsg_RenameChatRoom,
        EChatRoomServerMessage::k_EChatRoomServerMsg_Joined,
        EChatRoomServerMessage::k_EChatRoomServerMsg_Parted,
        EChatRoomServerMessage::k_EChatRoomServerMsg_Kicked,
        EChatRoomServerMessage::k_EChatRoomServerMsg_Invited,
        EChatRoomServerMessage::k_EChatRoomServerMsg_InviteDismissed,
        EChatRoomServerMessage::k_EChatRoomServerMsg_ChatRoomTaglineChanged,
        EChatRoomServerMessage::k_EChatRoomServerMsg_ChatRoomAvatarChanged,
        EChatRoomServerMessage::k_EChatRoomServerMsg_AppCustom,
    ];
}

impl ::std::default::Default for EChatRoomServerMessage {
    fn default() -> Self {
        EChatRoomServerMessage::k_EChatRoomServerMsg_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EChatRoomMessageReactionType)
pub enum EChatRoomMessageReactionType {
    // @@protoc_insertion_point(enum_value:EChatRoomMessageReactionType.k_EChatRoomMessageReactionType_Invalid)
    k_EChatRoomMessageReactionType_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EChatRoomMessageReactionType.k_EChatRoomMessageReactionType_Emoticon)
    k_EChatRoomMessageReactionType_Emoticon = 1,
    // @@protoc_insertion_point(enum_value:EChatRoomMessageReactionType.k_EChatRoomMessageReactionType_Sticker)
    k_EChatRoomMessageReactionType_Sticker = 2,
}

impl ::protobuf::Enum for EChatRoomMessageReactionType {
    const NAME: &'static str = "EChatRoomMessageReactionType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EChatRoomMessageReactionType> {
        match value {
            0 => ::std::option::Option::Some(EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Invalid),
            1 => ::std::option::Option::Some(EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Emoticon),
            2 => ::std::option::Option::Some(EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Sticker),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EChatRoomMessageReactionType> {
        match str {
            "k_EChatRoomMessageReactionType_Invalid" => ::std::option::Option::Some(EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Invalid),
            "k_EChatRoomMessageReactionType_Emoticon" => ::std::option::Option::Some(EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Emoticon),
            "k_EChatRoomMessageReactionType_Sticker" => ::std::option::Option::Some(EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Sticker),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EChatRoomMessageReactionType] = &[
        EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Invalid,
        EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Emoticon,
        EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Sticker,
    ];
}

impl ::std::default::Default for EChatRoomMessageReactionType {
    fn default() -> Self {
        EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EChatRoomMemberStateChange)
pub enum EChatRoomMemberStateChange {
    // @@protoc_insertion_point(enum_value:EChatRoomMemberStateChange.k_EChatRoomMemberStateChange_Invalid)
    k_EChatRoomMemberStateChange_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EChatRoomMemberStateChange.k_EChatRoomMemberStateChange_Joined)
    k_EChatRoomMemberStateChange_Joined = 1,
    // @@protoc_insertion_point(enum_value:EChatRoomMemberStateChange.k_EChatRoomMemberStateChange_Parted)
    k_EChatRoomMemberStateChange_Parted = 2,
    // @@protoc_insertion_point(enum_value:EChatRoomMemberStateChange.k_EChatRoomMemberStateChange_Kicked)
    k_EChatRoomMemberStateChange_Kicked = 3,
    // @@protoc_insertion_point(enum_value:EChatRoomMemberStateChange.k_EChatRoomMemberStateChange_Invited)
    k_EChatRoomMemberStateChange_Invited = 4,
    // @@protoc_insertion_point(enum_value:EChatRoomMemberStateChange.k_EChatRoomMemberStateChange_RankChanged)
    k_EChatRoomMemberStateChange_RankChanged = 7,
    // @@protoc_insertion_point(enum_value:EChatRoomMemberStateChange.k_EChatRoomMemberStateChange_InviteDismissed)
    k_EChatRoomMemberStateChange_InviteDismissed = 8,
    // @@protoc_insertion_point(enum_value:EChatRoomMemberStateChange.k_EChatRoomMemberStateChange_Muted)
    k_EChatRoomMemberStateChange_Muted = 9,
    // @@protoc_insertion_point(enum_value:EChatRoomMemberStateChange.k_EChatRoomMemberStateChange_Banned)
    k_EChatRoomMemberStateChange_Banned = 10,
    // @@protoc_insertion_point(enum_value:EChatRoomMemberStateChange.k_EChatRoomMemberStateChange_RolesChanged)
    k_EChatRoomMemberStateChange_RolesChanged = 12,
}

impl ::protobuf::Enum for EChatRoomMemberStateChange {
    const NAME: &'static str = "EChatRoomMemberStateChange";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EChatRoomMemberStateChange> {
        match value {
            0 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invalid),
            1 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Joined),
            2 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Parted),
            3 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Kicked),
            4 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invited),
            7 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_RankChanged),
            8 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_InviteDismissed),
            9 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Muted),
            10 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Banned),
            12 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_RolesChanged),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EChatRoomMemberStateChange> {
        match str {
            "k_EChatRoomMemberStateChange_Invalid" => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invalid),
            "k_EChatRoomMemberStateChange_Joined" => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Joined),
            "k_EChatRoomMemberStateChange_Parted" => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Parted),
            "k_EChatRoomMemberStateChange_Kicked" => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Kicked),
            "k_EChatRoomMemberStateChange_Invited" => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invited),
            "k_EChatRoomMemberStateChange_RankChanged" => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_RankChanged),
            "k_EChatRoomMemberStateChange_InviteDismissed" => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_InviteDismissed),
            "k_EChatRoomMemberStateChange_Muted" => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Muted),
            "k_EChatRoomMemberStateChange_Banned" => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Banned),
            "k_EChatRoomMemberStateChange_RolesChanged" => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_RolesChanged),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EChatRoomMemberStateChange] = &[
        EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invalid,
        EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Joined,
        EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Parted,
        EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Kicked,
        EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invited,
        EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_RankChanged,
        EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_InviteDismissed,
        EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Muted,
        EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Banned,
        EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_RolesChanged,
    ];
}

impl ::std::default::Default for EChatRoomMemberStateChange {
    fn default() -> Self {
        EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invalid
    }
}

#[allow(unused_imports)]
use crate::steammessages_base::*;
#[allow(unused_imports)]
use crate::steammessages_unified_base_steamclient::*;
#[allow(unused_imports)]
use crate::steammessages_clientserver_friends::*;
impl crate::RpcMessage for CChat_RequestFriendPersonaStates_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChat_RequestFriendPersonaStates_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_CreateChatRoomGroup_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRole {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoleActions {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatPartyBeacon {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoomGroupHeaderState {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoomMember {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoomState {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoomGroupState {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CUserChatRoomState {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CUserChatRoomGroupState {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_CreateChatRoomGroup_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_SaveChatRoomGroup_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_SaveChatRoomGroup_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_RenameChatRoomGroup_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_RenameChatRoomGroup_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_SetChatRoomGroupTagline_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_SetChatRoomGroupTagline_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_SetChatRoomGroupAvatar_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_SetChatRoomGroupAvatar_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_JoinMiniGameForChatRoomGroup_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_JoinMiniGameForChatRoomGroup_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_EndMiniGameForChatRoomGroup_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_EndMiniGameForChatRoomGroup_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_MuteUser_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_MuteUser_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_KickUser_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_KickUser_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_SetUserBanState_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_SetUserBanState_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_RevokeInvite_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_RevokeInvite_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_CreateRole_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_CreateRole_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_GetRoles_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_GetRoles_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_RenameRole_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_RenameRole_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_ReorderRole_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_ReorderRole_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_DeleteRole_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_DeleteRole_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_GetRoleActions_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_GetRoleActions_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_ReplaceRoleActions_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_ReplaceRoleActions_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_AddRoleToUser_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_AddRoleToUser_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_GetRolesForUser_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_GetRolesForUser_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_DeleteRoleFromUser_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_DeleteRoleFromUser_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_JoinChatRoomGroup_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_JoinChatRoomGroup_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_InviteFriendToChatRoomGroup_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_InviteFriendToChatRoomGroup_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_LeaveChatRoomGroup_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_LeaveChatRoomGroup_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_CreateChatRoom_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_CreateChatRoom_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_DeleteChatRoom_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_DeleteChatRoom_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_RenameChatRoom_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_RenameChatRoom_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_ReorderChatRoom_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_ReorderChatRoom_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_SendChatMessage_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_SendChatMessage_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_JoinVoiceChat_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_JoinVoiceChat_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_LeaveVoiceChat_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_LeaveVoiceChat_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_GetMessageHistory_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for ServerMessage {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_GetMessageHistory_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_GetMyChatRoomGroups_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_GetChatRoomGroupSummary_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoomSummaryPair {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_GetMyChatRoomGroups_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_GetChatRoomGroupState_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_GetChatRoomGroupState_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_GetChatRoomGroupSummary_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_SetAppChatRoomGroupForceActive_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_SetAppChatRoomGroupForceActive_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_AckChatMessage_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_CreateInviteLink_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_CreateInviteLink_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_GetInviteLinkInfo_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_GetInviteLinkInfo_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_GetInviteInfo_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_GetInviteInfo_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_GetInviteLinksForGroup_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_GetInviteLinksForGroup_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_GetBanList_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_GetBanList_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_GetInviteList_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoomGroupInvite {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_GetInviteList_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_DeleteInviteLink_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_DeleteInviteLink_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_SetSessionActiveChatRoomGroups_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_SetSessionActiveChatRoomGroups_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_SetUserChatGroupPreferences_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_SetUserChatGroupPreferences_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_DeleteChatMessages_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_DeleteChatMessages_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_UpdateMemberListView_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_SearchMembers_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_SearchMembers_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_UpdateMessageReaction_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_UpdateMessageReaction_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_GetMessageReactionReactors_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_GetMessageReactionReactors_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClanChatRooms_GetClanChatRoomInfo_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClanChatRooms_GetClanChatRoomInfo_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClanChatRooms_SetClanChatRoomPrivate_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClanChatRooms_SetClanChatRoomPrivate_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatMentions {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_IncomingChatMessage_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_ChatMessageModified_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_MemberStateChange_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_ChatRoomHeaderState_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_ChatRoomGroupRoomsChange_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for ChatRoomClient_NotifyChatRoomDisconnect_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoomMemberListView {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoomMemberSummaryCounts {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoomClient_MemberListViewUpdated_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatRoom_MessageReaction_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatUsability_ClientUsabilityMetrics_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CChatUsability_RequestClientUsabilityMetrics_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
///Chat-related services
struct Chat {}
impl crate::RpcService for Chat {
    const SERVICE_NAME: &'static str = "Chat";
}
///Service for joining, managing, and using multi-user chat rooms
struct ChatRoom {}
impl crate::RpcService for ChatRoom {
    const SERVICE_NAME: &'static str = "ChatRoom";
}
///Methods for getting clan chat information
struct ClanChatRooms {}
impl crate::RpcService for ClanChatRooms {
    const SERVICE_NAME: &'static str = "ClanChatRooms";
}
///Client notifications for chat events
struct ChatRoomClient {}
impl crate::RpcService for ChatRoomClient {
    const SERVICE_NAME: &'static str = "ChatRoomClient";
}
///Client notifications for chat events
struct ChatUsability {}
impl crate::RpcService for ChatUsability {
    const SERVICE_NAME: &'static str = "ChatUsability";
}
///Client notifications for chat usability
struct ChatUsabilityClient {}
impl crate::RpcService for ChatUsabilityClient {
    const SERVICE_NAME: &'static str = "ChatUsabilityClient";
}
impl crate::RpcMethod for CChatRoomClient_MemberListViewUpdated_Notification {
    const METHOD_NAME: &'static str = "ChatRoomClient.NotifyMemberListViewUpdated#1";
    type Response = ();
}
impl crate::RpcMethod for CChatRoom_AckChatMessage_Notification {
    const METHOD_NAME: &'static str = "ChatRoom.AckChatMessage#1";
    type Response = ();
}
impl crate::RpcMethod for CChatRoom_AddRoleToUser_Request {
    const METHOD_NAME: &'static str = "ChatRoom.AddRoleToUser#1";
    type Response = CChatRoom_AddRoleToUser_Response;
}
impl crate::RpcMethod for CChatRoom_ChatMessageModified_Notification {
    const METHOD_NAME: &'static str = "ChatRoomClient.NotifyChatMessageModified#1";
    type Response = ();
}
impl crate::RpcMethod for CChatRoom_ChatRoomGroupRoomsChange_Notification {
    const METHOD_NAME: &'static str = "ChatRoomClient.NotifyChatRoomGroupRoomsChange#1";
    type Response = ();
}
impl crate::RpcMethod for CChatRoom_ChatRoomHeaderState_Notification {
    const METHOD_NAME: &'static str = "ChatRoomClient.NotifyChatRoomHeaderStateChange#1";
    type Response = ();
}
impl crate::RpcMethod for CChatRoom_CreateChatRoomGroup_Request {
    const METHOD_NAME: &'static str = "ChatRoom.CreateChatRoomGroup#1";
    type Response = CChatRoom_CreateChatRoomGroup_Response;
}
impl crate::RpcMethod for CChatRoom_CreateChatRoom_Request {
    const METHOD_NAME: &'static str = "ChatRoom.CreateChatRoom#1";
    type Response = CChatRoom_CreateChatRoom_Response;
}
impl crate::RpcMethod for CChatRoom_CreateInviteLink_Request {
    const METHOD_NAME: &'static str = "ChatRoom.CreateInviteLink#1";
    type Response = CChatRoom_CreateInviteLink_Response;
}
impl crate::RpcMethod for CChatRoom_CreateRole_Request {
    const METHOD_NAME: &'static str = "ChatRoom.CreateRole#1";
    type Response = CChatRoom_CreateRole_Response;
}
impl crate::RpcMethod for CChatRoom_DeleteChatMessages_Request {
    const METHOD_NAME: &'static str = "ChatRoom.DeleteChatMessages#1";
    type Response = CChatRoom_DeleteChatMessages_Response;
}
impl crate::RpcMethod for CChatRoom_DeleteChatRoom_Request {
    const METHOD_NAME: &'static str = "ChatRoom.DeleteChatRoom#1";
    type Response = CChatRoom_DeleteChatRoom_Response;
}
impl crate::RpcMethod for CChatRoom_DeleteInviteLink_Request {
    const METHOD_NAME: &'static str = "ChatRoom.DeleteInviteLink#1";
    type Response = CChatRoom_DeleteInviteLink_Response;
}
impl crate::RpcMethod for CChatRoom_DeleteRoleFromUser_Request {
    const METHOD_NAME: &'static str = "ChatRoom.DeleteRoleFromUser#1";
    type Response = CChatRoom_DeleteRoleFromUser_Response;
}
impl crate::RpcMethod for CChatRoom_DeleteRole_Request {
    const METHOD_NAME: &'static str = "ChatRoom.DeleteRole#1";
    type Response = CChatRoom_DeleteRole_Response;
}
impl crate::RpcMethod for CChatRoom_EndMiniGameForChatRoomGroup_Request {
    const METHOD_NAME: &'static str = "ChatRoom.EndMiniGameForChatRoomGroup#1";
    type Response = CChatRoom_EndMiniGameForChatRoomGroup_Response;
}
impl crate::RpcMethod for CChatRoom_GetBanList_Request {
    const METHOD_NAME: &'static str = "ChatRoom.GetBanList#1";
    type Response = CChatRoom_GetBanList_Response;
}
impl crate::RpcMethod for CChatRoom_GetChatRoomGroupState_Request {
    const METHOD_NAME: &'static str = "ChatRoom.GetChatRoomGroupState#1";
    type Response = CChatRoom_GetChatRoomGroupState_Response;
}
impl crate::RpcMethod for CChatRoom_GetChatRoomGroupSummary_Request {
    const METHOD_NAME: &'static str = "ChatRoom.GetChatRoomGroupSummary#1";
    type Response = CChatRoom_GetChatRoomGroupSummary_Response;
}
impl crate::RpcMethod for CChatRoom_GetInviteInfo_Request {
    const METHOD_NAME: &'static str = "ChatRoom.GetInviteInfo#1";
    type Response = CChatRoom_GetInviteInfo_Response;
}
impl crate::RpcMethod for CChatRoom_GetInviteLinkInfo_Request {
    const METHOD_NAME: &'static str = "ChatRoom.GetInviteLinkInfo#1";
    type Response = CChatRoom_GetInviteLinkInfo_Response;
}
impl crate::RpcMethod for CChatRoom_GetInviteLinksForGroup_Request {
    const METHOD_NAME: &'static str = "ChatRoom.GetInviteLinksForGroup#1";
    type Response = CChatRoom_GetInviteLinksForGroup_Response;
}
impl crate::RpcMethod for CChatRoom_GetInviteList_Request {
    const METHOD_NAME: &'static str = "ChatRoom.GetInviteList#1";
    type Response = CChatRoom_GetInviteList_Response;
}
impl crate::RpcMethod for CChatRoom_GetMessageHistory_Request {
    const METHOD_NAME: &'static str = "ChatRoom.GetMessageHistory#1";
    type Response = CChatRoom_GetMessageHistory_Response;
}
impl crate::RpcMethod for CChatRoom_GetMessageReactionReactors_Request {
    const METHOD_NAME: &'static str = "ChatRoom.GetMessageReactionReactors#1";
    type Response = CChatRoom_GetMessageReactionReactors_Response;
}
impl crate::RpcMethod for CChatRoom_GetMyChatRoomGroups_Request {
    const METHOD_NAME: &'static str = "ChatRoom.GetMyChatRoomGroups#1";
    type Response = CChatRoom_GetMyChatRoomGroups_Response;
}
impl crate::RpcMethod for CChatRoom_GetRoleActions_Request {
    const METHOD_NAME: &'static str = "ChatRoom.GetRoleActions#1";
    type Response = CChatRoom_GetRoleActions_Response;
}
impl crate::RpcMethod for CChatRoom_GetRolesForUser_Request {
    const METHOD_NAME: &'static str = "ChatRoom.GetRolesForUser#1";
    type Response = CChatRoom_GetRolesForUser_Response;
}
impl crate::RpcMethod for CChatRoom_GetRoles_Request {
    const METHOD_NAME: &'static str = "ChatRoom.GetRoles#1";
    type Response = CChatRoom_GetRoles_Response;
}
impl crate::RpcMethod for CChatRoom_IncomingChatMessage_Notification {
    const METHOD_NAME: &'static str = "ChatRoomClient.NotifyIncomingChatMessage#1";
    type Response = ();
}
impl crate::RpcMethod for CChatRoom_InviteFriendToChatRoomGroup_Request {
    const METHOD_NAME: &'static str = "ChatRoom.InviteFriendToChatRoomGroup#1";
    type Response = CChatRoom_InviteFriendToChatRoomGroup_Response;
}
impl crate::RpcMethod for CChatRoom_JoinChatRoomGroup_Request {
    const METHOD_NAME: &'static str = "ChatRoom.JoinChatRoomGroup#1";
    type Response = CChatRoom_JoinChatRoomGroup_Response;
}
impl crate::RpcMethod for CChatRoom_JoinMiniGameForChatRoomGroup_Request {
    const METHOD_NAME: &'static str = "ChatRoom.JoinMiniGameForChatRoomGroup#1";
    type Response = CChatRoom_JoinMiniGameForChatRoomGroup_Response;
}
impl crate::RpcMethod for CChatRoom_JoinVoiceChat_Request {
    const METHOD_NAME: &'static str = "ChatRoom.JoinVoiceChat#1";
    type Response = CChatRoom_JoinVoiceChat_Response;
}
impl crate::RpcMethod for CChatRoom_KickUser_Request {
    const METHOD_NAME: &'static str = "ChatRoom.KickUserFromGroup#1";
    type Response = CChatRoom_KickUser_Response;
}
impl crate::RpcMethod for CChatRoom_LeaveChatRoomGroup_Request {
    const METHOD_NAME: &'static str = "ChatRoom.LeaveChatRoomGroup#1";
    type Response = CChatRoom_LeaveChatRoomGroup_Response;
}
impl crate::RpcMethod for CChatRoom_LeaveVoiceChat_Request {
    const METHOD_NAME: &'static str = "ChatRoom.LeaveVoiceChat#1";
    type Response = CChatRoom_LeaveVoiceChat_Response;
}
impl crate::RpcMethod for CChatRoom_MemberStateChange_Notification {
    const METHOD_NAME: &'static str = "ChatRoomClient.NotifyMemberStateChange#1";
    type Response = ();
}
impl crate::RpcMethod for CChatRoom_MessageReaction_Notification {
    const METHOD_NAME: &'static str = "ChatRoomClient.NotifyMessageReaction#1";
    type Response = ();
}
impl crate::RpcMethod for CChatRoom_MuteUser_Request {
    const METHOD_NAME: &'static str = "ChatRoom.MuteUserInGroup#1";
    type Response = CChatRoom_MuteUser_Response;
}
impl crate::RpcMethod for CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
    const METHOD_NAME: &'static str = "ChatRoomClient.NotifyShouldRejoinChatRoomVoiceChat#1";
    type Response = ();
}
impl crate::RpcMethod for CChatRoom_RenameChatRoomGroup_Request {
    const METHOD_NAME: &'static str = "ChatRoom.RenameChatRoomGroup#1";
    type Response = CChatRoom_RenameChatRoomGroup_Response;
}
impl crate::RpcMethod for CChatRoom_RenameChatRoom_Request {
    const METHOD_NAME: &'static str = "ChatRoom.RenameChatRoom#1";
    type Response = CChatRoom_RenameChatRoom_Response;
}
impl crate::RpcMethod for CChatRoom_RenameRole_Request {
    const METHOD_NAME: &'static str = "ChatRoom.RenameRole#1";
    type Response = CChatRoom_RenameRole_Response;
}
impl crate::RpcMethod for CChatRoom_ReorderChatRoom_Request {
    const METHOD_NAME: &'static str = "ChatRoom.ReorderChatRoom#1";
    type Response = CChatRoom_ReorderChatRoom_Response;
}
impl crate::RpcMethod for CChatRoom_ReorderRole_Request {
    const METHOD_NAME: &'static str = "ChatRoom.ReorderRole#1";
    type Response = CChatRoom_ReorderRole_Response;
}
impl crate::RpcMethod for CChatRoom_ReplaceRoleActions_Request {
    const METHOD_NAME: &'static str = "ChatRoom.ReplaceRoleActions#1";
    type Response = CChatRoom_ReplaceRoleActions_Response;
}
impl crate::RpcMethod for CChatRoom_RevokeInvite_Request {
    const METHOD_NAME: &'static str = "ChatRoom.RevokeInviteToGroup#1";
    type Response = CChatRoom_RevokeInvite_Response;
}
impl crate::RpcMethod for CChatRoom_SaveChatRoomGroup_Request {
    const METHOD_NAME: &'static str = "ChatRoom.SaveChatRoomGroup#1";
    type Response = CChatRoom_SaveChatRoomGroup_Response;
}
impl crate::RpcMethod for CChatRoom_SearchMembers_Request {
    const METHOD_NAME: &'static str = "ChatRoom.SearchMembers#1";
    type Response = CChatRoom_SearchMembers_Response;
}
impl crate::RpcMethod for CChatRoom_SendChatMessage_Request {
    const METHOD_NAME: &'static str = "ChatRoom.SendChatMessage#1";
    type Response = CChatRoom_SendChatMessage_Response;
}
impl crate::RpcMethod for CChatRoom_SetAppChatRoomGroupForceActive_Request {
    const METHOD_NAME: &'static str = "ChatRoom.SetAppChatRoomGroupForceActive#1";
    type Response = CChatRoom_SetAppChatRoomGroupForceActive_Response;
}
impl crate::RpcMethod for CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
    const METHOD_NAME: &'static str = "ChatRoom.SetAppChatRoomGroupStopForceActive#1";
    type Response = ();
}
impl crate::RpcMethod for CChatRoom_SetChatRoomGroupAvatar_Request {
    const METHOD_NAME: &'static str = "ChatRoom.SetChatRoomGroupAvatar#1";
    type Response = CChatRoom_SetChatRoomGroupAvatar_Response;
}
impl crate::RpcMethod for CChatRoom_SetChatRoomGroupTagline_Request {
    const METHOD_NAME: &'static str = "ChatRoom.SetChatRoomGroupTagline#1";
    type Response = CChatRoom_SetChatRoomGroupTagline_Response;
}
impl crate::RpcMethod for CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
    const METHOD_NAME: &'static str = "ChatRoom.SetChatRoomGroupWatchingBroadcast#1";
    type Response = CChatRoom_SetChatRoomGroupWatchingBroadcast_Response;
}
impl crate::RpcMethod for CChatRoom_SetSessionActiveChatRoomGroups_Request {
    const METHOD_NAME: &'static str = "ChatRoom.SetSessionActiveChatRoomGroups#1";
    type Response = CChatRoom_SetSessionActiveChatRoomGroups_Response;
}
impl crate::RpcMethod for CChatRoom_SetUserBanState_Request {
    const METHOD_NAME: &'static str = "ChatRoom.SetUserBanState#1";
    type Response = CChatRoom_SetUserBanState_Response;
}
impl crate::RpcMethod for CChatRoom_SetUserChatGroupPreferences_Request {
    const METHOD_NAME: &'static str = "ChatRoom.SetUserChatGroupPreferences#1";
    type Response = CChatRoom_SetUserChatGroupPreferences_Response;
}
impl crate::RpcMethod for CChatRoom_UpdateMemberListView_Notification {
    const METHOD_NAME: &'static str = "ChatRoom.UpdateMemberListView#1";
    type Response = ();
}
impl crate::RpcMethod for CChatRoom_UpdateMessageReaction_Request {
    const METHOD_NAME: &'static str = "ChatRoom.UpdateMessageReaction#1";
    type Response = CChatRoom_UpdateMessageReaction_Response;
}
impl crate::RpcMethod for CChatUsability_ClientUsabilityMetrics_Notification {
    const METHOD_NAME: &'static str = "ChatUsability.NotifyClientUsabilityMetrics#1";
    type Response = ();
}
impl crate::RpcMethod for CChatUsability_RequestClientUsabilityMetrics_Notification {
    const METHOD_NAME: &'static str = "ChatUsabilityClient.NotifyRequestClientUsabilityMetrics#1";
    type Response = ();
}
impl crate::RpcMethod for CChat_RequestFriendPersonaStates_Request {
    const METHOD_NAME: &'static str = "Chat.RequestFriendPersonaStates#1";
    type Response = CChat_RequestFriendPersonaStates_Response;
}
impl crate::RpcMethod for CClanChatRooms_GetClanChatRoomInfo_Request {
    const METHOD_NAME: &'static str = "ClanChatRooms.GetClanChatRoomInfo#1";
    type Response = CClanChatRooms_GetClanChatRoomInfo_Response;
}
impl crate::RpcMethod for CClanChatRooms_SetClanChatRoomPrivate_Request {
    const METHOD_NAME: &'static str = "ClanChatRooms.SetClanChatRoomPrivate#1";
    type Response = CClanChatRooms_SetClanChatRoomPrivate_Response;
}
impl crate::RpcMethod for ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
    const METHOD_NAME: &'static str = "ChatRoomClient.NotifyChatGroupUserStateChanged#1";
    type Response = ();
}
impl crate::RpcMethod for ChatRoomClient_NotifyChatRoomDisconnect_Notification {
    const METHOD_NAME: &'static str = "ChatRoomClient.NotifyChatRoomDisconnect#1";
    type Response = ();
}
