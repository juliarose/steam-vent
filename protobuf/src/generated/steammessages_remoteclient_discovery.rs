// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_remoteclient_discovery.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:CMsgRemoteClientBroadcastHeader)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRemoteClientBroadcastHeader {
    // message fields
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastHeader.client_id)
    pub client_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastHeader.msg_type)
    pub msg_type: ::std::option::Option<::protobuf::EnumOrUnknown<ERemoteClientBroadcastMsg>>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastHeader.instance_id)
    pub instance_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastHeader.device_id)
    pub device_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastHeader.device_token)
    pub device_token: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRemoteClientBroadcastHeader.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteClientBroadcastHeader {
    fn default() -> &'a CMsgRemoteClientBroadcastHeader {
        <CMsgRemoteClientBroadcastHeader as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteClientBroadcastHeader {
    pub fn new() -> CMsgRemoteClientBroadcastHeader {
        ::std::default::Default::default()
    }

    // optional uint64 client_id = 1;

    pub fn client_id(&self) -> u64 {
        self.client_id.unwrap_or(0)
    }

    pub fn clear_client_id(&mut self) {
        self.client_id = ::std::option::Option::None;
    }

    pub fn has_client_id(&self) -> bool {
        self.client_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_id(&mut self, v: u64) {
        self.client_id = ::std::option::Option::Some(v);
    }

    // optional .ERemoteClientBroadcastMsg msg_type = 2;

    pub fn msg_type(&self) -> ERemoteClientBroadcastMsg {
        match self.msg_type {
            Some(e) => e.enum_value_or(ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgDiscovery),
            None => ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgDiscovery,
        }
    }

    pub fn clear_msg_type(&mut self) {
        self.msg_type = ::std::option::Option::None;
    }

    pub fn has_msg_type(&self) -> bool {
        self.msg_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_type(&mut self, v: ERemoteClientBroadcastMsg) {
        self.msg_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 instance_id = 3;

    pub fn instance_id(&self) -> u64 {
        self.instance_id.unwrap_or(0)
    }

    pub fn clear_instance_id(&mut self) {
        self.instance_id = ::std::option::Option::None;
    }

    pub fn has_instance_id(&self) -> bool {
        self.instance_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instance_id(&mut self, v: u64) {
        self.instance_id = ::std::option::Option::Some(v);
    }

    // optional uint64 device_id = 4;

    pub fn device_id(&self) -> u64 {
        self.device_id.unwrap_or(0)
    }

    pub fn clear_device_id(&mut self) {
        self.device_id = ::std::option::Option::None;
    }

    pub fn has_device_id(&self) -> bool {
        self.device_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_id(&mut self, v: u64) {
        self.device_id = ::std::option::Option::Some(v);
    }

    // optional bytes device_token = 5;

    pub fn device_token(&self) -> &[u8] {
        match self.device_token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_device_token(&mut self) {
        self.device_token = ::std::option::Option::None;
    }

    pub fn has_device_token(&self) -> bool {
        self.device_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.device_token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.device_token.is_none() {
            self.device_token = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.device_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_token(&mut self) -> ::std::vec::Vec<u8> {
        self.device_token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgRemoteClientBroadcastHeader {
    const NAME: &'static str = "CMsgRemoteClientBroadcastHeader";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.client_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.msg_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.instance_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.device_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                42 => {
                    self.device_token = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.client_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.msg_type {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.instance_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.device_id {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.device_token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.client_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.msg_type {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.instance_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.device_id {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.device_token.as_ref() {
            os.write_bytes(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRemoteClientBroadcastHeader {
        CMsgRemoteClientBroadcastHeader::new()
    }

    fn clear(&mut self) {
        self.client_id = ::std::option::Option::None;
        self.msg_type = ::std::option::Option::None;
        self.instance_id = ::std::option::Option::None;
        self.device_id = ::std::option::Option::None;
        self.device_token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRemoteClientBroadcastHeader {
        static instance: CMsgRemoteClientBroadcastHeader = CMsgRemoteClientBroadcastHeader {
            client_id: ::std::option::Option::None,
            msg_type: ::std::option::Option::None,
            instance_id: ::std::option::Option::None,
            device_id: ::std::option::Option::None,
            device_token: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgRemoteClientBroadcastStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRemoteClientBroadcastStatus {
    // message fields
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.version)
    pub version: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.min_version)
    pub min_version: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.connect_port)
    pub connect_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.hostname)
    pub hostname: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.enabled_services)
    pub enabled_services: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.ostype)
    pub ostype: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.is64bit)
    pub is64bit: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.users)
    pub users: ::std::vec::Vec<cmsg_remote_client_broadcast_status::User>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.euniverse)
    pub euniverse: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.screen_locked)
    pub screen_locked: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.games_running)
    pub games_running: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.mac_addresses)
    pub mac_addresses: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.download_lan_peer_group)
    pub download_lan_peer_group: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.broadcasting_active)
    pub broadcasting_active: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.vr_active)
    pub vr_active: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.content_cache_port)
    pub content_cache_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.ip_addresses)
    pub ip_addresses: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.public_ip_address)
    pub public_ip_address: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.remoteplay_active)
    pub remoteplay_active: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.supported_services)
    pub supported_services: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.steam_deck)
    pub steam_deck: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.steam_version)
    pub steam_version: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRemoteClientBroadcastStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteClientBroadcastStatus {
    fn default() -> &'a CMsgRemoteClientBroadcastStatus {
        <CMsgRemoteClientBroadcastStatus as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteClientBroadcastStatus {
    pub fn new() -> CMsgRemoteClientBroadcastStatus {
        ::std::default::Default::default()
    }

    // optional int32 version = 1;

    pub fn version(&self) -> i32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional int32 min_version = 2;

    pub fn min_version(&self) -> i32 {
        self.min_version.unwrap_or(0)
    }

    pub fn clear_min_version(&mut self) {
        self.min_version = ::std::option::Option::None;
    }

    pub fn has_min_version(&self) -> bool {
        self.min_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_version(&mut self, v: i32) {
        self.min_version = ::std::option::Option::Some(v);
    }

    // optional uint32 connect_port = 3;

    pub fn connect_port(&self) -> u32 {
        self.connect_port.unwrap_or(0)
    }

    pub fn clear_connect_port(&mut self) {
        self.connect_port = ::std::option::Option::None;
    }

    pub fn has_connect_port(&self) -> bool {
        self.connect_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connect_port(&mut self, v: u32) {
        self.connect_port = ::std::option::Option::Some(v);
    }

    // optional string hostname = 4;

    pub fn hostname(&self) -> &str {
        match self.hostname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_hostname(&mut self) {
        self.hostname = ::std::option::Option::None;
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname(&mut self) -> &mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 enabled_services = 6;

    pub fn enabled_services(&self) -> u32 {
        self.enabled_services.unwrap_or(0)
    }

    pub fn clear_enabled_services(&mut self) {
        self.enabled_services = ::std::option::Option::None;
    }

    pub fn has_enabled_services(&self) -> bool {
        self.enabled_services.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enabled_services(&mut self, v: u32) {
        self.enabled_services = ::std::option::Option::Some(v);
    }

    // optional int32 ostype = 7;

    pub fn ostype(&self) -> i32 {
        self.ostype.unwrap_or(0i32)
    }

    pub fn clear_ostype(&mut self) {
        self.ostype = ::std::option::Option::None;
    }

    pub fn has_ostype(&self) -> bool {
        self.ostype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ostype(&mut self, v: i32) {
        self.ostype = ::std::option::Option::Some(v);
    }

    // optional bool is64bit = 8;

    pub fn is64bit(&self) -> bool {
        self.is64bit.unwrap_or(false)
    }

    pub fn clear_is64bit(&mut self) {
        self.is64bit = ::std::option::Option::None;
    }

    pub fn has_is64bit(&self) -> bool {
        self.is64bit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is64bit(&mut self, v: bool) {
        self.is64bit = ::std::option::Option::Some(v);
    }

    // optional int32 euniverse = 11;

    pub fn euniverse(&self) -> i32 {
        self.euniverse.unwrap_or(0)
    }

    pub fn clear_euniverse(&mut self) {
        self.euniverse = ::std::option::Option::None;
    }

    pub fn has_euniverse(&self) -> bool {
        self.euniverse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_euniverse(&mut self, v: i32) {
        self.euniverse = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp = 12;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional bool screen_locked = 13;

    pub fn screen_locked(&self) -> bool {
        self.screen_locked.unwrap_or(false)
    }

    pub fn clear_screen_locked(&mut self) {
        self.screen_locked = ::std::option::Option::None;
    }

    pub fn has_screen_locked(&self) -> bool {
        self.screen_locked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screen_locked(&mut self, v: bool) {
        self.screen_locked = ::std::option::Option::Some(v);
    }

    // optional bool games_running = 14;

    pub fn games_running(&self) -> bool {
        self.games_running.unwrap_or(false)
    }

    pub fn clear_games_running(&mut self) {
        self.games_running = ::std::option::Option::None;
    }

    pub fn has_games_running(&self) -> bool {
        self.games_running.is_some()
    }

    // Param is passed by value, moved
    pub fn set_games_running(&mut self, v: bool) {
        self.games_running = ::std::option::Option::Some(v);
    }

    // optional uint32 download_lan_peer_group = 16;

    pub fn download_lan_peer_group(&self) -> u32 {
        self.download_lan_peer_group.unwrap_or(0)
    }

    pub fn clear_download_lan_peer_group(&mut self) {
        self.download_lan_peer_group = ::std::option::Option::None;
    }

    pub fn has_download_lan_peer_group(&self) -> bool {
        self.download_lan_peer_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_lan_peer_group(&mut self, v: u32) {
        self.download_lan_peer_group = ::std::option::Option::Some(v);
    }

    // optional bool broadcasting_active = 17;

    pub fn broadcasting_active(&self) -> bool {
        self.broadcasting_active.unwrap_or(false)
    }

    pub fn clear_broadcasting_active(&mut self) {
        self.broadcasting_active = ::std::option::Option::None;
    }

    pub fn has_broadcasting_active(&self) -> bool {
        self.broadcasting_active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcasting_active(&mut self, v: bool) {
        self.broadcasting_active = ::std::option::Option::Some(v);
    }

    // optional bool vr_active = 18;

    pub fn vr_active(&self) -> bool {
        self.vr_active.unwrap_or(false)
    }

    pub fn clear_vr_active(&mut self) {
        self.vr_active = ::std::option::Option::None;
    }

    pub fn has_vr_active(&self) -> bool {
        self.vr_active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vr_active(&mut self, v: bool) {
        self.vr_active = ::std::option::Option::Some(v);
    }

    // optional uint32 content_cache_port = 19;

    pub fn content_cache_port(&self) -> u32 {
        self.content_cache_port.unwrap_or(0)
    }

    pub fn clear_content_cache_port(&mut self) {
        self.content_cache_port = ::std::option::Option::None;
    }

    pub fn has_content_cache_port(&self) -> bool {
        self.content_cache_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_content_cache_port(&mut self, v: u32) {
        self.content_cache_port = ::std::option::Option::Some(v);
    }

    // optional string public_ip_address = 21;

    pub fn public_ip_address(&self) -> &str {
        match self.public_ip_address.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_public_ip_address(&mut self) {
        self.public_ip_address = ::std::option::Option::None;
    }

    pub fn has_public_ip_address(&self) -> bool {
        self.public_ip_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_public_ip_address(&mut self, v: ::std::string::String) {
        self.public_ip_address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_public_ip_address(&mut self) -> &mut ::std::string::String {
        if self.public_ip_address.is_none() {
            self.public_ip_address = ::std::option::Option::Some(::std::string::String::new());
        }
        self.public_ip_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_public_ip_address(&mut self) -> ::std::string::String {
        self.public_ip_address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool remoteplay_active = 22;

    pub fn remoteplay_active(&self) -> bool {
        self.remoteplay_active.unwrap_or(false)
    }

    pub fn clear_remoteplay_active(&mut self) {
        self.remoteplay_active = ::std::option::Option::None;
    }

    pub fn has_remoteplay_active(&self) -> bool {
        self.remoteplay_active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remoteplay_active(&mut self, v: bool) {
        self.remoteplay_active = ::std::option::Option::Some(v);
    }

    // optional uint32 supported_services = 23;

    pub fn supported_services(&self) -> u32 {
        self.supported_services.unwrap_or(0)
    }

    pub fn clear_supported_services(&mut self) {
        self.supported_services = ::std::option::Option::None;
    }

    pub fn has_supported_services(&self) -> bool {
        self.supported_services.is_some()
    }

    // Param is passed by value, moved
    pub fn set_supported_services(&mut self, v: u32) {
        self.supported_services = ::std::option::Option::Some(v);
    }

    // optional bool steam_deck = 24;

    pub fn steam_deck(&self) -> bool {
        self.steam_deck.unwrap_or(false)
    }

    pub fn clear_steam_deck(&mut self) {
        self.steam_deck = ::std::option::Option::None;
    }

    pub fn has_steam_deck(&self) -> bool {
        self.steam_deck.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_deck(&mut self, v: bool) {
        self.steam_deck = ::std::option::Option::Some(v);
    }

    // optional uint64 steam_version = 25;

    pub fn steam_version(&self) -> u64 {
        self.steam_version.unwrap_or(0)
    }

    pub fn clear_steam_version(&mut self) {
        self.steam_version = ::std::option::Option::None;
    }

    pub fn has_steam_version(&self) -> bool {
        self.steam_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_version(&mut self, v: u64) {
        self.steam_version = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgRemoteClientBroadcastStatus {
    const NAME: &'static str = "CMsgRemoteClientBroadcastStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.min_version = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.connect_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.hostname = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.enabled_services = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.ostype = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.is64bit = ::std::option::Option::Some(is.read_bool()?);
                },
                74 => {
                    self.users.push(is.read_message()?);
                },
                88 => {
                    self.euniverse = ::std::option::Option::Some(is.read_int32()?);
                },
                96 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.screen_locked = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.games_running = ::std::option::Option::Some(is.read_bool()?);
                },
                122 => {
                    self.mac_addresses.push(is.read_string()?);
                },
                128 => {
                    self.download_lan_peer_group = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.broadcasting_active = ::std::option::Option::Some(is.read_bool()?);
                },
                144 => {
                    self.vr_active = ::std::option::Option::Some(is.read_bool()?);
                },
                152 => {
                    self.content_cache_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                162 => {
                    self.ip_addresses.push(is.read_string()?);
                },
                170 => {
                    self.public_ip_address = ::std::option::Option::Some(is.read_string()?);
                },
                176 => {
                    self.remoteplay_active = ::std::option::Option::Some(is.read_bool()?);
                },
                184 => {
                    self.supported_services = ::std::option::Option::Some(is.read_uint32()?);
                },
                192 => {
                    self.steam_deck = ::std::option::Option::Some(is.read_bool()?);
                },
                200 => {
                    self.steam_version = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.min_version {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.connect_port {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.hostname.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.enabled_services {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.ostype {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.is64bit {
            my_size += 1 + 1;
        }
        for value in &self.users {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.euniverse {
            my_size += ::protobuf::rt::int32_size(11, v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.screen_locked {
            my_size += 1 + 1;
        }
        if let Some(v) = self.games_running {
            my_size += 1 + 1;
        }
        for value in &self.mac_addresses {
            my_size += ::protobuf::rt::string_size(15, &value);
        };
        if let Some(v) = self.download_lan_peer_group {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.broadcasting_active {
            my_size += 2 + 1;
        }
        if let Some(v) = self.vr_active {
            my_size += 2 + 1;
        }
        if let Some(v) = self.content_cache_port {
            my_size += ::protobuf::rt::uint32_size(19, v);
        }
        for value in &self.ip_addresses {
            my_size += ::protobuf::rt::string_size(20, &value);
        };
        if let Some(v) = self.public_ip_address.as_ref() {
            my_size += ::protobuf::rt::string_size(21, &v);
        }
        if let Some(v) = self.remoteplay_active {
            my_size += 2 + 1;
        }
        if let Some(v) = self.supported_services {
            my_size += ::protobuf::rt::uint32_size(23, v);
        }
        if let Some(v) = self.steam_deck {
            my_size += 2 + 1;
        }
        if let Some(v) = self.steam_version {
            my_size += ::protobuf::rt::uint64_size(25, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.min_version {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.connect_port {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.hostname.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.enabled_services {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.ostype {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.is64bit {
            os.write_bool(8, v)?;
        }
        for v in &self.users {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        if let Some(v) = self.euniverse {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.screen_locked {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.games_running {
            os.write_bool(14, v)?;
        }
        for v in &self.mac_addresses {
            os.write_string(15, &v)?;
        };
        if let Some(v) = self.download_lan_peer_group {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.broadcasting_active {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.vr_active {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.content_cache_port {
            os.write_uint32(19, v)?;
        }
        for v in &self.ip_addresses {
            os.write_string(20, &v)?;
        };
        if let Some(v) = self.public_ip_address.as_ref() {
            os.write_string(21, v)?;
        }
        if let Some(v) = self.remoteplay_active {
            os.write_bool(22, v)?;
        }
        if let Some(v) = self.supported_services {
            os.write_uint32(23, v)?;
        }
        if let Some(v) = self.steam_deck {
            os.write_bool(24, v)?;
        }
        if let Some(v) = self.steam_version {
            os.write_uint64(25, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRemoteClientBroadcastStatus {
        CMsgRemoteClientBroadcastStatus::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.min_version = ::std::option::Option::None;
        self.connect_port = ::std::option::Option::None;
        self.hostname = ::std::option::Option::None;
        self.enabled_services = ::std::option::Option::None;
        self.ostype = ::std::option::Option::None;
        self.is64bit = ::std::option::Option::None;
        self.users.clear();
        self.euniverse = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.screen_locked = ::std::option::Option::None;
        self.games_running = ::std::option::Option::None;
        self.mac_addresses.clear();
        self.download_lan_peer_group = ::std::option::Option::None;
        self.broadcasting_active = ::std::option::Option::None;
        self.vr_active = ::std::option::Option::None;
        self.content_cache_port = ::std::option::Option::None;
        self.ip_addresses.clear();
        self.public_ip_address = ::std::option::Option::None;
        self.remoteplay_active = ::std::option::Option::None;
        self.supported_services = ::std::option::Option::None;
        self.steam_deck = ::std::option::Option::None;
        self.steam_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRemoteClientBroadcastStatus {
        static instance: CMsgRemoteClientBroadcastStatus = CMsgRemoteClientBroadcastStatus {
            version: ::std::option::Option::None,
            min_version: ::std::option::Option::None,
            connect_port: ::std::option::Option::None,
            hostname: ::std::option::Option::None,
            enabled_services: ::std::option::Option::None,
            ostype: ::std::option::Option::None,
            is64bit: ::std::option::Option::None,
            users: ::std::vec::Vec::new(),
            euniverse: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            screen_locked: ::std::option::Option::None,
            games_running: ::std::option::Option::None,
            mac_addresses: ::std::vec::Vec::new(),
            download_lan_peer_group: ::std::option::Option::None,
            broadcasting_active: ::std::option::Option::None,
            vr_active: ::std::option::Option::None,
            content_cache_port: ::std::option::Option::None,
            ip_addresses: ::std::vec::Vec::new(),
            public_ip_address: ::std::option::Option::None,
            remoteplay_active: ::std::option::Option::None,
            supported_services: ::std::option::Option::None,
            steam_deck: ::std::option::Option::None,
            steam_version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgRemoteClientBroadcastStatus`
pub mod cmsg_remote_client_broadcast_status {
    // @@protoc_insertion_point(message:CMsgRemoteClientBroadcastStatus.User)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct User {
        // message fields
        // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.User.steamid)
        pub steamid: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.User.auth_key_id)
        pub auth_key_id: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgRemoteClientBroadcastStatus.User.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a User {
        fn default() -> &'a User {
            <User as ::protobuf::Message>::default_instance()
        }
    }

    impl User {
        pub fn new() -> User {
            ::std::default::Default::default()
        }

        // optional fixed64 steamid = 1;

        pub fn steamid(&self) -> u64 {
            self.steamid.unwrap_or(0)
        }

        pub fn clear_steamid(&mut self) {
            self.steamid = ::std::option::Option::None;
        }

        pub fn has_steamid(&self) -> bool {
            self.steamid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steamid(&mut self, v: u64) {
            self.steamid = ::std::option::Option::Some(v);
        }

        // optional uint32 auth_key_id = 2;

        pub fn auth_key_id(&self) -> u32 {
            self.auth_key_id.unwrap_or(0)
        }

        pub fn clear_auth_key_id(&mut self) {
            self.auth_key_id = ::std::option::Option::None;
        }

        pub fn has_auth_key_id(&self) -> bool {
            self.auth_key_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_auth_key_id(&mut self, v: u32) {
            self.auth_key_id = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for User {
        const NAME: &'static str = "User";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.auth_key_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steamid {
                my_size += 1 + 8;
            }
            if let Some(v) = self.auth_key_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.steamid {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.auth_key_id {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> User {
            User::new()
        }

        fn clear(&mut self) {
            self.steamid = ::std::option::Option::None;
            self.auth_key_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static User {
            static instance: User = User {
                steamid: ::std::option::Option::None,
                auth_key_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgRemoteClientBroadcastDiscovery)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRemoteClientBroadcastDiscovery {
    // message fields
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastDiscovery.seq_num)
    pub seq_num: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastDiscovery.client_ids)
    pub client_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRemoteClientBroadcastDiscovery.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteClientBroadcastDiscovery {
    fn default() -> &'a CMsgRemoteClientBroadcastDiscovery {
        <CMsgRemoteClientBroadcastDiscovery as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteClientBroadcastDiscovery {
    pub fn new() -> CMsgRemoteClientBroadcastDiscovery {
        ::std::default::Default::default()
    }

    // optional uint32 seq_num = 1;

    pub fn seq_num(&self) -> u32 {
        self.seq_num.unwrap_or(0)
    }

    pub fn clear_seq_num(&mut self) {
        self.seq_num = ::std::option::Option::None;
    }

    pub fn has_seq_num(&self) -> bool {
        self.seq_num.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num(&mut self, v: u32) {
        self.seq_num = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgRemoteClientBroadcastDiscovery {
    const NAME: &'static str = "CMsgRemoteClientBroadcastDiscovery";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.seq_num = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint64_into(&mut self.client_ids)?;
                },
                16 => {
                    self.client_ids.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.seq_num {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.client_ids {
            my_size += ::protobuf::rt::uint64_size(2, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.seq_num {
            os.write_uint32(1, v)?;
        }
        for v in &self.client_ids {
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRemoteClientBroadcastDiscovery {
        CMsgRemoteClientBroadcastDiscovery::new()
    }

    fn clear(&mut self) {
        self.seq_num = ::std::option::Option::None;
        self.client_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRemoteClientBroadcastDiscovery {
        static instance: CMsgRemoteClientBroadcastDiscovery = CMsgRemoteClientBroadcastDiscovery {
            seq_num: ::std::option::Option::None,
            client_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgRemoteClientBroadcastClientIDDeconflict)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRemoteClientBroadcastClientIDDeconflict {
    // message fields
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastClientIDDeconflict.client_ids)
    pub client_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRemoteClientBroadcastClientIDDeconflict.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteClientBroadcastClientIDDeconflict {
    fn default() -> &'a CMsgRemoteClientBroadcastClientIDDeconflict {
        <CMsgRemoteClientBroadcastClientIDDeconflict as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteClientBroadcastClientIDDeconflict {
    pub fn new() -> CMsgRemoteClientBroadcastClientIDDeconflict {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgRemoteClientBroadcastClientIDDeconflict {
    const NAME: &'static str = "CMsgRemoteClientBroadcastClientIDDeconflict";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    is.read_repeated_packed_uint64_into(&mut self.client_ids)?;
                },
                16 => {
                    self.client_ids.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.client_ids {
            my_size += ::protobuf::rt::uint64_size(2, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.client_ids {
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRemoteClientBroadcastClientIDDeconflict {
        CMsgRemoteClientBroadcastClientIDDeconflict::new()
    }

    fn clear(&mut self) {
        self.client_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRemoteClientBroadcastClientIDDeconflict {
        static instance: CMsgRemoteClientBroadcastClientIDDeconflict = CMsgRemoteClientBroadcastClientIDDeconflict {
            client_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgRemoteDeviceAuthorizationRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRemoteDeviceAuthorizationRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationRequest.device_token)
    pub device_token: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationRequest.device_name)
    pub device_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationRequest.encrypted_request)
    pub encrypted_request: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationRequest.auth_key)
    pub auth_key: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRemoteDeviceAuthorizationRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceAuthorizationRequest {
    fn default() -> &'a CMsgRemoteDeviceAuthorizationRequest {
        <CMsgRemoteDeviceAuthorizationRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceAuthorizationRequest {
    pub fn new() -> CMsgRemoteDeviceAuthorizationRequest {
        ::std::default::Default::default()
    }

    // required bytes device_token = 1;

    pub fn device_token(&self) -> &[u8] {
        match self.device_token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_device_token(&mut self) {
        self.device_token = ::std::option::Option::None;
    }

    pub fn has_device_token(&self) -> bool {
        self.device_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.device_token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.device_token.is_none() {
            self.device_token = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.device_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_token(&mut self) -> ::std::vec::Vec<u8> {
        self.device_token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string device_name = 2;

    pub fn device_name(&self) -> &str {
        match self.device_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_device_name(&mut self) {
        self.device_name = ::std::option::Option::None;
    }

    pub fn has_device_name(&self) -> bool {
        self.device_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_name(&mut self, v: ::std::string::String) {
        self.device_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_name(&mut self) -> &mut ::std::string::String {
        if self.device_name.is_none() {
            self.device_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.device_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_name(&mut self) -> ::std::string::String {
        self.device_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required bytes encrypted_request = 3;

    pub fn encrypted_request(&self) -> &[u8] {
        match self.encrypted_request.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_encrypted_request(&mut self) {
        self.encrypted_request = ::std::option::Option::None;
    }

    pub fn has_encrypted_request(&self) -> bool {
        self.encrypted_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encrypted_request(&mut self, v: ::std::vec::Vec<u8>) {
        self.encrypted_request = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encrypted_request(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.encrypted_request.is_none() {
            self.encrypted_request = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.encrypted_request.as_mut().unwrap()
    }

    // Take field
    pub fn take_encrypted_request(&mut self) -> ::std::vec::Vec<u8> {
        self.encrypted_request.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes auth_key = 4;

    pub fn auth_key(&self) -> &[u8] {
        match self.auth_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_auth_key(&mut self) {
        self.auth_key = ::std::option::Option::None;
    }

    pub fn has_auth_key(&self) -> bool {
        self.auth_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auth_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.auth_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.auth_key.is_none() {
            self.auth_key = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.auth_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_auth_key(&mut self) -> ::std::vec::Vec<u8> {
        self.auth_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgRemoteDeviceAuthorizationRequest {
    const NAME: &'static str = "CMsgRemoteDeviceAuthorizationRequest";

    fn is_initialized(&self) -> bool {
        if self.device_token.is_none() {
            return false;
        }
        if self.encrypted_request.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.device_token = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.device_name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.encrypted_request = ::std::option::Option::Some(is.read_bytes()?);
                },
                34 => {
                    self.auth_key = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.device_token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.device_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.encrypted_request.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.auth_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.device_token.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.device_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.encrypted_request.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.auth_key.as_ref() {
            os.write_bytes(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRemoteDeviceAuthorizationRequest {
        CMsgRemoteDeviceAuthorizationRequest::new()
    }

    fn clear(&mut self) {
        self.device_token = ::std::option::Option::None;
        self.device_name = ::std::option::Option::None;
        self.encrypted_request = ::std::option::Option::None;
        self.auth_key = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRemoteDeviceAuthorizationRequest {
        static instance: CMsgRemoteDeviceAuthorizationRequest = CMsgRemoteDeviceAuthorizationRequest {
            device_token: ::std::option::Option::None,
            device_name: ::std::option::Option::None,
            encrypted_request: ::std::option::Option::None,
            auth_key: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgRemoteDeviceAuthorizationRequest`
pub mod cmsg_remote_device_authorization_request {
    // @@protoc_insertion_point(message:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CKeyEscrow_Ticket {
        // message fields
        // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.password)
        pub password: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.identifier)
        pub identifier: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.payload)
        pub payload: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.timestamp)
        pub timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.usage)
        pub usage: ::std::option::Option<::protobuf::EnumOrUnknown<EKeyEscrowUsage>>,
        // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.device_name)
        pub device_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.device_model)
        pub device_model: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.device_serial)
        pub device_serial: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.device_provisioning_id)
        pub device_provisioning_id: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CKeyEscrow_Ticket {
        fn default() -> &'a CKeyEscrow_Ticket {
            <CKeyEscrow_Ticket as ::protobuf::Message>::default_instance()
        }
    }

    impl CKeyEscrow_Ticket {
        pub fn new() -> CKeyEscrow_Ticket {
            ::std::default::Default::default()
        }

        // optional bytes password = 1;

        pub fn password(&self) -> &[u8] {
            match self.password.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_password(&mut self) {
            self.password = ::std::option::Option::None;
        }

        pub fn has_password(&self) -> bool {
            self.password.is_some()
        }

        // Param is passed by value, moved
        pub fn set_password(&mut self, v: ::std::vec::Vec<u8>) {
            self.password = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_password(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.password.is_none() {
                self.password = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.password.as_mut().unwrap()
        }

        // Take field
        pub fn take_password(&mut self) -> ::std::vec::Vec<u8> {
            self.password.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional uint64 identifier = 2;

        pub fn identifier(&self) -> u64 {
            self.identifier.unwrap_or(0)
        }

        pub fn clear_identifier(&mut self) {
            self.identifier = ::std::option::Option::None;
        }

        pub fn has_identifier(&self) -> bool {
            self.identifier.is_some()
        }

        // Param is passed by value, moved
        pub fn set_identifier(&mut self, v: u64) {
            self.identifier = ::std::option::Option::Some(v);
        }

        // optional bytes payload = 3;

        pub fn payload(&self) -> &[u8] {
            match self.payload.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_payload(&mut self) {
            self.payload = ::std::option::Option::None;
        }

        pub fn has_payload(&self) -> bool {
            self.payload.is_some()
        }

        // Param is passed by value, moved
        pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
            self.payload = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.payload.is_none() {
                self.payload = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.payload.as_mut().unwrap()
        }

        // Take field
        pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
            self.payload.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional uint32 timestamp = 4;

        pub fn timestamp(&self) -> u32 {
            self.timestamp.unwrap_or(0)
        }

        pub fn clear_timestamp(&mut self) {
            self.timestamp = ::std::option::Option::None;
        }

        pub fn has_timestamp(&self) -> bool {
            self.timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp(&mut self, v: u32) {
            self.timestamp = ::std::option::Option::Some(v);
        }

        // optional .CMsgRemoteDeviceAuthorizationRequest.EKeyEscrowUsage usage = 5;

        pub fn usage(&self) -> EKeyEscrowUsage {
            match self.usage {
                Some(e) => e.enum_value_or(EKeyEscrowUsage::k_EKeyEscrowUsageStreamingDevice),
                None => EKeyEscrowUsage::k_EKeyEscrowUsageStreamingDevice,
            }
        }

        pub fn clear_usage(&mut self) {
            self.usage = ::std::option::Option::None;
        }

        pub fn has_usage(&self) -> bool {
            self.usage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_usage(&mut self, v: EKeyEscrowUsage) {
            self.usage = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional string device_name = 6;

        pub fn device_name(&self) -> &str {
            match self.device_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_device_name(&mut self) {
            self.device_name = ::std::option::Option::None;
        }

        pub fn has_device_name(&self) -> bool {
            self.device_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_device_name(&mut self, v: ::std::string::String) {
            self.device_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_device_name(&mut self) -> &mut ::std::string::String {
            if self.device_name.is_none() {
                self.device_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.device_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_device_name(&mut self) -> ::std::string::String {
            self.device_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string device_model = 7;

        pub fn device_model(&self) -> &str {
            match self.device_model.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_device_model(&mut self) {
            self.device_model = ::std::option::Option::None;
        }

        pub fn has_device_model(&self) -> bool {
            self.device_model.is_some()
        }

        // Param is passed by value, moved
        pub fn set_device_model(&mut self, v: ::std::string::String) {
            self.device_model = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_device_model(&mut self) -> &mut ::std::string::String {
            if self.device_model.is_none() {
                self.device_model = ::std::option::Option::Some(::std::string::String::new());
            }
            self.device_model.as_mut().unwrap()
        }

        // Take field
        pub fn take_device_model(&mut self) -> ::std::string::String {
            self.device_model.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string device_serial = 8;

        pub fn device_serial(&self) -> &str {
            match self.device_serial.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_device_serial(&mut self) {
            self.device_serial = ::std::option::Option::None;
        }

        pub fn has_device_serial(&self) -> bool {
            self.device_serial.is_some()
        }

        // Param is passed by value, moved
        pub fn set_device_serial(&mut self, v: ::std::string::String) {
            self.device_serial = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_device_serial(&mut self) -> &mut ::std::string::String {
            if self.device_serial.is_none() {
                self.device_serial = ::std::option::Option::Some(::std::string::String::new());
            }
            self.device_serial.as_mut().unwrap()
        }

        // Take field
        pub fn take_device_serial(&mut self) -> ::std::string::String {
            self.device_serial.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 device_provisioning_id = 9;

        pub fn device_provisioning_id(&self) -> u32 {
            self.device_provisioning_id.unwrap_or(0)
        }

        pub fn clear_device_provisioning_id(&mut self) {
            self.device_provisioning_id = ::std::option::Option::None;
        }

        pub fn has_device_provisioning_id(&self) -> bool {
            self.device_provisioning_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_device_provisioning_id(&mut self, v: u32) {
            self.device_provisioning_id = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for CKeyEscrow_Ticket {
        const NAME: &'static str = "CKeyEscrow_Ticket";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.password = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    16 => {
                        self.identifier = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    26 => {
                        self.payload = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    32 => {
                        self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.usage = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    50 => {
                        self.device_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    58 => {
                        self.device_model = ::std::option::Option::Some(is.read_string()?);
                    },
                    66 => {
                        self.device_serial = ::std::option::Option::Some(is.read_string()?);
                    },
                    72 => {
                        self.device_provisioning_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.password.as_ref() {
                my_size += ::protobuf::rt::bytes_size(1, &v);
            }
            if let Some(v) = self.identifier {
                my_size += ::protobuf::rt::uint64_size(2, v);
            }
            if let Some(v) = self.payload.as_ref() {
                my_size += ::protobuf::rt::bytes_size(3, &v);
            }
            if let Some(v) = self.timestamp {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.usage {
                my_size += ::protobuf::rt::int32_size(5, v.value());
            }
            if let Some(v) = self.device_name.as_ref() {
                my_size += ::protobuf::rt::string_size(6, &v);
            }
            if let Some(v) = self.device_model.as_ref() {
                my_size += ::protobuf::rt::string_size(7, &v);
            }
            if let Some(v) = self.device_serial.as_ref() {
                my_size += ::protobuf::rt::string_size(8, &v);
            }
            if let Some(v) = self.device_provisioning_id {
                my_size += ::protobuf::rt::uint32_size(9, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.password.as_ref() {
                os.write_bytes(1, v)?;
            }
            if let Some(v) = self.identifier {
                os.write_uint64(2, v)?;
            }
            if let Some(v) = self.payload.as_ref() {
                os.write_bytes(3, v)?;
            }
            if let Some(v) = self.timestamp {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.usage {
                os.write_enum(5, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.device_name.as_ref() {
                os.write_string(6, v)?;
            }
            if let Some(v) = self.device_model.as_ref() {
                os.write_string(7, v)?;
            }
            if let Some(v) = self.device_serial.as_ref() {
                os.write_string(8, v)?;
            }
            if let Some(v) = self.device_provisioning_id {
                os.write_uint32(9, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CKeyEscrow_Ticket {
            CKeyEscrow_Ticket::new()
        }

        fn clear(&mut self) {
            self.password = ::std::option::Option::None;
            self.identifier = ::std::option::Option::None;
            self.payload = ::std::option::Option::None;
            self.timestamp = ::std::option::Option::None;
            self.usage = ::std::option::Option::None;
            self.device_name = ::std::option::Option::None;
            self.device_model = ::std::option::Option::None;
            self.device_serial = ::std::option::Option::None;
            self.device_provisioning_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CKeyEscrow_Ticket {
            static instance: CKeyEscrow_Ticket = CKeyEscrow_Ticket {
                password: ::std::option::Option::None,
                identifier: ::std::option::Option::None,
                payload: ::std::option::Option::None,
                timestamp: ::std::option::Option::None,
                usage: ::std::option::Option::None,
                device_name: ::std::option::Option::None,
                device_model: ::std::option::Option::None,
                device_serial: ::std::option::Option::None,
                device_provisioning_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgRemoteDeviceAuthorizationRequest.EKeyEscrowUsage)
    pub enum EKeyEscrowUsage {
        // @@protoc_insertion_point(enum_value:CMsgRemoteDeviceAuthorizationRequest.EKeyEscrowUsage.k_EKeyEscrowUsageStreamingDevice)
        k_EKeyEscrowUsageStreamingDevice = 0,
    }

    impl ::protobuf::Enum for EKeyEscrowUsage {
        const NAME: &'static str = "EKeyEscrowUsage";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EKeyEscrowUsage> {
            match value {
                0 => ::std::option::Option::Some(EKeyEscrowUsage::k_EKeyEscrowUsageStreamingDevice),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EKeyEscrowUsage> {
            match str {
                "k_EKeyEscrowUsageStreamingDevice" => ::std::option::Option::Some(EKeyEscrowUsage::k_EKeyEscrowUsageStreamingDevice),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EKeyEscrowUsage] = &[
            EKeyEscrowUsage::k_EKeyEscrowUsageStreamingDevice,
        ];
    }

    impl ::std::default::Default for EKeyEscrowUsage {
        fn default() -> Self {
            EKeyEscrowUsage::k_EKeyEscrowUsageStreamingDevice
        }
    }

}

// @@protoc_insertion_point(message:CMsgRemoteDeviceAuthorizationCancelRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRemoteDeviceAuthorizationCancelRequest {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRemoteDeviceAuthorizationCancelRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceAuthorizationCancelRequest {
    fn default() -> &'a CMsgRemoteDeviceAuthorizationCancelRequest {
        <CMsgRemoteDeviceAuthorizationCancelRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceAuthorizationCancelRequest {
    pub fn new() -> CMsgRemoteDeviceAuthorizationCancelRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgRemoteDeviceAuthorizationCancelRequest {
    const NAME: &'static str = "CMsgRemoteDeviceAuthorizationCancelRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRemoteDeviceAuthorizationCancelRequest {
        CMsgRemoteDeviceAuthorizationCancelRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRemoteDeviceAuthorizationCancelRequest {
        static instance: CMsgRemoteDeviceAuthorizationCancelRequest = CMsgRemoteDeviceAuthorizationCancelRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgRemoteDeviceAuthorizationResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRemoteDeviceAuthorizationResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<ERemoteDeviceAuthorizationResult>>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationResponse.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationResponse.auth_key)
    pub auth_key: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationResponse.device_token)
    pub device_token: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRemoteDeviceAuthorizationResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceAuthorizationResponse {
    fn default() -> &'a CMsgRemoteDeviceAuthorizationResponse {
        <CMsgRemoteDeviceAuthorizationResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceAuthorizationResponse {
    pub fn new() -> CMsgRemoteDeviceAuthorizationResponse {
        ::std::default::Default::default()
    }

    // required .ERemoteDeviceAuthorizationResult result = 1;

    pub fn result(&self) -> ERemoteDeviceAuthorizationResult {
        match self.result {
            Some(e) => e.enum_value_or(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationSuccess),
            None => ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationSuccess,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: ERemoteDeviceAuthorizationResult) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional fixed64 steamid = 2;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional bytes auth_key = 3;

    pub fn auth_key(&self) -> &[u8] {
        match self.auth_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_auth_key(&mut self) {
        self.auth_key = ::std::option::Option::None;
    }

    pub fn has_auth_key(&self) -> bool {
        self.auth_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auth_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.auth_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.auth_key.is_none() {
            self.auth_key = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.auth_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_auth_key(&mut self) -> ::std::vec::Vec<u8> {
        self.auth_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes device_token = 4;

    pub fn device_token(&self) -> &[u8] {
        match self.device_token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_device_token(&mut self) {
        self.device_token = ::std::option::Option::None;
    }

    pub fn has_device_token(&self) -> bool {
        self.device_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.device_token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.device_token.is_none() {
            self.device_token = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.device_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_token(&mut self) -> ::std::vec::Vec<u8> {
        self.device_token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgRemoteDeviceAuthorizationResponse {
    const NAME: &'static str = "CMsgRemoteDeviceAuthorizationResponse";

    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                17 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    self.auth_key = ::std::option::Option::Some(is.read_bytes()?);
                },
                34 => {
                    self.device_token = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.auth_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.device_token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.auth_key.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.device_token.as_ref() {
            os.write_bytes(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRemoteDeviceAuthorizationResponse {
        CMsgRemoteDeviceAuthorizationResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.auth_key = ::std::option::Option::None;
        self.device_token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRemoteDeviceAuthorizationResponse {
        static instance: CMsgRemoteDeviceAuthorizationResponse = CMsgRemoteDeviceAuthorizationResponse {
            result: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            auth_key: ::std::option::Option::None,
            device_token: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgRemoteDeviceAuthorizationConfirmed)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRemoteDeviceAuthorizationConfirmed {
    // message fields
    // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationConfirmed.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<ERemoteDeviceAuthorizationResult>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRemoteDeviceAuthorizationConfirmed.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceAuthorizationConfirmed {
    fn default() -> &'a CMsgRemoteDeviceAuthorizationConfirmed {
        <CMsgRemoteDeviceAuthorizationConfirmed as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceAuthorizationConfirmed {
    pub fn new() -> CMsgRemoteDeviceAuthorizationConfirmed {
        ::std::default::Default::default()
    }

    // required .ERemoteDeviceAuthorizationResult result = 1;

    pub fn result(&self) -> ERemoteDeviceAuthorizationResult {
        match self.result {
            Some(e) => e.enum_value_or(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationSuccess),
            None => ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationSuccess,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: ERemoteDeviceAuthorizationResult) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::protobuf::Message for CMsgRemoteDeviceAuthorizationConfirmed {
    const NAME: &'static str = "CMsgRemoteDeviceAuthorizationConfirmed";

    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRemoteDeviceAuthorizationConfirmed {
        CMsgRemoteDeviceAuthorizationConfirmed::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRemoteDeviceAuthorizationConfirmed {
        static instance: CMsgRemoteDeviceAuthorizationConfirmed = CMsgRemoteDeviceAuthorizationConfirmed {
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgRemoteDeviceStreamingRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRemoteDeviceStreamingRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.request_id)
    pub request_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.maximum_resolution_x)
    pub maximum_resolution_x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.maximum_resolution_y)
    pub maximum_resolution_y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.audio_channel_count)
    pub audio_channel_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.device_version)
    pub device_version: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.stream_desktop)
    pub stream_desktop: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.device_token)
    pub device_token: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.pin)
    pub pin: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.enable_video_streaming)
    pub enable_video_streaming: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.enable_audio_streaming)
    pub enable_audio_streaming: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.enable_input_streaming)
    pub enable_input_streaming: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.network_test)
    pub network_test: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.client_id)
    pub client_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.supported_transport)
    pub supported_transport: ::std::vec::Vec<::protobuf::EnumOrUnknown<EStreamTransport>>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.restricted)
    pub restricted: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.form_factor)
    pub form_factor: ::std::option::Option<::protobuf::EnumOrUnknown<EStreamDeviceFormFactor>>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.gamepad_count)
    pub gamepad_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.gamepads)
    pub gamepads: ::std::vec::Vec<cmsg_remote_device_streaming_request::ReservedGamepad>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.gameid)
    pub gameid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.stream_interface)
    pub stream_interface: ::std::option::Option<::protobuf::EnumOrUnknown<EStreamInterface>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRemoteDeviceStreamingRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceStreamingRequest {
    fn default() -> &'a CMsgRemoteDeviceStreamingRequest {
        <CMsgRemoteDeviceStreamingRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceStreamingRequest {
    pub fn new() -> CMsgRemoteDeviceStreamingRequest {
        ::std::default::Default::default()
    }

    // required uint32 request_id = 1;

    pub fn request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional int32 maximum_resolution_x = 2;

    pub fn maximum_resolution_x(&self) -> i32 {
        self.maximum_resolution_x.unwrap_or(0)
    }

    pub fn clear_maximum_resolution_x(&mut self) {
        self.maximum_resolution_x = ::std::option::Option::None;
    }

    pub fn has_maximum_resolution_x(&self) -> bool {
        self.maximum_resolution_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum_resolution_x(&mut self, v: i32) {
        self.maximum_resolution_x = ::std::option::Option::Some(v);
    }

    // optional int32 maximum_resolution_y = 3;

    pub fn maximum_resolution_y(&self) -> i32 {
        self.maximum_resolution_y.unwrap_or(0)
    }

    pub fn clear_maximum_resolution_y(&mut self) {
        self.maximum_resolution_y = ::std::option::Option::None;
    }

    pub fn has_maximum_resolution_y(&self) -> bool {
        self.maximum_resolution_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum_resolution_y(&mut self, v: i32) {
        self.maximum_resolution_y = ::std::option::Option::Some(v);
    }

    // optional int32 audio_channel_count = 4;

    pub fn audio_channel_count(&self) -> i32 {
        self.audio_channel_count.unwrap_or(2i32)
    }

    pub fn clear_audio_channel_count(&mut self) {
        self.audio_channel_count = ::std::option::Option::None;
    }

    pub fn has_audio_channel_count(&self) -> bool {
        self.audio_channel_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_audio_channel_count(&mut self, v: i32) {
        self.audio_channel_count = ::std::option::Option::Some(v);
    }

    // optional string device_version = 5;

    pub fn device_version(&self) -> &str {
        match self.device_version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_device_version(&mut self) {
        self.device_version = ::std::option::Option::None;
    }

    pub fn has_device_version(&self) -> bool {
        self.device_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_version(&mut self, v: ::std::string::String) {
        self.device_version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_version(&mut self) -> &mut ::std::string::String {
        if self.device_version.is_none() {
            self.device_version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.device_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_version(&mut self) -> ::std::string::String {
        self.device_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool stream_desktop = 6;

    pub fn stream_desktop(&self) -> bool {
        self.stream_desktop.unwrap_or(false)
    }

    pub fn clear_stream_desktop(&mut self) {
        self.stream_desktop = ::std::option::Option::None;
    }

    pub fn has_stream_desktop(&self) -> bool {
        self.stream_desktop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stream_desktop(&mut self, v: bool) {
        self.stream_desktop = ::std::option::Option::Some(v);
    }

    // optional bytes device_token = 7;

    pub fn device_token(&self) -> &[u8] {
        match self.device_token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_device_token(&mut self) {
        self.device_token = ::std::option::Option::None;
    }

    pub fn has_device_token(&self) -> bool {
        self.device_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.device_token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.device_token.is_none() {
            self.device_token = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.device_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_token(&mut self) -> ::std::vec::Vec<u8> {
        self.device_token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes pin = 8;

    pub fn pin(&self) -> &[u8] {
        match self.pin.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_pin(&mut self) {
        self.pin = ::std::option::Option::None;
    }

    pub fn has_pin(&self) -> bool {
        self.pin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pin(&mut self, v: ::std::vec::Vec<u8>) {
        self.pin = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pin(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pin.is_none() {
            self.pin = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.pin.as_mut().unwrap()
    }

    // Take field
    pub fn take_pin(&mut self) -> ::std::vec::Vec<u8> {
        self.pin.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool enable_video_streaming = 9;

    pub fn enable_video_streaming(&self) -> bool {
        self.enable_video_streaming.unwrap_or(true)
    }

    pub fn clear_enable_video_streaming(&mut self) {
        self.enable_video_streaming = ::std::option::Option::None;
    }

    pub fn has_enable_video_streaming(&self) -> bool {
        self.enable_video_streaming.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_video_streaming(&mut self, v: bool) {
        self.enable_video_streaming = ::std::option::Option::Some(v);
    }

    // optional bool enable_audio_streaming = 10;

    pub fn enable_audio_streaming(&self) -> bool {
        self.enable_audio_streaming.unwrap_or(true)
    }

    pub fn clear_enable_audio_streaming(&mut self) {
        self.enable_audio_streaming = ::std::option::Option::None;
    }

    pub fn has_enable_audio_streaming(&self) -> bool {
        self.enable_audio_streaming.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_audio_streaming(&mut self, v: bool) {
        self.enable_audio_streaming = ::std::option::Option::Some(v);
    }

    // optional bool enable_input_streaming = 11;

    pub fn enable_input_streaming(&self) -> bool {
        self.enable_input_streaming.unwrap_or(true)
    }

    pub fn clear_enable_input_streaming(&mut self) {
        self.enable_input_streaming = ::std::option::Option::None;
    }

    pub fn has_enable_input_streaming(&self) -> bool {
        self.enable_input_streaming.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_input_streaming(&mut self, v: bool) {
        self.enable_input_streaming = ::std::option::Option::Some(v);
    }

    // optional bool network_test = 12;

    pub fn network_test(&self) -> bool {
        self.network_test.unwrap_or(false)
    }

    pub fn clear_network_test(&mut self) {
        self.network_test = ::std::option::Option::None;
    }

    pub fn has_network_test(&self) -> bool {
        self.network_test.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_test(&mut self, v: bool) {
        self.network_test = ::std::option::Option::Some(v);
    }

    // optional uint64 client_id = 13;

    pub fn client_id(&self) -> u64 {
        self.client_id.unwrap_or(0)
    }

    pub fn clear_client_id(&mut self) {
        self.client_id = ::std::option::Option::None;
    }

    pub fn has_client_id(&self) -> bool {
        self.client_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_id(&mut self, v: u64) {
        self.client_id = ::std::option::Option::Some(v);
    }

    // optional bool restricted = 15;

    pub fn restricted(&self) -> bool {
        self.restricted.unwrap_or(false)
    }

    pub fn clear_restricted(&mut self) {
        self.restricted = ::std::option::Option::None;
    }

    pub fn has_restricted(&self) -> bool {
        self.restricted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_restricted(&mut self, v: bool) {
        self.restricted = ::std::option::Option::Some(v);
    }

    // optional .EStreamDeviceFormFactor form_factor = 16;

    pub fn form_factor(&self) -> EStreamDeviceFormFactor {
        match self.form_factor {
            Some(e) => e.enum_value_or(EStreamDeviceFormFactor::k_EStreamDeviceFormFactorUnknown),
            None => EStreamDeviceFormFactor::k_EStreamDeviceFormFactorUnknown,
        }
    }

    pub fn clear_form_factor(&mut self) {
        self.form_factor = ::std::option::Option::None;
    }

    pub fn has_form_factor(&self) -> bool {
        self.form_factor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_form_factor(&mut self, v: EStreamDeviceFormFactor) {
        self.form_factor = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 gamepad_count = 17;

    pub fn gamepad_count(&self) -> i32 {
        self.gamepad_count.unwrap_or(0)
    }

    pub fn clear_gamepad_count(&mut self) {
        self.gamepad_count = ::std::option::Option::None;
    }

    pub fn has_gamepad_count(&self) -> bool {
        self.gamepad_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gamepad_count(&mut self, v: i32) {
        self.gamepad_count = ::std::option::Option::Some(v);
    }

    // optional uint64 gameid = 19;

    pub fn gameid(&self) -> u64 {
        self.gameid.unwrap_or(0)
    }

    pub fn clear_gameid(&mut self) {
        self.gameid = ::std::option::Option::None;
    }

    pub fn has_gameid(&self) -> bool {
        self.gameid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameid(&mut self, v: u64) {
        self.gameid = ::std::option::Option::Some(v);
    }

    // optional .EStreamInterface stream_interface = 20;

    pub fn stream_interface(&self) -> EStreamInterface {
        match self.stream_interface {
            Some(e) => e.enum_value_or(EStreamInterface::k_EStreamInterfaceDefault),
            None => EStreamInterface::k_EStreamInterfaceDefault,
        }
    }

    pub fn clear_stream_interface(&mut self) {
        self.stream_interface = ::std::option::Option::None;
    }

    pub fn has_stream_interface(&self) -> bool {
        self.stream_interface.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stream_interface(&mut self, v: EStreamInterface) {
        self.stream_interface = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::protobuf::Message for CMsgRemoteDeviceStreamingRequest {
    const NAME: &'static str = "CMsgRemoteDeviceStreamingRequest";

    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        for v in &self.gamepads {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.request_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.maximum_resolution_x = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.maximum_resolution_y = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.audio_channel_count = ::std::option::Option::Some(is.read_int32()?);
                },
                42 => {
                    self.device_version = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.stream_desktop = ::std::option::Option::Some(is.read_bool()?);
                },
                58 => {
                    self.device_token = ::std::option::Option::Some(is.read_bytes()?);
                },
                66 => {
                    self.pin = ::std::option::Option::Some(is.read_bytes()?);
                },
                72 => {
                    self.enable_video_streaming = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.enable_audio_streaming = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.enable_input_streaming = ::std::option::Option::Some(is.read_bool()?);
                },
                96 => {
                    self.network_test = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.client_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                112 => {
                    self.supported_transport.push(is.read_enum_or_unknown()?);
                },
                114 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.supported_transport)?
                },
                120 => {
                    self.restricted = ::std::option::Option::Some(is.read_bool()?);
                },
                128 => {
                    self.form_factor = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                136 => {
                    self.gamepad_count = ::std::option::Option::Some(is.read_int32()?);
                },
                146 => {
                    self.gamepads.push(is.read_message()?);
                },
                152 => {
                    self.gameid = ::std::option::Option::Some(is.read_uint64()?);
                },
                160 => {
                    self.stream_interface = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.maximum_resolution_x {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.maximum_resolution_y {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.audio_channel_count {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.device_version.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.stream_desktop {
            my_size += 1 + 1;
        }
        if let Some(v) = self.device_token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.pin.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.enable_video_streaming {
            my_size += 1 + 1;
        }
        if let Some(v) = self.enable_audio_streaming {
            my_size += 1 + 1;
        }
        if let Some(v) = self.enable_input_streaming {
            my_size += 1 + 1;
        }
        if let Some(v) = self.network_test {
            my_size += 1 + 1;
        }
        if let Some(v) = self.client_id {
            my_size += ::protobuf::rt::uint64_size(13, v);
        }
        for value in &self.supported_transport {
            my_size += ::protobuf::rt::int32_size(14, value.value());
        };
        if let Some(v) = self.restricted {
            my_size += 1 + 1;
        }
        if let Some(v) = self.form_factor {
            my_size += ::protobuf::rt::int32_size(16, v.value());
        }
        if let Some(v) = self.gamepad_count {
            my_size += ::protobuf::rt::int32_size(17, v);
        }
        for value in &self.gamepads {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.gameid {
            my_size += ::protobuf::rt::uint64_size(19, v);
        }
        if let Some(v) = self.stream_interface {
            my_size += ::protobuf::rt::int32_size(20, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.request_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.maximum_resolution_x {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.maximum_resolution_y {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.audio_channel_count {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.device_version.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.stream_desktop {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.device_token.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.pin.as_ref() {
            os.write_bytes(8, v)?;
        }
        if let Some(v) = self.enable_video_streaming {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.enable_audio_streaming {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.enable_input_streaming {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.network_test {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.client_id {
            os.write_uint64(13, v)?;
        }
        for v in &self.supported_transport {
            os.write_enum(14, ::protobuf::EnumOrUnknown::value(v))?;
        };
        if let Some(v) = self.restricted {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.form_factor {
            os.write_enum(16, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.gamepad_count {
            os.write_int32(17, v)?;
        }
        for v in &self.gamepads {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        };
        if let Some(v) = self.gameid {
            os.write_uint64(19, v)?;
        }
        if let Some(v) = self.stream_interface {
            os.write_enum(20, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRemoteDeviceStreamingRequest {
        CMsgRemoteDeviceStreamingRequest::new()
    }

    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.maximum_resolution_x = ::std::option::Option::None;
        self.maximum_resolution_y = ::std::option::Option::None;
        self.audio_channel_count = ::std::option::Option::None;
        self.device_version = ::std::option::Option::None;
        self.stream_desktop = ::std::option::Option::None;
        self.device_token = ::std::option::Option::None;
        self.pin = ::std::option::Option::None;
        self.enable_video_streaming = ::std::option::Option::None;
        self.enable_audio_streaming = ::std::option::Option::None;
        self.enable_input_streaming = ::std::option::Option::None;
        self.network_test = ::std::option::Option::None;
        self.client_id = ::std::option::Option::None;
        self.supported_transport.clear();
        self.restricted = ::std::option::Option::None;
        self.form_factor = ::std::option::Option::None;
        self.gamepad_count = ::std::option::Option::None;
        self.gamepads.clear();
        self.gameid = ::std::option::Option::None;
        self.stream_interface = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRemoteDeviceStreamingRequest {
        static instance: CMsgRemoteDeviceStreamingRequest = CMsgRemoteDeviceStreamingRequest {
            request_id: ::std::option::Option::None,
            maximum_resolution_x: ::std::option::Option::None,
            maximum_resolution_y: ::std::option::Option::None,
            audio_channel_count: ::std::option::Option::None,
            device_version: ::std::option::Option::None,
            stream_desktop: ::std::option::Option::None,
            device_token: ::std::option::Option::None,
            pin: ::std::option::Option::None,
            enable_video_streaming: ::std::option::Option::None,
            enable_audio_streaming: ::std::option::Option::None,
            enable_input_streaming: ::std::option::Option::None,
            network_test: ::std::option::Option::None,
            client_id: ::std::option::Option::None,
            supported_transport: ::std::vec::Vec::new(),
            restricted: ::std::option::Option::None,
            form_factor: ::std::option::Option::None,
            gamepad_count: ::std::option::Option::None,
            gamepads: ::std::vec::Vec::new(),
            gameid: ::std::option::Option::None,
            stream_interface: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgRemoteDeviceStreamingRequest`
pub mod cmsg_remote_device_streaming_request {
    // @@protoc_insertion_point(message:CMsgRemoteDeviceStreamingRequest.ReservedGamepad)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ReservedGamepad {
        // message fields
        // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.ReservedGamepad.controller_type)
        pub controller_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.ReservedGamepad.controller_subtype)
        pub controller_subtype: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgRemoteDeviceStreamingRequest.ReservedGamepad.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ReservedGamepad {
        fn default() -> &'a ReservedGamepad {
            <ReservedGamepad as ::protobuf::Message>::default_instance()
        }
    }

    impl ReservedGamepad {
        pub fn new() -> ReservedGamepad {
            ::std::default::Default::default()
        }

        // optional uint32 controller_type = 1;

        pub fn controller_type(&self) -> u32 {
            self.controller_type.unwrap_or(0)
        }

        pub fn clear_controller_type(&mut self) {
            self.controller_type = ::std::option::Option::None;
        }

        pub fn has_controller_type(&self) -> bool {
            self.controller_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_controller_type(&mut self, v: u32) {
            self.controller_type = ::std::option::Option::Some(v);
        }

        // optional uint32 controller_subtype = 2;

        pub fn controller_subtype(&self) -> u32 {
            self.controller_subtype.unwrap_or(0)
        }

        pub fn clear_controller_subtype(&mut self) {
            self.controller_subtype = ::std::option::Option::None;
        }

        pub fn has_controller_subtype(&self) -> bool {
            self.controller_subtype.is_some()
        }

        // Param is passed by value, moved
        pub fn set_controller_subtype(&mut self, v: u32) {
            self.controller_subtype = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for ReservedGamepad {
        const NAME: &'static str = "ReservedGamepad";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.controller_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.controller_subtype = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.controller_type {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.controller_subtype {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.controller_type {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.controller_subtype {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ReservedGamepad {
            ReservedGamepad::new()
        }

        fn clear(&mut self) {
            self.controller_type = ::std::option::Option::None;
            self.controller_subtype = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ReservedGamepad {
            static instance: ReservedGamepad = ReservedGamepad {
                controller_type: ::std::option::Option::None,
                controller_subtype: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgRemoteDeviceStreamingCancelRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRemoteDeviceStreamingCancelRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingCancelRequest.request_id)
    pub request_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRemoteDeviceStreamingCancelRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceStreamingCancelRequest {
    fn default() -> &'a CMsgRemoteDeviceStreamingCancelRequest {
        <CMsgRemoteDeviceStreamingCancelRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceStreamingCancelRequest {
    pub fn new() -> CMsgRemoteDeviceStreamingCancelRequest {
        ::std::default::Default::default()
    }

    // required uint32 request_id = 1;

    pub fn request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgRemoteDeviceStreamingCancelRequest {
    const NAME: &'static str = "CMsgRemoteDeviceStreamingCancelRequest";

    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.request_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.request_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRemoteDeviceStreamingCancelRequest {
        CMsgRemoteDeviceStreamingCancelRequest::new()
    }

    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRemoteDeviceStreamingCancelRequest {
        static instance: CMsgRemoteDeviceStreamingCancelRequest = CMsgRemoteDeviceStreamingCancelRequest {
            request_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgRemoteDeviceStreamingProgress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRemoteDeviceStreamingProgress {
    // message fields
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingProgress.request_id)
    pub request_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingProgress.progress)
    pub progress: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRemoteDeviceStreamingProgress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceStreamingProgress {
    fn default() -> &'a CMsgRemoteDeviceStreamingProgress {
        <CMsgRemoteDeviceStreamingProgress as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceStreamingProgress {
    pub fn new() -> CMsgRemoteDeviceStreamingProgress {
        ::std::default::Default::default()
    }

    // required uint32 request_id = 1;

    pub fn request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional float progress = 2;

    pub fn progress(&self) -> f32 {
        self.progress.unwrap_or(0.)
    }

    pub fn clear_progress(&mut self) {
        self.progress = ::std::option::Option::None;
    }

    pub fn has_progress(&self) -> bool {
        self.progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_progress(&mut self, v: f32) {
        self.progress = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgRemoteDeviceStreamingProgress {
    const NAME: &'static str = "CMsgRemoteDeviceStreamingProgress";

    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.request_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.progress = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.progress {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.request_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.progress {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRemoteDeviceStreamingProgress {
        CMsgRemoteDeviceStreamingProgress::new()
    }

    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.progress = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRemoteDeviceStreamingProgress {
        static instance: CMsgRemoteDeviceStreamingProgress = CMsgRemoteDeviceStreamingProgress {
            request_id: ::std::option::Option::None,
            progress: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgRemoteDeviceStreamingResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRemoteDeviceStreamingResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingResponse.request_id)
    pub request_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<ERemoteDeviceStreamingResult>>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingResponse.port)
    pub port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingResponse.encrypted_session_key)
    pub encrypted_session_key: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingResponse.transport)
    pub transport: ::std::option::Option<::protobuf::EnumOrUnknown<EStreamTransport>>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingResponse.relay_server)
    pub relay_server: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingResponse.cert)
    pub cert: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRemoteDeviceStreamingResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceStreamingResponse {
    fn default() -> &'a CMsgRemoteDeviceStreamingResponse {
        <CMsgRemoteDeviceStreamingResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceStreamingResponse {
    pub fn new() -> CMsgRemoteDeviceStreamingResponse {
        ::std::default::Default::default()
    }

    // required uint32 request_id = 1;

    pub fn request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // required .ERemoteDeviceStreamingResult result = 2;

    pub fn result(&self) -> ERemoteDeviceStreamingResult {
        match self.result {
            Some(e) => e.enum_value_or(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingSuccess),
            None => ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingSuccess,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: ERemoteDeviceStreamingResult) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 port = 3;

    pub fn port(&self) -> u32 {
        self.port.unwrap_or(0)
    }

    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = ::std::option::Option::Some(v);
    }

    // optional bytes encrypted_session_key = 4;

    pub fn encrypted_session_key(&self) -> &[u8] {
        match self.encrypted_session_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_encrypted_session_key(&mut self) {
        self.encrypted_session_key = ::std::option::Option::None;
    }

    pub fn has_encrypted_session_key(&self) -> bool {
        self.encrypted_session_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encrypted_session_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.encrypted_session_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encrypted_session_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.encrypted_session_key.is_none() {
            self.encrypted_session_key = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.encrypted_session_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_encrypted_session_key(&mut self) -> ::std::vec::Vec<u8> {
        self.encrypted_session_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .EStreamTransport transport = 6;

    pub fn transport(&self) -> EStreamTransport {
        match self.transport {
            Some(e) => e.enum_value_or(EStreamTransport::k_EStreamTransportUDP),
            None => EStreamTransport::k_EStreamTransportUDP,
        }
    }

    pub fn clear_transport(&mut self) {
        self.transport = ::std::option::Option::None;
    }

    pub fn has_transport(&self) -> bool {
        self.transport.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transport(&mut self, v: EStreamTransport) {
        self.transport = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string relay_server = 7;

    pub fn relay_server(&self) -> &str {
        match self.relay_server.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_relay_server(&mut self) {
        self.relay_server = ::std::option::Option::None;
    }

    pub fn has_relay_server(&self) -> bool {
        self.relay_server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relay_server(&mut self, v: ::std::string::String) {
        self.relay_server = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_relay_server(&mut self) -> &mut ::std::string::String {
        if self.relay_server.is_none() {
            self.relay_server = ::std::option::Option::Some(::std::string::String::new());
        }
        self.relay_server.as_mut().unwrap()
    }

    // Take field
    pub fn take_relay_server(&mut self) -> ::std::string::String {
        self.relay_server.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string cert = 8;

    pub fn cert(&self) -> &str {
        match self.cert.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_cert(&mut self) {
        self.cert = ::std::option::Option::None;
    }

    pub fn has_cert(&self) -> bool {
        self.cert.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cert(&mut self, v: ::std::string::String) {
        self.cert = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cert(&mut self) -> &mut ::std::string::String {
        if self.cert.is_none() {
            self.cert = ::std::option::Option::Some(::std::string::String::new());
        }
        self.cert.as_mut().unwrap()
    }

    // Take field
    pub fn take_cert(&mut self) -> ::std::string::String {
        self.cert.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgRemoteDeviceStreamingResponse {
    const NAME: &'static str = "CMsgRemoteDeviceStreamingResponse";

    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.request_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.port = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.encrypted_session_key = ::std::option::Option::Some(is.read_bytes()?);
                },
                48 => {
                    self.transport = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                58 => {
                    self.relay_server = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.cert = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.port {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.encrypted_session_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.transport {
            my_size += ::protobuf::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.relay_server.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.cert.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.request_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.result {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.port {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.encrypted_session_key.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.transport {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.relay_server.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.cert.as_ref() {
            os.write_string(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRemoteDeviceStreamingResponse {
        CMsgRemoteDeviceStreamingResponse::new()
    }

    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.port = ::std::option::Option::None;
        self.encrypted_session_key = ::std::option::Option::None;
        self.transport = ::std::option::Option::None;
        self.relay_server = ::std::option::Option::None;
        self.cert = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRemoteDeviceStreamingResponse {
        static instance: CMsgRemoteDeviceStreamingResponse = CMsgRemoteDeviceStreamingResponse {
            request_id: ::std::option::Option::None,
            result: ::std::option::Option::None,
            port: ::std::option::Option::None,
            encrypted_session_key: ::std::option::Option::None,
            transport: ::std::option::Option::None,
            relay_server: ::std::option::Option::None,
            cert: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgRemoteDeviceProofRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRemoteDeviceProofRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgRemoteDeviceProofRequest.challenge)
    pub challenge: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceProofRequest.request_id)
    pub request_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceProofRequest.update_secret)
    pub update_secret: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRemoteDeviceProofRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceProofRequest {
    fn default() -> &'a CMsgRemoteDeviceProofRequest {
        <CMsgRemoteDeviceProofRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceProofRequest {
    pub fn new() -> CMsgRemoteDeviceProofRequest {
        ::std::default::Default::default()
    }

    // required bytes challenge = 1;

    pub fn challenge(&self) -> &[u8] {
        match self.challenge.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_challenge(&mut self) {
        self.challenge = ::std::option::Option::None;
    }

    pub fn has_challenge(&self) -> bool {
        self.challenge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge(&mut self, v: ::std::vec::Vec<u8>) {
        self.challenge = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_challenge(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.challenge.is_none() {
            self.challenge = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.challenge.as_mut().unwrap()
    }

    // Take field
    pub fn take_challenge(&mut self) -> ::std::vec::Vec<u8> {
        self.challenge.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 request_id = 2;

    pub fn request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional bool update_secret = 3;

    pub fn update_secret(&self) -> bool {
        self.update_secret.unwrap_or(false)
    }

    pub fn clear_update_secret(&mut self) {
        self.update_secret = ::std::option::Option::None;
    }

    pub fn has_update_secret(&self) -> bool {
        self.update_secret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_secret(&mut self, v: bool) {
        self.update_secret = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgRemoteDeviceProofRequest {
    const NAME: &'static str = "CMsgRemoteDeviceProofRequest";

    fn is_initialized(&self) -> bool {
        if self.challenge.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.challenge = ::std::option::Option::Some(is.read_bytes()?);
                },
                16 => {
                    self.request_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.update_secret = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.challenge.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.update_secret {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.challenge.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.request_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.update_secret {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRemoteDeviceProofRequest {
        CMsgRemoteDeviceProofRequest::new()
    }

    fn clear(&mut self) {
        self.challenge = ::std::option::Option::None;
        self.request_id = ::std::option::Option::None;
        self.update_secret = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRemoteDeviceProofRequest {
        static instance: CMsgRemoteDeviceProofRequest = CMsgRemoteDeviceProofRequest {
            challenge: ::std::option::Option::None,
            request_id: ::std::option::Option::None,
            update_secret: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgRemoteDeviceProofResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRemoteDeviceProofResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgRemoteDeviceProofResponse.response)
    pub response: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceProofResponse.request_id)
    pub request_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceProofResponse.updated_secret)
    pub updated_secret: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRemoteDeviceProofResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceProofResponse {
    fn default() -> &'a CMsgRemoteDeviceProofResponse {
        <CMsgRemoteDeviceProofResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceProofResponse {
    pub fn new() -> CMsgRemoteDeviceProofResponse {
        ::std::default::Default::default()
    }

    // required bytes response = 1;

    pub fn response(&self) -> &[u8] {
        match self.response.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: ::std::vec::Vec<u8>) {
        self.response = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_response(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.response.is_none() {
            self.response = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.response.as_mut().unwrap()
    }

    // Take field
    pub fn take_response(&mut self) -> ::std::vec::Vec<u8> {
        self.response.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 request_id = 2;

    pub fn request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional bool updated_secret = 3;

    pub fn updated_secret(&self) -> bool {
        self.updated_secret.unwrap_or(false)
    }

    pub fn clear_updated_secret(&mut self) {
        self.updated_secret = ::std::option::Option::None;
    }

    pub fn has_updated_secret(&self) -> bool {
        self.updated_secret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updated_secret(&mut self, v: bool) {
        self.updated_secret = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgRemoteDeviceProofResponse {
    const NAME: &'static str = "CMsgRemoteDeviceProofResponse";

    fn is_initialized(&self) -> bool {
        if self.response.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.response = ::std::option::Option::Some(is.read_bytes()?);
                },
                16 => {
                    self.request_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.updated_secret = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.updated_secret {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.response.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.request_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.updated_secret {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRemoteDeviceProofResponse {
        CMsgRemoteDeviceProofResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.request_id = ::std::option::Option::None;
        self.updated_secret = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRemoteDeviceProofResponse {
        static instance: CMsgRemoteDeviceProofResponse = CMsgRemoteDeviceProofResponse {
            response: ::std::option::Option::None,
            request_id: ::std::option::Option::None,
            updated_secret: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgRemoteDeviceStreamTransportSignal)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRemoteDeviceStreamTransportSignal {
    // message fields
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamTransportSignal.token)
    pub token: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamTransportSignal.payload)
    pub payload: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRemoteDeviceStreamTransportSignal.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceStreamTransportSignal {
    fn default() -> &'a CMsgRemoteDeviceStreamTransportSignal {
        <CMsgRemoteDeviceStreamTransportSignal as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceStreamTransportSignal {
    pub fn new() -> CMsgRemoteDeviceStreamTransportSignal {
        ::std::default::Default::default()
    }

    // optional bytes token = 1;

    pub fn token(&self) -> &[u8] {
        match self.token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.token.is_none() {
            self.token = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::vec::Vec<u8> {
        self.token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes payload = 2;

    pub fn payload(&self) -> &[u8] {
        match self.payload.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_payload(&mut self) {
        self.payload = ::std::option::Option::None;
    }

    pub fn has_payload(&self) -> bool {
        self.payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.payload.is_none() {
            self.payload = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        self.payload.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgRemoteDeviceStreamTransportSignal {
    const NAME: &'static str = "CMsgRemoteDeviceStreamTransportSignal";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.token = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.payload = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.payload.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.token.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.payload.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRemoteDeviceStreamTransportSignal {
        CMsgRemoteDeviceStreamTransportSignal::new()
    }

    fn clear(&mut self) {
        self.token = ::std::option::Option::None;
        self.payload = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRemoteDeviceStreamTransportSignal {
        static instance: CMsgRemoteDeviceStreamTransportSignal = CMsgRemoteDeviceStreamTransportSignal {
            token: ::std::option::Option::None,
            payload: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ERemoteClientBroadcastMsg)
pub enum ERemoteClientBroadcastMsg {
    // @@protoc_insertion_point(enum_value:ERemoteClientBroadcastMsg.k_ERemoteClientBroadcastMsgDiscovery)
    k_ERemoteClientBroadcastMsgDiscovery = 0,
    // @@protoc_insertion_point(enum_value:ERemoteClientBroadcastMsg.k_ERemoteClientBroadcastMsgStatus)
    k_ERemoteClientBroadcastMsgStatus = 1,
    // @@protoc_insertion_point(enum_value:ERemoteClientBroadcastMsg.k_ERemoteClientBroadcastMsgOffline)
    k_ERemoteClientBroadcastMsgOffline = 2,
    // @@protoc_insertion_point(enum_value:ERemoteClientBroadcastMsg.k_ERemoteDeviceAuthorizationRequest)
    k_ERemoteDeviceAuthorizationRequest = 3,
    // @@protoc_insertion_point(enum_value:ERemoteClientBroadcastMsg.k_ERemoteDeviceAuthorizationResponse)
    k_ERemoteDeviceAuthorizationResponse = 4,
    // @@protoc_insertion_point(enum_value:ERemoteClientBroadcastMsg.k_ERemoteDeviceStreamingRequest)
    k_ERemoteDeviceStreamingRequest = 5,
    // @@protoc_insertion_point(enum_value:ERemoteClientBroadcastMsg.k_ERemoteDeviceStreamingResponse)
    k_ERemoteDeviceStreamingResponse = 6,
    // @@protoc_insertion_point(enum_value:ERemoteClientBroadcastMsg.k_ERemoteDeviceProofRequest)
    k_ERemoteDeviceProofRequest = 7,
    // @@protoc_insertion_point(enum_value:ERemoteClientBroadcastMsg.k_ERemoteDeviceProofResponse)
    k_ERemoteDeviceProofResponse = 8,
    // @@protoc_insertion_point(enum_value:ERemoteClientBroadcastMsg.k_ERemoteDeviceAuthorizationCancelRequest)
    k_ERemoteDeviceAuthorizationCancelRequest = 9,
    // @@protoc_insertion_point(enum_value:ERemoteClientBroadcastMsg.k_ERemoteDeviceStreamingCancelRequest)
    k_ERemoteDeviceStreamingCancelRequest = 10,
    // @@protoc_insertion_point(enum_value:ERemoteClientBroadcastMsg.k_ERemoteClientBroadcastMsgClientIDDeconflict)
    k_ERemoteClientBroadcastMsgClientIDDeconflict = 11,
    // @@protoc_insertion_point(enum_value:ERemoteClientBroadcastMsg.k_ERemoteDeviceStreamTransportSignal)
    k_ERemoteDeviceStreamTransportSignal = 12,
    // @@protoc_insertion_point(enum_value:ERemoteClientBroadcastMsg.k_ERemoteDeviceStreamingProgress)
    k_ERemoteDeviceStreamingProgress = 13,
    // @@protoc_insertion_point(enum_value:ERemoteClientBroadcastMsg.k_ERemoteDeviceAuthorizationConfirmed)
    k_ERemoteDeviceAuthorizationConfirmed = 14,
}

impl ::protobuf::Enum for ERemoteClientBroadcastMsg {
    const NAME: &'static str = "ERemoteClientBroadcastMsg";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ERemoteClientBroadcastMsg> {
        match value {
            0 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgDiscovery),
            1 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgStatus),
            2 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgOffline),
            3 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceAuthorizationRequest),
            4 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceAuthorizationResponse),
            5 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingRequest),
            6 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingResponse),
            7 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceProofRequest),
            8 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceProofResponse),
            9 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceAuthorizationCancelRequest),
            10 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingCancelRequest),
            11 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgClientIDDeconflict),
            12 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamTransportSignal),
            13 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingProgress),
            14 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceAuthorizationConfirmed),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ERemoteClientBroadcastMsg> {
        match str {
            "k_ERemoteClientBroadcastMsgDiscovery" => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgDiscovery),
            "k_ERemoteClientBroadcastMsgStatus" => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgStatus),
            "k_ERemoteClientBroadcastMsgOffline" => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgOffline),
            "k_ERemoteDeviceAuthorizationRequest" => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceAuthorizationRequest),
            "k_ERemoteDeviceAuthorizationResponse" => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceAuthorizationResponse),
            "k_ERemoteDeviceStreamingRequest" => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingRequest),
            "k_ERemoteDeviceStreamingResponse" => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingResponse),
            "k_ERemoteDeviceProofRequest" => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceProofRequest),
            "k_ERemoteDeviceProofResponse" => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceProofResponse),
            "k_ERemoteDeviceAuthorizationCancelRequest" => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceAuthorizationCancelRequest),
            "k_ERemoteDeviceStreamingCancelRequest" => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingCancelRequest),
            "k_ERemoteClientBroadcastMsgClientIDDeconflict" => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgClientIDDeconflict),
            "k_ERemoteDeviceStreamTransportSignal" => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamTransportSignal),
            "k_ERemoteDeviceStreamingProgress" => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingProgress),
            "k_ERemoteDeviceAuthorizationConfirmed" => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceAuthorizationConfirmed),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ERemoteClientBroadcastMsg] = &[
        ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgDiscovery,
        ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgStatus,
        ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgOffline,
        ERemoteClientBroadcastMsg::k_ERemoteDeviceAuthorizationRequest,
        ERemoteClientBroadcastMsg::k_ERemoteDeviceAuthorizationResponse,
        ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingRequest,
        ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingResponse,
        ERemoteClientBroadcastMsg::k_ERemoteDeviceProofRequest,
        ERemoteClientBroadcastMsg::k_ERemoteDeviceProofResponse,
        ERemoteClientBroadcastMsg::k_ERemoteDeviceAuthorizationCancelRequest,
        ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingCancelRequest,
        ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgClientIDDeconflict,
        ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamTransportSignal,
        ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingProgress,
        ERemoteClientBroadcastMsg::k_ERemoteDeviceAuthorizationConfirmed,
    ];
}

impl ::std::default::Default for ERemoteClientBroadcastMsg {
    fn default() -> Self {
        ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgDiscovery
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ERemoteClientService)
pub enum ERemoteClientService {
    // @@protoc_insertion_point(enum_value:ERemoteClientService.k_ERemoteClientServiceNone)
    k_ERemoteClientServiceNone = 0,
    // @@protoc_insertion_point(enum_value:ERemoteClientService.k_ERemoteClientServiceRemoteControl)
    k_ERemoteClientServiceRemoteControl = 1,
    // @@protoc_insertion_point(enum_value:ERemoteClientService.k_ERemoteClientServiceGameStreaming)
    k_ERemoteClientServiceGameStreaming = 2,
    // @@protoc_insertion_point(enum_value:ERemoteClientService.k_ERemoteClientServiceSiteLicense)
    k_ERemoteClientServiceSiteLicense = 4,
    // @@protoc_insertion_point(enum_value:ERemoteClientService.k_ERemoteClientServiceContentCache)
    k_ERemoteClientServiceContentCache = 8,
    // @@protoc_insertion_point(enum_value:ERemoteClientService.k_ERemoteClientServiceContentServer)
    k_ERemoteClientServiceContentServer = 16,
}

impl ::protobuf::Enum for ERemoteClientService {
    const NAME: &'static str = "ERemoteClientService";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ERemoteClientService> {
        match value {
            0 => ::std::option::Option::Some(ERemoteClientService::k_ERemoteClientServiceNone),
            1 => ::std::option::Option::Some(ERemoteClientService::k_ERemoteClientServiceRemoteControl),
            2 => ::std::option::Option::Some(ERemoteClientService::k_ERemoteClientServiceGameStreaming),
            4 => ::std::option::Option::Some(ERemoteClientService::k_ERemoteClientServiceSiteLicense),
            8 => ::std::option::Option::Some(ERemoteClientService::k_ERemoteClientServiceContentCache),
            16 => ::std::option::Option::Some(ERemoteClientService::k_ERemoteClientServiceContentServer),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ERemoteClientService> {
        match str {
            "k_ERemoteClientServiceNone" => ::std::option::Option::Some(ERemoteClientService::k_ERemoteClientServiceNone),
            "k_ERemoteClientServiceRemoteControl" => ::std::option::Option::Some(ERemoteClientService::k_ERemoteClientServiceRemoteControl),
            "k_ERemoteClientServiceGameStreaming" => ::std::option::Option::Some(ERemoteClientService::k_ERemoteClientServiceGameStreaming),
            "k_ERemoteClientServiceSiteLicense" => ::std::option::Option::Some(ERemoteClientService::k_ERemoteClientServiceSiteLicense),
            "k_ERemoteClientServiceContentCache" => ::std::option::Option::Some(ERemoteClientService::k_ERemoteClientServiceContentCache),
            "k_ERemoteClientServiceContentServer" => ::std::option::Option::Some(ERemoteClientService::k_ERemoteClientServiceContentServer),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ERemoteClientService] = &[
        ERemoteClientService::k_ERemoteClientServiceNone,
        ERemoteClientService::k_ERemoteClientServiceRemoteControl,
        ERemoteClientService::k_ERemoteClientServiceGameStreaming,
        ERemoteClientService::k_ERemoteClientServiceSiteLicense,
        ERemoteClientService::k_ERemoteClientServiceContentCache,
        ERemoteClientService::k_ERemoteClientServiceContentServer,
    ];
}

impl ::std::default::Default for ERemoteClientService {
    fn default() -> Self {
        ERemoteClientService::k_ERemoteClientServiceNone
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ERemoteDeviceAuthorizationResult)
pub enum ERemoteDeviceAuthorizationResult {
    // @@protoc_insertion_point(enum_value:ERemoteDeviceAuthorizationResult.k_ERemoteDeviceAuthorizationSuccess)
    k_ERemoteDeviceAuthorizationSuccess = 0,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceAuthorizationResult.k_ERemoteDeviceAuthorizationDenied)
    k_ERemoteDeviceAuthorizationDenied = 1,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceAuthorizationResult.k_ERemoteDeviceAuthorizationNotLoggedIn)
    k_ERemoteDeviceAuthorizationNotLoggedIn = 2,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceAuthorizationResult.k_ERemoteDeviceAuthorizationOffline)
    k_ERemoteDeviceAuthorizationOffline = 3,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceAuthorizationResult.k_ERemoteDeviceAuthorizationBusy)
    k_ERemoteDeviceAuthorizationBusy = 4,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceAuthorizationResult.k_ERemoteDeviceAuthorizationInProgress)
    k_ERemoteDeviceAuthorizationInProgress = 5,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceAuthorizationResult.k_ERemoteDeviceAuthorizationTimedOut)
    k_ERemoteDeviceAuthorizationTimedOut = 6,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceAuthorizationResult.k_ERemoteDeviceAuthorizationFailed)
    k_ERemoteDeviceAuthorizationFailed = 7,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceAuthorizationResult.k_ERemoteDeviceAuthorizationCanceled)
    k_ERemoteDeviceAuthorizationCanceled = 8,
}

impl ::protobuf::Enum for ERemoteDeviceAuthorizationResult {
    const NAME: &'static str = "ERemoteDeviceAuthorizationResult";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ERemoteDeviceAuthorizationResult> {
        match value {
            0 => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationSuccess),
            1 => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationDenied),
            2 => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationNotLoggedIn),
            3 => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationOffline),
            4 => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationBusy),
            5 => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationInProgress),
            6 => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationTimedOut),
            7 => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationFailed),
            8 => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationCanceled),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ERemoteDeviceAuthorizationResult> {
        match str {
            "k_ERemoteDeviceAuthorizationSuccess" => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationSuccess),
            "k_ERemoteDeviceAuthorizationDenied" => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationDenied),
            "k_ERemoteDeviceAuthorizationNotLoggedIn" => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationNotLoggedIn),
            "k_ERemoteDeviceAuthorizationOffline" => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationOffline),
            "k_ERemoteDeviceAuthorizationBusy" => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationBusy),
            "k_ERemoteDeviceAuthorizationInProgress" => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationInProgress),
            "k_ERemoteDeviceAuthorizationTimedOut" => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationTimedOut),
            "k_ERemoteDeviceAuthorizationFailed" => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationFailed),
            "k_ERemoteDeviceAuthorizationCanceled" => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationCanceled),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ERemoteDeviceAuthorizationResult] = &[
        ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationSuccess,
        ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationDenied,
        ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationNotLoggedIn,
        ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationOffline,
        ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationBusy,
        ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationInProgress,
        ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationTimedOut,
        ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationFailed,
        ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationCanceled,
    ];
}

impl ::std::default::Default for ERemoteDeviceAuthorizationResult {
    fn default() -> Self {
        ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationSuccess
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamDeviceFormFactor)
pub enum EStreamDeviceFormFactor {
    // @@protoc_insertion_point(enum_value:EStreamDeviceFormFactor.k_EStreamDeviceFormFactorUnknown)
    k_EStreamDeviceFormFactorUnknown = 0,
    // @@protoc_insertion_point(enum_value:EStreamDeviceFormFactor.k_EStreamDeviceFormFactorPhone)
    k_EStreamDeviceFormFactorPhone = 1,
    // @@protoc_insertion_point(enum_value:EStreamDeviceFormFactor.k_EStreamDeviceFormFactorTablet)
    k_EStreamDeviceFormFactorTablet = 2,
    // @@protoc_insertion_point(enum_value:EStreamDeviceFormFactor.k_EStreamDeviceFormFactorComputer)
    k_EStreamDeviceFormFactorComputer = 3,
    // @@protoc_insertion_point(enum_value:EStreamDeviceFormFactor.k_EStreamDeviceFormFactorTV)
    k_EStreamDeviceFormFactorTV = 4,
}

impl ::protobuf::Enum for EStreamDeviceFormFactor {
    const NAME: &'static str = "EStreamDeviceFormFactor";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamDeviceFormFactor> {
        match value {
            0 => ::std::option::Option::Some(EStreamDeviceFormFactor::k_EStreamDeviceFormFactorUnknown),
            1 => ::std::option::Option::Some(EStreamDeviceFormFactor::k_EStreamDeviceFormFactorPhone),
            2 => ::std::option::Option::Some(EStreamDeviceFormFactor::k_EStreamDeviceFormFactorTablet),
            3 => ::std::option::Option::Some(EStreamDeviceFormFactor::k_EStreamDeviceFormFactorComputer),
            4 => ::std::option::Option::Some(EStreamDeviceFormFactor::k_EStreamDeviceFormFactorTV),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamDeviceFormFactor> {
        match str {
            "k_EStreamDeviceFormFactorUnknown" => ::std::option::Option::Some(EStreamDeviceFormFactor::k_EStreamDeviceFormFactorUnknown),
            "k_EStreamDeviceFormFactorPhone" => ::std::option::Option::Some(EStreamDeviceFormFactor::k_EStreamDeviceFormFactorPhone),
            "k_EStreamDeviceFormFactorTablet" => ::std::option::Option::Some(EStreamDeviceFormFactor::k_EStreamDeviceFormFactorTablet),
            "k_EStreamDeviceFormFactorComputer" => ::std::option::Option::Some(EStreamDeviceFormFactor::k_EStreamDeviceFormFactorComputer),
            "k_EStreamDeviceFormFactorTV" => ::std::option::Option::Some(EStreamDeviceFormFactor::k_EStreamDeviceFormFactorTV),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamDeviceFormFactor] = &[
        EStreamDeviceFormFactor::k_EStreamDeviceFormFactorUnknown,
        EStreamDeviceFormFactor::k_EStreamDeviceFormFactorPhone,
        EStreamDeviceFormFactor::k_EStreamDeviceFormFactorTablet,
        EStreamDeviceFormFactor::k_EStreamDeviceFormFactorComputer,
        EStreamDeviceFormFactor::k_EStreamDeviceFormFactorTV,
    ];
}

impl ::std::default::Default for EStreamDeviceFormFactor {
    fn default() -> Self {
        EStreamDeviceFormFactor::k_EStreamDeviceFormFactorUnknown
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamTransport)
pub enum EStreamTransport {
    // @@protoc_insertion_point(enum_value:EStreamTransport.k_EStreamTransportNone)
    k_EStreamTransportNone = 0,
    // @@protoc_insertion_point(enum_value:EStreamTransport.k_EStreamTransportUDP)
    k_EStreamTransportUDP = 1,
    // @@protoc_insertion_point(enum_value:EStreamTransport.k_EStreamTransportUDPRelay)
    k_EStreamTransportUDPRelay = 2,
    // @@protoc_insertion_point(enum_value:EStreamTransport.k_EStreamTransportWebRTC)
    k_EStreamTransportWebRTC = 3,
    // @@protoc_insertion_point(enum_value:EStreamTransport.k_EStreamTransportSDR)
    k_EStreamTransportSDR = 4,
    // @@protoc_insertion_point(enum_value:EStreamTransport.k_EStreamTransportUDP_SNS)
    k_EStreamTransportUDP_SNS = 5,
    // @@protoc_insertion_point(enum_value:EStreamTransport.k_EStreamTransportUDPRelay_SNS)
    k_EStreamTransportUDPRelay_SNS = 6,
}

impl ::protobuf::Enum for EStreamTransport {
    const NAME: &'static str = "EStreamTransport";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamTransport> {
        match value {
            0 => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportNone),
            1 => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportUDP),
            2 => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportUDPRelay),
            3 => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportWebRTC),
            4 => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportSDR),
            5 => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportUDP_SNS),
            6 => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportUDPRelay_SNS),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamTransport> {
        match str {
            "k_EStreamTransportNone" => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportNone),
            "k_EStreamTransportUDP" => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportUDP),
            "k_EStreamTransportUDPRelay" => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportUDPRelay),
            "k_EStreamTransportWebRTC" => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportWebRTC),
            "k_EStreamTransportSDR" => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportSDR),
            "k_EStreamTransportUDP_SNS" => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportUDP_SNS),
            "k_EStreamTransportUDPRelay_SNS" => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportUDPRelay_SNS),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamTransport] = &[
        EStreamTransport::k_EStreamTransportNone,
        EStreamTransport::k_EStreamTransportUDP,
        EStreamTransport::k_EStreamTransportUDPRelay,
        EStreamTransport::k_EStreamTransportWebRTC,
        EStreamTransport::k_EStreamTransportSDR,
        EStreamTransport::k_EStreamTransportUDP_SNS,
        EStreamTransport::k_EStreamTransportUDPRelay_SNS,
    ];
}

impl ::std::default::Default for EStreamTransport {
    fn default() -> Self {
        EStreamTransport::k_EStreamTransportNone
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamInterface)
pub enum EStreamInterface {
    // @@protoc_insertion_point(enum_value:EStreamInterface.k_EStreamInterfaceDefault)
    k_EStreamInterfaceDefault = 0,
    // @@protoc_insertion_point(enum_value:EStreamInterface.k_EStreamInterfaceRecentGames)
    k_EStreamInterfaceRecentGames = 1,
    // @@protoc_insertion_point(enum_value:EStreamInterface.k_EStreamInterfaceBigPicture)
    k_EStreamInterfaceBigPicture = 2,
    // @@protoc_insertion_point(enum_value:EStreamInterface.k_EStreamInterfaceDesktop)
    k_EStreamInterfaceDesktop = 3,
}

impl ::protobuf::Enum for EStreamInterface {
    const NAME: &'static str = "EStreamInterface";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamInterface> {
        match value {
            0 => ::std::option::Option::Some(EStreamInterface::k_EStreamInterfaceDefault),
            1 => ::std::option::Option::Some(EStreamInterface::k_EStreamInterfaceRecentGames),
            2 => ::std::option::Option::Some(EStreamInterface::k_EStreamInterfaceBigPicture),
            3 => ::std::option::Option::Some(EStreamInterface::k_EStreamInterfaceDesktop),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamInterface> {
        match str {
            "k_EStreamInterfaceDefault" => ::std::option::Option::Some(EStreamInterface::k_EStreamInterfaceDefault),
            "k_EStreamInterfaceRecentGames" => ::std::option::Option::Some(EStreamInterface::k_EStreamInterfaceRecentGames),
            "k_EStreamInterfaceBigPicture" => ::std::option::Option::Some(EStreamInterface::k_EStreamInterfaceBigPicture),
            "k_EStreamInterfaceDesktop" => ::std::option::Option::Some(EStreamInterface::k_EStreamInterfaceDesktop),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamInterface] = &[
        EStreamInterface::k_EStreamInterfaceDefault,
        EStreamInterface::k_EStreamInterfaceRecentGames,
        EStreamInterface::k_EStreamInterfaceBigPicture,
        EStreamInterface::k_EStreamInterfaceDesktop,
    ];
}

impl ::std::default::Default for EStreamInterface {
    fn default() -> Self {
        EStreamInterface::k_EStreamInterfaceDefault
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ERemoteDeviceStreamingResult)
pub enum ERemoteDeviceStreamingResult {
    // @@protoc_insertion_point(enum_value:ERemoteDeviceStreamingResult.k_ERemoteDeviceStreamingSuccess)
    k_ERemoteDeviceStreamingSuccess = 0,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceStreamingResult.k_ERemoteDeviceStreamingUnauthorized)
    k_ERemoteDeviceStreamingUnauthorized = 1,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceStreamingResult.k_ERemoteDeviceStreamingScreenLocked)
    k_ERemoteDeviceStreamingScreenLocked = 2,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceStreamingResult.k_ERemoteDeviceStreamingFailed)
    k_ERemoteDeviceStreamingFailed = 3,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceStreamingResult.k_ERemoteDeviceStreamingBusy)
    k_ERemoteDeviceStreamingBusy = 4,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceStreamingResult.k_ERemoteDeviceStreamingInProgress)
    k_ERemoteDeviceStreamingInProgress = 5,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceStreamingResult.k_ERemoteDeviceStreamingCanceled)
    k_ERemoteDeviceStreamingCanceled = 6,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceStreamingResult.k_ERemoteDeviceStreamingDriversNotInstalled)
    k_ERemoteDeviceStreamingDriversNotInstalled = 7,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceStreamingResult.k_ERemoteDeviceStreamingDisabled)
    k_ERemoteDeviceStreamingDisabled = 8,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceStreamingResult.k_ERemoteDeviceStreamingBroadcastingActive)
    k_ERemoteDeviceStreamingBroadcastingActive = 9,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceStreamingResult.k_ERemoteDeviceStreamingVRActive)
    k_ERemoteDeviceStreamingVRActive = 10,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceStreamingResult.k_ERemoteDeviceStreamingPINRequired)
    k_ERemoteDeviceStreamingPINRequired = 11,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceStreamingResult.k_ERemoteDeviceStreamingTransportUnavailable)
    k_ERemoteDeviceStreamingTransportUnavailable = 12,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceStreamingResult.k_ERemoteDeviceStreamingInvisible)
    k_ERemoteDeviceStreamingInvisible = 13,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceStreamingResult.k_ERemoteDeviceStreamingGameLaunchFailed)
    k_ERemoteDeviceStreamingGameLaunchFailed = 14,
}

impl ::protobuf::Enum for ERemoteDeviceStreamingResult {
    const NAME: &'static str = "ERemoteDeviceStreamingResult";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ERemoteDeviceStreamingResult> {
        match value {
            0 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingSuccess),
            1 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingUnauthorized),
            2 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingScreenLocked),
            3 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingFailed),
            4 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingBusy),
            5 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingInProgress),
            6 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingCanceled),
            7 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingDriversNotInstalled),
            8 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingDisabled),
            9 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingBroadcastingActive),
            10 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingVRActive),
            11 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingPINRequired),
            12 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingTransportUnavailable),
            13 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingInvisible),
            14 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingGameLaunchFailed),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ERemoteDeviceStreamingResult> {
        match str {
            "k_ERemoteDeviceStreamingSuccess" => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingSuccess),
            "k_ERemoteDeviceStreamingUnauthorized" => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingUnauthorized),
            "k_ERemoteDeviceStreamingScreenLocked" => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingScreenLocked),
            "k_ERemoteDeviceStreamingFailed" => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingFailed),
            "k_ERemoteDeviceStreamingBusy" => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingBusy),
            "k_ERemoteDeviceStreamingInProgress" => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingInProgress),
            "k_ERemoteDeviceStreamingCanceled" => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingCanceled),
            "k_ERemoteDeviceStreamingDriversNotInstalled" => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingDriversNotInstalled),
            "k_ERemoteDeviceStreamingDisabled" => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingDisabled),
            "k_ERemoteDeviceStreamingBroadcastingActive" => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingBroadcastingActive),
            "k_ERemoteDeviceStreamingVRActive" => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingVRActive),
            "k_ERemoteDeviceStreamingPINRequired" => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingPINRequired),
            "k_ERemoteDeviceStreamingTransportUnavailable" => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingTransportUnavailable),
            "k_ERemoteDeviceStreamingInvisible" => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingInvisible),
            "k_ERemoteDeviceStreamingGameLaunchFailed" => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingGameLaunchFailed),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ERemoteDeviceStreamingResult] = &[
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingSuccess,
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingUnauthorized,
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingScreenLocked,
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingFailed,
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingBusy,
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingInProgress,
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingCanceled,
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingDriversNotInstalled,
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingDisabled,
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingBroadcastingActive,
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingVRActive,
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingPINRequired,
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingTransportUnavailable,
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingInvisible,
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingGameLaunchFailed,
    ];
}

impl ::std::default::Default for ERemoteDeviceStreamingResult {
    fn default() -> Self {
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingSuccess
    }
}

impl crate::RpcMessage for CMsgRemoteClientBroadcastHeader {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgRemoteClientBroadcastStatus {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgRemoteClientBroadcastDiscovery {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgRemoteClientBroadcastClientIDDeconflict {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgRemoteDeviceAuthorizationRequest {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgRemoteDeviceAuthorizationCancelRequest {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgRemoteDeviceAuthorizationResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgRemoteDeviceAuthorizationConfirmed {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgRemoteDeviceStreamingRequest {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgRemoteDeviceStreamingCancelRequest {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgRemoteDeviceStreamingProgress {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgRemoteDeviceStreamingResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgRemoteDeviceProofRequest {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgRemoteDeviceProofResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgRemoteDeviceStreamTransportSignal {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
