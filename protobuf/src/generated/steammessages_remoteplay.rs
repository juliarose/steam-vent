// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_remoteplay.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:CDiscoveryPingRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDiscoveryPingRequest {
    // message fields
    // @@protoc_insertion_point(field:CDiscoveryPingRequest.sequence)
    pub sequence: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDiscoveryPingRequest.packet_size_requested)
    pub packet_size_requested: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDiscoveryPingRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDiscoveryPingRequest {
    fn default() -> &'a CDiscoveryPingRequest {
        <CDiscoveryPingRequest as ::protobuf::Message>::default_instance()
    }
}

impl CDiscoveryPingRequest {
    pub fn new() -> CDiscoveryPingRequest {
        ::std::default::Default::default()
    }

    // optional uint32 sequence = 1;

    pub fn sequence(&self) -> u32 {
        self.sequence.unwrap_or(0)
    }

    pub fn clear_sequence(&mut self) {
        self.sequence = ::std::option::Option::None;
    }

    pub fn has_sequence(&self) -> bool {
        self.sequence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence(&mut self, v: u32) {
        self.sequence = ::std::option::Option::Some(v);
    }

    // optional uint32 packet_size_requested = 2;

    pub fn packet_size_requested(&self) -> u32 {
        self.packet_size_requested.unwrap_or(0)
    }

    pub fn clear_packet_size_requested(&mut self) {
        self.packet_size_requested = ::std::option::Option::None;
    }

    pub fn has_packet_size_requested(&self) -> bool {
        self.packet_size_requested.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packet_size_requested(&mut self, v: u32) {
        self.packet_size_requested = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CDiscoveryPingRequest {
    const NAME: &'static str = "CDiscoveryPingRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sequence = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.packet_size_requested = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.sequence {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.packet_size_requested {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.sequence {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.packet_size_requested {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDiscoveryPingRequest {
        CDiscoveryPingRequest::new()
    }

    fn clear(&mut self) {
        self.sequence = ::std::option::Option::None;
        self.packet_size_requested = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDiscoveryPingRequest {
        static instance: CDiscoveryPingRequest = CDiscoveryPingRequest {
            sequence: ::std::option::Option::None,
            packet_size_requested: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDiscoveryPingResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDiscoveryPingResponse {
    // message fields
    // @@protoc_insertion_point(field:CDiscoveryPingResponse.sequence)
    pub sequence: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDiscoveryPingResponse.packet_size_received)
    pub packet_size_received: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDiscoveryPingResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDiscoveryPingResponse {
    fn default() -> &'a CDiscoveryPingResponse {
        <CDiscoveryPingResponse as ::protobuf::Message>::default_instance()
    }
}

impl CDiscoveryPingResponse {
    pub fn new() -> CDiscoveryPingResponse {
        ::std::default::Default::default()
    }

    // optional uint32 sequence = 1;

    pub fn sequence(&self) -> u32 {
        self.sequence.unwrap_or(0)
    }

    pub fn clear_sequence(&mut self) {
        self.sequence = ::std::option::Option::None;
    }

    pub fn has_sequence(&self) -> bool {
        self.sequence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence(&mut self, v: u32) {
        self.sequence = ::std::option::Option::Some(v);
    }

    // optional uint32 packet_size_received = 2;

    pub fn packet_size_received(&self) -> u32 {
        self.packet_size_received.unwrap_or(0)
    }

    pub fn clear_packet_size_received(&mut self) {
        self.packet_size_received = ::std::option::Option::None;
    }

    pub fn has_packet_size_received(&self) -> bool {
        self.packet_size_received.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packet_size_received(&mut self, v: u32) {
        self.packet_size_received = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CDiscoveryPingResponse {
    const NAME: &'static str = "CDiscoveryPingResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sequence = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.packet_size_received = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.sequence {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.packet_size_received {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.sequence {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.packet_size_received {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDiscoveryPingResponse {
        CDiscoveryPingResponse::new()
    }

    fn clear(&mut self) {
        self.sequence = ::std::option::Option::None;
        self.packet_size_received = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDiscoveryPingResponse {
        static instance: CDiscoveryPingResponse = CDiscoveryPingResponse {
            sequence: ::std::option::Option::None,
            packet_size_received: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CStreamingClientHandshakeInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStreamingClientHandshakeInfo {
    // message fields
    // @@protoc_insertion_point(field:CStreamingClientHandshakeInfo.network_test)
    pub network_test: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CStreamingClientHandshakeInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStreamingClientHandshakeInfo {
    fn default() -> &'a CStreamingClientHandshakeInfo {
        <CStreamingClientHandshakeInfo as ::protobuf::Message>::default_instance()
    }
}

impl CStreamingClientHandshakeInfo {
    pub fn new() -> CStreamingClientHandshakeInfo {
        ::std::default::Default::default()
    }

    // optional int32 network_test = 2;

    pub fn network_test(&self) -> i32 {
        self.network_test.unwrap_or(0)
    }

    pub fn clear_network_test(&mut self) {
        self.network_test = ::std::option::Option::None;
    }

    pub fn has_network_test(&self) -> bool {
        self.network_test.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_test(&mut self, v: i32) {
        self.network_test = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CStreamingClientHandshakeInfo {
    const NAME: &'static str = "CStreamingClientHandshakeInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.network_test = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.network_test {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.network_test {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStreamingClientHandshakeInfo {
        CStreamingClientHandshakeInfo::new()
    }

    fn clear(&mut self) {
        self.network_test = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStreamingClientHandshakeInfo {
        static instance: CStreamingClientHandshakeInfo = CStreamingClientHandshakeInfo {
            network_test: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CClientHandshakeMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientHandshakeMsg {
    // message fields
    // @@protoc_insertion_point(field:CClientHandshakeMsg.info)
    pub info: ::protobuf::MessageField<CStreamingClientHandshakeInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientHandshakeMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientHandshakeMsg {
    fn default() -> &'a CClientHandshakeMsg {
        <CClientHandshakeMsg as ::protobuf::Message>::default_instance()
    }
}

impl CClientHandshakeMsg {
    pub fn new() -> CClientHandshakeMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CClientHandshakeMsg {
    const NAME: &'static str = "CClientHandshakeMsg";

    fn is_initialized(&self) -> bool {
        if self.info.is_none() {
            return false;
        }
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientHandshakeMsg {
        CClientHandshakeMsg::new()
    }

    fn clear(&mut self) {
        self.info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientHandshakeMsg {
        static instance: CClientHandshakeMsg = CClientHandshakeMsg {
            info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CStreamingServerHandshakeInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStreamingServerHandshakeInfo {
    // message fields
    // @@protoc_insertion_point(field:CStreamingServerHandshakeInfo.mtu)
    pub mtu: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CStreamingServerHandshakeInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStreamingServerHandshakeInfo {
    fn default() -> &'a CStreamingServerHandshakeInfo {
        <CStreamingServerHandshakeInfo as ::protobuf::Message>::default_instance()
    }
}

impl CStreamingServerHandshakeInfo {
    pub fn new() -> CStreamingServerHandshakeInfo {
        ::std::default::Default::default()
    }

    // optional int32 mtu = 1;

    pub fn mtu(&self) -> i32 {
        self.mtu.unwrap_or(0)
    }

    pub fn clear_mtu(&mut self) {
        self.mtu = ::std::option::Option::None;
    }

    pub fn has_mtu(&self) -> bool {
        self.mtu.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mtu(&mut self, v: i32) {
        self.mtu = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CStreamingServerHandshakeInfo {
    const NAME: &'static str = "CStreamingServerHandshakeInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.mtu = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mtu {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.mtu {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStreamingServerHandshakeInfo {
        CStreamingServerHandshakeInfo::new()
    }

    fn clear(&mut self) {
        self.mtu = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStreamingServerHandshakeInfo {
        static instance: CStreamingServerHandshakeInfo = CStreamingServerHandshakeInfo {
            mtu: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CServerHandshakeMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CServerHandshakeMsg {
    // message fields
    // @@protoc_insertion_point(field:CServerHandshakeMsg.info)
    pub info: ::protobuf::MessageField<CStreamingServerHandshakeInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CServerHandshakeMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CServerHandshakeMsg {
    fn default() -> &'a CServerHandshakeMsg {
        <CServerHandshakeMsg as ::protobuf::Message>::default_instance()
    }
}

impl CServerHandshakeMsg {
    pub fn new() -> CServerHandshakeMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CServerHandshakeMsg {
    const NAME: &'static str = "CServerHandshakeMsg";

    fn is_initialized(&self) -> bool {
        if self.info.is_none() {
            return false;
        }
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CServerHandshakeMsg {
        CServerHandshakeMsg::new()
    }

    fn clear(&mut self) {
        self.info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CServerHandshakeMsg {
        static instance: CServerHandshakeMsg = CServerHandshakeMsg {
            info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CAuthenticationRequestMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CAuthenticationRequestMsg {
    // message fields
    // @@protoc_insertion_point(field:CAuthenticationRequestMsg.token)
    pub token: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CAuthenticationRequestMsg.version)
    pub version: ::std::option::Option<::protobuf::EnumOrUnknown<EStreamVersion>>,
    // @@protoc_insertion_point(field:CAuthenticationRequestMsg.steamid)
    pub steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CAuthenticationRequestMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CAuthenticationRequestMsg {
    fn default() -> &'a CAuthenticationRequestMsg {
        <CAuthenticationRequestMsg as ::protobuf::Message>::default_instance()
    }
}

impl CAuthenticationRequestMsg {
    pub fn new() -> CAuthenticationRequestMsg {
        ::std::default::Default::default()
    }

    // optional bytes token = 1;

    pub fn token(&self) -> &[u8] {
        match self.token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.token.is_none() {
            self.token = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::vec::Vec<u8> {
        self.token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .EStreamVersion version = 2;

    pub fn version(&self) -> EStreamVersion {
        match self.version {
            Some(e) => e.enum_value_or(EStreamVersion::k_EStreamVersionNone),
            None => EStreamVersion::k_EStreamVersionNone,
        }
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: EStreamVersion) {
        self.version = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 steamid = 3;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CAuthenticationRequestMsg {
    const NAME: &'static str = "CAuthenticationRequestMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.token = ::std::option::Option::Some(is.read_bytes()?);
                },
                16 => {
                    self.version = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.steamid = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.steamid {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.token.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.version {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.steamid {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CAuthenticationRequestMsg {
        CAuthenticationRequestMsg::new()
    }

    fn clear(&mut self) {
        self.token = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CAuthenticationRequestMsg {
        static instance: CAuthenticationRequestMsg = CAuthenticationRequestMsg {
            token: ::std::option::Option::None,
            version: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CAuthenticationResponseMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CAuthenticationResponseMsg {
    // message fields
    // @@protoc_insertion_point(field:CAuthenticationResponseMsg.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<cauthentication_response_msg::AuthenticationResult>>,
    // @@protoc_insertion_point(field:CAuthenticationResponseMsg.version)
    pub version: ::std::option::Option<::protobuf::EnumOrUnknown<EStreamVersion>>,
    // special fields
    // @@protoc_insertion_point(special_field:CAuthenticationResponseMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CAuthenticationResponseMsg {
    fn default() -> &'a CAuthenticationResponseMsg {
        <CAuthenticationResponseMsg as ::protobuf::Message>::default_instance()
    }
}

impl CAuthenticationResponseMsg {
    pub fn new() -> CAuthenticationResponseMsg {
        ::std::default::Default::default()
    }

    // optional .CAuthenticationResponseMsg.AuthenticationResult result = 1;

    pub fn result(&self) -> cauthentication_response_msg::AuthenticationResult {
        match self.result {
            Some(e) => e.enum_value_or(cauthentication_response_msg::AuthenticationResult::SUCCEEDED),
            None => cauthentication_response_msg::AuthenticationResult::SUCCEEDED,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cauthentication_response_msg::AuthenticationResult) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .EStreamVersion version = 2;

    pub fn version(&self) -> EStreamVersion {
        match self.version {
            Some(e) => e.enum_value_or(EStreamVersion::k_EStreamVersionNone),
            None => EStreamVersion::k_EStreamVersionNone,
        }
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: EStreamVersion) {
        self.version = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::protobuf::Message for CAuthenticationResponseMsg {
    const NAME: &'static str = "CAuthenticationResponseMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.version = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.version {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CAuthenticationResponseMsg {
        CAuthenticationResponseMsg::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CAuthenticationResponseMsg {
        static instance: CAuthenticationResponseMsg = CAuthenticationResponseMsg {
            result: ::std::option::Option::None,
            version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CAuthenticationResponseMsg`
pub mod cauthentication_response_msg {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CAuthenticationResponseMsg.AuthenticationResult)
    pub enum AuthenticationResult {
        // @@protoc_insertion_point(enum_value:CAuthenticationResponseMsg.AuthenticationResult.SUCCEEDED)
        SUCCEEDED = 0,
        // @@protoc_insertion_point(enum_value:CAuthenticationResponseMsg.AuthenticationResult.FAILED)
        FAILED = 1,
    }

    impl ::protobuf::Enum for AuthenticationResult {
        const NAME: &'static str = "AuthenticationResult";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<AuthenticationResult> {
            match value {
                0 => ::std::option::Option::Some(AuthenticationResult::SUCCEEDED),
                1 => ::std::option::Option::Some(AuthenticationResult::FAILED),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<AuthenticationResult> {
            match str {
                "SUCCEEDED" => ::std::option::Option::Some(AuthenticationResult::SUCCEEDED),
                "FAILED" => ::std::option::Option::Some(AuthenticationResult::FAILED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [AuthenticationResult] = &[
            AuthenticationResult::SUCCEEDED,
            AuthenticationResult::FAILED,
        ];
    }

    impl ::std::default::Default for AuthenticationResult {
        fn default() -> Self {
            AuthenticationResult::SUCCEEDED
        }
    }

}

// @@protoc_insertion_point(message:CKeepAliveMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CKeepAliveMsg {
    // special fields
    // @@protoc_insertion_point(special_field:CKeepAliveMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CKeepAliveMsg {
    fn default() -> &'a CKeepAliveMsg {
        <CKeepAliveMsg as ::protobuf::Message>::default_instance()
    }
}

impl CKeepAliveMsg {
    pub fn new() -> CKeepAliveMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CKeepAliveMsg {
    const NAME: &'static str = "CKeepAliveMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CKeepAliveMsg {
        CKeepAliveMsg::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CKeepAliveMsg {
        static instance: CKeepAliveMsg = CKeepAliveMsg {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CStartNetworkTestMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStartNetworkTestMsg {
    // message fields
    // @@protoc_insertion_point(field:CStartNetworkTestMsg.frames)
    pub frames: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStartNetworkTestMsg.framerate)
    pub framerate: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStartNetworkTestMsg.bitrate_kbps)
    pub bitrate_kbps: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStartNetworkTestMsg.burst_bitrate_kbps)
    pub burst_bitrate_kbps: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStartNetworkTestMsg.bandwidth_test)
    pub bandwidth_test: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CStartNetworkTestMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStartNetworkTestMsg {
    fn default() -> &'a CStartNetworkTestMsg {
        <CStartNetworkTestMsg as ::protobuf::Message>::default_instance()
    }
}

impl CStartNetworkTestMsg {
    pub fn new() -> CStartNetworkTestMsg {
        ::std::default::Default::default()
    }

    // optional uint32 frames = 1;

    pub fn frames(&self) -> u32 {
        self.frames.unwrap_or(0)
    }

    pub fn clear_frames(&mut self) {
        self.frames = ::std::option::Option::None;
    }

    pub fn has_frames(&self) -> bool {
        self.frames.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frames(&mut self, v: u32) {
        self.frames = ::std::option::Option::Some(v);
    }

    // optional uint32 framerate = 2;

    pub fn framerate(&self) -> u32 {
        self.framerate.unwrap_or(0)
    }

    pub fn clear_framerate(&mut self) {
        self.framerate = ::std::option::Option::None;
    }

    pub fn has_framerate(&self) -> bool {
        self.framerate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_framerate(&mut self, v: u32) {
        self.framerate = ::std::option::Option::Some(v);
    }

    // optional uint32 bitrate_kbps = 3;

    pub fn bitrate_kbps(&self) -> u32 {
        self.bitrate_kbps.unwrap_or(0)
    }

    pub fn clear_bitrate_kbps(&mut self) {
        self.bitrate_kbps = ::std::option::Option::None;
    }

    pub fn has_bitrate_kbps(&self) -> bool {
        self.bitrate_kbps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bitrate_kbps(&mut self, v: u32) {
        self.bitrate_kbps = ::std::option::Option::Some(v);
    }

    // optional uint32 burst_bitrate_kbps = 4;

    pub fn burst_bitrate_kbps(&self) -> u32 {
        self.burst_bitrate_kbps.unwrap_or(0)
    }

    pub fn clear_burst_bitrate_kbps(&mut self) {
        self.burst_bitrate_kbps = ::std::option::Option::None;
    }

    pub fn has_burst_bitrate_kbps(&self) -> bool {
        self.burst_bitrate_kbps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_burst_bitrate_kbps(&mut self, v: u32) {
        self.burst_bitrate_kbps = ::std::option::Option::Some(v);
    }

    // optional bool bandwidth_test = 5;

    pub fn bandwidth_test(&self) -> bool {
        self.bandwidth_test.unwrap_or(false)
    }

    pub fn clear_bandwidth_test(&mut self) {
        self.bandwidth_test = ::std::option::Option::None;
    }

    pub fn has_bandwidth_test(&self) -> bool {
        self.bandwidth_test.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bandwidth_test(&mut self, v: bool) {
        self.bandwidth_test = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CStartNetworkTestMsg {
    const NAME: &'static str = "CStartNetworkTestMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.frames = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.framerate = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.bitrate_kbps = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.burst_bitrate_kbps = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.bandwidth_test = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.frames {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.framerate {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.bitrate_kbps {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.burst_bitrate_kbps {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.bandwidth_test {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.frames {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.framerate {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.bitrate_kbps {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.burst_bitrate_kbps {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.bandwidth_test {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStartNetworkTestMsg {
        CStartNetworkTestMsg::new()
    }

    fn clear(&mut self) {
        self.frames = ::std::option::Option::None;
        self.framerate = ::std::option::Option::None;
        self.bitrate_kbps = ::std::option::Option::None;
        self.burst_bitrate_kbps = ::std::option::Option::None;
        self.bandwidth_test = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStartNetworkTestMsg {
        static instance: CStartNetworkTestMsg = CStartNetworkTestMsg {
            frames: ::std::option::Option::None,
            framerate: ::std::option::Option::None,
            bitrate_kbps: ::std::option::Option::None,
            burst_bitrate_kbps: ::std::option::Option::None,
            bandwidth_test: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CStreamVideoMode)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStreamVideoMode {
    // message fields
    // @@protoc_insertion_point(field:CStreamVideoMode.width)
    pub width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStreamVideoMode.height)
    pub height: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStreamVideoMode.refresh_rate)
    pub refresh_rate: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStreamVideoMode.refresh_rate_numerator)
    pub refresh_rate_numerator: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStreamVideoMode.refresh_rate_denominator)
    pub refresh_rate_denominator: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CStreamVideoMode.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStreamVideoMode {
    fn default() -> &'a CStreamVideoMode {
        <CStreamVideoMode as ::protobuf::Message>::default_instance()
    }
}

impl CStreamVideoMode {
    pub fn new() -> CStreamVideoMode {
        ::std::default::Default::default()
    }

    // required uint32 width = 1;

    pub fn width(&self) -> u32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // required uint32 height = 2;

    pub fn height(&self) -> u32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional uint32 refresh_rate = 3;

    pub fn refresh_rate(&self) -> u32 {
        self.refresh_rate.unwrap_or(0)
    }

    pub fn clear_refresh_rate(&mut self) {
        self.refresh_rate = ::std::option::Option::None;
    }

    pub fn has_refresh_rate(&self) -> bool {
        self.refresh_rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_refresh_rate(&mut self, v: u32) {
        self.refresh_rate = ::std::option::Option::Some(v);
    }

    // optional uint32 refresh_rate_numerator = 4;

    pub fn refresh_rate_numerator(&self) -> u32 {
        self.refresh_rate_numerator.unwrap_or(0)
    }

    pub fn clear_refresh_rate_numerator(&mut self) {
        self.refresh_rate_numerator = ::std::option::Option::None;
    }

    pub fn has_refresh_rate_numerator(&self) -> bool {
        self.refresh_rate_numerator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_refresh_rate_numerator(&mut self, v: u32) {
        self.refresh_rate_numerator = ::std::option::Option::Some(v);
    }

    // optional uint32 refresh_rate_denominator = 5;

    pub fn refresh_rate_denominator(&self) -> u32 {
        self.refresh_rate_denominator.unwrap_or(0)
    }

    pub fn clear_refresh_rate_denominator(&mut self) {
        self.refresh_rate_denominator = ::std::option::Option::None;
    }

    pub fn has_refresh_rate_denominator(&self) -> bool {
        self.refresh_rate_denominator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_refresh_rate_denominator(&mut self, v: u32) {
        self.refresh_rate_denominator = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CStreamVideoMode {
    const NAME: &'static str = "CStreamVideoMode";

    fn is_initialized(&self) -> bool {
        if self.width.is_none() {
            return false;
        }
        if self.height.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.width = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.height = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.refresh_rate = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.refresh_rate_numerator = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.refresh_rate_denominator = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.refresh_rate {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.refresh_rate_numerator {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.refresh_rate_denominator {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.width {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.refresh_rate {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.refresh_rate_numerator {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.refresh_rate_denominator {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStreamVideoMode {
        CStreamVideoMode::new()
    }

    fn clear(&mut self) {
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.refresh_rate = ::std::option::Option::None;
        self.refresh_rate_numerator = ::std::option::Option::None;
        self.refresh_rate_denominator = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStreamVideoMode {
        static instance: CStreamVideoMode = CStreamVideoMode {
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            refresh_rate: ::std::option::Option::None,
            refresh_rate_numerator: ::std::option::Option::None,
            refresh_rate_denominator: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CStreamingClientCaps)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStreamingClientCaps {
    // message fields
    // @@protoc_insertion_point(field:CStreamingClientCaps.system_info)
    pub system_info: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CStreamingClientCaps.system_can_suspend)
    pub system_can_suspend: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingClientCaps.maximum_decode_bitrate_kbps)
    pub maximum_decode_bitrate_kbps: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CStreamingClientCaps.maximum_burst_bitrate_kbps)
    pub maximum_burst_bitrate_kbps: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CStreamingClientCaps.supports_video_hevc)
    pub supports_video_hevc: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingClientCaps.disable_steam_store)
    pub disable_steam_store: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingClientCaps.disable_client_cursor)
    pub disable_client_cursor: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingClientCaps.disable_intel_hardware_encoding)
    pub disable_intel_hardware_encoding: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingClientCaps.disable_amd_hardware_encoding)
    pub disable_amd_hardware_encoding: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingClientCaps.disable_nvidia_hardware_encoding)
    pub disable_nvidia_hardware_encoding: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingClientCaps.form_factor)
    pub form_factor: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CStreamingClientCaps.has_on_screen_keyboard)
    pub has_on_screen_keyboard: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingClientCaps.supported_colorspaces)
    pub supported_colorspaces: ::std::vec::Vec<::protobuf::EnumOrUnknown<EStreamColorspace>>,
    // special fields
    // @@protoc_insertion_point(special_field:CStreamingClientCaps.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStreamingClientCaps {
    fn default() -> &'a CStreamingClientCaps {
        <CStreamingClientCaps as ::protobuf::Message>::default_instance()
    }
}

impl CStreamingClientCaps {
    pub fn new() -> CStreamingClientCaps {
        ::std::default::Default::default()
    }

    // optional string system_info = 1;

    pub fn system_info(&self) -> &str {
        match self.system_info.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_system_info(&mut self) {
        self.system_info = ::std::option::Option::None;
    }

    pub fn has_system_info(&self) -> bool {
        self.system_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_system_info(&mut self, v: ::std::string::String) {
        self.system_info = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_system_info(&mut self) -> &mut ::std::string::String {
        if self.system_info.is_none() {
            self.system_info = ::std::option::Option::Some(::std::string::String::new());
        }
        self.system_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_system_info(&mut self) -> ::std::string::String {
        self.system_info.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool system_can_suspend = 2;

    pub fn system_can_suspend(&self) -> bool {
        self.system_can_suspend.unwrap_or(false)
    }

    pub fn clear_system_can_suspend(&mut self) {
        self.system_can_suspend = ::std::option::Option::None;
    }

    pub fn has_system_can_suspend(&self) -> bool {
        self.system_can_suspend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_system_can_suspend(&mut self, v: bool) {
        self.system_can_suspend = ::std::option::Option::Some(v);
    }

    // optional int32 maximum_decode_bitrate_kbps = 3;

    pub fn maximum_decode_bitrate_kbps(&self) -> i32 {
        self.maximum_decode_bitrate_kbps.unwrap_or(0)
    }

    pub fn clear_maximum_decode_bitrate_kbps(&mut self) {
        self.maximum_decode_bitrate_kbps = ::std::option::Option::None;
    }

    pub fn has_maximum_decode_bitrate_kbps(&self) -> bool {
        self.maximum_decode_bitrate_kbps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum_decode_bitrate_kbps(&mut self, v: i32) {
        self.maximum_decode_bitrate_kbps = ::std::option::Option::Some(v);
    }

    // optional int32 maximum_burst_bitrate_kbps = 4;

    pub fn maximum_burst_bitrate_kbps(&self) -> i32 {
        self.maximum_burst_bitrate_kbps.unwrap_or(0)
    }

    pub fn clear_maximum_burst_bitrate_kbps(&mut self) {
        self.maximum_burst_bitrate_kbps = ::std::option::Option::None;
    }

    pub fn has_maximum_burst_bitrate_kbps(&self) -> bool {
        self.maximum_burst_bitrate_kbps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum_burst_bitrate_kbps(&mut self, v: i32) {
        self.maximum_burst_bitrate_kbps = ::std::option::Option::Some(v);
    }

    // optional bool supports_video_hevc = 5;

    pub fn supports_video_hevc(&self) -> bool {
        self.supports_video_hevc.unwrap_or(false)
    }

    pub fn clear_supports_video_hevc(&mut self) {
        self.supports_video_hevc = ::std::option::Option::None;
    }

    pub fn has_supports_video_hevc(&self) -> bool {
        self.supports_video_hevc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_supports_video_hevc(&mut self, v: bool) {
        self.supports_video_hevc = ::std::option::Option::Some(v);
    }

    // optional bool disable_steam_store = 6;

    pub fn disable_steam_store(&self) -> bool {
        self.disable_steam_store.unwrap_or(false)
    }

    pub fn clear_disable_steam_store(&mut self) {
        self.disable_steam_store = ::std::option::Option::None;
    }

    pub fn has_disable_steam_store(&self) -> bool {
        self.disable_steam_store.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable_steam_store(&mut self, v: bool) {
        self.disable_steam_store = ::std::option::Option::Some(v);
    }

    // optional bool disable_client_cursor = 7;

    pub fn disable_client_cursor(&self) -> bool {
        self.disable_client_cursor.unwrap_or(false)
    }

    pub fn clear_disable_client_cursor(&mut self) {
        self.disable_client_cursor = ::std::option::Option::None;
    }

    pub fn has_disable_client_cursor(&self) -> bool {
        self.disable_client_cursor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable_client_cursor(&mut self, v: bool) {
        self.disable_client_cursor = ::std::option::Option::Some(v);
    }

    // optional bool disable_intel_hardware_encoding = 8;

    pub fn disable_intel_hardware_encoding(&self) -> bool {
        self.disable_intel_hardware_encoding.unwrap_or(false)
    }

    pub fn clear_disable_intel_hardware_encoding(&mut self) {
        self.disable_intel_hardware_encoding = ::std::option::Option::None;
    }

    pub fn has_disable_intel_hardware_encoding(&self) -> bool {
        self.disable_intel_hardware_encoding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable_intel_hardware_encoding(&mut self, v: bool) {
        self.disable_intel_hardware_encoding = ::std::option::Option::Some(v);
    }

    // optional bool disable_amd_hardware_encoding = 9;

    pub fn disable_amd_hardware_encoding(&self) -> bool {
        self.disable_amd_hardware_encoding.unwrap_or(false)
    }

    pub fn clear_disable_amd_hardware_encoding(&mut self) {
        self.disable_amd_hardware_encoding = ::std::option::Option::None;
    }

    pub fn has_disable_amd_hardware_encoding(&self) -> bool {
        self.disable_amd_hardware_encoding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable_amd_hardware_encoding(&mut self, v: bool) {
        self.disable_amd_hardware_encoding = ::std::option::Option::Some(v);
    }

    // optional bool disable_nvidia_hardware_encoding = 10;

    pub fn disable_nvidia_hardware_encoding(&self) -> bool {
        self.disable_nvidia_hardware_encoding.unwrap_or(false)
    }

    pub fn clear_disable_nvidia_hardware_encoding(&mut self) {
        self.disable_nvidia_hardware_encoding = ::std::option::Option::None;
    }

    pub fn has_disable_nvidia_hardware_encoding(&self) -> bool {
        self.disable_nvidia_hardware_encoding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable_nvidia_hardware_encoding(&mut self, v: bool) {
        self.disable_nvidia_hardware_encoding = ::std::option::Option::Some(v);
    }

    // optional int32 form_factor = 11;

    pub fn form_factor(&self) -> i32 {
        self.form_factor.unwrap_or(0)
    }

    pub fn clear_form_factor(&mut self) {
        self.form_factor = ::std::option::Option::None;
    }

    pub fn has_form_factor(&self) -> bool {
        self.form_factor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_form_factor(&mut self, v: i32) {
        self.form_factor = ::std::option::Option::Some(v);
    }

    // optional bool has_on_screen_keyboard = 12;

    pub fn has_on_screen_keyboard(&self) -> bool {
        self.has_on_screen_keyboard.unwrap_or(false)
    }

    pub fn clear_has_on_screen_keyboard(&mut self) {
        self.has_on_screen_keyboard = ::std::option::Option::None;
    }

    pub fn has_has_on_screen_keyboard(&self) -> bool {
        self.has_on_screen_keyboard.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_on_screen_keyboard(&mut self, v: bool) {
        self.has_on_screen_keyboard = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CStreamingClientCaps {
    const NAME: &'static str = "CStreamingClientCaps";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.system_info = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.system_can_suspend = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.maximum_decode_bitrate_kbps = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.maximum_burst_bitrate_kbps = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.supports_video_hevc = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.disable_steam_store = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.disable_client_cursor = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.disable_intel_hardware_encoding = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.disable_amd_hardware_encoding = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.disable_nvidia_hardware_encoding = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.form_factor = ::std::option::Option::Some(is.read_int32()?);
                },
                96 => {
                    self.has_on_screen_keyboard = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.supported_colorspaces.push(is.read_enum_or_unknown()?);
                },
                106 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.supported_colorspaces)?
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.system_info.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.system_can_suspend {
            my_size += 1 + 1;
        }
        if let Some(v) = self.maximum_decode_bitrate_kbps {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.maximum_burst_bitrate_kbps {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.supports_video_hevc {
            my_size += 1 + 1;
        }
        if let Some(v) = self.disable_steam_store {
            my_size += 1 + 1;
        }
        if let Some(v) = self.disable_client_cursor {
            my_size += 1 + 1;
        }
        if let Some(v) = self.disable_intel_hardware_encoding {
            my_size += 1 + 1;
        }
        if let Some(v) = self.disable_amd_hardware_encoding {
            my_size += 1 + 1;
        }
        if let Some(v) = self.disable_nvidia_hardware_encoding {
            my_size += 1 + 1;
        }
        if let Some(v) = self.form_factor {
            my_size += ::protobuf::rt::int32_size(11, v);
        }
        if let Some(v) = self.has_on_screen_keyboard {
            my_size += 1 + 1;
        }
        for value in &self.supported_colorspaces {
            my_size += ::protobuf::rt::int32_size(13, value.value());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.system_info.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.system_can_suspend {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.maximum_decode_bitrate_kbps {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.maximum_burst_bitrate_kbps {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.supports_video_hevc {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.disable_steam_store {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.disable_client_cursor {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.disable_intel_hardware_encoding {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.disable_amd_hardware_encoding {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.disable_nvidia_hardware_encoding {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.form_factor {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.has_on_screen_keyboard {
            os.write_bool(12, v)?;
        }
        for v in &self.supported_colorspaces {
            os.write_enum(13, ::protobuf::EnumOrUnknown::value(v))?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStreamingClientCaps {
        CStreamingClientCaps::new()
    }

    fn clear(&mut self) {
        self.system_info = ::std::option::Option::None;
        self.system_can_suspend = ::std::option::Option::None;
        self.maximum_decode_bitrate_kbps = ::std::option::Option::None;
        self.maximum_burst_bitrate_kbps = ::std::option::Option::None;
        self.supports_video_hevc = ::std::option::Option::None;
        self.disable_steam_store = ::std::option::Option::None;
        self.disable_client_cursor = ::std::option::Option::None;
        self.disable_intel_hardware_encoding = ::std::option::Option::None;
        self.disable_amd_hardware_encoding = ::std::option::Option::None;
        self.disable_nvidia_hardware_encoding = ::std::option::Option::None;
        self.form_factor = ::std::option::Option::None;
        self.has_on_screen_keyboard = ::std::option::Option::None;
        self.supported_colorspaces.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStreamingClientCaps {
        static instance: CStreamingClientCaps = CStreamingClientCaps {
            system_info: ::std::option::Option::None,
            system_can_suspend: ::std::option::Option::None,
            maximum_decode_bitrate_kbps: ::std::option::Option::None,
            maximum_burst_bitrate_kbps: ::std::option::Option::None,
            supports_video_hevc: ::std::option::Option::None,
            disable_steam_store: ::std::option::Option::None,
            disable_client_cursor: ::std::option::Option::None,
            disable_intel_hardware_encoding: ::std::option::Option::None,
            disable_amd_hardware_encoding: ::std::option::Option::None,
            disable_nvidia_hardware_encoding: ::std::option::Option::None,
            form_factor: ::std::option::Option::None,
            has_on_screen_keyboard: ::std::option::Option::None,
            supported_colorspaces: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CStreamingClientConfig)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStreamingClientConfig {
    // message fields
    // @@protoc_insertion_point(field:CStreamingClientConfig.quality)
    pub quality: ::std::option::Option<::protobuf::EnumOrUnknown<EStreamQualityPreference>>,
    // @@protoc_insertion_point(field:CStreamingClientConfig.maximum_resolution_x)
    pub maximum_resolution_x: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStreamingClientConfig.maximum_resolution_y)
    pub maximum_resolution_y: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStreamingClientConfig.maximum_framerate_numerator)
    pub maximum_framerate_numerator: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStreamingClientConfig.maximum_framerate_denominator)
    pub maximum_framerate_denominator: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStreamingClientConfig.maximum_bitrate_kbps)
    pub maximum_bitrate_kbps: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CStreamingClientConfig.enable_hardware_decoding)
    pub enable_hardware_decoding: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingClientConfig.enable_performance_overlay)
    pub enable_performance_overlay: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingClientConfig.enable_video_streaming)
    pub enable_video_streaming: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingClientConfig.enable_audio_streaming)
    pub enable_audio_streaming: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingClientConfig.enable_input_streaming)
    pub enable_input_streaming: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingClientConfig.audio_channels)
    pub audio_channels: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CStreamingClientConfig.enable_video_hevc)
    pub enable_video_hevc: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingClientConfig.enable_performance_icons)
    pub enable_performance_icons: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingClientConfig.enable_microphone_streaming)
    pub enable_microphone_streaming: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingClientConfig.controller_overlay_hotkey)
    pub controller_overlay_hotkey: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CStreamingClientConfig.enable_touch_controller_OBSOLETE)
    pub enable_touch_controller_OBSOLETE: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingClientConfig.p2p_scope)
    pub p2p_scope: ::std::option::Option<::protobuf::EnumOrUnknown<EStreamP2PScope>>,
    // @@protoc_insertion_point(field:CStreamingClientConfig.enable_audio_uncompressed)
    pub enable_audio_uncompressed: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CStreamingClientConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStreamingClientConfig {
    fn default() -> &'a CStreamingClientConfig {
        <CStreamingClientConfig as ::protobuf::Message>::default_instance()
    }
}

impl CStreamingClientConfig {
    pub fn new() -> CStreamingClientConfig {
        ::std::default::Default::default()
    }

    // optional .EStreamQualityPreference quality = 1;

    pub fn quality(&self) -> EStreamQualityPreference {
        match self.quality {
            Some(e) => e.enum_value_or(EStreamQualityPreference::k_EStreamQualityBalanced),
            None => EStreamQualityPreference::k_EStreamQualityBalanced,
        }
    }

    pub fn clear_quality(&mut self) {
        self.quality = ::std::option::Option::None;
    }

    pub fn has_quality(&self) -> bool {
        self.quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality(&mut self, v: EStreamQualityPreference) {
        self.quality = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 maximum_resolution_x = 2;

    pub fn maximum_resolution_x(&self) -> u32 {
        self.maximum_resolution_x.unwrap_or(0)
    }

    pub fn clear_maximum_resolution_x(&mut self) {
        self.maximum_resolution_x = ::std::option::Option::None;
    }

    pub fn has_maximum_resolution_x(&self) -> bool {
        self.maximum_resolution_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum_resolution_x(&mut self, v: u32) {
        self.maximum_resolution_x = ::std::option::Option::Some(v);
    }

    // optional uint32 maximum_resolution_y = 3;

    pub fn maximum_resolution_y(&self) -> u32 {
        self.maximum_resolution_y.unwrap_or(0)
    }

    pub fn clear_maximum_resolution_y(&mut self) {
        self.maximum_resolution_y = ::std::option::Option::None;
    }

    pub fn has_maximum_resolution_y(&self) -> bool {
        self.maximum_resolution_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum_resolution_y(&mut self, v: u32) {
        self.maximum_resolution_y = ::std::option::Option::Some(v);
    }

    // optional uint32 maximum_framerate_numerator = 4;

    pub fn maximum_framerate_numerator(&self) -> u32 {
        self.maximum_framerate_numerator.unwrap_or(0)
    }

    pub fn clear_maximum_framerate_numerator(&mut self) {
        self.maximum_framerate_numerator = ::std::option::Option::None;
    }

    pub fn has_maximum_framerate_numerator(&self) -> bool {
        self.maximum_framerate_numerator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum_framerate_numerator(&mut self, v: u32) {
        self.maximum_framerate_numerator = ::std::option::Option::Some(v);
    }

    // optional uint32 maximum_framerate_denominator = 5;

    pub fn maximum_framerate_denominator(&self) -> u32 {
        self.maximum_framerate_denominator.unwrap_or(0)
    }

    pub fn clear_maximum_framerate_denominator(&mut self) {
        self.maximum_framerate_denominator = ::std::option::Option::None;
    }

    pub fn has_maximum_framerate_denominator(&self) -> bool {
        self.maximum_framerate_denominator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum_framerate_denominator(&mut self, v: u32) {
        self.maximum_framerate_denominator = ::std::option::Option::Some(v);
    }

    // optional int32 maximum_bitrate_kbps = 6;

    pub fn maximum_bitrate_kbps(&self) -> i32 {
        self.maximum_bitrate_kbps.unwrap_or(-1i32)
    }

    pub fn clear_maximum_bitrate_kbps(&mut self) {
        self.maximum_bitrate_kbps = ::std::option::Option::None;
    }

    pub fn has_maximum_bitrate_kbps(&self) -> bool {
        self.maximum_bitrate_kbps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum_bitrate_kbps(&mut self, v: i32) {
        self.maximum_bitrate_kbps = ::std::option::Option::Some(v);
    }

    // optional bool enable_hardware_decoding = 7;

    pub fn enable_hardware_decoding(&self) -> bool {
        self.enable_hardware_decoding.unwrap_or(true)
    }

    pub fn clear_enable_hardware_decoding(&mut self) {
        self.enable_hardware_decoding = ::std::option::Option::None;
    }

    pub fn has_enable_hardware_decoding(&self) -> bool {
        self.enable_hardware_decoding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_hardware_decoding(&mut self, v: bool) {
        self.enable_hardware_decoding = ::std::option::Option::Some(v);
    }

    // optional bool enable_performance_overlay = 8;

    pub fn enable_performance_overlay(&self) -> bool {
        self.enable_performance_overlay.unwrap_or(false)
    }

    pub fn clear_enable_performance_overlay(&mut self) {
        self.enable_performance_overlay = ::std::option::Option::None;
    }

    pub fn has_enable_performance_overlay(&self) -> bool {
        self.enable_performance_overlay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_performance_overlay(&mut self, v: bool) {
        self.enable_performance_overlay = ::std::option::Option::Some(v);
    }

    // optional bool enable_video_streaming = 9;

    pub fn enable_video_streaming(&self) -> bool {
        self.enable_video_streaming.unwrap_or(true)
    }

    pub fn clear_enable_video_streaming(&mut self) {
        self.enable_video_streaming = ::std::option::Option::None;
    }

    pub fn has_enable_video_streaming(&self) -> bool {
        self.enable_video_streaming.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_video_streaming(&mut self, v: bool) {
        self.enable_video_streaming = ::std::option::Option::Some(v);
    }

    // optional bool enable_audio_streaming = 10;

    pub fn enable_audio_streaming(&self) -> bool {
        self.enable_audio_streaming.unwrap_or(true)
    }

    pub fn clear_enable_audio_streaming(&mut self) {
        self.enable_audio_streaming = ::std::option::Option::None;
    }

    pub fn has_enable_audio_streaming(&self) -> bool {
        self.enable_audio_streaming.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_audio_streaming(&mut self, v: bool) {
        self.enable_audio_streaming = ::std::option::Option::Some(v);
    }

    // optional bool enable_input_streaming = 11;

    pub fn enable_input_streaming(&self) -> bool {
        self.enable_input_streaming.unwrap_or(true)
    }

    pub fn clear_enable_input_streaming(&mut self) {
        self.enable_input_streaming = ::std::option::Option::None;
    }

    pub fn has_enable_input_streaming(&self) -> bool {
        self.enable_input_streaming.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_input_streaming(&mut self, v: bool) {
        self.enable_input_streaming = ::std::option::Option::Some(v);
    }

    // optional int32 audio_channels = 12;

    pub fn audio_channels(&self) -> i32 {
        self.audio_channels.unwrap_or(2i32)
    }

    pub fn clear_audio_channels(&mut self) {
        self.audio_channels = ::std::option::Option::None;
    }

    pub fn has_audio_channels(&self) -> bool {
        self.audio_channels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_audio_channels(&mut self, v: i32) {
        self.audio_channels = ::std::option::Option::Some(v);
    }

    // optional bool enable_video_hevc = 13;

    pub fn enable_video_hevc(&self) -> bool {
        self.enable_video_hevc.unwrap_or(false)
    }

    pub fn clear_enable_video_hevc(&mut self) {
        self.enable_video_hevc = ::std::option::Option::None;
    }

    pub fn has_enable_video_hevc(&self) -> bool {
        self.enable_video_hevc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_video_hevc(&mut self, v: bool) {
        self.enable_video_hevc = ::std::option::Option::Some(v);
    }

    // optional bool enable_performance_icons = 14;

    pub fn enable_performance_icons(&self) -> bool {
        self.enable_performance_icons.unwrap_or(true)
    }

    pub fn clear_enable_performance_icons(&mut self) {
        self.enable_performance_icons = ::std::option::Option::None;
    }

    pub fn has_enable_performance_icons(&self) -> bool {
        self.enable_performance_icons.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_performance_icons(&mut self, v: bool) {
        self.enable_performance_icons = ::std::option::Option::Some(v);
    }

    // optional bool enable_microphone_streaming = 15;

    pub fn enable_microphone_streaming(&self) -> bool {
        self.enable_microphone_streaming.unwrap_or(false)
    }

    pub fn clear_enable_microphone_streaming(&mut self) {
        self.enable_microphone_streaming = ::std::option::Option::None;
    }

    pub fn has_enable_microphone_streaming(&self) -> bool {
        self.enable_microphone_streaming.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_microphone_streaming(&mut self, v: bool) {
        self.enable_microphone_streaming = ::std::option::Option::Some(v);
    }

    // optional string controller_overlay_hotkey = 16;

    pub fn controller_overlay_hotkey(&self) -> &str {
        match self.controller_overlay_hotkey.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_controller_overlay_hotkey(&mut self) {
        self.controller_overlay_hotkey = ::std::option::Option::None;
    }

    pub fn has_controller_overlay_hotkey(&self) -> bool {
        self.controller_overlay_hotkey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_overlay_hotkey(&mut self, v: ::std::string::String) {
        self.controller_overlay_hotkey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_controller_overlay_hotkey(&mut self) -> &mut ::std::string::String {
        if self.controller_overlay_hotkey.is_none() {
            self.controller_overlay_hotkey = ::std::option::Option::Some(::std::string::String::new());
        }
        self.controller_overlay_hotkey.as_mut().unwrap()
    }

    // Take field
    pub fn take_controller_overlay_hotkey(&mut self) -> ::std::string::String {
        self.controller_overlay_hotkey.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool enable_touch_controller_OBSOLETE = 17;

    pub fn enable_touch_controller_OBSOLETE(&self) -> bool {
        self.enable_touch_controller_OBSOLETE.unwrap_or(false)
    }

    pub fn clear_enable_touch_controller_OBSOLETE(&mut self) {
        self.enable_touch_controller_OBSOLETE = ::std::option::Option::None;
    }

    pub fn has_enable_touch_controller_OBSOLETE(&self) -> bool {
        self.enable_touch_controller_OBSOLETE.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_touch_controller_OBSOLETE(&mut self, v: bool) {
        self.enable_touch_controller_OBSOLETE = ::std::option::Option::Some(v);
    }

    // optional .EStreamP2PScope p2p_scope = 19;

    pub fn p2p_scope(&self) -> EStreamP2PScope {
        match self.p2p_scope {
            Some(e) => e.enum_value_or(EStreamP2PScope::k_EStreamP2PScopeAutomatic),
            None => EStreamP2PScope::k_EStreamP2PScopeAutomatic,
        }
    }

    pub fn clear_p2p_scope(&mut self) {
        self.p2p_scope = ::std::option::Option::None;
    }

    pub fn has_p2p_scope(&self) -> bool {
        self.p2p_scope.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p2p_scope(&mut self, v: EStreamP2PScope) {
        self.p2p_scope = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool enable_audio_uncompressed = 20;

    pub fn enable_audio_uncompressed(&self) -> bool {
        self.enable_audio_uncompressed.unwrap_or(false)
    }

    pub fn clear_enable_audio_uncompressed(&mut self) {
        self.enable_audio_uncompressed = ::std::option::Option::None;
    }

    pub fn has_enable_audio_uncompressed(&self) -> bool {
        self.enable_audio_uncompressed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_audio_uncompressed(&mut self, v: bool) {
        self.enable_audio_uncompressed = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CStreamingClientConfig {
    const NAME: &'static str = "CStreamingClientConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.quality = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.maximum_resolution_x = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.maximum_resolution_y = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.maximum_framerate_numerator = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.maximum_framerate_denominator = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.maximum_bitrate_kbps = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.enable_hardware_decoding = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.enable_performance_overlay = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.enable_video_streaming = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.enable_audio_streaming = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.enable_input_streaming = ::std::option::Option::Some(is.read_bool()?);
                },
                96 => {
                    self.audio_channels = ::std::option::Option::Some(is.read_int32()?);
                },
                104 => {
                    self.enable_video_hevc = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.enable_performance_icons = ::std::option::Option::Some(is.read_bool()?);
                },
                120 => {
                    self.enable_microphone_streaming = ::std::option::Option::Some(is.read_bool()?);
                },
                130 => {
                    self.controller_overlay_hotkey = ::std::option::Option::Some(is.read_string()?);
                },
                136 => {
                    self.enable_touch_controller_OBSOLETE = ::std::option::Option::Some(is.read_bool()?);
                },
                152 => {
                    self.p2p_scope = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                160 => {
                    self.enable_audio_uncompressed = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.quality {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.maximum_resolution_x {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.maximum_resolution_y {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.maximum_framerate_numerator {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.maximum_framerate_denominator {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.maximum_bitrate_kbps {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.enable_hardware_decoding {
            my_size += 1 + 1;
        }
        if let Some(v) = self.enable_performance_overlay {
            my_size += 1 + 1;
        }
        if let Some(v) = self.enable_video_streaming {
            my_size += 1 + 1;
        }
        if let Some(v) = self.enable_audio_streaming {
            my_size += 1 + 1;
        }
        if let Some(v) = self.enable_input_streaming {
            my_size += 1 + 1;
        }
        if let Some(v) = self.audio_channels {
            my_size += ::protobuf::rt::int32_size(12, v);
        }
        if let Some(v) = self.enable_video_hevc {
            my_size += 1 + 1;
        }
        if let Some(v) = self.enable_performance_icons {
            my_size += 1 + 1;
        }
        if let Some(v) = self.enable_microphone_streaming {
            my_size += 1 + 1;
        }
        if let Some(v) = self.controller_overlay_hotkey.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        if let Some(v) = self.enable_touch_controller_OBSOLETE {
            my_size += 2 + 1;
        }
        if let Some(v) = self.p2p_scope {
            my_size += ::protobuf::rt::int32_size(19, v.value());
        }
        if let Some(v) = self.enable_audio_uncompressed {
            my_size += 2 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.quality {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.maximum_resolution_x {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.maximum_resolution_y {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.maximum_framerate_numerator {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.maximum_framerate_denominator {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.maximum_bitrate_kbps {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.enable_hardware_decoding {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.enable_performance_overlay {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.enable_video_streaming {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.enable_audio_streaming {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.enable_input_streaming {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.audio_channels {
            os.write_int32(12, v)?;
        }
        if let Some(v) = self.enable_video_hevc {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.enable_performance_icons {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.enable_microphone_streaming {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.controller_overlay_hotkey.as_ref() {
            os.write_string(16, v)?;
        }
        if let Some(v) = self.enable_touch_controller_OBSOLETE {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.p2p_scope {
            os.write_enum(19, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.enable_audio_uncompressed {
            os.write_bool(20, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStreamingClientConfig {
        CStreamingClientConfig::new()
    }

    fn clear(&mut self) {
        self.quality = ::std::option::Option::None;
        self.maximum_resolution_x = ::std::option::Option::None;
        self.maximum_resolution_y = ::std::option::Option::None;
        self.maximum_framerate_numerator = ::std::option::Option::None;
        self.maximum_framerate_denominator = ::std::option::Option::None;
        self.maximum_bitrate_kbps = ::std::option::Option::None;
        self.enable_hardware_decoding = ::std::option::Option::None;
        self.enable_performance_overlay = ::std::option::Option::None;
        self.enable_video_streaming = ::std::option::Option::None;
        self.enable_audio_streaming = ::std::option::Option::None;
        self.enable_input_streaming = ::std::option::Option::None;
        self.audio_channels = ::std::option::Option::None;
        self.enable_video_hevc = ::std::option::Option::None;
        self.enable_performance_icons = ::std::option::Option::None;
        self.enable_microphone_streaming = ::std::option::Option::None;
        self.controller_overlay_hotkey = ::std::option::Option::None;
        self.enable_touch_controller_OBSOLETE = ::std::option::Option::None;
        self.p2p_scope = ::std::option::Option::None;
        self.enable_audio_uncompressed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStreamingClientConfig {
        static instance: CStreamingClientConfig = CStreamingClientConfig {
            quality: ::std::option::Option::None,
            maximum_resolution_x: ::std::option::Option::None,
            maximum_resolution_y: ::std::option::Option::None,
            maximum_framerate_numerator: ::std::option::Option::None,
            maximum_framerate_denominator: ::std::option::Option::None,
            maximum_bitrate_kbps: ::std::option::Option::None,
            enable_hardware_decoding: ::std::option::Option::None,
            enable_performance_overlay: ::std::option::Option::None,
            enable_video_streaming: ::std::option::Option::None,
            enable_audio_streaming: ::std::option::Option::None,
            enable_input_streaming: ::std::option::Option::None,
            audio_channels: ::std::option::Option::None,
            enable_video_hevc: ::std::option::Option::None,
            enable_performance_icons: ::std::option::Option::None,
            enable_microphone_streaming: ::std::option::Option::None,
            controller_overlay_hotkey: ::std::option::Option::None,
            enable_touch_controller_OBSOLETE: ::std::option::Option::None,
            p2p_scope: ::std::option::Option::None,
            enable_audio_uncompressed: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CStreamingServerConfig)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStreamingServerConfig {
    // message fields
    // @@protoc_insertion_point(field:CStreamingServerConfig.change_desktop_resolution)
    pub change_desktop_resolution: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingServerConfig.dynamically_adjust_resolution)
    pub dynamically_adjust_resolution: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingServerConfig.enable_capture_nvfbc)
    pub enable_capture_nvfbc: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingServerConfig.enable_hardware_encoding_nvidia)
    pub enable_hardware_encoding_nvidia: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingServerConfig.enable_hardware_encoding_amd)
    pub enable_hardware_encoding_amd: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingServerConfig.enable_hardware_encoding_intel)
    pub enable_hardware_encoding_intel: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingServerConfig.software_encoding_threads)
    pub software_encoding_threads: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CStreamingServerConfig.enable_traffic_priority)
    pub enable_traffic_priority: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingServerConfig.host_play_audio)
    pub host_play_audio: ::std::option::Option<::protobuf::EnumOrUnknown<EStreamHostPlayAudioPreference>>,
    // special fields
    // @@protoc_insertion_point(special_field:CStreamingServerConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStreamingServerConfig {
    fn default() -> &'a CStreamingServerConfig {
        <CStreamingServerConfig as ::protobuf::Message>::default_instance()
    }
}

impl CStreamingServerConfig {
    pub fn new() -> CStreamingServerConfig {
        ::std::default::Default::default()
    }

    // optional bool change_desktop_resolution = 1;

    pub fn change_desktop_resolution(&self) -> bool {
        self.change_desktop_resolution.unwrap_or(false)
    }

    pub fn clear_change_desktop_resolution(&mut self) {
        self.change_desktop_resolution = ::std::option::Option::None;
    }

    pub fn has_change_desktop_resolution(&self) -> bool {
        self.change_desktop_resolution.is_some()
    }

    // Param is passed by value, moved
    pub fn set_change_desktop_resolution(&mut self, v: bool) {
        self.change_desktop_resolution = ::std::option::Option::Some(v);
    }

    // optional bool dynamically_adjust_resolution = 2;

    pub fn dynamically_adjust_resolution(&self) -> bool {
        self.dynamically_adjust_resolution.unwrap_or(false)
    }

    pub fn clear_dynamically_adjust_resolution(&mut self) {
        self.dynamically_adjust_resolution = ::std::option::Option::None;
    }

    pub fn has_dynamically_adjust_resolution(&self) -> bool {
        self.dynamically_adjust_resolution.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dynamically_adjust_resolution(&mut self, v: bool) {
        self.dynamically_adjust_resolution = ::std::option::Option::Some(v);
    }

    // optional bool enable_capture_nvfbc = 3;

    pub fn enable_capture_nvfbc(&self) -> bool {
        self.enable_capture_nvfbc.unwrap_or(false)
    }

    pub fn clear_enable_capture_nvfbc(&mut self) {
        self.enable_capture_nvfbc = ::std::option::Option::None;
    }

    pub fn has_enable_capture_nvfbc(&self) -> bool {
        self.enable_capture_nvfbc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_capture_nvfbc(&mut self, v: bool) {
        self.enable_capture_nvfbc = ::std::option::Option::Some(v);
    }

    // optional bool enable_hardware_encoding_nvidia = 4;

    pub fn enable_hardware_encoding_nvidia(&self) -> bool {
        self.enable_hardware_encoding_nvidia.unwrap_or(false)
    }

    pub fn clear_enable_hardware_encoding_nvidia(&mut self) {
        self.enable_hardware_encoding_nvidia = ::std::option::Option::None;
    }

    pub fn has_enable_hardware_encoding_nvidia(&self) -> bool {
        self.enable_hardware_encoding_nvidia.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_hardware_encoding_nvidia(&mut self, v: bool) {
        self.enable_hardware_encoding_nvidia = ::std::option::Option::Some(v);
    }

    // optional bool enable_hardware_encoding_amd = 5;

    pub fn enable_hardware_encoding_amd(&self) -> bool {
        self.enable_hardware_encoding_amd.unwrap_or(false)
    }

    pub fn clear_enable_hardware_encoding_amd(&mut self) {
        self.enable_hardware_encoding_amd = ::std::option::Option::None;
    }

    pub fn has_enable_hardware_encoding_amd(&self) -> bool {
        self.enable_hardware_encoding_amd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_hardware_encoding_amd(&mut self, v: bool) {
        self.enable_hardware_encoding_amd = ::std::option::Option::Some(v);
    }

    // optional bool enable_hardware_encoding_intel = 6;

    pub fn enable_hardware_encoding_intel(&self) -> bool {
        self.enable_hardware_encoding_intel.unwrap_or(false)
    }

    pub fn clear_enable_hardware_encoding_intel(&mut self) {
        self.enable_hardware_encoding_intel = ::std::option::Option::None;
    }

    pub fn has_enable_hardware_encoding_intel(&self) -> bool {
        self.enable_hardware_encoding_intel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_hardware_encoding_intel(&mut self, v: bool) {
        self.enable_hardware_encoding_intel = ::std::option::Option::Some(v);
    }

    // optional int32 software_encoding_threads = 7;

    pub fn software_encoding_threads(&self) -> i32 {
        self.software_encoding_threads.unwrap_or(0)
    }

    pub fn clear_software_encoding_threads(&mut self) {
        self.software_encoding_threads = ::std::option::Option::None;
    }

    pub fn has_software_encoding_threads(&self) -> bool {
        self.software_encoding_threads.is_some()
    }

    // Param is passed by value, moved
    pub fn set_software_encoding_threads(&mut self, v: i32) {
        self.software_encoding_threads = ::std::option::Option::Some(v);
    }

    // optional bool enable_traffic_priority = 8;

    pub fn enable_traffic_priority(&self) -> bool {
        self.enable_traffic_priority.unwrap_or(false)
    }

    pub fn clear_enable_traffic_priority(&mut self) {
        self.enable_traffic_priority = ::std::option::Option::None;
    }

    pub fn has_enable_traffic_priority(&self) -> bool {
        self.enable_traffic_priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_traffic_priority(&mut self, v: bool) {
        self.enable_traffic_priority = ::std::option::Option::Some(v);
    }

    // optional .EStreamHostPlayAudioPreference host_play_audio = 9;

    pub fn host_play_audio(&self) -> EStreamHostPlayAudioPreference {
        match self.host_play_audio {
            Some(e) => e.enum_value_or(EStreamHostPlayAudioPreference::k_EStreamHostPlayAudioDefault),
            None => EStreamHostPlayAudioPreference::k_EStreamHostPlayAudioDefault,
        }
    }

    pub fn clear_host_play_audio(&mut self) {
        self.host_play_audio = ::std::option::Option::None;
    }

    pub fn has_host_play_audio(&self) -> bool {
        self.host_play_audio.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host_play_audio(&mut self, v: EStreamHostPlayAudioPreference) {
        self.host_play_audio = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::protobuf::Message for CStreamingServerConfig {
    const NAME: &'static str = "CStreamingServerConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.change_desktop_resolution = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.dynamically_adjust_resolution = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.enable_capture_nvfbc = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.enable_hardware_encoding_nvidia = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.enable_hardware_encoding_amd = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.enable_hardware_encoding_intel = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.software_encoding_threads = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.enable_traffic_priority = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.host_play_audio = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.change_desktop_resolution {
            my_size += 1 + 1;
        }
        if let Some(v) = self.dynamically_adjust_resolution {
            my_size += 1 + 1;
        }
        if let Some(v) = self.enable_capture_nvfbc {
            my_size += 1 + 1;
        }
        if let Some(v) = self.enable_hardware_encoding_nvidia {
            my_size += 1 + 1;
        }
        if let Some(v) = self.enable_hardware_encoding_amd {
            my_size += 1 + 1;
        }
        if let Some(v) = self.enable_hardware_encoding_intel {
            my_size += 1 + 1;
        }
        if let Some(v) = self.software_encoding_threads {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.enable_traffic_priority {
            my_size += 1 + 1;
        }
        if let Some(v) = self.host_play_audio {
            my_size += ::protobuf::rt::int32_size(9, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.change_desktop_resolution {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.dynamically_adjust_resolution {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.enable_capture_nvfbc {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.enable_hardware_encoding_nvidia {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.enable_hardware_encoding_amd {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.enable_hardware_encoding_intel {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.software_encoding_threads {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.enable_traffic_priority {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.host_play_audio {
            os.write_enum(9, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStreamingServerConfig {
        CStreamingServerConfig::new()
    }

    fn clear(&mut self) {
        self.change_desktop_resolution = ::std::option::Option::None;
        self.dynamically_adjust_resolution = ::std::option::Option::None;
        self.enable_capture_nvfbc = ::std::option::Option::None;
        self.enable_hardware_encoding_nvidia = ::std::option::Option::None;
        self.enable_hardware_encoding_amd = ::std::option::Option::None;
        self.enable_hardware_encoding_intel = ::std::option::Option::None;
        self.software_encoding_threads = ::std::option::Option::None;
        self.enable_traffic_priority = ::std::option::Option::None;
        self.host_play_audio = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStreamingServerConfig {
        static instance: CStreamingServerConfig = CStreamingServerConfig {
            change_desktop_resolution: ::std::option::Option::None,
            dynamically_adjust_resolution: ::std::option::Option::None,
            enable_capture_nvfbc: ::std::option::Option::None,
            enable_hardware_encoding_nvidia: ::std::option::Option::None,
            enable_hardware_encoding_amd: ::std::option::Option::None,
            enable_hardware_encoding_intel: ::std::option::Option::None,
            software_encoding_threads: ::std::option::Option::None,
            enable_traffic_priority: ::std::option::Option::None,
            host_play_audio: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CNegotiatedConfig)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CNegotiatedConfig {
    // message fields
    // @@protoc_insertion_point(field:CNegotiatedConfig.reliable_data)
    pub reliable_data: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CNegotiatedConfig.selected_audio_codec)
    pub selected_audio_codec: ::std::option::Option<::protobuf::EnumOrUnknown<EStreamAudioCodec>>,
    // @@protoc_insertion_point(field:CNegotiatedConfig.selected_video_codec)
    pub selected_video_codec: ::std::option::Option<::protobuf::EnumOrUnknown<EStreamVideoCodec>>,
    // @@protoc_insertion_point(field:CNegotiatedConfig.available_video_modes)
    pub available_video_modes: ::std::vec::Vec<CStreamVideoMode>,
    // @@protoc_insertion_point(field:CNegotiatedConfig.enable_remote_hid)
    pub enable_remote_hid: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CNegotiatedConfig.enable_touch_input)
    pub enable_touch_input: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CNegotiatedConfig.disable_client_cursor)
    pub disable_client_cursor: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CNegotiatedConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CNegotiatedConfig {
    fn default() -> &'a CNegotiatedConfig {
        <CNegotiatedConfig as ::protobuf::Message>::default_instance()
    }
}

impl CNegotiatedConfig {
    pub fn new() -> CNegotiatedConfig {
        ::std::default::Default::default()
    }

    // optional bool reliable_data = 1;

    pub fn reliable_data(&self) -> bool {
        self.reliable_data.unwrap_or(false)
    }

    pub fn clear_reliable_data(&mut self) {
        self.reliable_data = ::std::option::Option::None;
    }

    pub fn has_reliable_data(&self) -> bool {
        self.reliable_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reliable_data(&mut self, v: bool) {
        self.reliable_data = ::std::option::Option::Some(v);
    }

    // optional .EStreamAudioCodec selected_audio_codec = 2;

    pub fn selected_audio_codec(&self) -> EStreamAudioCodec {
        match self.selected_audio_codec {
            Some(e) => e.enum_value_or(EStreamAudioCodec::k_EStreamAudioCodecNone),
            None => EStreamAudioCodec::k_EStreamAudioCodecNone,
        }
    }

    pub fn clear_selected_audio_codec(&mut self) {
        self.selected_audio_codec = ::std::option::Option::None;
    }

    pub fn has_selected_audio_codec(&self) -> bool {
        self.selected_audio_codec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selected_audio_codec(&mut self, v: EStreamAudioCodec) {
        self.selected_audio_codec = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .EStreamVideoCodec selected_video_codec = 3;

    pub fn selected_video_codec(&self) -> EStreamVideoCodec {
        match self.selected_video_codec {
            Some(e) => e.enum_value_or(EStreamVideoCodec::k_EStreamVideoCodecNone),
            None => EStreamVideoCodec::k_EStreamVideoCodecNone,
        }
    }

    pub fn clear_selected_video_codec(&mut self) {
        self.selected_video_codec = ::std::option::Option::None;
    }

    pub fn has_selected_video_codec(&self) -> bool {
        self.selected_video_codec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selected_video_codec(&mut self, v: EStreamVideoCodec) {
        self.selected_video_codec = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool enable_remote_hid = 5;

    pub fn enable_remote_hid(&self) -> bool {
        self.enable_remote_hid.unwrap_or(false)
    }

    pub fn clear_enable_remote_hid(&mut self) {
        self.enable_remote_hid = ::std::option::Option::None;
    }

    pub fn has_enable_remote_hid(&self) -> bool {
        self.enable_remote_hid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_remote_hid(&mut self, v: bool) {
        self.enable_remote_hid = ::std::option::Option::Some(v);
    }

    // optional bool enable_touch_input = 6;

    pub fn enable_touch_input(&self) -> bool {
        self.enable_touch_input.unwrap_or(false)
    }

    pub fn clear_enable_touch_input(&mut self) {
        self.enable_touch_input = ::std::option::Option::None;
    }

    pub fn has_enable_touch_input(&self) -> bool {
        self.enable_touch_input.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_touch_input(&mut self, v: bool) {
        self.enable_touch_input = ::std::option::Option::Some(v);
    }

    // optional bool disable_client_cursor = 7;

    pub fn disable_client_cursor(&self) -> bool {
        self.disable_client_cursor.unwrap_or(false)
    }

    pub fn clear_disable_client_cursor(&mut self) {
        self.disable_client_cursor = ::std::option::Option::None;
    }

    pub fn has_disable_client_cursor(&self) -> bool {
        self.disable_client_cursor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable_client_cursor(&mut self, v: bool) {
        self.disable_client_cursor = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CNegotiatedConfig {
    const NAME: &'static str = "CNegotiatedConfig";

    fn is_initialized(&self) -> bool {
        for v in &self.available_video_modes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.reliable_data = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.selected_audio_codec = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.selected_video_codec = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                34 => {
                    self.available_video_modes.push(is.read_message()?);
                },
                40 => {
                    self.enable_remote_hid = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.enable_touch_input = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.disable_client_cursor = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.reliable_data {
            my_size += 1 + 1;
        }
        if let Some(v) = self.selected_audio_codec {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.selected_video_codec {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        for value in &self.available_video_modes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.enable_remote_hid {
            my_size += 1 + 1;
        }
        if let Some(v) = self.enable_touch_input {
            my_size += 1 + 1;
        }
        if let Some(v) = self.disable_client_cursor {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.reliable_data {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.selected_audio_codec {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.selected_video_codec {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.available_video_modes {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.enable_remote_hid {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.enable_touch_input {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.disable_client_cursor {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CNegotiatedConfig {
        CNegotiatedConfig::new()
    }

    fn clear(&mut self) {
        self.reliable_data = ::std::option::Option::None;
        self.selected_audio_codec = ::std::option::Option::None;
        self.selected_video_codec = ::std::option::Option::None;
        self.available_video_modes.clear();
        self.enable_remote_hid = ::std::option::Option::None;
        self.enable_touch_input = ::std::option::Option::None;
        self.disable_client_cursor = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CNegotiatedConfig {
        static instance: CNegotiatedConfig = CNegotiatedConfig {
            reliable_data: ::std::option::Option::None,
            selected_audio_codec: ::std::option::Option::None,
            selected_video_codec: ::std::option::Option::None,
            available_video_modes: ::std::vec::Vec::new(),
            enable_remote_hid: ::std::option::Option::None,
            enable_touch_input: ::std::option::Option::None,
            disable_client_cursor: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CNegotiationInitMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CNegotiationInitMsg {
    // message fields
    // @@protoc_insertion_point(field:CNegotiationInitMsg.reliable_data)
    pub reliable_data: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CNegotiationInitMsg.supported_audio_codecs)
    pub supported_audio_codecs: ::std::vec::Vec<::protobuf::EnumOrUnknown<EStreamAudioCodec>>,
    // @@protoc_insertion_point(field:CNegotiationInitMsg.supported_video_codecs)
    pub supported_video_codecs: ::std::vec::Vec<::protobuf::EnumOrUnknown<EStreamVideoCodec>>,
    // @@protoc_insertion_point(field:CNegotiationInitMsg.supports_remote_hid)
    pub supports_remote_hid: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CNegotiationInitMsg.supports_touch_input)
    pub supports_touch_input: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CNegotiationInitMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CNegotiationInitMsg {
    fn default() -> &'a CNegotiationInitMsg {
        <CNegotiationInitMsg as ::protobuf::Message>::default_instance()
    }
}

impl CNegotiationInitMsg {
    pub fn new() -> CNegotiationInitMsg {
        ::std::default::Default::default()
    }

    // optional bool reliable_data = 1;

    pub fn reliable_data(&self) -> bool {
        self.reliable_data.unwrap_or(false)
    }

    pub fn clear_reliable_data(&mut self) {
        self.reliable_data = ::std::option::Option::None;
    }

    pub fn has_reliable_data(&self) -> bool {
        self.reliable_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reliable_data(&mut self, v: bool) {
        self.reliable_data = ::std::option::Option::Some(v);
    }

    // optional bool supports_remote_hid = 4;

    pub fn supports_remote_hid(&self) -> bool {
        self.supports_remote_hid.unwrap_or(false)
    }

    pub fn clear_supports_remote_hid(&mut self) {
        self.supports_remote_hid = ::std::option::Option::None;
    }

    pub fn has_supports_remote_hid(&self) -> bool {
        self.supports_remote_hid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_supports_remote_hid(&mut self, v: bool) {
        self.supports_remote_hid = ::std::option::Option::Some(v);
    }

    // optional bool supports_touch_input = 5;

    pub fn supports_touch_input(&self) -> bool {
        self.supports_touch_input.unwrap_or(false)
    }

    pub fn clear_supports_touch_input(&mut self) {
        self.supports_touch_input = ::std::option::Option::None;
    }

    pub fn has_supports_touch_input(&self) -> bool {
        self.supports_touch_input.is_some()
    }

    // Param is passed by value, moved
    pub fn set_supports_touch_input(&mut self, v: bool) {
        self.supports_touch_input = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CNegotiationInitMsg {
    const NAME: &'static str = "CNegotiationInitMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.reliable_data = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.supported_audio_codecs.push(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.supported_audio_codecs)?
                },
                24 => {
                    self.supported_video_codecs.push(is.read_enum_or_unknown()?);
                },
                26 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.supported_video_codecs)?
                },
                32 => {
                    self.supports_remote_hid = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.supports_touch_input = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.reliable_data {
            my_size += 1 + 1;
        }
        for value in &self.supported_audio_codecs {
            my_size += ::protobuf::rt::int32_size(2, value.value());
        };
        for value in &self.supported_video_codecs {
            my_size += ::protobuf::rt::int32_size(3, value.value());
        };
        if let Some(v) = self.supports_remote_hid {
            my_size += 1 + 1;
        }
        if let Some(v) = self.supports_touch_input {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.reliable_data {
            os.write_bool(1, v)?;
        }
        for v in &self.supported_audio_codecs {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(v))?;
        };
        for v in &self.supported_video_codecs {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(v))?;
        };
        if let Some(v) = self.supports_remote_hid {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.supports_touch_input {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CNegotiationInitMsg {
        CNegotiationInitMsg::new()
    }

    fn clear(&mut self) {
        self.reliable_data = ::std::option::Option::None;
        self.supported_audio_codecs.clear();
        self.supported_video_codecs.clear();
        self.supports_remote_hid = ::std::option::Option::None;
        self.supports_touch_input = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CNegotiationInitMsg {
        static instance: CNegotiationInitMsg = CNegotiationInitMsg {
            reliable_data: ::std::option::Option::None,
            supported_audio_codecs: ::std::vec::Vec::new(),
            supported_video_codecs: ::std::vec::Vec::new(),
            supports_remote_hid: ::std::option::Option::None,
            supports_touch_input: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CNegotiationSetConfigMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CNegotiationSetConfigMsg {
    // message fields
    // @@protoc_insertion_point(field:CNegotiationSetConfigMsg.config)
    pub config: ::protobuf::MessageField<CNegotiatedConfig>,
    // @@protoc_insertion_point(field:CNegotiationSetConfigMsg.streaming_client_config)
    pub streaming_client_config: ::protobuf::MessageField<CStreamingClientConfig>,
    // @@protoc_insertion_point(field:CNegotiationSetConfigMsg.streaming_client_caps)
    pub streaming_client_caps: ::protobuf::MessageField<CStreamingClientCaps>,
    // special fields
    // @@protoc_insertion_point(special_field:CNegotiationSetConfigMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CNegotiationSetConfigMsg {
    fn default() -> &'a CNegotiationSetConfigMsg {
        <CNegotiationSetConfigMsg as ::protobuf::Message>::default_instance()
    }
}

impl CNegotiationSetConfigMsg {
    pub fn new() -> CNegotiationSetConfigMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CNegotiationSetConfigMsg {
    const NAME: &'static str = "CNegotiationSetConfigMsg";

    fn is_initialized(&self) -> bool {
        if self.config.is_none() {
            return false;
        }
        for v in &self.config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.streaming_client_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.streaming_client_caps {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.config)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.streaming_client_config)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.streaming_client_caps)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.streaming_client_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.streaming_client_caps.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.config.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.streaming_client_config.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.streaming_client_caps.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CNegotiationSetConfigMsg {
        CNegotiationSetConfigMsg::new()
    }

    fn clear(&mut self) {
        self.config.clear();
        self.streaming_client_config.clear();
        self.streaming_client_caps.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CNegotiationSetConfigMsg {
        static instance: CNegotiationSetConfigMsg = CNegotiationSetConfigMsg {
            config: ::protobuf::MessageField::none(),
            streaming_client_config: ::protobuf::MessageField::none(),
            streaming_client_caps: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CNegotiationCompleteMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CNegotiationCompleteMsg {
    // special fields
    // @@protoc_insertion_point(special_field:CNegotiationCompleteMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CNegotiationCompleteMsg {
    fn default() -> &'a CNegotiationCompleteMsg {
        <CNegotiationCompleteMsg as ::protobuf::Message>::default_instance()
    }
}

impl CNegotiationCompleteMsg {
    pub fn new() -> CNegotiationCompleteMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CNegotiationCompleteMsg {
    const NAME: &'static str = "CNegotiationCompleteMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CNegotiationCompleteMsg {
        CNegotiationCompleteMsg::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CNegotiationCompleteMsg {
        static instance: CNegotiationCompleteMsg = CNegotiationCompleteMsg {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CStartAudioDataMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStartAudioDataMsg {
    // message fields
    // @@protoc_insertion_point(field:CStartAudioDataMsg.channel)
    pub channel: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStartAudioDataMsg.codec)
    pub codec: ::std::option::Option<::protobuf::EnumOrUnknown<EStreamAudioCodec>>,
    // @@protoc_insertion_point(field:CStartAudioDataMsg.codec_data)
    pub codec_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CStartAudioDataMsg.frequency)
    pub frequency: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStartAudioDataMsg.channels)
    pub channels: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CStartAudioDataMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStartAudioDataMsg {
    fn default() -> &'a CStartAudioDataMsg {
        <CStartAudioDataMsg as ::protobuf::Message>::default_instance()
    }
}

impl CStartAudioDataMsg {
    pub fn new() -> CStartAudioDataMsg {
        ::std::default::Default::default()
    }

    // required uint32 channel = 2;

    pub fn channel(&self) -> u32 {
        self.channel.unwrap_or(0)
    }

    pub fn clear_channel(&mut self) {
        self.channel = ::std::option::Option::None;
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: u32) {
        self.channel = ::std::option::Option::Some(v);
    }

    // optional .EStreamAudioCodec codec = 3;

    pub fn codec(&self) -> EStreamAudioCodec {
        match self.codec {
            Some(e) => e.enum_value_or(EStreamAudioCodec::k_EStreamAudioCodecNone),
            None => EStreamAudioCodec::k_EStreamAudioCodecNone,
        }
    }

    pub fn clear_codec(&mut self) {
        self.codec = ::std::option::Option::None;
    }

    pub fn has_codec(&self) -> bool {
        self.codec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_codec(&mut self, v: EStreamAudioCodec) {
        self.codec = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bytes codec_data = 4;

    pub fn codec_data(&self) -> &[u8] {
        match self.codec_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_codec_data(&mut self) {
        self.codec_data = ::std::option::Option::None;
    }

    pub fn has_codec_data(&self) -> bool {
        self.codec_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_codec_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.codec_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_codec_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.codec_data.is_none() {
            self.codec_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.codec_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_codec_data(&mut self) -> ::std::vec::Vec<u8> {
        self.codec_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 frequency = 5;

    pub fn frequency(&self) -> u32 {
        self.frequency.unwrap_or(0)
    }

    pub fn clear_frequency(&mut self) {
        self.frequency = ::std::option::Option::None;
    }

    pub fn has_frequency(&self) -> bool {
        self.frequency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frequency(&mut self, v: u32) {
        self.frequency = ::std::option::Option::Some(v);
    }

    // optional uint32 channels = 6;

    pub fn channels(&self) -> u32 {
        self.channels.unwrap_or(0)
    }

    pub fn clear_channels(&mut self) {
        self.channels = ::std::option::Option::None;
    }

    pub fn has_channels(&self) -> bool {
        self.channels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channels(&mut self, v: u32) {
        self.channels = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CStartAudioDataMsg {
    const NAME: &'static str = "CStartAudioDataMsg";

    fn is_initialized(&self) -> bool {
        if self.channel.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.channel = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.codec = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                34 => {
                    self.codec_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                40 => {
                    self.frequency = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.channels = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.channel {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.codec {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.codec_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.frequency {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.channels {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.channel {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.codec {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.codec_data.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.frequency {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.channels {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStartAudioDataMsg {
        CStartAudioDataMsg::new()
    }

    fn clear(&mut self) {
        self.channel = ::std::option::Option::None;
        self.codec = ::std::option::Option::None;
        self.codec_data = ::std::option::Option::None;
        self.frequency = ::std::option::Option::None;
        self.channels = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStartAudioDataMsg {
        static instance: CStartAudioDataMsg = CStartAudioDataMsg {
            channel: ::std::option::Option::None,
            codec: ::std::option::Option::None,
            codec_data: ::std::option::Option::None,
            frequency: ::std::option::Option::None,
            channels: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CStopAudioDataMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStopAudioDataMsg {
    // special fields
    // @@protoc_insertion_point(special_field:CStopAudioDataMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStopAudioDataMsg {
    fn default() -> &'a CStopAudioDataMsg {
        <CStopAudioDataMsg as ::protobuf::Message>::default_instance()
    }
}

impl CStopAudioDataMsg {
    pub fn new() -> CStopAudioDataMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CStopAudioDataMsg {
    const NAME: &'static str = "CStopAudioDataMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStopAudioDataMsg {
        CStopAudioDataMsg::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStopAudioDataMsg {
        static instance: CStopAudioDataMsg = CStopAudioDataMsg {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CStartVideoDataMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStartVideoDataMsg {
    // message fields
    // @@protoc_insertion_point(field:CStartVideoDataMsg.channel)
    pub channel: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStartVideoDataMsg.codec)
    pub codec: ::std::option::Option<::protobuf::EnumOrUnknown<EStreamVideoCodec>>,
    // @@protoc_insertion_point(field:CStartVideoDataMsg.codec_data)
    pub codec_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CStartVideoDataMsg.width)
    pub width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStartVideoDataMsg.height)
    pub height: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CStartVideoDataMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStartVideoDataMsg {
    fn default() -> &'a CStartVideoDataMsg {
        <CStartVideoDataMsg as ::protobuf::Message>::default_instance()
    }
}

impl CStartVideoDataMsg {
    pub fn new() -> CStartVideoDataMsg {
        ::std::default::Default::default()
    }

    // required uint32 channel = 1;

    pub fn channel(&self) -> u32 {
        self.channel.unwrap_or(0)
    }

    pub fn clear_channel(&mut self) {
        self.channel = ::std::option::Option::None;
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: u32) {
        self.channel = ::std::option::Option::Some(v);
    }

    // optional .EStreamVideoCodec codec = 2;

    pub fn codec(&self) -> EStreamVideoCodec {
        match self.codec {
            Some(e) => e.enum_value_or(EStreamVideoCodec::k_EStreamVideoCodecNone),
            None => EStreamVideoCodec::k_EStreamVideoCodecNone,
        }
    }

    pub fn clear_codec(&mut self) {
        self.codec = ::std::option::Option::None;
    }

    pub fn has_codec(&self) -> bool {
        self.codec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_codec(&mut self, v: EStreamVideoCodec) {
        self.codec = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bytes codec_data = 3;

    pub fn codec_data(&self) -> &[u8] {
        match self.codec_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_codec_data(&mut self) {
        self.codec_data = ::std::option::Option::None;
    }

    pub fn has_codec_data(&self) -> bool {
        self.codec_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_codec_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.codec_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_codec_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.codec_data.is_none() {
            self.codec_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.codec_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_codec_data(&mut self) -> ::std::vec::Vec<u8> {
        self.codec_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 width = 4;

    pub fn width(&self) -> u32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional uint32 height = 5;

    pub fn height(&self) -> u32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CStartVideoDataMsg {
    const NAME: &'static str = "CStartVideoDataMsg";

    fn is_initialized(&self) -> bool {
        if self.channel.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.channel = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.codec = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    self.codec_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                32 => {
                    self.width = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.height = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.channel {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.codec {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.codec_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.channel {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.codec {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.codec_data.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.width {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStartVideoDataMsg {
        CStartVideoDataMsg::new()
    }

    fn clear(&mut self) {
        self.channel = ::std::option::Option::None;
        self.codec = ::std::option::Option::None;
        self.codec_data = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStartVideoDataMsg {
        static instance: CStartVideoDataMsg = CStartVideoDataMsg {
            channel: ::std::option::Option::None,
            codec: ::std::option::Option::None,
            codec_data: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CStopVideoDataMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStopVideoDataMsg {
    // special fields
    // @@protoc_insertion_point(special_field:CStopVideoDataMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStopVideoDataMsg {
    fn default() -> &'a CStopVideoDataMsg {
        <CStopVideoDataMsg as ::protobuf::Message>::default_instance()
    }
}

impl CStopVideoDataMsg {
    pub fn new() -> CStopVideoDataMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CStopVideoDataMsg {
    const NAME: &'static str = "CStopVideoDataMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStopVideoDataMsg {
        CStopVideoDataMsg::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStopVideoDataMsg {
        static instance: CStopVideoDataMsg = CStopVideoDataMsg {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CStartNeptuneDataMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStartNeptuneDataMsg {
    // message fields
    // @@protoc_insertion_point(field:CStartNeptuneDataMsg.channel)
    pub channel: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CStartNeptuneDataMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStartNeptuneDataMsg {
    fn default() -> &'a CStartNeptuneDataMsg {
        <CStartNeptuneDataMsg as ::protobuf::Message>::default_instance()
    }
}

impl CStartNeptuneDataMsg {
    pub fn new() -> CStartNeptuneDataMsg {
        ::std::default::Default::default()
    }

    // required uint32 channel = 1;

    pub fn channel(&self) -> u32 {
        self.channel.unwrap_or(0)
    }

    pub fn clear_channel(&mut self) {
        self.channel = ::std::option::Option::None;
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: u32) {
        self.channel = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CStartNeptuneDataMsg {
    const NAME: &'static str = "CStartNeptuneDataMsg";

    fn is_initialized(&self) -> bool {
        if self.channel.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.channel = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.channel {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.channel {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStartNeptuneDataMsg {
        CStartNeptuneDataMsg::new()
    }

    fn clear(&mut self) {
        self.channel = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStartNeptuneDataMsg {
        static instance: CStartNeptuneDataMsg = CStartNeptuneDataMsg {
            channel: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CStopNeptuneDataMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStopNeptuneDataMsg {
    // special fields
    // @@protoc_insertion_point(special_field:CStopNeptuneDataMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStopNeptuneDataMsg {
    fn default() -> &'a CStopNeptuneDataMsg {
        <CStopNeptuneDataMsg as ::protobuf::Message>::default_instance()
    }
}

impl CStopNeptuneDataMsg {
    pub fn new() -> CStopNeptuneDataMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CStopNeptuneDataMsg {
    const NAME: &'static str = "CStopNeptuneDataMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStopNeptuneDataMsg {
        CStopNeptuneDataMsg::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStopNeptuneDataMsg {
        static instance: CStopNeptuneDataMsg = CStopNeptuneDataMsg {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CRecordedInput)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CRecordedInput {
    // message fields
    // @@protoc_insertion_point(field:CRecordedInput.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<EStreamControlMessage>>,
    // @@protoc_insertion_point(field:CRecordedInput.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // message oneof groups
    pub data: ::std::option::Option<crecorded_input::Data>,
    // special fields
    // @@protoc_insertion_point(special_field:CRecordedInput.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CRecordedInput {
    fn default() -> &'a CRecordedInput {
        <CRecordedInput as ::protobuf::Message>::default_instance()
    }
}

impl CRecordedInput {
    pub fn new() -> CRecordedInput {
        ::std::default::Default::default()
    }

    // optional .EStreamControlMessage type = 1;

    pub fn type_(&self) -> EStreamControlMessage {
        match self.type_ {
            Some(e) => e.enum_value_or(EStreamControlMessage::k_EStreamControlAuthenticationRequest),
            None => EStreamControlMessage::k_EStreamControlAuthenticationRequest,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: EStreamControlMessage) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 timestamp = 2;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional .CInputTouchFingerDownMsg finger_down = 3;

    pub fn finger_down(&self) -> &CInputTouchFingerDownMsg {
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::FingerDown(ref v)) => v,
            _ => <CInputTouchFingerDownMsg as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_finger_down(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_finger_down(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::FingerDown(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_finger_down(&mut self, v: CInputTouchFingerDownMsg) {
        self.data = ::std::option::Option::Some(crecorded_input::Data::FingerDown(v))
    }

    // Mutable pointer to the field.
    pub fn mut_finger_down(&mut self) -> &mut CInputTouchFingerDownMsg {
        if let ::std::option::Option::Some(crecorded_input::Data::FingerDown(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(crecorded_input::Data::FingerDown(CInputTouchFingerDownMsg::new()));
        }
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::FingerDown(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_finger_down(&mut self) -> CInputTouchFingerDownMsg {
        if self.has_finger_down() {
            match self.data.take() {
                ::std::option::Option::Some(crecorded_input::Data::FingerDown(v)) => v,
                _ => panic!(),
            }
        } else {
            CInputTouchFingerDownMsg::new()
        }
    }

    // optional .CInputTouchFingerMotionMsg finger_motion = 4;

    pub fn finger_motion(&self) -> &CInputTouchFingerMotionMsg {
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::FingerMotion(ref v)) => v,
            _ => <CInputTouchFingerMotionMsg as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_finger_motion(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_finger_motion(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::FingerMotion(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_finger_motion(&mut self, v: CInputTouchFingerMotionMsg) {
        self.data = ::std::option::Option::Some(crecorded_input::Data::FingerMotion(v))
    }

    // Mutable pointer to the field.
    pub fn mut_finger_motion(&mut self) -> &mut CInputTouchFingerMotionMsg {
        if let ::std::option::Option::Some(crecorded_input::Data::FingerMotion(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(crecorded_input::Data::FingerMotion(CInputTouchFingerMotionMsg::new()));
        }
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::FingerMotion(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_finger_motion(&mut self) -> CInputTouchFingerMotionMsg {
        if self.has_finger_motion() {
            match self.data.take() {
                ::std::option::Option::Some(crecorded_input::Data::FingerMotion(v)) => v,
                _ => panic!(),
            }
        } else {
            CInputTouchFingerMotionMsg::new()
        }
    }

    // optional .CInputTouchFingerUpMsg finger_up = 5;

    pub fn finger_up(&self) -> &CInputTouchFingerUpMsg {
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::FingerUp(ref v)) => v,
            _ => <CInputTouchFingerUpMsg as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_finger_up(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_finger_up(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::FingerUp(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_finger_up(&mut self, v: CInputTouchFingerUpMsg) {
        self.data = ::std::option::Option::Some(crecorded_input::Data::FingerUp(v))
    }

    // Mutable pointer to the field.
    pub fn mut_finger_up(&mut self) -> &mut CInputTouchFingerUpMsg {
        if let ::std::option::Option::Some(crecorded_input::Data::FingerUp(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(crecorded_input::Data::FingerUp(CInputTouchFingerUpMsg::new()));
        }
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::FingerUp(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_finger_up(&mut self) -> CInputTouchFingerUpMsg {
        if self.has_finger_up() {
            match self.data.take() {
                ::std::option::Option::Some(crecorded_input::Data::FingerUp(v)) => v,
                _ => panic!(),
            }
        } else {
            CInputTouchFingerUpMsg::new()
        }
    }

    // optional .CInputMouseMotionMsg mouse_motion = 6;

    pub fn mouse_motion(&self) -> &CInputMouseMotionMsg {
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::MouseMotion(ref v)) => v,
            _ => <CInputMouseMotionMsg as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_mouse_motion(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_mouse_motion(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::MouseMotion(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mouse_motion(&mut self, v: CInputMouseMotionMsg) {
        self.data = ::std::option::Option::Some(crecorded_input::Data::MouseMotion(v))
    }

    // Mutable pointer to the field.
    pub fn mut_mouse_motion(&mut self) -> &mut CInputMouseMotionMsg {
        if let ::std::option::Option::Some(crecorded_input::Data::MouseMotion(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(crecorded_input::Data::MouseMotion(CInputMouseMotionMsg::new()));
        }
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::MouseMotion(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_mouse_motion(&mut self) -> CInputMouseMotionMsg {
        if self.has_mouse_motion() {
            match self.data.take() {
                ::std::option::Option::Some(crecorded_input::Data::MouseMotion(v)) => v,
                _ => panic!(),
            }
        } else {
            CInputMouseMotionMsg::new()
        }
    }

    // optional .CInputMouseWheelMsg mouse_wheel = 7;

    pub fn mouse_wheel(&self) -> &CInputMouseWheelMsg {
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::MouseWheel(ref v)) => v,
            _ => <CInputMouseWheelMsg as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_mouse_wheel(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_mouse_wheel(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::MouseWheel(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mouse_wheel(&mut self, v: CInputMouseWheelMsg) {
        self.data = ::std::option::Option::Some(crecorded_input::Data::MouseWheel(v))
    }

    // Mutable pointer to the field.
    pub fn mut_mouse_wheel(&mut self) -> &mut CInputMouseWheelMsg {
        if let ::std::option::Option::Some(crecorded_input::Data::MouseWheel(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(crecorded_input::Data::MouseWheel(CInputMouseWheelMsg::new()));
        }
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::MouseWheel(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_mouse_wheel(&mut self) -> CInputMouseWheelMsg {
        if self.has_mouse_wheel() {
            match self.data.take() {
                ::std::option::Option::Some(crecorded_input::Data::MouseWheel(v)) => v,
                _ => panic!(),
            }
        } else {
            CInputMouseWheelMsg::new()
        }
    }

    // optional .CInputMouseDownMsg mouse_down = 8;

    pub fn mouse_down(&self) -> &CInputMouseDownMsg {
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::MouseDown(ref v)) => v,
            _ => <CInputMouseDownMsg as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_mouse_down(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_mouse_down(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::MouseDown(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mouse_down(&mut self, v: CInputMouseDownMsg) {
        self.data = ::std::option::Option::Some(crecorded_input::Data::MouseDown(v))
    }

    // Mutable pointer to the field.
    pub fn mut_mouse_down(&mut self) -> &mut CInputMouseDownMsg {
        if let ::std::option::Option::Some(crecorded_input::Data::MouseDown(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(crecorded_input::Data::MouseDown(CInputMouseDownMsg::new()));
        }
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::MouseDown(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_mouse_down(&mut self) -> CInputMouseDownMsg {
        if self.has_mouse_down() {
            match self.data.take() {
                ::std::option::Option::Some(crecorded_input::Data::MouseDown(v)) => v,
                _ => panic!(),
            }
        } else {
            CInputMouseDownMsg::new()
        }
    }

    // optional .CInputMouseUpMsg mouse_up = 9;

    pub fn mouse_up(&self) -> &CInputMouseUpMsg {
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::MouseUp(ref v)) => v,
            _ => <CInputMouseUpMsg as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_mouse_up(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_mouse_up(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::MouseUp(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mouse_up(&mut self, v: CInputMouseUpMsg) {
        self.data = ::std::option::Option::Some(crecorded_input::Data::MouseUp(v))
    }

    // Mutable pointer to the field.
    pub fn mut_mouse_up(&mut self) -> &mut CInputMouseUpMsg {
        if let ::std::option::Option::Some(crecorded_input::Data::MouseUp(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(crecorded_input::Data::MouseUp(CInputMouseUpMsg::new()));
        }
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::MouseUp(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_mouse_up(&mut self) -> CInputMouseUpMsg {
        if self.has_mouse_up() {
            match self.data.take() {
                ::std::option::Option::Some(crecorded_input::Data::MouseUp(v)) => v,
                _ => panic!(),
            }
        } else {
            CInputMouseUpMsg::new()
        }
    }

    // optional .CInputKeyDownMsg key_down = 10;

    pub fn key_down(&self) -> &CInputKeyDownMsg {
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::KeyDown(ref v)) => v,
            _ => <CInputKeyDownMsg as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_key_down(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_key_down(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::KeyDown(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_key_down(&mut self, v: CInputKeyDownMsg) {
        self.data = ::std::option::Option::Some(crecorded_input::Data::KeyDown(v))
    }

    // Mutable pointer to the field.
    pub fn mut_key_down(&mut self) -> &mut CInputKeyDownMsg {
        if let ::std::option::Option::Some(crecorded_input::Data::KeyDown(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(crecorded_input::Data::KeyDown(CInputKeyDownMsg::new()));
        }
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::KeyDown(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_key_down(&mut self) -> CInputKeyDownMsg {
        if self.has_key_down() {
            match self.data.take() {
                ::std::option::Option::Some(crecorded_input::Data::KeyDown(v)) => v,
                _ => panic!(),
            }
        } else {
            CInputKeyDownMsg::new()
        }
    }

    // optional .CInputKeyUpMsg key_up = 11;

    pub fn key_up(&self) -> &CInputKeyUpMsg {
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::KeyUp(ref v)) => v,
            _ => <CInputKeyUpMsg as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_key_up(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_key_up(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::KeyUp(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_key_up(&mut self, v: CInputKeyUpMsg) {
        self.data = ::std::option::Option::Some(crecorded_input::Data::KeyUp(v))
    }

    // Mutable pointer to the field.
    pub fn mut_key_up(&mut self) -> &mut CInputKeyUpMsg {
        if let ::std::option::Option::Some(crecorded_input::Data::KeyUp(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(crecorded_input::Data::KeyUp(CInputKeyUpMsg::new()));
        }
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::KeyUp(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_key_up(&mut self) -> CInputKeyUpMsg {
        if self.has_key_up() {
            match self.data.take() {
                ::std::option::Option::Some(crecorded_input::Data::KeyUp(v)) => v,
                _ => panic!(),
            }
        } else {
            CInputKeyUpMsg::new()
        }
    }

    // optional .CInputTextMsg text = 12;

    pub fn text(&self) -> &CInputTextMsg {
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::Text(ref v)) => v,
            _ => <CInputTextMsg as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_text(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::Text(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: CInputTextMsg) {
        self.data = ::std::option::Option::Some(crecorded_input::Data::Text(v))
    }

    // Mutable pointer to the field.
    pub fn mut_text(&mut self) -> &mut CInputTextMsg {
        if let ::std::option::Option::Some(crecorded_input::Data::Text(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(crecorded_input::Data::Text(CInputTextMsg::new()));
        }
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::Text(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_text(&mut self) -> CInputTextMsg {
        if self.has_text() {
            match self.data.take() {
                ::std::option::Option::Some(crecorded_input::Data::Text(v)) => v,
                _ => panic!(),
            }
        } else {
            CInputTextMsg::new()
        }
    }

    // optional .CRemoteHIDMsg hid = 13;

    pub fn hid(&self) -> &CRemoteHIDMsg {
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::Hid(ref v)) => v,
            _ => <CRemoteHIDMsg as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_hid(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_hid(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::Hid(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_hid(&mut self, v: CRemoteHIDMsg) {
        self.data = ::std::option::Option::Some(crecorded_input::Data::Hid(v))
    }

    // Mutable pointer to the field.
    pub fn mut_hid(&mut self) -> &mut CRemoteHIDMsg {
        if let ::std::option::Option::Some(crecorded_input::Data::Hid(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(crecorded_input::Data::Hid(CRemoteHIDMsg::new()));
        }
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::Hid(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_hid(&mut self) -> CRemoteHIDMsg {
        if self.has_hid() {
            match self.data.take() {
                ::std::option::Option::Some(crecorded_input::Data::Hid(v)) => v,
                _ => panic!(),
            }
        } else {
            CRemoteHIDMsg::new()
        }
    }
}

impl ::protobuf::Message for CRecordedInput {
    const NAME: &'static str = "CRecordedInput";

    fn is_initialized(&self) -> bool {
        if let Some(crecorded_input::Data::FingerDown(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(crecorded_input::Data::FingerMotion(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(crecorded_input::Data::FingerUp(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(crecorded_input::Data::MouseMotion(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(crecorded_input::Data::MouseWheel(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(crecorded_input::Data::MouseDown(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(crecorded_input::Data::MouseUp(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(crecorded_input::Data::KeyDown(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(crecorded_input::Data::KeyUp(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(crecorded_input::Data::Text(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(crecorded_input::Data::Hid(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.data = ::std::option::Option::Some(crecorded_input::Data::FingerDown(is.read_message()?));
                },
                34 => {
                    self.data = ::std::option::Option::Some(crecorded_input::Data::FingerMotion(is.read_message()?));
                },
                42 => {
                    self.data = ::std::option::Option::Some(crecorded_input::Data::FingerUp(is.read_message()?));
                },
                50 => {
                    self.data = ::std::option::Option::Some(crecorded_input::Data::MouseMotion(is.read_message()?));
                },
                58 => {
                    self.data = ::std::option::Option::Some(crecorded_input::Data::MouseWheel(is.read_message()?));
                },
                66 => {
                    self.data = ::std::option::Option::Some(crecorded_input::Data::MouseDown(is.read_message()?));
                },
                74 => {
                    self.data = ::std::option::Option::Some(crecorded_input::Data::MouseUp(is.read_message()?));
                },
                82 => {
                    self.data = ::std::option::Option::Some(crecorded_input::Data::KeyDown(is.read_message()?));
                },
                90 => {
                    self.data = ::std::option::Option::Some(crecorded_input::Data::KeyUp(is.read_message()?));
                },
                98 => {
                    self.data = ::std::option::Option::Some(crecorded_input::Data::Text(is.read_message()?));
                },
                106 => {
                    self.data = ::std::option::Option::Some(crecorded_input::Data::Hid(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &crecorded_input::Data::FingerDown(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &crecorded_input::Data::FingerMotion(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &crecorded_input::Data::FingerUp(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &crecorded_input::Data::MouseMotion(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &crecorded_input::Data::MouseWheel(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &crecorded_input::Data::MouseDown(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &crecorded_input::Data::MouseUp(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &crecorded_input::Data::KeyDown(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &crecorded_input::Data::KeyUp(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &crecorded_input::Data::Text(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &crecorded_input::Data::Hid(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(2, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &crecorded_input::Data::FingerDown(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &crecorded_input::Data::FingerMotion(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &crecorded_input::Data::FingerUp(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &crecorded_input::Data::MouseMotion(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &crecorded_input::Data::MouseWheel(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &crecorded_input::Data::MouseDown(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &crecorded_input::Data::MouseUp(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
                },
                &crecorded_input::Data::KeyDown(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
                },
                &crecorded_input::Data::KeyUp(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
                },
                &crecorded_input::Data::Text(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
                },
                &crecorded_input::Data::Hid(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CRecordedInput {
        CRecordedInput::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CRecordedInput {
        static instance: CRecordedInput = CRecordedInput {
            type_: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CRecordedInput`
pub mod crecorded_input {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:CRecordedInput.data)
    pub enum Data {
        // @@protoc_insertion_point(oneof_field:CRecordedInput.finger_down)
        FingerDown(super::CInputTouchFingerDownMsg),
        // @@protoc_insertion_point(oneof_field:CRecordedInput.finger_motion)
        FingerMotion(super::CInputTouchFingerMotionMsg),
        // @@protoc_insertion_point(oneof_field:CRecordedInput.finger_up)
        FingerUp(super::CInputTouchFingerUpMsg),
        // @@protoc_insertion_point(oneof_field:CRecordedInput.mouse_motion)
        MouseMotion(super::CInputMouseMotionMsg),
        // @@protoc_insertion_point(oneof_field:CRecordedInput.mouse_wheel)
        MouseWheel(super::CInputMouseWheelMsg),
        // @@protoc_insertion_point(oneof_field:CRecordedInput.mouse_down)
        MouseDown(super::CInputMouseDownMsg),
        // @@protoc_insertion_point(oneof_field:CRecordedInput.mouse_up)
        MouseUp(super::CInputMouseUpMsg),
        // @@protoc_insertion_point(oneof_field:CRecordedInput.key_down)
        KeyDown(super::CInputKeyDownMsg),
        // @@protoc_insertion_point(oneof_field:CRecordedInput.key_up)
        KeyUp(super::CInputKeyUpMsg),
        // @@protoc_insertion_point(oneof_field:CRecordedInput.text)
        Text(super::CInputTextMsg),
        // @@protoc_insertion_point(oneof_field:CRecordedInput.hid)
        Hid(super::CRemoteHIDMsg),
    }

    impl ::protobuf::Oneof for Data {
    }

    impl Data {
    }
}

// @@protoc_insertion_point(message:CRecordedInputStream)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CRecordedInputStream {
    // message fields
    // @@protoc_insertion_point(field:CRecordedInputStream.entries)
    pub entries: ::std::vec::Vec<CRecordedInput>,
    // special fields
    // @@protoc_insertion_point(special_field:CRecordedInputStream.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CRecordedInputStream {
    fn default() -> &'a CRecordedInputStream {
        <CRecordedInputStream as ::protobuf::Message>::default_instance()
    }
}

impl CRecordedInputStream {
    pub fn new() -> CRecordedInputStream {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CRecordedInputStream {
    const NAME: &'static str = "CRecordedInputStream";

    fn is_initialized(&self) -> bool {
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.entries.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.entries {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CRecordedInputStream {
        CRecordedInputStream::new()
    }

    fn clear(&mut self) {
        self.entries.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CRecordedInputStream {
        static instance: CRecordedInputStream = CRecordedInputStream {
            entries: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CInputLatencyTestMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CInputLatencyTestMsg {
    // message fields
    // @@protoc_insertion_point(field:CInputLatencyTestMsg.input_mark)
    pub input_mark: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CInputLatencyTestMsg.color)
    pub color: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CInputLatencyTestMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CInputLatencyTestMsg {
    fn default() -> &'a CInputLatencyTestMsg {
        <CInputLatencyTestMsg as ::protobuf::Message>::default_instance()
    }
}

impl CInputLatencyTestMsg {
    pub fn new() -> CInputLatencyTestMsg {
        ::std::default::Default::default()
    }

    // required uint32 input_mark = 1;

    pub fn input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }

    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    // optional uint32 color = 2;

    pub fn color(&self) -> u32 {
        self.color.unwrap_or(0)
    }

    pub fn clear_color(&mut self) {
        self.color = ::std::option::Option::None;
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: u32) {
        self.color = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CInputLatencyTestMsg {
    const NAME: &'static str = "CInputLatencyTestMsg";

    fn is_initialized(&self) -> bool {
        if self.input_mark.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.input_mark = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.color = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.color {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.color {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CInputLatencyTestMsg {
        CInputLatencyTestMsg::new()
    }

    fn clear(&mut self) {
        self.input_mark = ::std::option::Option::None;
        self.color = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CInputLatencyTestMsg {
        static instance: CInputLatencyTestMsg = CInputLatencyTestMsg {
            input_mark: ::std::option::Option::None,
            color: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CInputTouchFingerDownMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CInputTouchFingerDownMsg {
    // message fields
    // @@protoc_insertion_point(field:CInputTouchFingerDownMsg.input_mark)
    pub input_mark: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CInputTouchFingerDownMsg.fingerid)
    pub fingerid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CInputTouchFingerDownMsg.x_normalized)
    pub x_normalized: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CInputTouchFingerDownMsg.y_normalized)
    pub y_normalized: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CInputTouchFingerDownMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CInputTouchFingerDownMsg {
    fn default() -> &'a CInputTouchFingerDownMsg {
        <CInputTouchFingerDownMsg as ::protobuf::Message>::default_instance()
    }
}

impl CInputTouchFingerDownMsg {
    pub fn new() -> CInputTouchFingerDownMsg {
        ::std::default::Default::default()
    }

    // optional uint32 input_mark = 1;

    pub fn input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }

    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    // optional uint64 fingerid = 2;

    pub fn fingerid(&self) -> u64 {
        self.fingerid.unwrap_or(0)
    }

    pub fn clear_fingerid(&mut self) {
        self.fingerid = ::std::option::Option::None;
    }

    pub fn has_fingerid(&self) -> bool {
        self.fingerid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fingerid(&mut self, v: u64) {
        self.fingerid = ::std::option::Option::Some(v);
    }

    // optional float x_normalized = 3;

    pub fn x_normalized(&self) -> f32 {
        self.x_normalized.unwrap_or(0.)
    }

    pub fn clear_x_normalized(&mut self) {
        self.x_normalized = ::std::option::Option::None;
    }

    pub fn has_x_normalized(&self) -> bool {
        self.x_normalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x_normalized(&mut self, v: f32) {
        self.x_normalized = ::std::option::Option::Some(v);
    }

    // optional float y_normalized = 4;

    pub fn y_normalized(&self) -> f32 {
        self.y_normalized.unwrap_or(0.)
    }

    pub fn clear_y_normalized(&mut self) {
        self.y_normalized = ::std::option::Option::None;
    }

    pub fn has_y_normalized(&self) -> bool {
        self.y_normalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y_normalized(&mut self, v: f32) {
        self.y_normalized = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CInputTouchFingerDownMsg {
    const NAME: &'static str = "CInputTouchFingerDownMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.input_mark = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.fingerid = ::std::option::Option::Some(is.read_uint64()?);
                },
                29 => {
                    self.x_normalized = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.y_normalized = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.fingerid {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.x_normalized {
            my_size += 1 + 4;
        }
        if let Some(v) = self.y_normalized {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.fingerid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.x_normalized {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.y_normalized {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CInputTouchFingerDownMsg {
        CInputTouchFingerDownMsg::new()
    }

    fn clear(&mut self) {
        self.input_mark = ::std::option::Option::None;
        self.fingerid = ::std::option::Option::None;
        self.x_normalized = ::std::option::Option::None;
        self.y_normalized = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CInputTouchFingerDownMsg {
        static instance: CInputTouchFingerDownMsg = CInputTouchFingerDownMsg {
            input_mark: ::std::option::Option::None,
            fingerid: ::std::option::Option::None,
            x_normalized: ::std::option::Option::None,
            y_normalized: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CInputTouchFingerMotionMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CInputTouchFingerMotionMsg {
    // message fields
    // @@protoc_insertion_point(field:CInputTouchFingerMotionMsg.input_mark)
    pub input_mark: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CInputTouchFingerMotionMsg.fingerid)
    pub fingerid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CInputTouchFingerMotionMsg.x_normalized)
    pub x_normalized: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CInputTouchFingerMotionMsg.y_normalized)
    pub y_normalized: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CInputTouchFingerMotionMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CInputTouchFingerMotionMsg {
    fn default() -> &'a CInputTouchFingerMotionMsg {
        <CInputTouchFingerMotionMsg as ::protobuf::Message>::default_instance()
    }
}

impl CInputTouchFingerMotionMsg {
    pub fn new() -> CInputTouchFingerMotionMsg {
        ::std::default::Default::default()
    }

    // optional uint32 input_mark = 1;

    pub fn input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }

    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    // optional uint64 fingerid = 2;

    pub fn fingerid(&self) -> u64 {
        self.fingerid.unwrap_or(0)
    }

    pub fn clear_fingerid(&mut self) {
        self.fingerid = ::std::option::Option::None;
    }

    pub fn has_fingerid(&self) -> bool {
        self.fingerid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fingerid(&mut self, v: u64) {
        self.fingerid = ::std::option::Option::Some(v);
    }

    // optional float x_normalized = 3;

    pub fn x_normalized(&self) -> f32 {
        self.x_normalized.unwrap_or(0.)
    }

    pub fn clear_x_normalized(&mut self) {
        self.x_normalized = ::std::option::Option::None;
    }

    pub fn has_x_normalized(&self) -> bool {
        self.x_normalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x_normalized(&mut self, v: f32) {
        self.x_normalized = ::std::option::Option::Some(v);
    }

    // optional float y_normalized = 4;

    pub fn y_normalized(&self) -> f32 {
        self.y_normalized.unwrap_or(0.)
    }

    pub fn clear_y_normalized(&mut self) {
        self.y_normalized = ::std::option::Option::None;
    }

    pub fn has_y_normalized(&self) -> bool {
        self.y_normalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y_normalized(&mut self, v: f32) {
        self.y_normalized = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CInputTouchFingerMotionMsg {
    const NAME: &'static str = "CInputTouchFingerMotionMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.input_mark = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.fingerid = ::std::option::Option::Some(is.read_uint64()?);
                },
                29 => {
                    self.x_normalized = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.y_normalized = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.fingerid {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.x_normalized {
            my_size += 1 + 4;
        }
        if let Some(v) = self.y_normalized {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.fingerid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.x_normalized {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.y_normalized {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CInputTouchFingerMotionMsg {
        CInputTouchFingerMotionMsg::new()
    }

    fn clear(&mut self) {
        self.input_mark = ::std::option::Option::None;
        self.fingerid = ::std::option::Option::None;
        self.x_normalized = ::std::option::Option::None;
        self.y_normalized = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CInputTouchFingerMotionMsg {
        static instance: CInputTouchFingerMotionMsg = CInputTouchFingerMotionMsg {
            input_mark: ::std::option::Option::None,
            fingerid: ::std::option::Option::None,
            x_normalized: ::std::option::Option::None,
            y_normalized: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CInputTouchFingerUpMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CInputTouchFingerUpMsg {
    // message fields
    // @@protoc_insertion_point(field:CInputTouchFingerUpMsg.input_mark)
    pub input_mark: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CInputTouchFingerUpMsg.fingerid)
    pub fingerid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CInputTouchFingerUpMsg.x_normalized)
    pub x_normalized: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CInputTouchFingerUpMsg.y_normalized)
    pub y_normalized: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CInputTouchFingerUpMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CInputTouchFingerUpMsg {
    fn default() -> &'a CInputTouchFingerUpMsg {
        <CInputTouchFingerUpMsg as ::protobuf::Message>::default_instance()
    }
}

impl CInputTouchFingerUpMsg {
    pub fn new() -> CInputTouchFingerUpMsg {
        ::std::default::Default::default()
    }

    // optional uint32 input_mark = 1;

    pub fn input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }

    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    // optional uint64 fingerid = 2;

    pub fn fingerid(&self) -> u64 {
        self.fingerid.unwrap_or(0)
    }

    pub fn clear_fingerid(&mut self) {
        self.fingerid = ::std::option::Option::None;
    }

    pub fn has_fingerid(&self) -> bool {
        self.fingerid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fingerid(&mut self, v: u64) {
        self.fingerid = ::std::option::Option::Some(v);
    }

    // optional float x_normalized = 3;

    pub fn x_normalized(&self) -> f32 {
        self.x_normalized.unwrap_or(0.)
    }

    pub fn clear_x_normalized(&mut self) {
        self.x_normalized = ::std::option::Option::None;
    }

    pub fn has_x_normalized(&self) -> bool {
        self.x_normalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x_normalized(&mut self, v: f32) {
        self.x_normalized = ::std::option::Option::Some(v);
    }

    // optional float y_normalized = 4;

    pub fn y_normalized(&self) -> f32 {
        self.y_normalized.unwrap_or(0.)
    }

    pub fn clear_y_normalized(&mut self) {
        self.y_normalized = ::std::option::Option::None;
    }

    pub fn has_y_normalized(&self) -> bool {
        self.y_normalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y_normalized(&mut self, v: f32) {
        self.y_normalized = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CInputTouchFingerUpMsg {
    const NAME: &'static str = "CInputTouchFingerUpMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.input_mark = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.fingerid = ::std::option::Option::Some(is.read_uint64()?);
                },
                29 => {
                    self.x_normalized = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.y_normalized = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.fingerid {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.x_normalized {
            my_size += 1 + 4;
        }
        if let Some(v) = self.y_normalized {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.fingerid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.x_normalized {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.y_normalized {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CInputTouchFingerUpMsg {
        CInputTouchFingerUpMsg::new()
    }

    fn clear(&mut self) {
        self.input_mark = ::std::option::Option::None;
        self.fingerid = ::std::option::Option::None;
        self.x_normalized = ::std::option::Option::None;
        self.y_normalized = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CInputTouchFingerUpMsg {
        static instance: CInputTouchFingerUpMsg = CInputTouchFingerUpMsg {
            input_mark: ::std::option::Option::None,
            fingerid: ::std::option::Option::None,
            x_normalized: ::std::option::Option::None,
            y_normalized: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CInputMouseMotionMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CInputMouseMotionMsg {
    // message fields
    // @@protoc_insertion_point(field:CInputMouseMotionMsg.input_mark)
    pub input_mark: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CInputMouseMotionMsg.x_normalized)
    pub x_normalized: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CInputMouseMotionMsg.y_normalized)
    pub y_normalized: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CInputMouseMotionMsg.dx)
    pub dx: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CInputMouseMotionMsg.dy)
    pub dy: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CInputMouseMotionMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CInputMouseMotionMsg {
    fn default() -> &'a CInputMouseMotionMsg {
        <CInputMouseMotionMsg as ::protobuf::Message>::default_instance()
    }
}

impl CInputMouseMotionMsg {
    pub fn new() -> CInputMouseMotionMsg {
        ::std::default::Default::default()
    }

    // optional uint32 input_mark = 1;

    pub fn input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }

    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    // optional float x_normalized = 2;

    pub fn x_normalized(&self) -> f32 {
        self.x_normalized.unwrap_or(0.)
    }

    pub fn clear_x_normalized(&mut self) {
        self.x_normalized = ::std::option::Option::None;
    }

    pub fn has_x_normalized(&self) -> bool {
        self.x_normalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x_normalized(&mut self, v: f32) {
        self.x_normalized = ::std::option::Option::Some(v);
    }

    // optional float y_normalized = 3;

    pub fn y_normalized(&self) -> f32 {
        self.y_normalized.unwrap_or(0.)
    }

    pub fn clear_y_normalized(&mut self) {
        self.y_normalized = ::std::option::Option::None;
    }

    pub fn has_y_normalized(&self) -> bool {
        self.y_normalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y_normalized(&mut self, v: f32) {
        self.y_normalized = ::std::option::Option::Some(v);
    }

    // optional int32 dx = 4;

    pub fn dx(&self) -> i32 {
        self.dx.unwrap_or(0)
    }

    pub fn clear_dx(&mut self) {
        self.dx = ::std::option::Option::None;
    }

    pub fn has_dx(&self) -> bool {
        self.dx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dx(&mut self, v: i32) {
        self.dx = ::std::option::Option::Some(v);
    }

    // optional int32 dy = 5;

    pub fn dy(&self) -> i32 {
        self.dy.unwrap_or(0)
    }

    pub fn clear_dy(&mut self) {
        self.dy = ::std::option::Option::None;
    }

    pub fn has_dy(&self) -> bool {
        self.dy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dy(&mut self, v: i32) {
        self.dy = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CInputMouseMotionMsg {
    const NAME: &'static str = "CInputMouseMotionMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.input_mark = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.x_normalized = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.y_normalized = ::std::option::Option::Some(is.read_float()?);
                },
                32 => {
                    self.dx = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.dy = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.x_normalized {
            my_size += 1 + 4;
        }
        if let Some(v) = self.y_normalized {
            my_size += 1 + 4;
        }
        if let Some(v) = self.dx {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.dy {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x_normalized {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.y_normalized {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.dx {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.dy {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CInputMouseMotionMsg {
        CInputMouseMotionMsg::new()
    }

    fn clear(&mut self) {
        self.input_mark = ::std::option::Option::None;
        self.x_normalized = ::std::option::Option::None;
        self.y_normalized = ::std::option::Option::None;
        self.dx = ::std::option::Option::None;
        self.dy = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CInputMouseMotionMsg {
        static instance: CInputMouseMotionMsg = CInputMouseMotionMsg {
            input_mark: ::std::option::Option::None,
            x_normalized: ::std::option::Option::None,
            y_normalized: ::std::option::Option::None,
            dx: ::std::option::Option::None,
            dy: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CInputMouseWheelMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CInputMouseWheelMsg {
    // message fields
    // @@protoc_insertion_point(field:CInputMouseWheelMsg.input_mark)
    pub input_mark: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CInputMouseWheelMsg.direction)
    pub direction: ::std::option::Option<::protobuf::EnumOrUnknown<EStreamMouseWheelDirection>>,
    // special fields
    // @@protoc_insertion_point(special_field:CInputMouseWheelMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CInputMouseWheelMsg {
    fn default() -> &'a CInputMouseWheelMsg {
        <CInputMouseWheelMsg as ::protobuf::Message>::default_instance()
    }
}

impl CInputMouseWheelMsg {
    pub fn new() -> CInputMouseWheelMsg {
        ::std::default::Default::default()
    }

    // optional uint32 input_mark = 1;

    pub fn input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }

    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    // required .EStreamMouseWheelDirection direction = 2;

    pub fn direction(&self) -> EStreamMouseWheelDirection {
        match self.direction {
            Some(e) => e.enum_value_or(EStreamMouseWheelDirection::k_EStreamMouseWheelUp),
            None => EStreamMouseWheelDirection::k_EStreamMouseWheelUp,
        }
    }

    pub fn clear_direction(&mut self) {
        self.direction = ::std::option::Option::None;
    }

    pub fn has_direction(&self) -> bool {
        self.direction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: EStreamMouseWheelDirection) {
        self.direction = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::protobuf::Message for CInputMouseWheelMsg {
    const NAME: &'static str = "CInputMouseWheelMsg";

    fn is_initialized(&self) -> bool {
        if self.direction.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.input_mark = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.direction = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.direction {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.direction {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CInputMouseWheelMsg {
        CInputMouseWheelMsg::new()
    }

    fn clear(&mut self) {
        self.input_mark = ::std::option::Option::None;
        self.direction = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CInputMouseWheelMsg {
        static instance: CInputMouseWheelMsg = CInputMouseWheelMsg {
            input_mark: ::std::option::Option::None,
            direction: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CInputMouseDownMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CInputMouseDownMsg {
    // message fields
    // @@protoc_insertion_point(field:CInputMouseDownMsg.input_mark)
    pub input_mark: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CInputMouseDownMsg.button)
    pub button: ::std::option::Option<::protobuf::EnumOrUnknown<EStreamMouseButton>>,
    // special fields
    // @@protoc_insertion_point(special_field:CInputMouseDownMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CInputMouseDownMsg {
    fn default() -> &'a CInputMouseDownMsg {
        <CInputMouseDownMsg as ::protobuf::Message>::default_instance()
    }
}

impl CInputMouseDownMsg {
    pub fn new() -> CInputMouseDownMsg {
        ::std::default::Default::default()
    }

    // optional uint32 input_mark = 1;

    pub fn input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }

    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    // required .EStreamMouseButton button = 2;

    pub fn button(&self) -> EStreamMouseButton {
        match self.button {
            Some(e) => e.enum_value_or(EStreamMouseButton::k_EStreamMouseButtonLeft),
            None => EStreamMouseButton::k_EStreamMouseButtonLeft,
        }
    }

    pub fn clear_button(&mut self) {
        self.button = ::std::option::Option::None;
    }

    pub fn has_button(&self) -> bool {
        self.button.is_some()
    }

    // Param is passed by value, moved
    pub fn set_button(&mut self, v: EStreamMouseButton) {
        self.button = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::protobuf::Message for CInputMouseDownMsg {
    const NAME: &'static str = "CInputMouseDownMsg";

    fn is_initialized(&self) -> bool {
        if self.button.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.input_mark = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.button = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.button {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.button {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CInputMouseDownMsg {
        CInputMouseDownMsg::new()
    }

    fn clear(&mut self) {
        self.input_mark = ::std::option::Option::None;
        self.button = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CInputMouseDownMsg {
        static instance: CInputMouseDownMsg = CInputMouseDownMsg {
            input_mark: ::std::option::Option::None,
            button: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CInputMouseUpMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CInputMouseUpMsg {
    // message fields
    // @@protoc_insertion_point(field:CInputMouseUpMsg.input_mark)
    pub input_mark: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CInputMouseUpMsg.button)
    pub button: ::std::option::Option<::protobuf::EnumOrUnknown<EStreamMouseButton>>,
    // special fields
    // @@protoc_insertion_point(special_field:CInputMouseUpMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CInputMouseUpMsg {
    fn default() -> &'a CInputMouseUpMsg {
        <CInputMouseUpMsg as ::protobuf::Message>::default_instance()
    }
}

impl CInputMouseUpMsg {
    pub fn new() -> CInputMouseUpMsg {
        ::std::default::Default::default()
    }

    // optional uint32 input_mark = 1;

    pub fn input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }

    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    // required .EStreamMouseButton button = 2;

    pub fn button(&self) -> EStreamMouseButton {
        match self.button {
            Some(e) => e.enum_value_or(EStreamMouseButton::k_EStreamMouseButtonLeft),
            None => EStreamMouseButton::k_EStreamMouseButtonLeft,
        }
    }

    pub fn clear_button(&mut self) {
        self.button = ::std::option::Option::None;
    }

    pub fn has_button(&self) -> bool {
        self.button.is_some()
    }

    // Param is passed by value, moved
    pub fn set_button(&mut self, v: EStreamMouseButton) {
        self.button = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::protobuf::Message for CInputMouseUpMsg {
    const NAME: &'static str = "CInputMouseUpMsg";

    fn is_initialized(&self) -> bool {
        if self.button.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.input_mark = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.button = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.button {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.button {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CInputMouseUpMsg {
        CInputMouseUpMsg::new()
    }

    fn clear(&mut self) {
        self.input_mark = ::std::option::Option::None;
        self.button = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CInputMouseUpMsg {
        static instance: CInputMouseUpMsg = CInputMouseUpMsg {
            input_mark: ::std::option::Option::None,
            button: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CInputKeyDownMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CInputKeyDownMsg {
    // message fields
    // @@protoc_insertion_point(field:CInputKeyDownMsg.input_mark)
    pub input_mark: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CInputKeyDownMsg.scancode)
    pub scancode: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CInputKeyDownMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CInputKeyDownMsg {
    fn default() -> &'a CInputKeyDownMsg {
        <CInputKeyDownMsg as ::protobuf::Message>::default_instance()
    }
}

impl CInputKeyDownMsg {
    pub fn new() -> CInputKeyDownMsg {
        ::std::default::Default::default()
    }

    // optional uint32 input_mark = 1;

    pub fn input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }

    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    // required uint32 scancode = 2;

    pub fn scancode(&self) -> u32 {
        self.scancode.unwrap_or(0)
    }

    pub fn clear_scancode(&mut self) {
        self.scancode = ::std::option::Option::None;
    }

    pub fn has_scancode(&self) -> bool {
        self.scancode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scancode(&mut self, v: u32) {
        self.scancode = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CInputKeyDownMsg {
    const NAME: &'static str = "CInputKeyDownMsg";

    fn is_initialized(&self) -> bool {
        if self.scancode.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.input_mark = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.scancode = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.scancode {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.scancode {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CInputKeyDownMsg {
        CInputKeyDownMsg::new()
    }

    fn clear(&mut self) {
        self.input_mark = ::std::option::Option::None;
        self.scancode = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CInputKeyDownMsg {
        static instance: CInputKeyDownMsg = CInputKeyDownMsg {
            input_mark: ::std::option::Option::None,
            scancode: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CInputKeyUpMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CInputKeyUpMsg {
    // message fields
    // @@protoc_insertion_point(field:CInputKeyUpMsg.input_mark)
    pub input_mark: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CInputKeyUpMsg.scancode)
    pub scancode: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CInputKeyUpMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CInputKeyUpMsg {
    fn default() -> &'a CInputKeyUpMsg {
        <CInputKeyUpMsg as ::protobuf::Message>::default_instance()
    }
}

impl CInputKeyUpMsg {
    pub fn new() -> CInputKeyUpMsg {
        ::std::default::Default::default()
    }

    // optional uint32 input_mark = 1;

    pub fn input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }

    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    // required uint32 scancode = 2;

    pub fn scancode(&self) -> u32 {
        self.scancode.unwrap_or(0)
    }

    pub fn clear_scancode(&mut self) {
        self.scancode = ::std::option::Option::None;
    }

    pub fn has_scancode(&self) -> bool {
        self.scancode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scancode(&mut self, v: u32) {
        self.scancode = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CInputKeyUpMsg {
    const NAME: &'static str = "CInputKeyUpMsg";

    fn is_initialized(&self) -> bool {
        if self.scancode.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.input_mark = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.scancode = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.scancode {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.scancode {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CInputKeyUpMsg {
        CInputKeyUpMsg::new()
    }

    fn clear(&mut self) {
        self.input_mark = ::std::option::Option::None;
        self.scancode = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CInputKeyUpMsg {
        static instance: CInputKeyUpMsg = CInputKeyUpMsg {
            input_mark: ::std::option::Option::None,
            scancode: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CInputTextMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CInputTextMsg {
    // message fields
    // @@protoc_insertion_point(field:CInputTextMsg.input_mark)
    pub input_mark: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CInputTextMsg.text_utf8)
    pub text_utf8: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CInputTextMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CInputTextMsg {
    fn default() -> &'a CInputTextMsg {
        <CInputTextMsg as ::protobuf::Message>::default_instance()
    }
}

impl CInputTextMsg {
    pub fn new() -> CInputTextMsg {
        ::std::default::Default::default()
    }

    // optional uint32 input_mark = 1;

    pub fn input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }

    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    // required string text_utf8 = 2;

    pub fn text_utf8(&self) -> &str {
        match self.text_utf8.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text_utf8(&mut self) {
        self.text_utf8 = ::std::option::Option::None;
    }

    pub fn has_text_utf8(&self) -> bool {
        self.text_utf8.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text_utf8(&mut self, v: ::std::string::String) {
        self.text_utf8 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text_utf8(&mut self) -> &mut ::std::string::String {
        if self.text_utf8.is_none() {
            self.text_utf8 = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text_utf8.as_mut().unwrap()
    }

    // Take field
    pub fn take_text_utf8(&mut self) -> ::std::string::String {
        self.text_utf8.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CInputTextMsg {
    const NAME: &'static str = "CInputTextMsg";

    fn is_initialized(&self) -> bool {
        if self.text_utf8.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.input_mark = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.text_utf8 = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.text_utf8.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.text_utf8.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CInputTextMsg {
        CInputTextMsg::new()
    }

    fn clear(&mut self) {
        self.input_mark = ::std::option::Option::None;
        self.text_utf8 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CInputTextMsg {
        static instance: CInputTextMsg = CInputTextMsg {
            input_mark: ::std::option::Option::None,
            text_utf8: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSetTitleMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSetTitleMsg {
    // message fields
    // @@protoc_insertion_point(field:CSetTitleMsg.text)
    pub text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSetTitleMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSetTitleMsg {
    fn default() -> &'a CSetTitleMsg {
        <CSetTitleMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetTitleMsg {
    pub fn new() -> CSetTitleMsg {
        ::std::default::Default::default()
    }

    // optional string text = 1;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CSetTitleMsg {
    const NAME: &'static str = "CSetTitleMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.text.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSetTitleMsg {
        CSetTitleMsg::new()
    }

    fn clear(&mut self) {
        self.text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSetTitleMsg {
        static instance: CSetTitleMsg = CSetTitleMsg {
            text: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSetCaptureSizeMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSetCaptureSizeMsg {
    // message fields
    // @@protoc_insertion_point(field:CSetCaptureSizeMsg.width)
    pub width: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSetCaptureSizeMsg.height)
    pub height: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSetCaptureSizeMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSetCaptureSizeMsg {
    fn default() -> &'a CSetCaptureSizeMsg {
        <CSetCaptureSizeMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetCaptureSizeMsg {
    pub fn new() -> CSetCaptureSizeMsg {
        ::std::default::Default::default()
    }

    // optional int32 width = 1;

    pub fn width(&self) -> i32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: i32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional int32 height = 2;

    pub fn height(&self) -> i32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSetCaptureSizeMsg {
    const NAME: &'static str = "CSetCaptureSizeMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.width = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.height = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.width {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.height {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSetCaptureSizeMsg {
        CSetCaptureSizeMsg::new()
    }

    fn clear(&mut self) {
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSetCaptureSizeMsg {
        static instance: CSetCaptureSizeMsg = CSetCaptureSizeMsg {
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSetIconMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSetIconMsg {
    // message fields
    // @@protoc_insertion_point(field:CSetIconMsg.width)
    pub width: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSetIconMsg.height)
    pub height: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSetIconMsg.image)
    pub image: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CSetIconMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSetIconMsg {
    fn default() -> &'a CSetIconMsg {
        <CSetIconMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetIconMsg {
    pub fn new() -> CSetIconMsg {
        ::std::default::Default::default()
    }

    // optional int32 width = 1;

    pub fn width(&self) -> i32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: i32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional int32 height = 2;

    pub fn height(&self) -> i32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional bytes image = 3;

    pub fn image(&self) -> &[u8] {
        match self.image.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_image(&mut self) {
        self.image = ::std::option::Option::None;
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ::std::vec::Vec<u8>) {
        self.image = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.image.is_none() {
            self.image = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> ::std::vec::Vec<u8> {
        self.image.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CSetIconMsg {
    const NAME: &'static str = "CSetIconMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.width = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.height = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.image = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.image.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.width {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.height {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.image.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSetIconMsg {
        CSetIconMsg::new()
    }

    fn clear(&mut self) {
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.image = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSetIconMsg {
        static instance: CSetIconMsg = CSetIconMsg {
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            image: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSetFlashStateMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSetFlashStateMsg {
    // message fields
    // @@protoc_insertion_point(field:CSetFlashStateMsg.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSetFlashStateMsg.count)
    pub count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSetFlashStateMsg.timeout_ms)
    pub timeout_ms: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSetFlashStateMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSetFlashStateMsg {
    fn default() -> &'a CSetFlashStateMsg {
        <CSetFlashStateMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetFlashStateMsg {
    pub fn new() -> CSetFlashStateMsg {
        ::std::default::Default::default()
    }

    // optional uint32 flags = 1;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 count = 2;

    pub fn count(&self) -> u32 {
        self.count.unwrap_or(0)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional uint32 timeout_ms = 3;

    pub fn timeout_ms(&self) -> u32 {
        self.timeout_ms.unwrap_or(0)
    }

    pub fn clear_timeout_ms(&mut self) {
        self.timeout_ms = ::std::option::Option::None;
    }

    pub fn has_timeout_ms(&self) -> bool {
        self.timeout_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout_ms(&mut self, v: u32) {
        self.timeout_ms = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSetFlashStateMsg {
    const NAME: &'static str = "CSetFlashStateMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.count = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.timeout_ms = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.timeout_ms {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.flags {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.count {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.timeout_ms {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSetFlashStateMsg {
        CSetFlashStateMsg::new()
    }

    fn clear(&mut self) {
        self.flags = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.timeout_ms = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSetFlashStateMsg {
        static instance: CSetFlashStateMsg = CSetFlashStateMsg {
            flags: ::std::option::Option::None,
            count: ::std::option::Option::None,
            timeout_ms: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CShowCursorMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CShowCursorMsg {
    // message fields
    // @@protoc_insertion_point(field:CShowCursorMsg.x_normalized)
    pub x_normalized: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CShowCursorMsg.y_normalized)
    pub y_normalized: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CShowCursorMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CShowCursorMsg {
    fn default() -> &'a CShowCursorMsg {
        <CShowCursorMsg as ::protobuf::Message>::default_instance()
    }
}

impl CShowCursorMsg {
    pub fn new() -> CShowCursorMsg {
        ::std::default::Default::default()
    }

    // optional float x_normalized = 1;

    pub fn x_normalized(&self) -> f32 {
        self.x_normalized.unwrap_or(0.)
    }

    pub fn clear_x_normalized(&mut self) {
        self.x_normalized = ::std::option::Option::None;
    }

    pub fn has_x_normalized(&self) -> bool {
        self.x_normalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x_normalized(&mut self, v: f32) {
        self.x_normalized = ::std::option::Option::Some(v);
    }

    // optional float y_normalized = 2;

    pub fn y_normalized(&self) -> f32 {
        self.y_normalized.unwrap_or(0.)
    }

    pub fn clear_y_normalized(&mut self) {
        self.y_normalized = ::std::option::Option::None;
    }

    pub fn has_y_normalized(&self) -> bool {
        self.y_normalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y_normalized(&mut self, v: f32) {
        self.y_normalized = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CShowCursorMsg {
    const NAME: &'static str = "CShowCursorMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.x_normalized = ::std::option::Option::Some(is.read_float()?);
                },
                21 => {
                    self.y_normalized = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.x_normalized {
            my_size += 1 + 4;
        }
        if let Some(v) = self.y_normalized {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.x_normalized {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.y_normalized {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CShowCursorMsg {
        CShowCursorMsg::new()
    }

    fn clear(&mut self) {
        self.x_normalized = ::std::option::Option::None;
        self.y_normalized = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CShowCursorMsg {
        static instance: CShowCursorMsg = CShowCursorMsg {
            x_normalized: ::std::option::Option::None,
            y_normalized: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CHideCursorMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CHideCursorMsg {
    // special fields
    // @@protoc_insertion_point(special_field:CHideCursorMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CHideCursorMsg {
    fn default() -> &'a CHideCursorMsg {
        <CHideCursorMsg as ::protobuf::Message>::default_instance()
    }
}

impl CHideCursorMsg {
    pub fn new() -> CHideCursorMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CHideCursorMsg {
    const NAME: &'static str = "CHideCursorMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CHideCursorMsg {
        CHideCursorMsg::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CHideCursorMsg {
        static instance: CHideCursorMsg = CHideCursorMsg {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSetCursorMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSetCursorMsg {
    // message fields
    // @@protoc_insertion_point(field:CSetCursorMsg.cursor_id)
    pub cursor_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CSetCursorMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSetCursorMsg {
    fn default() -> &'a CSetCursorMsg {
        <CSetCursorMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetCursorMsg {
    pub fn new() -> CSetCursorMsg {
        ::std::default::Default::default()
    }

    // required uint64 cursor_id = 1;

    pub fn cursor_id(&self) -> u64 {
        self.cursor_id.unwrap_or(0)
    }

    pub fn clear_cursor_id(&mut self) {
        self.cursor_id = ::std::option::Option::None;
    }

    pub fn has_cursor_id(&self) -> bool {
        self.cursor_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cursor_id(&mut self, v: u64) {
        self.cursor_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSetCursorMsg {
    const NAME: &'static str = "CSetCursorMsg";

    fn is_initialized(&self) -> bool {
        if self.cursor_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.cursor_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cursor_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cursor_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSetCursorMsg {
        CSetCursorMsg::new()
    }

    fn clear(&mut self) {
        self.cursor_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSetCursorMsg {
        static instance: CSetCursorMsg = CSetCursorMsg {
            cursor_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGetCursorImageMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGetCursorImageMsg {
    // message fields
    // @@protoc_insertion_point(field:CGetCursorImageMsg.cursor_id)
    pub cursor_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CGetCursorImageMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGetCursorImageMsg {
    fn default() -> &'a CGetCursorImageMsg {
        <CGetCursorImageMsg as ::protobuf::Message>::default_instance()
    }
}

impl CGetCursorImageMsg {
    pub fn new() -> CGetCursorImageMsg {
        ::std::default::Default::default()
    }

    // required uint64 cursor_id = 1;

    pub fn cursor_id(&self) -> u64 {
        self.cursor_id.unwrap_or(0)
    }

    pub fn clear_cursor_id(&mut self) {
        self.cursor_id = ::std::option::Option::None;
    }

    pub fn has_cursor_id(&self) -> bool {
        self.cursor_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cursor_id(&mut self, v: u64) {
        self.cursor_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CGetCursorImageMsg {
    const NAME: &'static str = "CGetCursorImageMsg";

    fn is_initialized(&self) -> bool {
        if self.cursor_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.cursor_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cursor_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cursor_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGetCursorImageMsg {
        CGetCursorImageMsg::new()
    }

    fn clear(&mut self) {
        self.cursor_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGetCursorImageMsg {
        static instance: CGetCursorImageMsg = CGetCursorImageMsg {
            cursor_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSetCursorImageMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSetCursorImageMsg {
    // message fields
    // @@protoc_insertion_point(field:CSetCursorImageMsg.cursor_id)
    pub cursor_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSetCursorImageMsg.width)
    pub width: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSetCursorImageMsg.height)
    pub height: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSetCursorImageMsg.hot_x)
    pub hot_x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSetCursorImageMsg.hot_y)
    pub hot_y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSetCursorImageMsg.image)
    pub image: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CSetCursorImageMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSetCursorImageMsg {
    fn default() -> &'a CSetCursorImageMsg {
        <CSetCursorImageMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetCursorImageMsg {
    pub fn new() -> CSetCursorImageMsg {
        ::std::default::Default::default()
    }

    // required uint64 cursor_id = 1;

    pub fn cursor_id(&self) -> u64 {
        self.cursor_id.unwrap_or(0)
    }

    pub fn clear_cursor_id(&mut self) {
        self.cursor_id = ::std::option::Option::None;
    }

    pub fn has_cursor_id(&self) -> bool {
        self.cursor_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cursor_id(&mut self, v: u64) {
        self.cursor_id = ::std::option::Option::Some(v);
    }

    // optional int32 width = 2;

    pub fn width(&self) -> i32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: i32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional int32 height = 3;

    pub fn height(&self) -> i32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional int32 hot_x = 4;

    pub fn hot_x(&self) -> i32 {
        self.hot_x.unwrap_or(0)
    }

    pub fn clear_hot_x(&mut self) {
        self.hot_x = ::std::option::Option::None;
    }

    pub fn has_hot_x(&self) -> bool {
        self.hot_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hot_x(&mut self, v: i32) {
        self.hot_x = ::std::option::Option::Some(v);
    }

    // optional int32 hot_y = 5;

    pub fn hot_y(&self) -> i32 {
        self.hot_y.unwrap_or(0)
    }

    pub fn clear_hot_y(&mut self) {
        self.hot_y = ::std::option::Option::None;
    }

    pub fn has_hot_y(&self) -> bool {
        self.hot_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hot_y(&mut self, v: i32) {
        self.hot_y = ::std::option::Option::Some(v);
    }

    // optional bytes image = 6;

    pub fn image(&self) -> &[u8] {
        match self.image.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_image(&mut self) {
        self.image = ::std::option::Option::None;
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ::std::vec::Vec<u8>) {
        self.image = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.image.is_none() {
            self.image = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> ::std::vec::Vec<u8> {
        self.image.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CSetCursorImageMsg {
    const NAME: &'static str = "CSetCursorImageMsg";

    fn is_initialized(&self) -> bool {
        if self.cursor_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.cursor_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.width = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.height = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.hot_x = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.hot_y = ::std::option::Option::Some(is.read_int32()?);
                },
                50 => {
                    self.image = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cursor_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.hot_x {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.hot_y {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.image.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cursor_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.width {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.height {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.hot_x {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.hot_y {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.image.as_ref() {
            os.write_bytes(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSetCursorImageMsg {
        CSetCursorImageMsg::new()
    }

    fn clear(&mut self) {
        self.cursor_id = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.hot_x = ::std::option::Option::None;
        self.hot_y = ::std::option::Option::None;
        self.image = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSetCursorImageMsg {
        static instance: CSetCursorImageMsg = CSetCursorImageMsg {
            cursor_id: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            hot_x: ::std::option::Option::None,
            hot_y: ::std::option::Option::None,
            image: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CVideoDecoderInfoMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CVideoDecoderInfoMsg {
    // message fields
    // @@protoc_insertion_point(field:CVideoDecoderInfoMsg.info)
    pub info: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CVideoDecoderInfoMsg.threads)
    pub threads: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CVideoDecoderInfoMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CVideoDecoderInfoMsg {
    fn default() -> &'a CVideoDecoderInfoMsg {
        <CVideoDecoderInfoMsg as ::protobuf::Message>::default_instance()
    }
}

impl CVideoDecoderInfoMsg {
    pub fn new() -> CVideoDecoderInfoMsg {
        ::std::default::Default::default()
    }

    // optional string info = 1;

    pub fn info(&self) -> &str {
        match self.info.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_info(&mut self) {
        self.info = ::std::option::Option::None;
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: ::std::string::String) {
        self.info = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut ::std::string::String {
        if self.info.is_none() {
            self.info = ::std::option::Option::Some(::std::string::String::new());
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> ::std::string::String {
        self.info.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 threads = 2;

    pub fn threads(&self) -> i32 {
        self.threads.unwrap_or(0)
    }

    pub fn clear_threads(&mut self) {
        self.threads = ::std::option::Option::None;
    }

    pub fn has_threads(&self) -> bool {
        self.threads.is_some()
    }

    // Param is passed by value, moved
    pub fn set_threads(&mut self, v: i32) {
        self.threads = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CVideoDecoderInfoMsg {
    const NAME: &'static str = "CVideoDecoderInfoMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.info = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.threads = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.info.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.threads {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.info.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.threads {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CVideoDecoderInfoMsg {
        CVideoDecoderInfoMsg::new()
    }

    fn clear(&mut self) {
        self.info = ::std::option::Option::None;
        self.threads = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CVideoDecoderInfoMsg {
        static instance: CVideoDecoderInfoMsg = CVideoDecoderInfoMsg {
            info: ::std::option::Option::None,
            threads: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CVideoEncoderInfoMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CVideoEncoderInfoMsg {
    // message fields
    // @@protoc_insertion_point(field:CVideoEncoderInfoMsg.info)
    pub info: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CVideoEncoderInfoMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CVideoEncoderInfoMsg {
    fn default() -> &'a CVideoEncoderInfoMsg {
        <CVideoEncoderInfoMsg as ::protobuf::Message>::default_instance()
    }
}

impl CVideoEncoderInfoMsg {
    pub fn new() -> CVideoEncoderInfoMsg {
        ::std::default::Default::default()
    }

    // optional string info = 1;

    pub fn info(&self) -> &str {
        match self.info.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_info(&mut self) {
        self.info = ::std::option::Option::None;
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: ::std::string::String) {
        self.info = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut ::std::string::String {
        if self.info.is_none() {
            self.info = ::std::option::Option::Some(::std::string::String::new());
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> ::std::string::String {
        self.info.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CVideoEncoderInfoMsg {
    const NAME: &'static str = "CVideoEncoderInfoMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.info = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.info.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.info.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CVideoEncoderInfoMsg {
        CVideoEncoderInfoMsg::new()
    }

    fn clear(&mut self) {
        self.info = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CVideoEncoderInfoMsg {
        static instance: CVideoEncoderInfoMsg = CVideoEncoderInfoMsg {
            info: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CPauseMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CPauseMsg {
    // special fields
    // @@protoc_insertion_point(special_field:CPauseMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CPauseMsg {
    fn default() -> &'a CPauseMsg {
        <CPauseMsg as ::protobuf::Message>::default_instance()
    }
}

impl CPauseMsg {
    pub fn new() -> CPauseMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPauseMsg {
    const NAME: &'static str = "CPauseMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CPauseMsg {
        CPauseMsg::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CPauseMsg {
        static instance: CPauseMsg = CPauseMsg {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CResumeMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CResumeMsg {
    // special fields
    // @@protoc_insertion_point(special_field:CResumeMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CResumeMsg {
    fn default() -> &'a CResumeMsg {
        <CResumeMsg as ::protobuf::Message>::default_instance()
    }
}

impl CResumeMsg {
    pub fn new() -> CResumeMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CResumeMsg {
    const NAME: &'static str = "CResumeMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CResumeMsg {
        CResumeMsg::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CResumeMsg {
        static instance: CResumeMsg = CResumeMsg {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CEnableHighResCaptureMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CEnableHighResCaptureMsg {
    // special fields
    // @@protoc_insertion_point(special_field:CEnableHighResCaptureMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CEnableHighResCaptureMsg {
    fn default() -> &'a CEnableHighResCaptureMsg {
        <CEnableHighResCaptureMsg as ::protobuf::Message>::default_instance()
    }
}

impl CEnableHighResCaptureMsg {
    pub fn new() -> CEnableHighResCaptureMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CEnableHighResCaptureMsg {
    const NAME: &'static str = "CEnableHighResCaptureMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CEnableHighResCaptureMsg {
        CEnableHighResCaptureMsg::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CEnableHighResCaptureMsg {
        static instance: CEnableHighResCaptureMsg = CEnableHighResCaptureMsg {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDisableHighResCaptureMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDisableHighResCaptureMsg {
    // special fields
    // @@protoc_insertion_point(special_field:CDisableHighResCaptureMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDisableHighResCaptureMsg {
    fn default() -> &'a CDisableHighResCaptureMsg {
        <CDisableHighResCaptureMsg as ::protobuf::Message>::default_instance()
    }
}

impl CDisableHighResCaptureMsg {
    pub fn new() -> CDisableHighResCaptureMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CDisableHighResCaptureMsg {
    const NAME: &'static str = "CDisableHighResCaptureMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDisableHighResCaptureMsg {
        CDisableHighResCaptureMsg::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDisableHighResCaptureMsg {
        static instance: CDisableHighResCaptureMsg = CDisableHighResCaptureMsg {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CEnableNeptuneDataMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CEnableNeptuneDataMsg {
    // special fields
    // @@protoc_insertion_point(special_field:CEnableNeptuneDataMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CEnableNeptuneDataMsg {
    fn default() -> &'a CEnableNeptuneDataMsg {
        <CEnableNeptuneDataMsg as ::protobuf::Message>::default_instance()
    }
}

impl CEnableNeptuneDataMsg {
    pub fn new() -> CEnableNeptuneDataMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CEnableNeptuneDataMsg {
    const NAME: &'static str = "CEnableNeptuneDataMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CEnableNeptuneDataMsg {
        CEnableNeptuneDataMsg::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CEnableNeptuneDataMsg {
        static instance: CEnableNeptuneDataMsg = CEnableNeptuneDataMsg {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDisableNeptuneDataMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDisableNeptuneDataMsg {
    // special fields
    // @@protoc_insertion_point(special_field:CDisableNeptuneDataMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDisableNeptuneDataMsg {
    fn default() -> &'a CDisableNeptuneDataMsg {
        <CDisableNeptuneDataMsg as ::protobuf::Message>::default_instance()
    }
}

impl CDisableNeptuneDataMsg {
    pub fn new() -> CDisableNeptuneDataMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CDisableNeptuneDataMsg {
    const NAME: &'static str = "CDisableNeptuneDataMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDisableNeptuneDataMsg {
        CDisableNeptuneDataMsg::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDisableNeptuneDataMsg {
        static instance: CDisableNeptuneDataMsg = CDisableNeptuneDataMsg {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CPauseControllerInputMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CPauseControllerInputMsg {
    // special fields
    // @@protoc_insertion_point(special_field:CPauseControllerInputMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CPauseControllerInputMsg {
    fn default() -> &'a CPauseControllerInputMsg {
        <CPauseControllerInputMsg as ::protobuf::Message>::default_instance()
    }
}

impl CPauseControllerInputMsg {
    pub fn new() -> CPauseControllerInputMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPauseControllerInputMsg {
    const NAME: &'static str = "CPauseControllerInputMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CPauseControllerInputMsg {
        CPauseControllerInputMsg::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CPauseControllerInputMsg {
        static instance: CPauseControllerInputMsg = CPauseControllerInputMsg {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CResumeControllerInputMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CResumeControllerInputMsg {
    // special fields
    // @@protoc_insertion_point(special_field:CResumeControllerInputMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CResumeControllerInputMsg {
    fn default() -> &'a CResumeControllerInputMsg {
        <CResumeControllerInputMsg as ::protobuf::Message>::default_instance()
    }
}

impl CResumeControllerInputMsg {
    pub fn new() -> CResumeControllerInputMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CResumeControllerInputMsg {
    const NAME: &'static str = "CResumeControllerInputMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CResumeControllerInputMsg {
        CResumeControllerInputMsg::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CResumeControllerInputMsg {
        static instance: CResumeControllerInputMsg = CResumeControllerInputMsg {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CToggleMagnificationMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CToggleMagnificationMsg {
    // special fields
    // @@protoc_insertion_point(special_field:CToggleMagnificationMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CToggleMagnificationMsg {
    fn default() -> &'a CToggleMagnificationMsg {
        <CToggleMagnificationMsg as ::protobuf::Message>::default_instance()
    }
}

impl CToggleMagnificationMsg {
    pub fn new() -> CToggleMagnificationMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CToggleMagnificationMsg {
    const NAME: &'static str = "CToggleMagnificationMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CToggleMagnificationMsg {
        CToggleMagnificationMsg::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CToggleMagnificationMsg {
        static instance: CToggleMagnificationMsg = CToggleMagnificationMsg {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSetCapslockMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSetCapslockMsg {
    // message fields
    // @@protoc_insertion_point(field:CSetCapslockMsg.pressed)
    pub pressed: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSetCapslockMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSetCapslockMsg {
    fn default() -> &'a CSetCapslockMsg {
        <CSetCapslockMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetCapslockMsg {
    pub fn new() -> CSetCapslockMsg {
        ::std::default::Default::default()
    }

    // optional bool pressed = 1;

    pub fn pressed(&self) -> bool {
        self.pressed.unwrap_or(false)
    }

    pub fn clear_pressed(&mut self) {
        self.pressed = ::std::option::Option::None;
    }

    pub fn has_pressed(&self) -> bool {
        self.pressed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pressed(&mut self, v: bool) {
        self.pressed = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSetCapslockMsg {
    const NAME: &'static str = "CSetCapslockMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.pressed = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pressed {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pressed {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSetCapslockMsg {
        CSetCapslockMsg::new()
    }

    fn clear(&mut self) {
        self.pressed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSetCapslockMsg {
        static instance: CSetCapslockMsg = CSetCapslockMsg {
            pressed: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CStreamingKeymapEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStreamingKeymapEntry {
    // message fields
    // @@protoc_insertion_point(field:CStreamingKeymapEntry.scancode)
    pub scancode: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CStreamingKeymapEntry.normal_keycode)
    pub normal_keycode: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CStreamingKeymapEntry.shift_keycode)
    pub shift_keycode: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CStreamingKeymapEntry.capslock_keycode)
    pub capslock_keycode: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CStreamingKeymapEntry.shift_capslock_keycode)
    pub shift_capslock_keycode: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CStreamingKeymapEntry.altgr_keycode)
    pub altgr_keycode: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CStreamingKeymapEntry.altgr_shift_keycode)
    pub altgr_shift_keycode: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CStreamingKeymapEntry.altgr_capslock_keycode)
    pub altgr_capslock_keycode: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CStreamingKeymapEntry.altgr_shift_capslock_keycode)
    pub altgr_shift_capslock_keycode: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CStreamingKeymapEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStreamingKeymapEntry {
    fn default() -> &'a CStreamingKeymapEntry {
        <CStreamingKeymapEntry as ::protobuf::Message>::default_instance()
    }
}

impl CStreamingKeymapEntry {
    pub fn new() -> CStreamingKeymapEntry {
        ::std::default::Default::default()
    }

    // optional int32 scancode = 1;

    pub fn scancode(&self) -> i32 {
        self.scancode.unwrap_or(0)
    }

    pub fn clear_scancode(&mut self) {
        self.scancode = ::std::option::Option::None;
    }

    pub fn has_scancode(&self) -> bool {
        self.scancode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scancode(&mut self, v: i32) {
        self.scancode = ::std::option::Option::Some(v);
    }

    // optional int32 normal_keycode = 2;

    pub fn normal_keycode(&self) -> i32 {
        self.normal_keycode.unwrap_or(0)
    }

    pub fn clear_normal_keycode(&mut self) {
        self.normal_keycode = ::std::option::Option::None;
    }

    pub fn has_normal_keycode(&self) -> bool {
        self.normal_keycode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_normal_keycode(&mut self, v: i32) {
        self.normal_keycode = ::std::option::Option::Some(v);
    }

    // optional int32 shift_keycode = 3;

    pub fn shift_keycode(&self) -> i32 {
        self.shift_keycode.unwrap_or(0)
    }

    pub fn clear_shift_keycode(&mut self) {
        self.shift_keycode = ::std::option::Option::None;
    }

    pub fn has_shift_keycode(&self) -> bool {
        self.shift_keycode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shift_keycode(&mut self, v: i32) {
        self.shift_keycode = ::std::option::Option::Some(v);
    }

    // optional int32 capslock_keycode = 4;

    pub fn capslock_keycode(&self) -> i32 {
        self.capslock_keycode.unwrap_or(0)
    }

    pub fn clear_capslock_keycode(&mut self) {
        self.capslock_keycode = ::std::option::Option::None;
    }

    pub fn has_capslock_keycode(&self) -> bool {
        self.capslock_keycode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_capslock_keycode(&mut self, v: i32) {
        self.capslock_keycode = ::std::option::Option::Some(v);
    }

    // optional int32 shift_capslock_keycode = 5;

    pub fn shift_capslock_keycode(&self) -> i32 {
        self.shift_capslock_keycode.unwrap_or(0)
    }

    pub fn clear_shift_capslock_keycode(&mut self) {
        self.shift_capslock_keycode = ::std::option::Option::None;
    }

    pub fn has_shift_capslock_keycode(&self) -> bool {
        self.shift_capslock_keycode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shift_capslock_keycode(&mut self, v: i32) {
        self.shift_capslock_keycode = ::std::option::Option::Some(v);
    }

    // optional int32 altgr_keycode = 6;

    pub fn altgr_keycode(&self) -> i32 {
        self.altgr_keycode.unwrap_or(0)
    }

    pub fn clear_altgr_keycode(&mut self) {
        self.altgr_keycode = ::std::option::Option::None;
    }

    pub fn has_altgr_keycode(&self) -> bool {
        self.altgr_keycode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_altgr_keycode(&mut self, v: i32) {
        self.altgr_keycode = ::std::option::Option::Some(v);
    }

    // optional int32 altgr_shift_keycode = 7;

    pub fn altgr_shift_keycode(&self) -> i32 {
        self.altgr_shift_keycode.unwrap_or(0)
    }

    pub fn clear_altgr_shift_keycode(&mut self) {
        self.altgr_shift_keycode = ::std::option::Option::None;
    }

    pub fn has_altgr_shift_keycode(&self) -> bool {
        self.altgr_shift_keycode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_altgr_shift_keycode(&mut self, v: i32) {
        self.altgr_shift_keycode = ::std::option::Option::Some(v);
    }

    // optional int32 altgr_capslock_keycode = 8;

    pub fn altgr_capslock_keycode(&self) -> i32 {
        self.altgr_capslock_keycode.unwrap_or(0)
    }

    pub fn clear_altgr_capslock_keycode(&mut self) {
        self.altgr_capslock_keycode = ::std::option::Option::None;
    }

    pub fn has_altgr_capslock_keycode(&self) -> bool {
        self.altgr_capslock_keycode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_altgr_capslock_keycode(&mut self, v: i32) {
        self.altgr_capslock_keycode = ::std::option::Option::Some(v);
    }

    // optional int32 altgr_shift_capslock_keycode = 9;

    pub fn altgr_shift_capslock_keycode(&self) -> i32 {
        self.altgr_shift_capslock_keycode.unwrap_or(0)
    }

    pub fn clear_altgr_shift_capslock_keycode(&mut self) {
        self.altgr_shift_capslock_keycode = ::std::option::Option::None;
    }

    pub fn has_altgr_shift_capslock_keycode(&self) -> bool {
        self.altgr_shift_capslock_keycode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_altgr_shift_capslock_keycode(&mut self, v: i32) {
        self.altgr_shift_capslock_keycode = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CStreamingKeymapEntry {
    const NAME: &'static str = "CStreamingKeymapEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.scancode = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.normal_keycode = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.shift_keycode = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.capslock_keycode = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.shift_capslock_keycode = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.altgr_keycode = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.altgr_shift_keycode = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.altgr_capslock_keycode = ::std::option::Option::Some(is.read_int32()?);
                },
                72 => {
                    self.altgr_shift_capslock_keycode = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.scancode {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.normal_keycode {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.shift_keycode {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.capslock_keycode {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.shift_capslock_keycode {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.altgr_keycode {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.altgr_shift_keycode {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.altgr_capslock_keycode {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.altgr_shift_capslock_keycode {
            my_size += ::protobuf::rt::int32_size(9, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.scancode {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.normal_keycode {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.shift_keycode {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.capslock_keycode {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.shift_capslock_keycode {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.altgr_keycode {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.altgr_shift_keycode {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.altgr_capslock_keycode {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.altgr_shift_capslock_keycode {
            os.write_int32(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStreamingKeymapEntry {
        CStreamingKeymapEntry::new()
    }

    fn clear(&mut self) {
        self.scancode = ::std::option::Option::None;
        self.normal_keycode = ::std::option::Option::None;
        self.shift_keycode = ::std::option::Option::None;
        self.capslock_keycode = ::std::option::Option::None;
        self.shift_capslock_keycode = ::std::option::Option::None;
        self.altgr_keycode = ::std::option::Option::None;
        self.altgr_shift_keycode = ::std::option::Option::None;
        self.altgr_capslock_keycode = ::std::option::Option::None;
        self.altgr_shift_capslock_keycode = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStreamingKeymapEntry {
        static instance: CStreamingKeymapEntry = CStreamingKeymapEntry {
            scancode: ::std::option::Option::None,
            normal_keycode: ::std::option::Option::None,
            shift_keycode: ::std::option::Option::None,
            capslock_keycode: ::std::option::Option::None,
            shift_capslock_keycode: ::std::option::Option::None,
            altgr_keycode: ::std::option::Option::None,
            altgr_shift_keycode: ::std::option::Option::None,
            altgr_capslock_keycode: ::std::option::Option::None,
            altgr_shift_capslock_keycode: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CStreamingKeymap)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStreamingKeymap {
    // message fields
    // @@protoc_insertion_point(field:CStreamingKeymap.entries)
    pub entries: ::std::vec::Vec<CStreamingKeymapEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:CStreamingKeymap.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStreamingKeymap {
    fn default() -> &'a CStreamingKeymap {
        <CStreamingKeymap as ::protobuf::Message>::default_instance()
    }
}

impl CStreamingKeymap {
    pub fn new() -> CStreamingKeymap {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CStreamingKeymap {
    const NAME: &'static str = "CStreamingKeymap";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.entries.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.entries {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStreamingKeymap {
        CStreamingKeymap::new()
    }

    fn clear(&mut self) {
        self.entries.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStreamingKeymap {
        static instance: CStreamingKeymap = CStreamingKeymap {
            entries: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSetKeymapMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSetKeymapMsg {
    // message fields
    // @@protoc_insertion_point(field:CSetKeymapMsg.keymap)
    pub keymap: ::protobuf::MessageField<CStreamingKeymap>,
    // special fields
    // @@protoc_insertion_point(special_field:CSetKeymapMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSetKeymapMsg {
    fn default() -> &'a CSetKeymapMsg {
        <CSetKeymapMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetKeymapMsg {
    pub fn new() -> CSetKeymapMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CSetKeymapMsg {
    const NAME: &'static str = "CSetKeymapMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.keymap)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.keymap.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.keymap.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSetKeymapMsg {
        CSetKeymapMsg::new()
    }

    fn clear(&mut self) {
        self.keymap.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSetKeymapMsg {
        static instance: CSetKeymapMsg = CSetKeymapMsg {
            keymap: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CStopRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStopRequest {
    // special fields
    // @@protoc_insertion_point(special_field:CStopRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStopRequest {
    fn default() -> &'a CStopRequest {
        <CStopRequest as ::protobuf::Message>::default_instance()
    }
}

impl CStopRequest {
    pub fn new() -> CStopRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CStopRequest {
    const NAME: &'static str = "CStopRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStopRequest {
        CStopRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStopRequest {
        static instance: CStopRequest = CStopRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CQuitRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CQuitRequest {
    // special fields
    // @@protoc_insertion_point(special_field:CQuitRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CQuitRequest {
    fn default() -> &'a CQuitRequest {
        <CQuitRequest as ::protobuf::Message>::default_instance()
    }
}

impl CQuitRequest {
    pub fn new() -> CQuitRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CQuitRequest {
    const NAME: &'static str = "CQuitRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CQuitRequest {
        CQuitRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CQuitRequest {
        static instance: CQuitRequest = CQuitRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDeleteCursorMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDeleteCursorMsg {
    // message fields
    // @@protoc_insertion_point(field:CDeleteCursorMsg.cursor_id)
    pub cursor_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CDeleteCursorMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDeleteCursorMsg {
    fn default() -> &'a CDeleteCursorMsg {
        <CDeleteCursorMsg as ::protobuf::Message>::default_instance()
    }
}

impl CDeleteCursorMsg {
    pub fn new() -> CDeleteCursorMsg {
        ::std::default::Default::default()
    }

    // required uint64 cursor_id = 1;

    pub fn cursor_id(&self) -> u64 {
        self.cursor_id.unwrap_or(0)
    }

    pub fn clear_cursor_id(&mut self) {
        self.cursor_id = ::std::option::Option::None;
    }

    pub fn has_cursor_id(&self) -> bool {
        self.cursor_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cursor_id(&mut self, v: u64) {
        self.cursor_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CDeleteCursorMsg {
    const NAME: &'static str = "CDeleteCursorMsg";

    fn is_initialized(&self) -> bool {
        if self.cursor_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.cursor_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cursor_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cursor_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDeleteCursorMsg {
        CDeleteCursorMsg::new()
    }

    fn clear(&mut self) {
        self.cursor_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDeleteCursorMsg {
        static instance: CDeleteCursorMsg = CDeleteCursorMsg {
            cursor_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSetStreamingClientConfig)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSetStreamingClientConfig {
    // message fields
    // @@protoc_insertion_point(field:CSetStreamingClientConfig.config)
    pub config: ::protobuf::MessageField<CStreamingClientConfig>,
    // special fields
    // @@protoc_insertion_point(special_field:CSetStreamingClientConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSetStreamingClientConfig {
    fn default() -> &'a CSetStreamingClientConfig {
        <CSetStreamingClientConfig as ::protobuf::Message>::default_instance()
    }
}

impl CSetStreamingClientConfig {
    pub fn new() -> CSetStreamingClientConfig {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CSetStreamingClientConfig {
    const NAME: &'static str = "CSetStreamingClientConfig";

    fn is_initialized(&self) -> bool {
        if self.config.is_none() {
            return false;
        }
        for v in &self.config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.config)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.config.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSetStreamingClientConfig {
        CSetStreamingClientConfig::new()
    }

    fn clear(&mut self) {
        self.config.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSetStreamingClientConfig {
        static instance: CSetStreamingClientConfig = CSetStreamingClientConfig {
            config: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSetQoSMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSetQoSMsg {
    // message fields
    // @@protoc_insertion_point(field:CSetQoSMsg.use_qos)
    pub use_qos: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSetQoSMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSetQoSMsg {
    fn default() -> &'a CSetQoSMsg {
        <CSetQoSMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetQoSMsg {
    pub fn new() -> CSetQoSMsg {
        ::std::default::Default::default()
    }

    // required bool use_qos = 1;

    pub fn use_qos(&self) -> bool {
        self.use_qos.unwrap_or(false)
    }

    pub fn clear_use_qos(&mut self) {
        self.use_qos = ::std::option::Option::None;
    }

    pub fn has_use_qos(&self) -> bool {
        self.use_qos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_qos(&mut self, v: bool) {
        self.use_qos = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSetQoSMsg {
    const NAME: &'static str = "CSetQoSMsg";

    fn is_initialized(&self) -> bool {
        if self.use_qos.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.use_qos = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.use_qos {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.use_qos {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSetQoSMsg {
        CSetQoSMsg::new()
    }

    fn clear(&mut self) {
        self.use_qos = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSetQoSMsg {
        static instance: CSetQoSMsg = CSetQoSMsg {
            use_qos: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSetTargetFramerateMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSetTargetFramerateMsg {
    // message fields
    // @@protoc_insertion_point(field:CSetTargetFramerateMsg.framerate)
    pub framerate: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSetTargetFramerateMsg.reasons)
    pub reasons: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSetTargetFramerateMsg.framerate_numerator)
    pub framerate_numerator: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSetTargetFramerateMsg.framerate_denominator)
    pub framerate_denominator: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSetTargetFramerateMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSetTargetFramerateMsg {
    fn default() -> &'a CSetTargetFramerateMsg {
        <CSetTargetFramerateMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetTargetFramerateMsg {
    pub fn new() -> CSetTargetFramerateMsg {
        ::std::default::Default::default()
    }

    // required uint32 framerate = 1;

    pub fn framerate(&self) -> u32 {
        self.framerate.unwrap_or(0)
    }

    pub fn clear_framerate(&mut self) {
        self.framerate = ::std::option::Option::None;
    }

    pub fn has_framerate(&self) -> bool {
        self.framerate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_framerate(&mut self, v: u32) {
        self.framerate = ::std::option::Option::Some(v);
    }

    // optional uint32 reasons = 2;

    pub fn reasons(&self) -> u32 {
        self.reasons.unwrap_or(0)
    }

    pub fn clear_reasons(&mut self) {
        self.reasons = ::std::option::Option::None;
    }

    pub fn has_reasons(&self) -> bool {
        self.reasons.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reasons(&mut self, v: u32) {
        self.reasons = ::std::option::Option::Some(v);
    }

    // optional uint32 framerate_numerator = 3;

    pub fn framerate_numerator(&self) -> u32 {
        self.framerate_numerator.unwrap_or(0)
    }

    pub fn clear_framerate_numerator(&mut self) {
        self.framerate_numerator = ::std::option::Option::None;
    }

    pub fn has_framerate_numerator(&self) -> bool {
        self.framerate_numerator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_framerate_numerator(&mut self, v: u32) {
        self.framerate_numerator = ::std::option::Option::Some(v);
    }

    // optional uint32 framerate_denominator = 4;

    pub fn framerate_denominator(&self) -> u32 {
        self.framerate_denominator.unwrap_or(0)
    }

    pub fn clear_framerate_denominator(&mut self) {
        self.framerate_denominator = ::std::option::Option::None;
    }

    pub fn has_framerate_denominator(&self) -> bool {
        self.framerate_denominator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_framerate_denominator(&mut self, v: u32) {
        self.framerate_denominator = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSetTargetFramerateMsg {
    const NAME: &'static str = "CSetTargetFramerateMsg";

    fn is_initialized(&self) -> bool {
        if self.framerate.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.framerate = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.reasons = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.framerate_numerator = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.framerate_denominator = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.framerate {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.reasons {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.framerate_numerator {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.framerate_denominator {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.framerate {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.reasons {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.framerate_numerator {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.framerate_denominator {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSetTargetFramerateMsg {
        CSetTargetFramerateMsg::new()
    }

    fn clear(&mut self) {
        self.framerate = ::std::option::Option::None;
        self.reasons = ::std::option::Option::None;
        self.framerate_numerator = ::std::option::Option::None;
        self.framerate_denominator = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSetTargetFramerateMsg {
        static instance: CSetTargetFramerateMsg = CSetTargetFramerateMsg {
            framerate: ::std::option::Option::None,
            reasons: ::std::option::Option::None,
            framerate_numerator: ::std::option::Option::None,
            framerate_denominator: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSetTargetBitrateMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSetTargetBitrateMsg {
    // message fields
    // @@protoc_insertion_point(field:CSetTargetBitrateMsg.bitrate)
    pub bitrate: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSetTargetBitrateMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSetTargetBitrateMsg {
    fn default() -> &'a CSetTargetBitrateMsg {
        <CSetTargetBitrateMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetTargetBitrateMsg {
    pub fn new() -> CSetTargetBitrateMsg {
        ::std::default::Default::default()
    }

    // required int32 bitrate = 1;

    pub fn bitrate(&self) -> i32 {
        self.bitrate.unwrap_or(0)
    }

    pub fn clear_bitrate(&mut self) {
        self.bitrate = ::std::option::Option::None;
    }

    pub fn has_bitrate(&self) -> bool {
        self.bitrate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bitrate(&mut self, v: i32) {
        self.bitrate = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSetTargetBitrateMsg {
    const NAME: &'static str = "CSetTargetBitrateMsg";

    fn is_initialized(&self) -> bool {
        if self.bitrate.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.bitrate = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.bitrate {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.bitrate {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSetTargetBitrateMsg {
        CSetTargetBitrateMsg::new()
    }

    fn clear(&mut self) {
        self.bitrate = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSetTargetBitrateMsg {
        static instance: CSetTargetBitrateMsg = CSetTargetBitrateMsg {
            bitrate: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:COverlayEnabledMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct COverlayEnabledMsg {
    // message fields
    // @@protoc_insertion_point(field:COverlayEnabledMsg.enabled)
    pub enabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:COverlayEnabledMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a COverlayEnabledMsg {
    fn default() -> &'a COverlayEnabledMsg {
        <COverlayEnabledMsg as ::protobuf::Message>::default_instance()
    }
}

impl COverlayEnabledMsg {
    pub fn new() -> COverlayEnabledMsg {
        ::std::default::Default::default()
    }

    // required bool enabled = 1;

    pub fn enabled(&self) -> bool {
        self.enabled.unwrap_or(false)
    }

    pub fn clear_enabled(&mut self) {
        self.enabled = ::std::option::Option::None;
    }

    pub fn has_enabled(&self) -> bool {
        self.enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for COverlayEnabledMsg {
    const NAME: &'static str = "COverlayEnabledMsg";

    fn is_initialized(&self) -> bool {
        if self.enabled.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.enabled {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.enabled {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> COverlayEnabledMsg {
        COverlayEnabledMsg::new()
    }

    fn clear(&mut self) {
        self.enabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static COverlayEnabledMsg {
        static instance: COverlayEnabledMsg = COverlayEnabledMsg {
            enabled: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSetGammaRampMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSetGammaRampMsg {
    // message fields
    // @@protoc_insertion_point(field:CSetGammaRampMsg.gamma_ramp)
    pub gamma_ramp: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CSetGammaRampMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSetGammaRampMsg {
    fn default() -> &'a CSetGammaRampMsg {
        <CSetGammaRampMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetGammaRampMsg {
    pub fn new() -> CSetGammaRampMsg {
        ::std::default::Default::default()
    }

    // optional bytes gamma_ramp = 1;

    pub fn gamma_ramp(&self) -> &[u8] {
        match self.gamma_ramp.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_gamma_ramp(&mut self) {
        self.gamma_ramp = ::std::option::Option::None;
    }

    pub fn has_gamma_ramp(&self) -> bool {
        self.gamma_ramp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gamma_ramp(&mut self, v: ::std::vec::Vec<u8>) {
        self.gamma_ramp = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gamma_ramp(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.gamma_ramp.is_none() {
            self.gamma_ramp = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.gamma_ramp.as_mut().unwrap()
    }

    // Take field
    pub fn take_gamma_ramp(&mut self) -> ::std::vec::Vec<u8> {
        self.gamma_ramp.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CSetGammaRampMsg {
    const NAME: &'static str = "CSetGammaRampMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.gamma_ramp = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gamma_ramp.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.gamma_ramp.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSetGammaRampMsg {
        CSetGammaRampMsg::new()
    }

    fn clear(&mut self) {
        self.gamma_ramp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSetGammaRampMsg {
        static instance: CSetGammaRampMsg = CSetGammaRampMsg {
            gamma_ramp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSetActivityMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSetActivityMsg {
    // message fields
    // @@protoc_insertion_point(field:CSetActivityMsg.activity)
    pub activity: ::std::option::Option<::protobuf::EnumOrUnknown<EStreamActivity>>,
    // @@protoc_insertion_point(field:CSetActivityMsg.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSetActivityMsg.gameid)
    pub gameid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSetActivityMsg.game_name)
    pub game_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSetActivityMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSetActivityMsg {
    fn default() -> &'a CSetActivityMsg {
        <CSetActivityMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetActivityMsg {
    pub fn new() -> CSetActivityMsg {
        ::std::default::Default::default()
    }

    // optional .EStreamActivity activity = 1;

    pub fn activity(&self) -> EStreamActivity {
        match self.activity {
            Some(e) => e.enum_value_or(EStreamActivity::k_EStreamActivityIdle),
            None => EStreamActivity::k_EStreamActivityIdle,
        }
    }

    pub fn clear_activity(&mut self) {
        self.activity = ::std::option::Option::None;
    }

    pub fn has_activity(&self) -> bool {
        self.activity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_activity(&mut self, v: EStreamActivity) {
        self.activity = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 appid = 2;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint64 gameid = 3;

    pub fn gameid(&self) -> u64 {
        self.gameid.unwrap_or(0)
    }

    pub fn clear_gameid(&mut self) {
        self.gameid = ::std::option::Option::None;
    }

    pub fn has_gameid(&self) -> bool {
        self.gameid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameid(&mut self, v: u64) {
        self.gameid = ::std::option::Option::Some(v);
    }

    // optional string game_name = 4;

    pub fn game_name(&self) -> &str {
        match self.game_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_name(&mut self) {
        self.game_name = ::std::option::Option::None;
    }

    pub fn has_game_name(&self) -> bool {
        self.game_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_name(&mut self, v: ::std::string::String) {
        self.game_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_name(&mut self) -> &mut ::std::string::String {
        if self.game_name.is_none() {
            self.game_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_name(&mut self) -> ::std::string::String {
        self.game_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CSetActivityMsg {
    const NAME: &'static str = "CSetActivityMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.activity = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.gameid = ::std::option::Option::Some(is.read_uint64()?);
                },
                34 => {
                    self.game_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.activity {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.gameid {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.game_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.activity {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.gameid {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.game_name.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSetActivityMsg {
        CSetActivityMsg::new()
    }

    fn clear(&mut self) {
        self.activity = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.gameid = ::std::option::Option::None;
        self.game_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSetActivityMsg {
        static instance: CSetActivityMsg = CSetActivityMsg {
            activity: ::std::option::Option::None,
            appid: ::std::option::Option::None,
            gameid: ::std::option::Option::None,
            game_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSystemSuspendMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSystemSuspendMsg {
    // special fields
    // @@protoc_insertion_point(special_field:CSystemSuspendMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSystemSuspendMsg {
    fn default() -> &'a CSystemSuspendMsg {
        <CSystemSuspendMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSystemSuspendMsg {
    pub fn new() -> CSystemSuspendMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CSystemSuspendMsg {
    const NAME: &'static str = "CSystemSuspendMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSystemSuspendMsg {
        CSystemSuspendMsg::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSystemSuspendMsg {
        static instance: CSystemSuspendMsg = CSystemSuspendMsg {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CVirtualHereRequestMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CVirtualHereRequestMsg {
    // message fields
    // @@protoc_insertion_point(field:CVirtualHereRequestMsg.hostname)
    pub hostname: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CVirtualHereRequestMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CVirtualHereRequestMsg {
    fn default() -> &'a CVirtualHereRequestMsg {
        <CVirtualHereRequestMsg as ::protobuf::Message>::default_instance()
    }
}

impl CVirtualHereRequestMsg {
    pub fn new() -> CVirtualHereRequestMsg {
        ::std::default::Default::default()
    }

    // optional string hostname = 1;

    pub fn hostname(&self) -> &str {
        match self.hostname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_hostname(&mut self) {
        self.hostname = ::std::option::Option::None;
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname(&mut self) -> &mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CVirtualHereRequestMsg {
    const NAME: &'static str = "CVirtualHereRequestMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.hostname = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hostname.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.hostname.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CVirtualHereRequestMsg {
        CVirtualHereRequestMsg::new()
    }

    fn clear(&mut self) {
        self.hostname = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CVirtualHereRequestMsg {
        static instance: CVirtualHereRequestMsg = CVirtualHereRequestMsg {
            hostname: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CVirtualHereReadyMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CVirtualHereReadyMsg {
    // message fields
    // @@protoc_insertion_point(field:CVirtualHereReadyMsg.licensed_device_count)
    pub licensed_device_count: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CVirtualHereReadyMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CVirtualHereReadyMsg {
    fn default() -> &'a CVirtualHereReadyMsg {
        <CVirtualHereReadyMsg as ::protobuf::Message>::default_instance()
    }
}

impl CVirtualHereReadyMsg {
    pub fn new() -> CVirtualHereReadyMsg {
        ::std::default::Default::default()
    }

    // optional uint32 licensed_device_count = 1;

    pub fn licensed_device_count(&self) -> u32 {
        self.licensed_device_count.unwrap_or(0)
    }

    pub fn clear_licensed_device_count(&mut self) {
        self.licensed_device_count = ::std::option::Option::None;
    }

    pub fn has_licensed_device_count(&self) -> bool {
        self.licensed_device_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_licensed_device_count(&mut self, v: u32) {
        self.licensed_device_count = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CVirtualHereReadyMsg {
    const NAME: &'static str = "CVirtualHereReadyMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.licensed_device_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.licensed_device_count {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.licensed_device_count {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CVirtualHereReadyMsg {
        CVirtualHereReadyMsg::new()
    }

    fn clear(&mut self) {
        self.licensed_device_count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CVirtualHereReadyMsg {
        static instance: CVirtualHereReadyMsg = CVirtualHereReadyMsg {
            licensed_device_count: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CVirtualHereShareDeviceMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CVirtualHereShareDeviceMsg {
    // message fields
    // @@protoc_insertion_point(field:CVirtualHereShareDeviceMsg.device_address)
    pub device_address: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CVirtualHereShareDeviceMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CVirtualHereShareDeviceMsg {
    fn default() -> &'a CVirtualHereShareDeviceMsg {
        <CVirtualHereShareDeviceMsg as ::protobuf::Message>::default_instance()
    }
}

impl CVirtualHereShareDeviceMsg {
    pub fn new() -> CVirtualHereShareDeviceMsg {
        ::std::default::Default::default()
    }

    // optional string device_address = 1;

    pub fn device_address(&self) -> &str {
        match self.device_address.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_device_address(&mut self) {
        self.device_address = ::std::option::Option::None;
    }

    pub fn has_device_address(&self) -> bool {
        self.device_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_address(&mut self, v: ::std::string::String) {
        self.device_address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_address(&mut self) -> &mut ::std::string::String {
        if self.device_address.is_none() {
            self.device_address = ::std::option::Option::Some(::std::string::String::new());
        }
        self.device_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_address(&mut self) -> ::std::string::String {
        self.device_address.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CVirtualHereShareDeviceMsg {
    const NAME: &'static str = "CVirtualHereShareDeviceMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.device_address = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.device_address.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.device_address.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CVirtualHereShareDeviceMsg {
        CVirtualHereShareDeviceMsg::new()
    }

    fn clear(&mut self) {
        self.device_address = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CVirtualHereShareDeviceMsg {
        static instance: CVirtualHereShareDeviceMsg = CVirtualHereShareDeviceMsg {
            device_address: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSetSpectatorModeMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSetSpectatorModeMsg {
    // message fields
    // @@protoc_insertion_point(field:CSetSpectatorModeMsg.enabled)
    pub enabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSetSpectatorModeMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSetSpectatorModeMsg {
    fn default() -> &'a CSetSpectatorModeMsg {
        <CSetSpectatorModeMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetSpectatorModeMsg {
    pub fn new() -> CSetSpectatorModeMsg {
        ::std::default::Default::default()
    }

    // optional bool enabled = 1;

    pub fn enabled(&self) -> bool {
        self.enabled.unwrap_or(false)
    }

    pub fn clear_enabled(&mut self) {
        self.enabled = ::std::option::Option::None;
    }

    pub fn has_enabled(&self) -> bool {
        self.enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSetSpectatorModeMsg {
    const NAME: &'static str = "CSetSpectatorModeMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.enabled {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.enabled {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSetSpectatorModeMsg {
        CSetSpectatorModeMsg::new()
    }

    fn clear(&mut self) {
        self.enabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSetSpectatorModeMsg {
        static instance: CSetSpectatorModeMsg = CSetSpectatorModeMsg {
            enabled: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CRemoteHIDMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CRemoteHIDMsg {
    // message fields
    // @@protoc_insertion_point(field:CRemoteHIDMsg.data)
    pub data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CRemoteHIDMsg.active_input)
    pub active_input: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CRemoteHIDMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CRemoteHIDMsg {
    fn default() -> &'a CRemoteHIDMsg {
        <CRemoteHIDMsg as ::protobuf::Message>::default_instance()
    }
}

impl CRemoteHIDMsg {
    pub fn new() -> CRemoteHIDMsg {
        ::std::default::Default::default()
    }

    // optional bytes data = 1;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool active_input = 2;

    pub fn active_input(&self) -> bool {
        self.active_input.unwrap_or(false)
    }

    pub fn clear_active_input(&mut self) {
        self.active_input = ::std::option::Option::None;
    }

    pub fn has_active_input(&self) -> bool {
        self.active_input.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_input(&mut self, v: bool) {
        self.active_input = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CRemoteHIDMsg {
    const NAME: &'static str = "CRemoteHIDMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data = ::std::option::Option::Some(is.read_bytes()?);
                },
                16 => {
                    self.active_input = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.active_input {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.active_input {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CRemoteHIDMsg {
        CRemoteHIDMsg::new()
    }

    fn clear(&mut self) {
        self.data = ::std::option::Option::None;
        self.active_input = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CRemoteHIDMsg {
        static instance: CRemoteHIDMsg = CRemoteHIDMsg {
            data: ::std::option::Option::None,
            active_input: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CTouchConfigActiveMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CTouchConfigActiveMsg {
    // message fields
    // @@protoc_insertion_point(field:CTouchConfigActiveMsg.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CTouchConfigActiveMsg.revision)
    pub revision: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CTouchConfigActiveMsg.creator)
    pub creator: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CTouchConfigActiveMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CTouchConfigActiveMsg {
    fn default() -> &'a CTouchConfigActiveMsg {
        <CTouchConfigActiveMsg as ::protobuf::Message>::default_instance()
    }
}

impl CTouchConfigActiveMsg {
    pub fn new() -> CTouchConfigActiveMsg {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 revision = 2;

    pub fn revision(&self) -> u32 {
        self.revision.unwrap_or(0)
    }

    pub fn clear_revision(&mut self) {
        self.revision = ::std::option::Option::None;
    }

    pub fn has_revision(&self) -> bool {
        self.revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: u32) {
        self.revision = ::std::option::Option::Some(v);
    }

    // optional uint64 creator = 3;

    pub fn creator(&self) -> u64 {
        self.creator.unwrap_or(0)
    }

    pub fn clear_creator(&mut self) {
        self.creator = ::std::option::Option::None;
    }

    pub fn has_creator(&self) -> bool {
        self.creator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creator(&mut self, v: u64) {
        self.creator = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CTouchConfigActiveMsg {
    const NAME: &'static str = "CTouchConfigActiveMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.revision = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.creator = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.revision {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.creator {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.revision {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.creator {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CTouchConfigActiveMsg {
        CTouchConfigActiveMsg::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.revision = ::std::option::Option::None;
        self.creator = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CTouchConfigActiveMsg {
        static instance: CTouchConfigActiveMsg = CTouchConfigActiveMsg {
            appid: ::std::option::Option::None,
            revision: ::std::option::Option::None,
            creator: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGetTouchConfigDataMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGetTouchConfigDataMsg {
    // message fields
    // @@protoc_insertion_point(field:CGetTouchConfigDataMsg.appid)
    pub appid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CGetTouchConfigDataMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGetTouchConfigDataMsg {
    fn default() -> &'a CGetTouchConfigDataMsg {
        <CGetTouchConfigDataMsg as ::protobuf::Message>::default_instance()
    }
}

impl CGetTouchConfigDataMsg {
    pub fn new() -> CGetTouchConfigDataMsg {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CGetTouchConfigDataMsg {
    const NAME: &'static str = "CGetTouchConfigDataMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGetTouchConfigDataMsg {
        CGetTouchConfigDataMsg::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGetTouchConfigDataMsg {
        static instance: CGetTouchConfigDataMsg = CGetTouchConfigDataMsg {
            appid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSetTouchConfigDataMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSetTouchConfigDataMsg {
    // message fields
    // @@protoc_insertion_point(field:CSetTouchConfigDataMsg.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSetTouchConfigDataMsg.revision)
    pub revision: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSetTouchConfigDataMsg.data)
    pub data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CSetTouchConfigDataMsg.layout)
    pub layout: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CSetTouchConfigDataMsg.creator)
    pub creator: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CSetTouchConfigDataMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSetTouchConfigDataMsg {
    fn default() -> &'a CSetTouchConfigDataMsg {
        <CSetTouchConfigDataMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetTouchConfigDataMsg {
    pub fn new() -> CSetTouchConfigDataMsg {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 revision = 2;

    pub fn revision(&self) -> u32 {
        self.revision.unwrap_or(0)
    }

    pub fn clear_revision(&mut self) {
        self.revision = ::std::option::Option::None;
    }

    pub fn has_revision(&self) -> bool {
        self.revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: u32) {
        self.revision = ::std::option::Option::Some(v);
    }

    // optional bytes data = 3;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes layout = 4;

    pub fn layout(&self) -> &[u8] {
        match self.layout.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_layout(&mut self) {
        self.layout = ::std::option::Option::None;
    }

    pub fn has_layout(&self) -> bool {
        self.layout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layout(&mut self, v: ::std::vec::Vec<u8>) {
        self.layout = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_layout(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.layout.is_none() {
            self.layout = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.layout.as_mut().unwrap()
    }

    // Take field
    pub fn take_layout(&mut self) -> ::std::vec::Vec<u8> {
        self.layout.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 creator = 5;

    pub fn creator(&self) -> u64 {
        self.creator.unwrap_or(0)
    }

    pub fn clear_creator(&mut self) {
        self.creator = ::std::option::Option::None;
    }

    pub fn has_creator(&self) -> bool {
        self.creator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creator(&mut self, v: u64) {
        self.creator = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSetTouchConfigDataMsg {
    const NAME: &'static str = "CSetTouchConfigDataMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.revision = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.data = ::std::option::Option::Some(is.read_bytes()?);
                },
                34 => {
                    self.layout = ::std::option::Option::Some(is.read_bytes()?);
                },
                40 => {
                    self.creator = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.revision {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.layout.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.creator {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.revision {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.layout.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.creator {
            os.write_uint64(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSetTouchConfigDataMsg {
        CSetTouchConfigDataMsg::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.revision = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.layout = ::std::option::Option::None;
        self.creator = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSetTouchConfigDataMsg {
        static instance: CSetTouchConfigDataMsg = CSetTouchConfigDataMsg {
            appid: ::std::option::Option::None,
            revision: ::std::option::Option::None,
            data: ::std::option::Option::None,
            layout: ::std::option::Option::None,
            creator: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSaveTouchConfigLayoutMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSaveTouchConfigLayoutMsg {
    // message fields
    // @@protoc_insertion_point(field:CSaveTouchConfigLayoutMsg.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSaveTouchConfigLayoutMsg.layout)
    pub layout: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CSaveTouchConfigLayoutMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSaveTouchConfigLayoutMsg {
    fn default() -> &'a CSaveTouchConfigLayoutMsg {
        <CSaveTouchConfigLayoutMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSaveTouchConfigLayoutMsg {
    pub fn new() -> CSaveTouchConfigLayoutMsg {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional bytes layout = 4;

    pub fn layout(&self) -> &[u8] {
        match self.layout.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_layout(&mut self) {
        self.layout = ::std::option::Option::None;
    }

    pub fn has_layout(&self) -> bool {
        self.layout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layout(&mut self, v: ::std::vec::Vec<u8>) {
        self.layout = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_layout(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.layout.is_none() {
            self.layout = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.layout.as_mut().unwrap()
    }

    // Take field
    pub fn take_layout(&mut self) -> ::std::vec::Vec<u8> {
        self.layout.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CSaveTouchConfigLayoutMsg {
    const NAME: &'static str = "CSaveTouchConfigLayoutMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.layout = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.layout.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.layout.as_ref() {
            os.write_bytes(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSaveTouchConfigLayoutMsg {
        CSaveTouchConfigLayoutMsg::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.layout = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSaveTouchConfigLayoutMsg {
        static instance: CSaveTouchConfigLayoutMsg = CSaveTouchConfigLayoutMsg {
            appid: ::std::option::Option::None,
            layout: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CTouchActionSetActiveMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CTouchActionSetActiveMsg {
    // message fields
    // @@protoc_insertion_point(field:CTouchActionSetActiveMsg.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CTouchActionSetActiveMsg.actionset_id)
    pub actionset_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CTouchActionSetActiveMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CTouchActionSetActiveMsg {
    fn default() -> &'a CTouchActionSetActiveMsg {
        <CTouchActionSetActiveMsg as ::protobuf::Message>::default_instance()
    }
}

impl CTouchActionSetActiveMsg {
    pub fn new() -> CTouchActionSetActiveMsg {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional int32 actionset_id = 2;

    pub fn actionset_id(&self) -> i32 {
        self.actionset_id.unwrap_or(0)
    }

    pub fn clear_actionset_id(&mut self) {
        self.actionset_id = ::std::option::Option::None;
    }

    pub fn has_actionset_id(&self) -> bool {
        self.actionset_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actionset_id(&mut self, v: i32) {
        self.actionset_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CTouchActionSetActiveMsg {
    const NAME: &'static str = "CTouchActionSetActiveMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.actionset_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.actionset_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.actionset_id {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CTouchActionSetActiveMsg {
        CTouchActionSetActiveMsg::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.actionset_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CTouchActionSetActiveMsg {
        static instance: CTouchActionSetActiveMsg = CTouchActionSetActiveMsg {
            appid: ::std::option::Option::None,
            actionset_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CTouchActionSetLayerAddedMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CTouchActionSetLayerAddedMsg {
    // message fields
    // @@protoc_insertion_point(field:CTouchActionSetLayerAddedMsg.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CTouchActionSetLayerAddedMsg.actionset_id)
    pub actionset_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CTouchActionSetLayerAddedMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CTouchActionSetLayerAddedMsg {
    fn default() -> &'a CTouchActionSetLayerAddedMsg {
        <CTouchActionSetLayerAddedMsg as ::protobuf::Message>::default_instance()
    }
}

impl CTouchActionSetLayerAddedMsg {
    pub fn new() -> CTouchActionSetLayerAddedMsg {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional int32 actionset_id = 2;

    pub fn actionset_id(&self) -> i32 {
        self.actionset_id.unwrap_or(0)
    }

    pub fn clear_actionset_id(&mut self) {
        self.actionset_id = ::std::option::Option::None;
    }

    pub fn has_actionset_id(&self) -> bool {
        self.actionset_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actionset_id(&mut self, v: i32) {
        self.actionset_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CTouchActionSetLayerAddedMsg {
    const NAME: &'static str = "CTouchActionSetLayerAddedMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.actionset_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.actionset_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.actionset_id {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CTouchActionSetLayerAddedMsg {
        CTouchActionSetLayerAddedMsg::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.actionset_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CTouchActionSetLayerAddedMsg {
        static instance: CTouchActionSetLayerAddedMsg = CTouchActionSetLayerAddedMsg {
            appid: ::std::option::Option::None,
            actionset_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CTouchActionSetLayerRemovedMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CTouchActionSetLayerRemovedMsg {
    // message fields
    // @@protoc_insertion_point(field:CTouchActionSetLayerRemovedMsg.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CTouchActionSetLayerRemovedMsg.actionset_id)
    pub actionset_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CTouchActionSetLayerRemovedMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CTouchActionSetLayerRemovedMsg {
    fn default() -> &'a CTouchActionSetLayerRemovedMsg {
        <CTouchActionSetLayerRemovedMsg as ::protobuf::Message>::default_instance()
    }
}

impl CTouchActionSetLayerRemovedMsg {
    pub fn new() -> CTouchActionSetLayerRemovedMsg {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional int32 actionset_id = 2;

    pub fn actionset_id(&self) -> i32 {
        self.actionset_id.unwrap_or(0)
    }

    pub fn clear_actionset_id(&mut self) {
        self.actionset_id = ::std::option::Option::None;
    }

    pub fn has_actionset_id(&self) -> bool {
        self.actionset_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actionset_id(&mut self, v: i32) {
        self.actionset_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CTouchActionSetLayerRemovedMsg {
    const NAME: &'static str = "CTouchActionSetLayerRemovedMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.actionset_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.actionset_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.actionset_id {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CTouchActionSetLayerRemovedMsg {
        CTouchActionSetLayerRemovedMsg::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.actionset_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CTouchActionSetLayerRemovedMsg {
        static instance: CTouchActionSetLayerRemovedMsg = CTouchActionSetLayerRemovedMsg {
            appid: ::std::option::Option::None,
            actionset_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGetTouchIconDataMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGetTouchIconDataMsg {
    // message fields
    // @@protoc_insertion_point(field:CGetTouchIconDataMsg.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGetTouchIconDataMsg.icon)
    pub icon: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CGetTouchIconDataMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGetTouchIconDataMsg {
    fn default() -> &'a CGetTouchIconDataMsg {
        <CGetTouchIconDataMsg as ::protobuf::Message>::default_instance()
    }
}

impl CGetTouchIconDataMsg {
    pub fn new() -> CGetTouchIconDataMsg {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string icon = 2;

    pub fn icon(&self) -> &str {
        match self.icon.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_icon(&mut self) {
        self.icon = ::std::option::Option::None;
    }

    pub fn has_icon(&self) -> bool {
        self.icon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_icon(&mut self, v: ::std::string::String) {
        self.icon = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon(&mut self) -> &mut ::std::string::String {
        if self.icon.is_none() {
            self.icon = ::std::option::Option::Some(::std::string::String::new());
        }
        self.icon.as_mut().unwrap()
    }

    // Take field
    pub fn take_icon(&mut self) -> ::std::string::String {
        self.icon.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CGetTouchIconDataMsg {
    const NAME: &'static str = "CGetTouchIconDataMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.icon = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.icon.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.icon.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGetTouchIconDataMsg {
        CGetTouchIconDataMsg::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.icon = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGetTouchIconDataMsg {
        static instance: CGetTouchIconDataMsg = CGetTouchIconDataMsg {
            appid: ::std::option::Option::None,
            icon: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSetTouchIconDataMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSetTouchIconDataMsg {
    // message fields
    // @@protoc_insertion_point(field:CSetTouchIconDataMsg.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSetTouchIconDataMsg.icon)
    pub icon: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSetTouchIconDataMsg.data)
    pub data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CSetTouchIconDataMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSetTouchIconDataMsg {
    fn default() -> &'a CSetTouchIconDataMsg {
        <CSetTouchIconDataMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetTouchIconDataMsg {
    pub fn new() -> CSetTouchIconDataMsg {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string icon = 2;

    pub fn icon(&self) -> &str {
        match self.icon.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_icon(&mut self) {
        self.icon = ::std::option::Option::None;
    }

    pub fn has_icon(&self) -> bool {
        self.icon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_icon(&mut self, v: ::std::string::String) {
        self.icon = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon(&mut self) -> &mut ::std::string::String {
        if self.icon.is_none() {
            self.icon = ::std::option::Option::Some(::std::string::String::new());
        }
        self.icon.as_mut().unwrap()
    }

    // Take field
    pub fn take_icon(&mut self) -> ::std::string::String {
        self.icon.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes data = 3;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CSetTouchIconDataMsg {
    const NAME: &'static str = "CSetTouchIconDataMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.icon = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.icon.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.icon.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSetTouchIconDataMsg {
        CSetTouchIconDataMsg::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.icon = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSetTouchIconDataMsg {
        static instance: CSetTouchIconDataMsg = CSetTouchIconDataMsg {
            appid: ::std::option::Option::None,
            icon: ::std::option::Option::None,
            data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CRemotePlayTogetherGroupUpdateMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CRemotePlayTogetherGroupUpdateMsg {
    // message fields
    // @@protoc_insertion_point(field:CRemotePlayTogetherGroupUpdateMsg.players)
    pub players: ::std::vec::Vec<cremote_play_together_group_update_msg::Player>,
    // @@protoc_insertion_point(field:CRemotePlayTogetherGroupUpdateMsg.player_index)
    pub player_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CRemotePlayTogetherGroupUpdateMsg.miniprofile_location)
    pub miniprofile_location: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CRemotePlayTogetherGroupUpdateMsg.game_name)
    pub game_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CRemotePlayTogetherGroupUpdateMsg.avatar_location)
    pub avatar_location: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CRemotePlayTogetherGroupUpdateMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CRemotePlayTogetherGroupUpdateMsg {
    fn default() -> &'a CRemotePlayTogetherGroupUpdateMsg {
        <CRemotePlayTogetherGroupUpdateMsg as ::protobuf::Message>::default_instance()
    }
}

impl CRemotePlayTogetherGroupUpdateMsg {
    pub fn new() -> CRemotePlayTogetherGroupUpdateMsg {
        ::std::default::Default::default()
    }

    // optional int32 player_index = 2;

    pub fn player_index(&self) -> i32 {
        self.player_index.unwrap_or(0)
    }

    pub fn clear_player_index(&mut self) {
        self.player_index = ::std::option::Option::None;
    }

    pub fn has_player_index(&self) -> bool {
        self.player_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_index(&mut self, v: i32) {
        self.player_index = ::std::option::Option::Some(v);
    }

    // optional string miniprofile_location = 3;

    pub fn miniprofile_location(&self) -> &str {
        match self.miniprofile_location.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_miniprofile_location(&mut self) {
        self.miniprofile_location = ::std::option::Option::None;
    }

    pub fn has_miniprofile_location(&self) -> bool {
        self.miniprofile_location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_miniprofile_location(&mut self, v: ::std::string::String) {
        self.miniprofile_location = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_miniprofile_location(&mut self) -> &mut ::std::string::String {
        if self.miniprofile_location.is_none() {
            self.miniprofile_location = ::std::option::Option::Some(::std::string::String::new());
        }
        self.miniprofile_location.as_mut().unwrap()
    }

    // Take field
    pub fn take_miniprofile_location(&mut self) -> ::std::string::String {
        self.miniprofile_location.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string game_name = 4;

    pub fn game_name(&self) -> &str {
        match self.game_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_name(&mut self) {
        self.game_name = ::std::option::Option::None;
    }

    pub fn has_game_name(&self) -> bool {
        self.game_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_name(&mut self, v: ::std::string::String) {
        self.game_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_name(&mut self) -> &mut ::std::string::String {
        if self.game_name.is_none() {
            self.game_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_name(&mut self) -> ::std::string::String {
        self.game_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string avatar_location = 5;

    pub fn avatar_location(&self) -> &str {
        match self.avatar_location.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_avatar_location(&mut self) {
        self.avatar_location = ::std::option::Option::None;
    }

    pub fn has_avatar_location(&self) -> bool {
        self.avatar_location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avatar_location(&mut self, v: ::std::string::String) {
        self.avatar_location = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar_location(&mut self) -> &mut ::std::string::String {
        if self.avatar_location.is_none() {
            self.avatar_location = ::std::option::Option::Some(::std::string::String::new());
        }
        self.avatar_location.as_mut().unwrap()
    }

    // Take field
    pub fn take_avatar_location(&mut self) -> ::std::string::String {
        self.avatar_location.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CRemotePlayTogetherGroupUpdateMsg {
    const NAME: &'static str = "CRemotePlayTogetherGroupUpdateMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.players.push(is.read_message()?);
                },
                16 => {
                    self.player_index = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.miniprofile_location = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.game_name = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.avatar_location = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.player_index {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.miniprofile_location.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.game_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.avatar_location.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.players {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.player_index {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.miniprofile_location.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.game_name.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.avatar_location.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CRemotePlayTogetherGroupUpdateMsg {
        CRemotePlayTogetherGroupUpdateMsg::new()
    }

    fn clear(&mut self) {
        self.players.clear();
        self.player_index = ::std::option::Option::None;
        self.miniprofile_location = ::std::option::Option::None;
        self.game_name = ::std::option::Option::None;
        self.avatar_location = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CRemotePlayTogetherGroupUpdateMsg {
        static instance: CRemotePlayTogetherGroupUpdateMsg = CRemotePlayTogetherGroupUpdateMsg {
            players: ::std::vec::Vec::new(),
            player_index: ::std::option::Option::None,
            miniprofile_location: ::std::option::Option::None,
            game_name: ::std::option::Option::None,
            avatar_location: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CRemotePlayTogetherGroupUpdateMsg`
pub mod cremote_play_together_group_update_msg {
    // @@protoc_insertion_point(message:CRemotePlayTogetherGroupUpdateMsg.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:CRemotePlayTogetherGroupUpdateMsg.Player.accountid)
        pub accountid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CRemotePlayTogetherGroupUpdateMsg.Player.guestid)
        pub guestid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CRemotePlayTogetherGroupUpdateMsg.Player.keyboard_enabled)
        pub keyboard_enabled: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CRemotePlayTogetherGroupUpdateMsg.Player.mouse_enabled)
        pub mouse_enabled: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CRemotePlayTogetherGroupUpdateMsg.Player.controller_enabled)
        pub controller_enabled: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CRemotePlayTogetherGroupUpdateMsg.Player.controller_slots)
        pub controller_slots: ::std::vec::Vec<u32>,
        // @@protoc_insertion_point(field:CRemotePlayTogetherGroupUpdateMsg.Player.avatar_hash)
        pub avatar_hash: ::std::option::Option<::std::vec::Vec<u8>>,
        // special fields
        // @@protoc_insertion_point(special_field:CRemotePlayTogetherGroupUpdateMsg.Player.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional uint32 accountid = 1;

        pub fn accountid(&self) -> u32 {
            self.accountid.unwrap_or(0)
        }

        pub fn clear_accountid(&mut self) {
            self.accountid = ::std::option::Option::None;
        }

        pub fn has_accountid(&self) -> bool {
            self.accountid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_accountid(&mut self, v: u32) {
            self.accountid = ::std::option::Option::Some(v);
        }

        // optional uint32 guestid = 2;

        pub fn guestid(&self) -> u32 {
            self.guestid.unwrap_or(0)
        }

        pub fn clear_guestid(&mut self) {
            self.guestid = ::std::option::Option::None;
        }

        pub fn has_guestid(&self) -> bool {
            self.guestid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_guestid(&mut self, v: u32) {
            self.guestid = ::std::option::Option::Some(v);
        }

        // optional bool keyboard_enabled = 3;

        pub fn keyboard_enabled(&self) -> bool {
            self.keyboard_enabled.unwrap_or(false)
        }

        pub fn clear_keyboard_enabled(&mut self) {
            self.keyboard_enabled = ::std::option::Option::None;
        }

        pub fn has_keyboard_enabled(&self) -> bool {
            self.keyboard_enabled.is_some()
        }

        // Param is passed by value, moved
        pub fn set_keyboard_enabled(&mut self, v: bool) {
            self.keyboard_enabled = ::std::option::Option::Some(v);
        }

        // optional bool mouse_enabled = 4;

        pub fn mouse_enabled(&self) -> bool {
            self.mouse_enabled.unwrap_or(false)
        }

        pub fn clear_mouse_enabled(&mut self) {
            self.mouse_enabled = ::std::option::Option::None;
        }

        pub fn has_mouse_enabled(&self) -> bool {
            self.mouse_enabled.is_some()
        }

        // Param is passed by value, moved
        pub fn set_mouse_enabled(&mut self, v: bool) {
            self.mouse_enabled = ::std::option::Option::Some(v);
        }

        // optional bool controller_enabled = 5;

        pub fn controller_enabled(&self) -> bool {
            self.controller_enabled.unwrap_or(false)
        }

        pub fn clear_controller_enabled(&mut self) {
            self.controller_enabled = ::std::option::Option::None;
        }

        pub fn has_controller_enabled(&self) -> bool {
            self.controller_enabled.is_some()
        }

        // Param is passed by value, moved
        pub fn set_controller_enabled(&mut self, v: bool) {
            self.controller_enabled = ::std::option::Option::Some(v);
        }

        // optional bytes avatar_hash = 7;

        pub fn avatar_hash(&self) -> &[u8] {
            match self.avatar_hash.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_avatar_hash(&mut self) {
            self.avatar_hash = ::std::option::Option::None;
        }

        pub fn has_avatar_hash(&self) -> bool {
            self.avatar_hash.is_some()
        }

        // Param is passed by value, moved
        pub fn set_avatar_hash(&mut self, v: ::std::vec::Vec<u8>) {
            self.avatar_hash = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_avatar_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.avatar_hash.is_none() {
                self.avatar_hash = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.avatar_hash.as_mut().unwrap()
        }

        // Take field
        pub fn take_avatar_hash(&mut self) -> ::std::vec::Vec<u8> {
            self.avatar_hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }
    }

    impl ::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.guestid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.keyboard_enabled = ::std::option::Option::Some(is.read_bool()?);
                    },
                    32 => {
                        self.mouse_enabled = ::std::option::Option::Some(is.read_bool()?);
                    },
                    40 => {
                        self.controller_enabled = ::std::option::Option::Some(is.read_bool()?);
                    },
                    50 => {
                        is.read_repeated_packed_uint32_into(&mut self.controller_slots)?;
                    },
                    48 => {
                        self.controller_slots.push(is.read_uint32()?);
                    },
                    58 => {
                        self.avatar_hash = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.accountid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.guestid {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.keyboard_enabled {
                my_size += 1 + 1;
            }
            if let Some(v) = self.mouse_enabled {
                my_size += 1 + 1;
            }
            if let Some(v) = self.controller_enabled {
                my_size += 1 + 1;
            }
            for value in &self.controller_slots {
                my_size += ::protobuf::rt::uint32_size(6, *value);
            };
            if let Some(v) = self.avatar_hash.as_ref() {
                my_size += ::protobuf::rt::bytes_size(7, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.accountid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.guestid {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.keyboard_enabled {
                os.write_bool(3, v)?;
            }
            if let Some(v) = self.mouse_enabled {
                os.write_bool(4, v)?;
            }
            if let Some(v) = self.controller_enabled {
                os.write_bool(5, v)?;
            }
            for v in &self.controller_slots {
                os.write_uint32(6, *v)?;
            };
            if let Some(v) = self.avatar_hash.as_ref() {
                os.write_bytes(7, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.accountid = ::std::option::Option::None;
            self.guestid = ::std::option::Option::None;
            self.keyboard_enabled = ::std::option::Option::None;
            self.mouse_enabled = ::std::option::Option::None;
            self.controller_enabled = ::std::option::Option::None;
            self.controller_slots.clear();
            self.avatar_hash = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                accountid: ::std::option::Option::None,
                guestid: ::std::option::Option::None,
                keyboard_enabled: ::std::option::Option::None,
                mouse_enabled: ::std::option::Option::None,
                controller_enabled: ::std::option::Option::None,
                controller_slots: ::std::vec::Vec::new(),
                avatar_hash: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CSetInputTemporarilyDisabledMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSetInputTemporarilyDisabledMsg {
    // message fields
    // @@protoc_insertion_point(field:CSetInputTemporarilyDisabledMsg.disabled)
    pub disabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSetInputTemporarilyDisabledMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSetInputTemporarilyDisabledMsg {
    fn default() -> &'a CSetInputTemporarilyDisabledMsg {
        <CSetInputTemporarilyDisabledMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetInputTemporarilyDisabledMsg {
    pub fn new() -> CSetInputTemporarilyDisabledMsg {
        ::std::default::Default::default()
    }

    // optional bool disabled = 1;

    pub fn disabled(&self) -> bool {
        self.disabled.unwrap_or(false)
    }

    pub fn clear_disabled(&mut self) {
        self.disabled = ::std::option::Option::None;
    }

    pub fn has_disabled(&self) -> bool {
        self.disabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disabled(&mut self, v: bool) {
        self.disabled = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSetInputTemporarilyDisabledMsg {
    const NAME: &'static str = "CSetInputTemporarilyDisabledMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.disabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.disabled {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.disabled {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSetInputTemporarilyDisabledMsg {
        CSetInputTemporarilyDisabledMsg::new()
    }

    fn clear(&mut self) {
        self.disabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSetInputTemporarilyDisabledMsg {
        static instance: CSetInputTemporarilyDisabledMsg = CSetInputTemporarilyDisabledMsg {
            disabled: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSetQualityOverrideMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSetQualityOverrideMsg {
    // message fields
    // @@protoc_insertion_point(field:CSetQualityOverrideMsg.value)
    pub value: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSetQualityOverrideMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSetQualityOverrideMsg {
    fn default() -> &'a CSetQualityOverrideMsg {
        <CSetQualityOverrideMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetQualityOverrideMsg {
    pub fn new() -> CSetQualityOverrideMsg {
        ::std::default::Default::default()
    }

    // optional int32 value = 1;

    pub fn value(&self) -> i32 {
        self.value.unwrap_or(0)
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i32) {
        self.value = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSetQualityOverrideMsg {
    const NAME: &'static str = "CSetQualityOverrideMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.value = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.value {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSetQualityOverrideMsg {
        CSetQualityOverrideMsg::new()
    }

    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSetQualityOverrideMsg {
        static instance: CSetQualityOverrideMsg = CSetQualityOverrideMsg {
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSetBitrateOverrideMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSetBitrateOverrideMsg {
    // message fields
    // @@protoc_insertion_point(field:CSetBitrateOverrideMsg.value)
    pub value: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSetBitrateOverrideMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSetBitrateOverrideMsg {
    fn default() -> &'a CSetBitrateOverrideMsg {
        <CSetBitrateOverrideMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetBitrateOverrideMsg {
    pub fn new() -> CSetBitrateOverrideMsg {
        ::std::default::Default::default()
    }

    // optional int32 value = 1;

    pub fn value(&self) -> i32 {
        self.value.unwrap_or(0)
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i32) {
        self.value = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSetBitrateOverrideMsg {
    const NAME: &'static str = "CSetBitrateOverrideMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.value = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.value {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSetBitrateOverrideMsg {
        CSetBitrateOverrideMsg::new()
    }

    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSetBitrateOverrideMsg {
        static instance: CSetBitrateOverrideMsg = CSetBitrateOverrideMsg {
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CShowOnScreenKeyboardMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CShowOnScreenKeyboardMsg {
    // special fields
    // @@protoc_insertion_point(special_field:CShowOnScreenKeyboardMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CShowOnScreenKeyboardMsg {
    fn default() -> &'a CShowOnScreenKeyboardMsg {
        <CShowOnScreenKeyboardMsg as ::protobuf::Message>::default_instance()
    }
}

impl CShowOnScreenKeyboardMsg {
    pub fn new() -> CShowOnScreenKeyboardMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CShowOnScreenKeyboardMsg {
    const NAME: &'static str = "CShowOnScreenKeyboardMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CShowOnScreenKeyboardMsg {
        CShowOnScreenKeyboardMsg::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CShowOnScreenKeyboardMsg {
        static instance: CShowOnScreenKeyboardMsg = CShowOnScreenKeyboardMsg {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CControllerPersonalizationUpdateMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CControllerPersonalizationUpdateMsg {
    // message fields
    // @@protoc_insertion_point(field:CControllerPersonalizationUpdateMsg.controller_path)
    pub controller_path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CControllerPersonalizationUpdateMsg.controller_name)
    pub controller_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CControllerPersonalizationUpdateMsg.reverse_diamond_button_layout)
    pub reverse_diamond_button_layout: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CControllerPersonalizationUpdateMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CControllerPersonalizationUpdateMsg {
    fn default() -> &'a CControllerPersonalizationUpdateMsg {
        <CControllerPersonalizationUpdateMsg as ::protobuf::Message>::default_instance()
    }
}

impl CControllerPersonalizationUpdateMsg {
    pub fn new() -> CControllerPersonalizationUpdateMsg {
        ::std::default::Default::default()
    }

    // optional string controller_path = 1;

    pub fn controller_path(&self) -> &str {
        match self.controller_path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_controller_path(&mut self) {
        self.controller_path = ::std::option::Option::None;
    }

    pub fn has_controller_path(&self) -> bool {
        self.controller_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_path(&mut self, v: ::std::string::String) {
        self.controller_path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_controller_path(&mut self) -> &mut ::std::string::String {
        if self.controller_path.is_none() {
            self.controller_path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.controller_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_controller_path(&mut self) -> ::std::string::String {
        self.controller_path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string controller_name = 2;

    pub fn controller_name(&self) -> &str {
        match self.controller_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_controller_name(&mut self) {
        self.controller_name = ::std::option::Option::None;
    }

    pub fn has_controller_name(&self) -> bool {
        self.controller_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_name(&mut self, v: ::std::string::String) {
        self.controller_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_controller_name(&mut self) -> &mut ::std::string::String {
        if self.controller_name.is_none() {
            self.controller_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.controller_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_controller_name(&mut self) -> ::std::string::String {
        self.controller_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool reverse_diamond_button_layout = 3;

    pub fn reverse_diamond_button_layout(&self) -> bool {
        self.reverse_diamond_button_layout.unwrap_or(false)
    }

    pub fn clear_reverse_diamond_button_layout(&mut self) {
        self.reverse_diamond_button_layout = ::std::option::Option::None;
    }

    pub fn has_reverse_diamond_button_layout(&self) -> bool {
        self.reverse_diamond_button_layout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reverse_diamond_button_layout(&mut self, v: bool) {
        self.reverse_diamond_button_layout = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CControllerPersonalizationUpdateMsg {
    const NAME: &'static str = "CControllerPersonalizationUpdateMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.controller_path = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.controller_name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.reverse_diamond_button_layout = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.controller_path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.controller_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.reverse_diamond_button_layout {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.controller_path.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.controller_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.reverse_diamond_button_layout {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CControllerPersonalizationUpdateMsg {
        CControllerPersonalizationUpdateMsg::new()
    }

    fn clear(&mut self) {
        self.controller_path = ::std::option::Option::None;
        self.controller_name = ::std::option::Option::None;
        self.reverse_diamond_button_layout = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CControllerPersonalizationUpdateMsg {
        static instance: CControllerPersonalizationUpdateMsg = CControllerPersonalizationUpdateMsg {
            controller_path: ::std::option::Option::None,
            controller_name: ::std::option::Option::None,
            reverse_diamond_button_layout: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CStreamDataLostMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStreamDataLostMsg {
    // message fields
    // @@protoc_insertion_point(field:CStreamDataLostMsg.packets)
    pub packets: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CStreamDataLostMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStreamDataLostMsg {
    fn default() -> &'a CStreamDataLostMsg {
        <CStreamDataLostMsg as ::protobuf::Message>::default_instance()
    }
}

impl CStreamDataLostMsg {
    pub fn new() -> CStreamDataLostMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CStreamDataLostMsg {
    const NAME: &'static str = "CStreamDataLostMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.packets)?;
                },
                8 => {
                    self.packets.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.packets {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.packets {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStreamDataLostMsg {
        CStreamDataLostMsg::new()
    }

    fn clear(&mut self) {
        self.packets.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStreamDataLostMsg {
        static instance: CStreamDataLostMsg = CStreamDataLostMsg {
            packets: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CAudioFormat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CAudioFormat {
    // message fields
    // @@protoc_insertion_point(field:CAudioFormat.format)
    pub format: ::std::option::Option<::protobuf::EnumOrUnknown<EAudioFormat>>,
    // @@protoc_insertion_point(field:CAudioFormat.frequency)
    pub frequency: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CAudioFormat.channels)
    pub channels: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CAudioFormat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CAudioFormat {
    fn default() -> &'a CAudioFormat {
        <CAudioFormat as ::protobuf::Message>::default_instance()
    }
}

impl CAudioFormat {
    pub fn new() -> CAudioFormat {
        ::std::default::Default::default()
    }

    // required .EAudioFormat format = 1;

    pub fn format(&self) -> EAudioFormat {
        match self.format {
            Some(e) => e.enum_value_or(EAudioFormat::k_EAudioFormatNone),
            None => EAudioFormat::k_EAudioFormatNone,
        }
    }

    pub fn clear_format(&mut self) {
        self.format = ::std::option::Option::None;
    }

    pub fn has_format(&self) -> bool {
        self.format.is_some()
    }

    // Param is passed by value, moved
    pub fn set_format(&mut self, v: EAudioFormat) {
        self.format = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 frequency = 2;

    pub fn frequency(&self) -> u32 {
        self.frequency.unwrap_or(0)
    }

    pub fn clear_frequency(&mut self) {
        self.frequency = ::std::option::Option::None;
    }

    pub fn has_frequency(&self) -> bool {
        self.frequency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frequency(&mut self, v: u32) {
        self.frequency = ::std::option::Option::Some(v);
    }

    // optional uint32 channels = 3;

    pub fn channels(&self) -> u32 {
        self.channels.unwrap_or(0)
    }

    pub fn clear_channels(&mut self) {
        self.channels = ::std::option::Option::None;
    }

    pub fn has_channels(&self) -> bool {
        self.channels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channels(&mut self, v: u32) {
        self.channels = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CAudioFormat {
    const NAME: &'static str = "CAudioFormat";

    fn is_initialized(&self) -> bool {
        if self.format.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.format = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.frequency = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.channels = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.format {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.frequency {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.channels {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.format {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.frequency {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.channels {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CAudioFormat {
        CAudioFormat::new()
    }

    fn clear(&mut self) {
        self.format = ::std::option::Option::None;
        self.frequency = ::std::option::Option::None;
        self.channels = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CAudioFormat {
        static instance: CAudioFormat = CAudioFormat {
            format: ::std::option::Option::None,
            frequency: ::std::option::Option::None,
            channels: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CVideoFormat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CVideoFormat {
    // message fields
    // @@protoc_insertion_point(field:CVideoFormat.format)
    pub format: ::std::option::Option<::protobuf::EnumOrUnknown<EVideoFormat>>,
    // @@protoc_insertion_point(field:CVideoFormat.width)
    pub width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CVideoFormat.height)
    pub height: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CVideoFormat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CVideoFormat {
    fn default() -> &'a CVideoFormat {
        <CVideoFormat as ::protobuf::Message>::default_instance()
    }
}

impl CVideoFormat {
    pub fn new() -> CVideoFormat {
        ::std::default::Default::default()
    }

    // required .EVideoFormat format = 1;

    pub fn format(&self) -> EVideoFormat {
        match self.format {
            Some(e) => e.enum_value_or(EVideoFormat::k_EVideoFormatNone),
            None => EVideoFormat::k_EVideoFormatNone,
        }
    }

    pub fn clear_format(&mut self) {
        self.format = ::std::option::Option::None;
    }

    pub fn has_format(&self) -> bool {
        self.format.is_some()
    }

    // Param is passed by value, moved
    pub fn set_format(&mut self, v: EVideoFormat) {
        self.format = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 width = 2;

    pub fn width(&self) -> u32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional uint32 height = 3;

    pub fn height(&self) -> u32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CVideoFormat {
    const NAME: &'static str = "CVideoFormat";

    fn is_initialized(&self) -> bool {
        if self.format.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.format = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.width = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.height = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.format {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.format {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.width {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CVideoFormat {
        CVideoFormat::new()
    }

    fn clear(&mut self) {
        self.format = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CVideoFormat {
        static instance: CVideoFormat = CVideoFormat {
            format: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFrameEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFrameEvent {
    // message fields
    // @@protoc_insertion_point(field:CFrameEvent.event_id)
    pub event_id: ::std::option::Option<::protobuf::EnumOrUnknown<EStreamFrameEvent>>,
    // @@protoc_insertion_point(field:CFrameEvent.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CFrameEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFrameEvent {
    fn default() -> &'a CFrameEvent {
        <CFrameEvent as ::protobuf::Message>::default_instance()
    }
}

impl CFrameEvent {
    pub fn new() -> CFrameEvent {
        ::std::default::Default::default()
    }

    // required .EStreamFrameEvent event_id = 1;

    pub fn event_id(&self) -> EStreamFrameEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(EStreamFrameEvent::k_EStreamInputEventStart),
            None => EStreamFrameEvent::k_EStreamInputEventStart,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: EStreamFrameEvent) {
        self.event_id = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required uint32 timestamp = 2;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CFrameEvent {
    const NAME: &'static str = "CFrameEvent";

    fn is_initialized(&self) -> bool {
        if self.event_id.is_none() {
            return false;
        }
        if self.timestamp.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFrameEvent {
        CFrameEvent::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFrameEvent {
        static instance: CFrameEvent = CFrameEvent {
            event_id: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFrameStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFrameStats {
    // message fields
    // @@protoc_insertion_point(field:CFrameStats.frame_id)
    pub frame_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CFrameStats.input_mark)
    pub input_mark: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CFrameStats.events)
    pub events: ::std::vec::Vec<CFrameEvent>,
    // @@protoc_insertion_point(field:CFrameStats.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<EStreamFrameResult>>,
    // @@protoc_insertion_point(field:CFrameStats.frame_start_delta)
    pub frame_start_delta: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CFrameStats.frame_display_delta)
    pub frame_display_delta: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CFrameStats.ping_time)
    pub ping_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CFrameStats.server_bitrate)
    pub server_bitrate: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CFrameStats.client_bitrate)
    pub client_bitrate: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CFrameStats.link_bandwidth)
    pub link_bandwidth: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CFrameStats.packet_loss)
    pub packet_loss: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CFrameStats.frame_size)
    pub frame_size: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CFrameStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFrameStats {
    fn default() -> &'a CFrameStats {
        <CFrameStats as ::protobuf::Message>::default_instance()
    }
}

impl CFrameStats {
    pub fn new() -> CFrameStats {
        ::std::default::Default::default()
    }

    // required uint32 frame_id = 1;

    pub fn frame_id(&self) -> u32 {
        self.frame_id.unwrap_or(0)
    }

    pub fn clear_frame_id(&mut self) {
        self.frame_id = ::std::option::Option::None;
    }

    pub fn has_frame_id(&self) -> bool {
        self.frame_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frame_id(&mut self, v: u32) {
        self.frame_id = ::std::option::Option::Some(v);
    }

    // optional uint32 input_mark = 2;

    pub fn input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }

    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    // required .EStreamFrameResult result = 4;

    pub fn result(&self) -> EStreamFrameResult {
        match self.result {
            Some(e) => e.enum_value_or(EStreamFrameResult::k_EStreamFrameResultPending),
            None => EStreamFrameResult::k_EStreamFrameResultPending,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: EStreamFrameResult) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional float frame_start_delta = 5;

    pub fn frame_start_delta(&self) -> f32 {
        self.frame_start_delta.unwrap_or(0.)
    }

    pub fn clear_frame_start_delta(&mut self) {
        self.frame_start_delta = ::std::option::Option::None;
    }

    pub fn has_frame_start_delta(&self) -> bool {
        self.frame_start_delta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frame_start_delta(&mut self, v: f32) {
        self.frame_start_delta = ::std::option::Option::Some(v);
    }

    // optional float frame_display_delta = 6;

    pub fn frame_display_delta(&self) -> f32 {
        self.frame_display_delta.unwrap_or(0.)
    }

    pub fn clear_frame_display_delta(&mut self) {
        self.frame_display_delta = ::std::option::Option::None;
    }

    pub fn has_frame_display_delta(&self) -> bool {
        self.frame_display_delta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frame_display_delta(&mut self, v: f32) {
        self.frame_display_delta = ::std::option::Option::Some(v);
    }

    // optional float ping_time = 7;

    pub fn ping_time(&self) -> f32 {
        self.ping_time.unwrap_or(0.)
    }

    pub fn clear_ping_time(&mut self) {
        self.ping_time = ::std::option::Option::None;
    }

    pub fn has_ping_time(&self) -> bool {
        self.ping_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_time(&mut self, v: f32) {
        self.ping_time = ::std::option::Option::Some(v);
    }

    // optional float server_bitrate = 8;

    pub fn server_bitrate(&self) -> f32 {
        self.server_bitrate.unwrap_or(0.)
    }

    pub fn clear_server_bitrate(&mut self) {
        self.server_bitrate = ::std::option::Option::None;
    }

    pub fn has_server_bitrate(&self) -> bool {
        self.server_bitrate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_bitrate(&mut self, v: f32) {
        self.server_bitrate = ::std::option::Option::Some(v);
    }

    // optional float client_bitrate = 9;

    pub fn client_bitrate(&self) -> f32 {
        self.client_bitrate.unwrap_or(0.)
    }

    pub fn clear_client_bitrate(&mut self) {
        self.client_bitrate = ::std::option::Option::None;
    }

    pub fn has_client_bitrate(&self) -> bool {
        self.client_bitrate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_bitrate(&mut self, v: f32) {
        self.client_bitrate = ::std::option::Option::Some(v);
    }

    // optional float link_bandwidth = 10;

    pub fn link_bandwidth(&self) -> f32 {
        self.link_bandwidth.unwrap_or(0.)
    }

    pub fn clear_link_bandwidth(&mut self) {
        self.link_bandwidth = ::std::option::Option::None;
    }

    pub fn has_link_bandwidth(&self) -> bool {
        self.link_bandwidth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_link_bandwidth(&mut self, v: f32) {
        self.link_bandwidth = ::std::option::Option::Some(v);
    }

    // optional float packet_loss = 11;

    pub fn packet_loss(&self) -> f32 {
        self.packet_loss.unwrap_or(0.)
    }

    pub fn clear_packet_loss(&mut self) {
        self.packet_loss = ::std::option::Option::None;
    }

    pub fn has_packet_loss(&self) -> bool {
        self.packet_loss.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packet_loss(&mut self, v: f32) {
        self.packet_loss = ::std::option::Option::Some(v);
    }

    // optional uint32 frame_size = 12;

    pub fn frame_size(&self) -> u32 {
        self.frame_size.unwrap_or(0)
    }

    pub fn clear_frame_size(&mut self) {
        self.frame_size = ::std::option::Option::None;
    }

    pub fn has_frame_size(&self) -> bool {
        self.frame_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frame_size(&mut self, v: u32) {
        self.frame_size = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CFrameStats {
    const NAME: &'static str = "CFrameStats";

    fn is_initialized(&self) -> bool {
        if self.frame_id.is_none() {
            return false;
        }
        if self.result.is_none() {
            return false;
        }
        for v in &self.events {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.frame_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.input_mark = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.events.push(is.read_message()?);
                },
                32 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                45 => {
                    self.frame_start_delta = ::std::option::Option::Some(is.read_float()?);
                },
                53 => {
                    self.frame_display_delta = ::std::option::Option::Some(is.read_float()?);
                },
                61 => {
                    self.ping_time = ::std::option::Option::Some(is.read_float()?);
                },
                69 => {
                    self.server_bitrate = ::std::option::Option::Some(is.read_float()?);
                },
                77 => {
                    self.client_bitrate = ::std::option::Option::Some(is.read_float()?);
                },
                85 => {
                    self.link_bandwidth = ::std::option::Option::Some(is.read_float()?);
                },
                93 => {
                    self.packet_loss = ::std::option::Option::Some(is.read_float()?);
                },
                96 => {
                    self.frame_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.frame_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.input_mark {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.frame_start_delta {
            my_size += 1 + 4;
        }
        if let Some(v) = self.frame_display_delta {
            my_size += 1 + 4;
        }
        if let Some(v) = self.ping_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_bitrate {
            my_size += 1 + 4;
        }
        if let Some(v) = self.client_bitrate {
            my_size += 1 + 4;
        }
        if let Some(v) = self.link_bandwidth {
            my_size += 1 + 4;
        }
        if let Some(v) = self.packet_loss {
            my_size += 1 + 4;
        }
        if let Some(v) = self.frame_size {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.frame_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.input_mark {
            os.write_uint32(2, v)?;
        }
        for v in &self.events {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.result {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.frame_start_delta {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.frame_display_delta {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.ping_time {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.server_bitrate {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.client_bitrate {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.link_bandwidth {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.packet_loss {
            os.write_float(11, v)?;
        }
        if let Some(v) = self.frame_size {
            os.write_uint32(12, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFrameStats {
        CFrameStats::new()
    }

    fn clear(&mut self) {
        self.frame_id = ::std::option::Option::None;
        self.input_mark = ::std::option::Option::None;
        self.events.clear();
        self.result = ::std::option::Option::None;
        self.frame_start_delta = ::std::option::Option::None;
        self.frame_display_delta = ::std::option::Option::None;
        self.ping_time = ::std::option::Option::None;
        self.server_bitrate = ::std::option::Option::None;
        self.client_bitrate = ::std::option::Option::None;
        self.link_bandwidth = ::std::option::Option::None;
        self.packet_loss = ::std::option::Option::None;
        self.frame_size = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFrameStats {
        static instance: CFrameStats = CFrameStats {
            frame_id: ::std::option::Option::None,
            input_mark: ::std::option::Option::None,
            events: ::std::vec::Vec::new(),
            result: ::std::option::Option::None,
            frame_start_delta: ::std::option::Option::None,
            frame_display_delta: ::std::option::Option::None,
            ping_time: ::std::option::Option::None,
            server_bitrate: ::std::option::Option::None,
            client_bitrate: ::std::option::Option::None,
            link_bandwidth: ::std::option::Option::None,
            packet_loss: ::std::option::Option::None,
            frame_size: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFrameStatAccumulatedValue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFrameStatAccumulatedValue {
    // message fields
    // @@protoc_insertion_point(field:CFrameStatAccumulatedValue.stat_type)
    pub stat_type: ::std::option::Option<::protobuf::EnumOrUnknown<EFrameAccumulatedStat>>,
    // @@protoc_insertion_point(field:CFrameStatAccumulatedValue.count)
    pub count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CFrameStatAccumulatedValue.average)
    pub average: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CFrameStatAccumulatedValue.stddev)
    pub stddev: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CFrameStatAccumulatedValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFrameStatAccumulatedValue {
    fn default() -> &'a CFrameStatAccumulatedValue {
        <CFrameStatAccumulatedValue as ::protobuf::Message>::default_instance()
    }
}

impl CFrameStatAccumulatedValue {
    pub fn new() -> CFrameStatAccumulatedValue {
        ::std::default::Default::default()
    }

    // required .EFrameAccumulatedStat stat_type = 1;

    pub fn stat_type(&self) -> EFrameAccumulatedStat {
        match self.stat_type {
            Some(e) => e.enum_value_or(EFrameAccumulatedStat::k_EFrameStatFPS),
            None => EFrameAccumulatedStat::k_EFrameStatFPS,
        }
    }

    pub fn clear_stat_type(&mut self) {
        self.stat_type = ::std::option::Option::None;
    }

    pub fn has_stat_type(&self) -> bool {
        self.stat_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat_type(&mut self, v: EFrameAccumulatedStat) {
        self.stat_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int32 count = 2;

    pub fn count(&self) -> i32 {
        self.count.unwrap_or(0)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i32) {
        self.count = ::std::option::Option::Some(v);
    }

    // required float average = 3;

    pub fn average(&self) -> f32 {
        self.average.unwrap_or(0.)
    }

    pub fn clear_average(&mut self) {
        self.average = ::std::option::Option::None;
    }

    pub fn has_average(&self) -> bool {
        self.average.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average(&mut self, v: f32) {
        self.average = ::std::option::Option::Some(v);
    }

    // optional float stddev = 4;

    pub fn stddev(&self) -> f32 {
        self.stddev.unwrap_or(0.)
    }

    pub fn clear_stddev(&mut self) {
        self.stddev = ::std::option::Option::None;
    }

    pub fn has_stddev(&self) -> bool {
        self.stddev.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stddev(&mut self, v: f32) {
        self.stddev = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CFrameStatAccumulatedValue {
    const NAME: &'static str = "CFrameStatAccumulatedValue";

    fn is_initialized(&self) -> bool {
        if self.stat_type.is_none() {
            return false;
        }
        if self.count.is_none() {
            return false;
        }
        if self.average.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.stat_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.count = ::std::option::Option::Some(is.read_int32()?);
                },
                29 => {
                    self.average = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.stddev = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.stat_type {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.average {
            my_size += 1 + 4;
        }
        if let Some(v) = self.stddev {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.stat_type {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.count {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.average {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.stddev {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFrameStatAccumulatedValue {
        CFrameStatAccumulatedValue::new()
    }

    fn clear(&mut self) {
        self.stat_type = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.average = ::std::option::Option::None;
        self.stddev = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFrameStatAccumulatedValue {
        static instance: CFrameStatAccumulatedValue = CFrameStatAccumulatedValue {
            stat_type: ::std::option::Option::None,
            count: ::std::option::Option::None,
            average: ::std::option::Option::None,
            stddev: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFrameStatsListMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFrameStatsListMsg {
    // message fields
    // @@protoc_insertion_point(field:CFrameStatsListMsg.data_type)
    pub data_type: ::std::option::Option<::protobuf::EnumOrUnknown<EStreamingDataType>>,
    // @@protoc_insertion_point(field:CFrameStatsListMsg.stats)
    pub stats: ::std::vec::Vec<CFrameStats>,
    // @@protoc_insertion_point(field:CFrameStatsListMsg.accumulated_stats)
    pub accumulated_stats: ::std::vec::Vec<CFrameStatAccumulatedValue>,
    // @@protoc_insertion_point(field:CFrameStatsListMsg.latest_frame_id)
    pub latest_frame_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CFrameStatsListMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFrameStatsListMsg {
    fn default() -> &'a CFrameStatsListMsg {
        <CFrameStatsListMsg as ::protobuf::Message>::default_instance()
    }
}

impl CFrameStatsListMsg {
    pub fn new() -> CFrameStatsListMsg {
        ::std::default::Default::default()
    }

    // required .EStreamingDataType data_type = 1;

    pub fn data_type(&self) -> EStreamingDataType {
        match self.data_type {
            Some(e) => e.enum_value_or(EStreamingDataType::k_EStreamingAudioData),
            None => EStreamingDataType::k_EStreamingAudioData,
        }
    }

    pub fn clear_data_type(&mut self) {
        self.data_type = ::std::option::Option::None;
    }

    pub fn has_data_type(&self) -> bool {
        self.data_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_type(&mut self, v: EStreamingDataType) {
        self.data_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int32 latest_frame_id = 4;

    pub fn latest_frame_id(&self) -> i32 {
        self.latest_frame_id.unwrap_or(0)
    }

    pub fn clear_latest_frame_id(&mut self) {
        self.latest_frame_id = ::std::option::Option::None;
    }

    pub fn has_latest_frame_id(&self) -> bool {
        self.latest_frame_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_latest_frame_id(&mut self, v: i32) {
        self.latest_frame_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CFrameStatsListMsg {
    const NAME: &'static str = "CFrameStatsListMsg";

    fn is_initialized(&self) -> bool {
        if self.data_type.is_none() {
            return false;
        }
        if self.latest_frame_id.is_none() {
            return false;
        }
        for v in &self.stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.accumulated_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.data_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.stats.push(is.read_message()?);
                },
                26 => {
                    self.accumulated_stats.push(is.read_message()?);
                },
                32 => {
                    self.latest_frame_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data_type {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.accumulated_stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.latest_frame_id {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.data_type {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.stats {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.accumulated_stats {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.latest_frame_id {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFrameStatsListMsg {
        CFrameStatsListMsg::new()
    }

    fn clear(&mut self) {
        self.data_type = ::std::option::Option::None;
        self.stats.clear();
        self.accumulated_stats.clear();
        self.latest_frame_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFrameStatsListMsg {
        static instance: CFrameStatsListMsg = CFrameStatsListMsg {
            data_type: ::std::option::Option::None,
            stats: ::std::vec::Vec::new(),
            accumulated_stats: ::std::vec::Vec::new(),
            latest_frame_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CStreamingSessionStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStreamingSessionStats {
    // message fields
    // @@protoc_insertion_point(field:CStreamingSessionStats.frame_loss_percentage)
    pub frame_loss_percentage: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CStreamingSessionStats.average_network_time_ms)
    pub average_network_time_ms: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CStreamingSessionStats.stddev_network_time_ms)
    pub stddev_network_time_ms: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CStreamingSessionStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStreamingSessionStats {
    fn default() -> &'a CStreamingSessionStats {
        <CStreamingSessionStats as ::protobuf::Message>::default_instance()
    }
}

impl CStreamingSessionStats {
    pub fn new() -> CStreamingSessionStats {
        ::std::default::Default::default()
    }

    // optional float frame_loss_percentage = 1;

    pub fn frame_loss_percentage(&self) -> f32 {
        self.frame_loss_percentage.unwrap_or(0.)
    }

    pub fn clear_frame_loss_percentage(&mut self) {
        self.frame_loss_percentage = ::std::option::Option::None;
    }

    pub fn has_frame_loss_percentage(&self) -> bool {
        self.frame_loss_percentage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frame_loss_percentage(&mut self, v: f32) {
        self.frame_loss_percentage = ::std::option::Option::Some(v);
    }

    // optional float average_network_time_ms = 2;

    pub fn average_network_time_ms(&self) -> f32 {
        self.average_network_time_ms.unwrap_or(0.)
    }

    pub fn clear_average_network_time_ms(&mut self) {
        self.average_network_time_ms = ::std::option::Option::None;
    }

    pub fn has_average_network_time_ms(&self) -> bool {
        self.average_network_time_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average_network_time_ms(&mut self, v: f32) {
        self.average_network_time_ms = ::std::option::Option::Some(v);
    }

    // optional float stddev_network_time_ms = 3;

    pub fn stddev_network_time_ms(&self) -> f32 {
        self.stddev_network_time_ms.unwrap_or(0.)
    }

    pub fn clear_stddev_network_time_ms(&mut self) {
        self.stddev_network_time_ms = ::std::option::Option::None;
    }

    pub fn has_stddev_network_time_ms(&self) -> bool {
        self.stddev_network_time_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stddev_network_time_ms(&mut self, v: f32) {
        self.stddev_network_time_ms = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CStreamingSessionStats {
    const NAME: &'static str = "CStreamingSessionStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.frame_loss_percentage = ::std::option::Option::Some(is.read_float()?);
                },
                21 => {
                    self.average_network_time_ms = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.stddev_network_time_ms = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.frame_loss_percentage {
            my_size += 1 + 4;
        }
        if let Some(v) = self.average_network_time_ms {
            my_size += 1 + 4;
        }
        if let Some(v) = self.stddev_network_time_ms {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.frame_loss_percentage {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.average_network_time_ms {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.stddev_network_time_ms {
            os.write_float(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStreamingSessionStats {
        CStreamingSessionStats::new()
    }

    fn clear(&mut self) {
        self.frame_loss_percentage = ::std::option::Option::None;
        self.average_network_time_ms = ::std::option::Option::None;
        self.stddev_network_time_ms = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStreamingSessionStats {
        static instance: CStreamingSessionStats = CStreamingSessionStats {
            frame_loss_percentage: ::std::option::Option::None,
            average_network_time_ms: ::std::option::Option::None,
            stddev_network_time_ms: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDebugDumpMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDebugDumpMsg {
    // message fields
    // @@protoc_insertion_point(field:CDebugDumpMsg.screenshot)
    pub screenshot: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CDebugDumpMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDebugDumpMsg {
    fn default() -> &'a CDebugDumpMsg {
        <CDebugDumpMsg as ::protobuf::Message>::default_instance()
    }
}

impl CDebugDumpMsg {
    pub fn new() -> CDebugDumpMsg {
        ::std::default::Default::default()
    }

    // optional bytes screenshot = 1;

    pub fn screenshot(&self) -> &[u8] {
        match self.screenshot.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_screenshot(&mut self) {
        self.screenshot = ::std::option::Option::None;
    }

    pub fn has_screenshot(&self) -> bool {
        self.screenshot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screenshot(&mut self, v: ::std::vec::Vec<u8>) {
        self.screenshot = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_screenshot(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.screenshot.is_none() {
            self.screenshot = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.screenshot.as_mut().unwrap()
    }

    // Take field
    pub fn take_screenshot(&mut self) -> ::std::vec::Vec<u8> {
        self.screenshot.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CDebugDumpMsg {
    const NAME: &'static str = "CDebugDumpMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.screenshot = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.screenshot.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.screenshot.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDebugDumpMsg {
        CDebugDumpMsg::new()
    }

    fn clear(&mut self) {
        self.screenshot = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDebugDumpMsg {
        static instance: CDebugDumpMsg = CDebugDumpMsg {
            screenshot: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CLogMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CLogMsg {
    // message fields
    // @@protoc_insertion_point(field:CLogMsg.type)
    pub type_: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CLogMsg.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CLogMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CLogMsg {
    fn default() -> &'a CLogMsg {
        <CLogMsg as ::protobuf::Message>::default_instance()
    }
}

impl CLogMsg {
    pub fn new() -> CLogMsg {
        ::std::default::Default::default()
    }

    // optional int32 type = 1;

    pub fn type_(&self) -> i32 {
        self.type_.unwrap_or(0)
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: i32) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // optional string message = 2;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CLogMsg {
    const NAME: &'static str = "CLogMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CLogMsg {
        CLogMsg::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CLogMsg {
        static instance: CLogMsg = CLogMsg {
            type_: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CLogUploadMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CLogUploadMsg {
    // message fields
    // @@protoc_insertion_point(field:CLogUploadMsg.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<ELogFileType>>,
    // @@protoc_insertion_point(field:CLogUploadMsg.data)
    pub data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CLogUploadMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CLogUploadMsg {
    fn default() -> &'a CLogUploadMsg {
        <CLogUploadMsg as ::protobuf::Message>::default_instance()
    }
}

impl CLogUploadMsg {
    pub fn new() -> CLogUploadMsg {
        ::std::default::Default::default()
    }

    // optional .ELogFileType type = 1;

    pub fn type_(&self) -> ELogFileType {
        match self.type_ {
            Some(e) => e.enum_value_or(ELogFileType::k_ELogFileSystemBoot),
            None => ELogFileType::k_ELogFileSystemBoot,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ELogFileType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bytes data = 3;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CLogUploadMsg {
    const NAME: &'static str = "CLogUploadMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    self.data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CLogUploadMsg {
        CLogUploadMsg::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CLogUploadMsg {
        static instance: CLogUploadMsg = CLogUploadMsg {
            type_: ::std::option::Option::None,
            data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CTransportSignalMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CTransportSignalMsg {
    // message fields
    // @@protoc_insertion_point(field:CTransportSignalMsg.webrtc)
    pub webrtc: ::protobuf::MessageField<ctransport_signal_msg::WebRTCMessage>,
    // @@protoc_insertion_point(field:CTransportSignalMsg.sdr)
    pub sdr: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CTransportSignalMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CTransportSignalMsg {
    fn default() -> &'a CTransportSignalMsg {
        <CTransportSignalMsg as ::protobuf::Message>::default_instance()
    }
}

impl CTransportSignalMsg {
    pub fn new() -> CTransportSignalMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CTransportSignalMsg {
    const NAME: &'static str = "CTransportSignalMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.webrtc)?;
                },
                18 => {
                    self.sdr.push(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.webrtc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.sdr {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.webrtc.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.sdr {
            os.write_bytes(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CTransportSignalMsg {
        CTransportSignalMsg::new()
    }

    fn clear(&mut self) {
        self.webrtc.clear();
        self.sdr.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CTransportSignalMsg {
        static instance: CTransportSignalMsg = CTransportSignalMsg {
            webrtc: ::protobuf::MessageField::none(),
            sdr: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CTransportSignalMsg`
pub mod ctransport_signal_msg {
    // @@protoc_insertion_point(message:CTransportSignalMsg.WebRTCMessage)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct WebRTCMessage {
        // message oneof groups
        pub msg: ::std::option::Option<web_rtcmessage::Msg>,
        // special fields
        // @@protoc_insertion_point(special_field:CTransportSignalMsg.WebRTCMessage.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a WebRTCMessage {
        fn default() -> &'a WebRTCMessage {
            <WebRTCMessage as ::protobuf::Message>::default_instance()
        }
    }

    impl WebRTCMessage {
        pub fn new() -> WebRTCMessage {
            ::std::default::Default::default()
        }

        // optional bool greeting = 1;

        pub fn greeting(&self) -> bool {
            match self.msg {
                ::std::option::Option::Some(web_rtcmessage::Msg::Greeting(v)) => v,
                _ => false,
            }
        }

        pub fn clear_greeting(&mut self) {
            self.msg = ::std::option::Option::None;
        }

        pub fn has_greeting(&self) -> bool {
            match self.msg {
                ::std::option::Option::Some(web_rtcmessage::Msg::Greeting(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_greeting(&mut self, v: bool) {
            self.msg = ::std::option::Option::Some(web_rtcmessage::Msg::Greeting(v))
        }

        // optional string offer = 2;

        pub fn offer(&self) -> &str {
            match self.msg {
                ::std::option::Option::Some(web_rtcmessage::Msg::Offer(ref v)) => v,
                _ => "",
            }
        }

        pub fn clear_offer(&mut self) {
            self.msg = ::std::option::Option::None;
        }

        pub fn has_offer(&self) -> bool {
            match self.msg {
                ::std::option::Option::Some(web_rtcmessage::Msg::Offer(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_offer(&mut self, v: ::std::string::String) {
            self.msg = ::std::option::Option::Some(web_rtcmessage::Msg::Offer(v))
        }

        // Mutable pointer to the field.
        pub fn mut_offer(&mut self) -> &mut ::std::string::String {
            if let ::std::option::Option::Some(web_rtcmessage::Msg::Offer(_)) = self.msg {
            } else {
                self.msg = ::std::option::Option::Some(web_rtcmessage::Msg::Offer(::std::string::String::new()));
            }
            match self.msg {
                ::std::option::Option::Some(web_rtcmessage::Msg::Offer(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_offer(&mut self) -> ::std::string::String {
            if self.has_offer() {
                match self.msg.take() {
                    ::std::option::Option::Some(web_rtcmessage::Msg::Offer(v)) => v,
                    _ => panic!(),
                }
            } else {
                ::std::string::String::new()
            }
        }

        // optional string answer = 3;

        pub fn answer(&self) -> &str {
            match self.msg {
                ::std::option::Option::Some(web_rtcmessage::Msg::Answer(ref v)) => v,
                _ => "",
            }
        }

        pub fn clear_answer(&mut self) {
            self.msg = ::std::option::Option::None;
        }

        pub fn has_answer(&self) -> bool {
            match self.msg {
                ::std::option::Option::Some(web_rtcmessage::Msg::Answer(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_answer(&mut self, v: ::std::string::String) {
            self.msg = ::std::option::Option::Some(web_rtcmessage::Msg::Answer(v))
        }

        // Mutable pointer to the field.
        pub fn mut_answer(&mut self) -> &mut ::std::string::String {
            if let ::std::option::Option::Some(web_rtcmessage::Msg::Answer(_)) = self.msg {
            } else {
                self.msg = ::std::option::Option::Some(web_rtcmessage::Msg::Answer(::std::string::String::new()));
            }
            match self.msg {
                ::std::option::Option::Some(web_rtcmessage::Msg::Answer(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_answer(&mut self) -> ::std::string::String {
            if self.has_answer() {
                match self.msg.take() {
                    ::std::option::Option::Some(web_rtcmessage::Msg::Answer(v)) => v,
                    _ => panic!(),
                }
            } else {
                ::std::string::String::new()
            }
        }

        // optional .CTransportSignalMsg.WebRTCMessage.Candidate candidate = 4;

        pub fn candidate(&self) -> &web_rtcmessage::Candidate {
            match self.msg {
                ::std::option::Option::Some(web_rtcmessage::Msg::Candidate(ref v)) => v,
                _ => <web_rtcmessage::Candidate as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_candidate(&mut self) {
            self.msg = ::std::option::Option::None;
        }

        pub fn has_candidate(&self) -> bool {
            match self.msg {
                ::std::option::Option::Some(web_rtcmessage::Msg::Candidate(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_candidate(&mut self, v: web_rtcmessage::Candidate) {
            self.msg = ::std::option::Option::Some(web_rtcmessage::Msg::Candidate(v))
        }

        // Mutable pointer to the field.
        pub fn mut_candidate(&mut self) -> &mut web_rtcmessage::Candidate {
            if let ::std::option::Option::Some(web_rtcmessage::Msg::Candidate(_)) = self.msg {
            } else {
                self.msg = ::std::option::Option::Some(web_rtcmessage::Msg::Candidate(web_rtcmessage::Candidate::new()));
            }
            match self.msg {
                ::std::option::Option::Some(web_rtcmessage::Msg::Candidate(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_candidate(&mut self) -> web_rtcmessage::Candidate {
            if self.has_candidate() {
                match self.msg.take() {
                    ::std::option::Option::Some(web_rtcmessage::Msg::Candidate(v)) => v,
                    _ => panic!(),
                }
            } else {
                web_rtcmessage::Candidate::new()
            }
        }
    }

    impl ::protobuf::Message for WebRTCMessage {
        const NAME: &'static str = "WebRTCMessage";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.msg = ::std::option::Option::Some(web_rtcmessage::Msg::Greeting(is.read_bool()?));
                    },
                    18 => {
                        self.msg = ::std::option::Option::Some(web_rtcmessage::Msg::Offer(is.read_string()?));
                    },
                    26 => {
                        self.msg = ::std::option::Option::Some(web_rtcmessage::Msg::Answer(is.read_string()?));
                    },
                    34 => {
                        self.msg = ::std::option::Option::Some(web_rtcmessage::Msg::Candidate(is.read_message()?));
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let ::std::option::Option::Some(ref v) = self.msg {
                match v {
                    &web_rtcmessage::Msg::Greeting(v) => {
                        my_size += 1 + 1;
                    },
                    &web_rtcmessage::Msg::Offer(ref v) => {
                        my_size += ::protobuf::rt::string_size(2, &v);
                    },
                    &web_rtcmessage::Msg::Answer(ref v) => {
                        my_size += ::protobuf::rt::string_size(3, &v);
                    },
                    &web_rtcmessage::Msg::Candidate(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                };
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let ::std::option::Option::Some(ref v) = self.msg {
                match v {
                    &web_rtcmessage::Msg::Greeting(v) => {
                        os.write_bool(1, v)?;
                    },
                    &web_rtcmessage::Msg::Offer(ref v) => {
                        os.write_string(2, v)?;
                    },
                    &web_rtcmessage::Msg::Answer(ref v) => {
                        os.write_string(3, v)?;
                    },
                    &web_rtcmessage::Msg::Candidate(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                    },
                };
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> WebRTCMessage {
            WebRTCMessage::new()
        }

        fn clear(&mut self) {
            self.msg = ::std::option::Option::None;
            self.msg = ::std::option::Option::None;
            self.msg = ::std::option::Option::None;
            self.msg = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static WebRTCMessage {
            static instance: WebRTCMessage = WebRTCMessage {
                msg: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `WebRTCMessage`
    pub mod web_rtcmessage {

        #[derive(Clone,PartialEq,Debug)]
        #[non_exhaustive]
        // @@protoc_insertion_point(oneof:CTransportSignalMsg.WebRTCMessage.msg)
        pub enum Msg {
            // @@protoc_insertion_point(oneof_field:CTransportSignalMsg.WebRTCMessage.greeting)
            Greeting(bool),
            // @@protoc_insertion_point(oneof_field:CTransportSignalMsg.WebRTCMessage.offer)
            Offer(::std::string::String),
            // @@protoc_insertion_point(oneof_field:CTransportSignalMsg.WebRTCMessage.answer)
            Answer(::std::string::String),
            // @@protoc_insertion_point(oneof_field:CTransportSignalMsg.WebRTCMessage.candidate)
            Candidate(Candidate),
        }

        impl ::protobuf::Oneof for Msg {
        }

        impl Msg {
        }
        // @@protoc_insertion_point(message:CTransportSignalMsg.WebRTCMessage.Candidate)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Candidate {
            // message fields
            // @@protoc_insertion_point(field:CTransportSignalMsg.WebRTCMessage.Candidate.sdp_mid)
            pub sdp_mid: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:CTransportSignalMsg.WebRTCMessage.Candidate.sdp_mline_index)
            pub sdp_mline_index: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:CTransportSignalMsg.WebRTCMessage.Candidate.candidate)
            pub candidate: ::std::option::Option<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:CTransportSignalMsg.WebRTCMessage.Candidate.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Candidate {
            fn default() -> &'a Candidate {
                <Candidate as ::protobuf::Message>::default_instance()
            }
        }

        impl Candidate {
            pub fn new() -> Candidate {
                ::std::default::Default::default()
            }

            // optional string sdp_mid = 1;

            pub fn sdp_mid(&self) -> &str {
                match self.sdp_mid.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_sdp_mid(&mut self) {
                self.sdp_mid = ::std::option::Option::None;
            }

            pub fn has_sdp_mid(&self) -> bool {
                self.sdp_mid.is_some()
            }

            // Param is passed by value, moved
            pub fn set_sdp_mid(&mut self, v: ::std::string::String) {
                self.sdp_mid = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_sdp_mid(&mut self) -> &mut ::std::string::String {
                if self.sdp_mid.is_none() {
                    self.sdp_mid = ::std::option::Option::Some(::std::string::String::new());
                }
                self.sdp_mid.as_mut().unwrap()
            }

            // Take field
            pub fn take_sdp_mid(&mut self) -> ::std::string::String {
                self.sdp_mid.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional int32 sdp_mline_index = 2;

            pub fn sdp_mline_index(&self) -> i32 {
                self.sdp_mline_index.unwrap_or(0)
            }

            pub fn clear_sdp_mline_index(&mut self) {
                self.sdp_mline_index = ::std::option::Option::None;
            }

            pub fn has_sdp_mline_index(&self) -> bool {
                self.sdp_mline_index.is_some()
            }

            // Param is passed by value, moved
            pub fn set_sdp_mline_index(&mut self, v: i32) {
                self.sdp_mline_index = ::std::option::Option::Some(v);
            }

            // optional string candidate = 3;

            pub fn candidate(&self) -> &str {
                match self.candidate.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_candidate(&mut self) {
                self.candidate = ::std::option::Option::None;
            }

            pub fn has_candidate(&self) -> bool {
                self.candidate.is_some()
            }

            // Param is passed by value, moved
            pub fn set_candidate(&mut self, v: ::std::string::String) {
                self.candidate = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_candidate(&mut self) -> &mut ::std::string::String {
                if self.candidate.is_none() {
                    self.candidate = ::std::option::Option::Some(::std::string::String::new());
                }
                self.candidate.as_mut().unwrap()
            }

            // Take field
            pub fn take_candidate(&mut self) -> ::std::string::String {
                self.candidate.take().unwrap_or_else(|| ::std::string::String::new())
            }
        }

        impl ::protobuf::Message for Candidate {
            const NAME: &'static str = "Candidate";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.sdp_mid = ::std::option::Option::Some(is.read_string()?);
                        },
                        16 => {
                            self.sdp_mline_index = ::std::option::Option::Some(is.read_int32()?);
                        },
                        26 => {
                            self.candidate = ::std::option::Option::Some(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.sdp_mid.as_ref() {
                    my_size += ::protobuf::rt::string_size(1, &v);
                }
                if let Some(v) = self.sdp_mline_index {
                    my_size += ::protobuf::rt::int32_size(2, v);
                }
                if let Some(v) = self.candidate.as_ref() {
                    my_size += ::protobuf::rt::string_size(3, &v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.sdp_mid.as_ref() {
                    os.write_string(1, v)?;
                }
                if let Some(v) = self.sdp_mline_index {
                    os.write_int32(2, v)?;
                }
                if let Some(v) = self.candidate.as_ref() {
                    os.write_string(3, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Candidate {
                Candidate::new()
            }

            fn clear(&mut self) {
                self.sdp_mid = ::std::option::Option::None;
                self.sdp_mline_index = ::std::option::Option::None;
                self.candidate = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Candidate {
                static instance: Candidate = Candidate {
                    sdp_mid: ::std::option::Option::None,
                    sdp_mline_index: ::std::option::Option::None,
                    candidate: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }
    }
}

// @@protoc_insertion_point(message:CControllerConfigMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CControllerConfigMsg {
    // message fields
    // @@protoc_insertion_point(field:CControllerConfigMsg.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<EStreamControllerConfigMsg>>,
    // @@protoc_insertion_point(field:CControllerConfigMsg.controllerPath)
    pub controllerPath: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CControllerConfigMsg.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CControllerConfigMsg.personalizationResponse)
    pub personalizationResponse: ::protobuf::MessageField<ccontroller_config_msg::ControllerPersonalizationResponse>,
    // @@protoc_insertion_point(field:CControllerConfigMsg.configResponse)
    pub configResponse: ::std::vec::Vec<ccontroller_config_msg::ControllerConfigResponse>,
    // @@protoc_insertion_point(field:CControllerConfigMsg.activeConfigChangeMsg)
    pub activeConfigChangeMsg: ::protobuf::MessageField<ccontroller_config_msg::ControllerActiveConfigMsg>,
    // special fields
    // @@protoc_insertion_point(special_field:CControllerConfigMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CControllerConfigMsg {
    fn default() -> &'a CControllerConfigMsg {
        <CControllerConfigMsg as ::protobuf::Message>::default_instance()
    }
}

impl CControllerConfigMsg {
    pub fn new() -> CControllerConfigMsg {
        ::std::default::Default::default()
    }

    // required .EStreamControllerConfigMsg type = 1;

    pub fn type_(&self) -> EStreamControllerConfigMsg {
        match self.type_ {
            Some(e) => e.enum_value_or(EStreamControllerConfigMsg::k_EStreamControllerConfigMsg_RequestConfigsForApp),
            None => EStreamControllerConfigMsg::k_EStreamControllerConfigMsg_RequestConfigsForApp,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: EStreamControllerConfigMsg) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string controllerPath = 2;

    pub fn controllerPath(&self) -> &str {
        match self.controllerPath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_controllerPath(&mut self) {
        self.controllerPath = ::std::option::Option::None;
    }

    pub fn has_controllerPath(&self) -> bool {
        self.controllerPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controllerPath(&mut self, v: ::std::string::String) {
        self.controllerPath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_controllerPath(&mut self) -> &mut ::std::string::String {
        if self.controllerPath.is_none() {
            self.controllerPath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.controllerPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_controllerPath(&mut self) -> ::std::string::String {
        self.controllerPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 appid = 3;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CControllerConfigMsg {
    const NAME: &'static str = "CControllerConfigMsg";

    fn is_initialized(&self) -> bool {
        if self.type_.is_none() {
            return false;
        }
        for v in &self.personalizationResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.configResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.activeConfigChangeMsg {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.controllerPath = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.personalizationResponse)?;
                },
                50 => {
                    self.configResponse.push(is.read_message()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.activeConfigChangeMsg)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.controllerPath.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.personalizationResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.configResponse {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.activeConfigChangeMsg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.controllerPath.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.personalizationResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        for v in &self.configResponse {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if let Some(v) = self.activeConfigChangeMsg.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CControllerConfigMsg {
        CControllerConfigMsg::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.controllerPath = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.personalizationResponse.clear();
        self.configResponse.clear();
        self.activeConfigChangeMsg.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CControllerConfigMsg {
        static instance: CControllerConfigMsg = CControllerConfigMsg {
            type_: ::std::option::Option::None,
            controllerPath: ::std::option::Option::None,
            appid: ::std::option::Option::None,
            personalizationResponse: ::protobuf::MessageField::none(),
            configResponse: ::std::vec::Vec::new(),
            activeConfigChangeMsg: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CControllerConfigMsg`
pub mod ccontroller_config_msg {
    // @@protoc_insertion_point(message:CControllerConfigMsg.ControllerConfigResponse)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ControllerConfigResponse {
        // message fields
        // @@protoc_insertion_point(field:CControllerConfigMsg.ControllerConfigResponse.appid)
        pub appid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CControllerConfigMsg.ControllerConfigResponse.configURL)
        pub configURL: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CControllerConfigMsg.ControllerConfigResponse.controllerType)
        pub controllerType: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CControllerConfigMsg.ControllerConfigResponse.controllerData)
        pub controllerData: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CControllerConfigMsg.ControllerConfigResponse.selectionOrder)
        pub selectionOrder: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CControllerConfigMsg.ControllerConfigResponse.actionBlock)
        pub actionBlock: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CControllerConfigMsg.ControllerConfigResponse.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ControllerConfigResponse {
        fn default() -> &'a ControllerConfigResponse {
            <ControllerConfigResponse as ::protobuf::Message>::default_instance()
        }
    }

    impl ControllerConfigResponse {
        pub fn new() -> ControllerConfigResponse {
            ::std::default::Default::default()
        }

        // optional uint32 appid = 1;

        pub fn appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }

        // optional string configURL = 2;

        pub fn configURL(&self) -> &str {
            match self.configURL.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_configURL(&mut self) {
            self.configURL = ::std::option::Option::None;
        }

        pub fn has_configURL(&self) -> bool {
            self.configURL.is_some()
        }

        // Param is passed by value, moved
        pub fn set_configURL(&mut self, v: ::std::string::String) {
            self.configURL = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_configURL(&mut self) -> &mut ::std::string::String {
            if self.configURL.is_none() {
                self.configURL = ::std::option::Option::Some(::std::string::String::new());
            }
            self.configURL.as_mut().unwrap()
        }

        // Take field
        pub fn take_configURL(&mut self) -> ::std::string::String {
            self.configURL.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 controllerType = 3;

        pub fn controllerType(&self) -> u32 {
            self.controllerType.unwrap_or(0)
        }

        pub fn clear_controllerType(&mut self) {
            self.controllerType = ::std::option::Option::None;
        }

        pub fn has_controllerType(&self) -> bool {
            self.controllerType.is_some()
        }

        // Param is passed by value, moved
        pub fn set_controllerType(&mut self, v: u32) {
            self.controllerType = ::std::option::Option::Some(v);
        }

        // optional string controllerData = 4;

        pub fn controllerData(&self) -> &str {
            match self.controllerData.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_controllerData(&mut self) {
            self.controllerData = ::std::option::Option::None;
        }

        pub fn has_controllerData(&self) -> bool {
            self.controllerData.is_some()
        }

        // Param is passed by value, moved
        pub fn set_controllerData(&mut self, v: ::std::string::String) {
            self.controllerData = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_controllerData(&mut self) -> &mut ::std::string::String {
            if self.controllerData.is_none() {
                self.controllerData = ::std::option::Option::Some(::std::string::String::new());
            }
            self.controllerData.as_mut().unwrap()
        }

        // Take field
        pub fn take_controllerData(&mut self) -> ::std::string::String {
            self.controllerData.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 selectionOrder = 5;

        pub fn selectionOrder(&self) -> u32 {
            self.selectionOrder.unwrap_or(0)
        }

        pub fn clear_selectionOrder(&mut self) {
            self.selectionOrder = ::std::option::Option::None;
        }

        pub fn has_selectionOrder(&self) -> bool {
            self.selectionOrder.is_some()
        }

        // Param is passed by value, moved
        pub fn set_selectionOrder(&mut self, v: u32) {
            self.selectionOrder = ::std::option::Option::Some(v);
        }

        // optional bool actionBlock = 6;

        pub fn actionBlock(&self) -> bool {
            self.actionBlock.unwrap_or(false)
        }

        pub fn clear_actionBlock(&mut self) {
            self.actionBlock = ::std::option::Option::None;
        }

        pub fn has_actionBlock(&self) -> bool {
            self.actionBlock.is_some()
        }

        // Param is passed by value, moved
        pub fn set_actionBlock(&mut self, v: bool) {
            self.actionBlock = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for ControllerConfigResponse {
        const NAME: &'static str = "ControllerConfigResponse";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.configURL = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.controllerType = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    34 => {
                        self.controllerData = ::std::option::Option::Some(is.read_string()?);
                    },
                    40 => {
                        self.selectionOrder = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.actionBlock = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.appid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.configURL.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.controllerType {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.controllerData.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            if let Some(v) = self.selectionOrder {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.actionBlock {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.appid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.configURL.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.controllerType {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.controllerData.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.selectionOrder {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.actionBlock {
                os.write_bool(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ControllerConfigResponse {
            ControllerConfigResponse::new()
        }

        fn clear(&mut self) {
            self.appid = ::std::option::Option::None;
            self.configURL = ::std::option::Option::None;
            self.controllerType = ::std::option::Option::None;
            self.controllerData = ::std::option::Option::None;
            self.selectionOrder = ::std::option::Option::None;
            self.actionBlock = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ControllerConfigResponse {
            static instance: ControllerConfigResponse = ControllerConfigResponse {
                appid: ::std::option::Option::None,
                configURL: ::std::option::Option::None,
                controllerType: ::std::option::Option::None,
                controllerData: ::std::option::Option::None,
                selectionOrder: ::std::option::Option::None,
                actionBlock: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CControllerConfigMsg.ControllerPersonalizationResponse)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ControllerPersonalizationResponse {
        // message fields
        // @@protoc_insertion_point(field:CControllerConfigMsg.ControllerPersonalizationResponse.personalizationData)
        pub personalizationData: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CControllerConfigMsg.ControllerPersonalizationResponse.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ControllerPersonalizationResponse {
        fn default() -> &'a ControllerPersonalizationResponse {
            <ControllerPersonalizationResponse as ::protobuf::Message>::default_instance()
        }
    }

    impl ControllerPersonalizationResponse {
        pub fn new() -> ControllerPersonalizationResponse {
            ::std::default::Default::default()
        }

        // optional string personalizationData = 1;

        pub fn personalizationData(&self) -> &str {
            match self.personalizationData.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_personalizationData(&mut self) {
            self.personalizationData = ::std::option::Option::None;
        }

        pub fn has_personalizationData(&self) -> bool {
            self.personalizationData.is_some()
        }

        // Param is passed by value, moved
        pub fn set_personalizationData(&mut self, v: ::std::string::String) {
            self.personalizationData = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_personalizationData(&mut self) -> &mut ::std::string::String {
            if self.personalizationData.is_none() {
                self.personalizationData = ::std::option::Option::Some(::std::string::String::new());
            }
            self.personalizationData.as_mut().unwrap()
        }

        // Take field
        pub fn take_personalizationData(&mut self) -> ::std::string::String {
            self.personalizationData.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::protobuf::Message for ControllerPersonalizationResponse {
        const NAME: &'static str = "ControllerPersonalizationResponse";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.personalizationData = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.personalizationData.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.personalizationData.as_ref() {
                os.write_string(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ControllerPersonalizationResponse {
            ControllerPersonalizationResponse::new()
        }

        fn clear(&mut self) {
            self.personalizationData = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ControllerPersonalizationResponse {
            static instance: ControllerPersonalizationResponse = ControllerPersonalizationResponse {
                personalizationData: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CControllerConfigMsg.ControllerActiveConfigChangeResponse)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ControllerActiveConfigChangeResponse {
        // message fields
        // @@protoc_insertion_point(field:CControllerConfigMsg.ControllerActiveConfigChangeResponse.configURL)
        pub configURL: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CControllerConfigMsg.ControllerActiveConfigChangeResponse.controllerType)
        pub controllerType: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CControllerConfigMsg.ControllerActiveConfigChangeResponse.controllerData)
        pub controllerData: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CControllerConfigMsg.ControllerActiveConfigChangeResponse.selectionOrder)
        pub selectionOrder: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CControllerConfigMsg.ControllerActiveConfigChangeResponse.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ControllerActiveConfigChangeResponse {
        fn default() -> &'a ControllerActiveConfigChangeResponse {
            <ControllerActiveConfigChangeResponse as ::protobuf::Message>::default_instance()
        }
    }

    impl ControllerActiveConfigChangeResponse {
        pub fn new() -> ControllerActiveConfigChangeResponse {
            ::std::default::Default::default()
        }

        // optional string configURL = 2;

        pub fn configURL(&self) -> &str {
            match self.configURL.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_configURL(&mut self) {
            self.configURL = ::std::option::Option::None;
        }

        pub fn has_configURL(&self) -> bool {
            self.configURL.is_some()
        }

        // Param is passed by value, moved
        pub fn set_configURL(&mut self, v: ::std::string::String) {
            self.configURL = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_configURL(&mut self) -> &mut ::std::string::String {
            if self.configURL.is_none() {
                self.configURL = ::std::option::Option::Some(::std::string::String::new());
            }
            self.configURL.as_mut().unwrap()
        }

        // Take field
        pub fn take_configURL(&mut self) -> ::std::string::String {
            self.configURL.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 controllerType = 3;

        pub fn controllerType(&self) -> u32 {
            self.controllerType.unwrap_or(0)
        }

        pub fn clear_controllerType(&mut self) {
            self.controllerType = ::std::option::Option::None;
        }

        pub fn has_controllerType(&self) -> bool {
            self.controllerType.is_some()
        }

        // Param is passed by value, moved
        pub fn set_controllerType(&mut self, v: u32) {
            self.controllerType = ::std::option::Option::Some(v);
        }

        // optional string controllerData = 4;

        pub fn controllerData(&self) -> &str {
            match self.controllerData.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_controllerData(&mut self) {
            self.controllerData = ::std::option::Option::None;
        }

        pub fn has_controllerData(&self) -> bool {
            self.controllerData.is_some()
        }

        // Param is passed by value, moved
        pub fn set_controllerData(&mut self, v: ::std::string::String) {
            self.controllerData = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_controllerData(&mut self) -> &mut ::std::string::String {
            if self.controllerData.is_none() {
                self.controllerData = ::std::option::Option::Some(::std::string::String::new());
            }
            self.controllerData.as_mut().unwrap()
        }

        // Take field
        pub fn take_controllerData(&mut self) -> ::std::string::String {
            self.controllerData.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 selectionOrder = 5;

        pub fn selectionOrder(&self) -> u32 {
            self.selectionOrder.unwrap_or(0)
        }

        pub fn clear_selectionOrder(&mut self) {
            self.selectionOrder = ::std::option::Option::None;
        }

        pub fn has_selectionOrder(&self) -> bool {
            self.selectionOrder.is_some()
        }

        // Param is passed by value, moved
        pub fn set_selectionOrder(&mut self, v: u32) {
            self.selectionOrder = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for ControllerActiveConfigChangeResponse {
        const NAME: &'static str = "ControllerActiveConfigChangeResponse";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    18 => {
                        self.configURL = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.controllerType = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    34 => {
                        self.controllerData = ::std::option::Option::Some(is.read_string()?);
                    },
                    40 => {
                        self.selectionOrder = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.configURL.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.controllerType {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.controllerData.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            if let Some(v) = self.selectionOrder {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.configURL.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.controllerType {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.controllerData.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.selectionOrder {
                os.write_uint32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ControllerActiveConfigChangeResponse {
            ControllerActiveConfigChangeResponse::new()
        }

        fn clear(&mut self) {
            self.configURL = ::std::option::Option::None;
            self.controllerType = ::std::option::Option::None;
            self.controllerData = ::std::option::Option::None;
            self.selectionOrder = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ControllerActiveConfigChangeResponse {
            static instance: ControllerActiveConfigChangeResponse = ControllerActiveConfigChangeResponse {
                configURL: ::std::option::Option::None,
                controllerType: ::std::option::Option::None,
                controllerData: ::std::option::Option::None,
                selectionOrder: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CControllerConfigMsg.ControllerActiveConfigMsg)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ControllerActiveConfigMsg {
        // message fields
        // @@protoc_insertion_point(field:CControllerConfigMsg.ControllerActiveConfigMsg.appid)
        pub appid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CControllerConfigMsg.ControllerActiveConfigMsg.configURL)
        pub configURL: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CControllerConfigMsg.ControllerActiveConfigMsg.controllerType)
        pub controllerType: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CControllerConfigMsg.ControllerActiveConfigMsg.controllerData)
        pub controllerData: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CControllerConfigMsg.ControllerActiveConfigMsg.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ControllerActiveConfigMsg {
        fn default() -> &'a ControllerActiveConfigMsg {
            <ControllerActiveConfigMsg as ::protobuf::Message>::default_instance()
        }
    }

    impl ControllerActiveConfigMsg {
        pub fn new() -> ControllerActiveConfigMsg {
            ::std::default::Default::default()
        }

        // optional uint32 appid = 1;

        pub fn appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }

        // optional string configURL = 2;

        pub fn configURL(&self) -> &str {
            match self.configURL.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_configURL(&mut self) {
            self.configURL = ::std::option::Option::None;
        }

        pub fn has_configURL(&self) -> bool {
            self.configURL.is_some()
        }

        // Param is passed by value, moved
        pub fn set_configURL(&mut self, v: ::std::string::String) {
            self.configURL = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_configURL(&mut self) -> &mut ::std::string::String {
            if self.configURL.is_none() {
                self.configURL = ::std::option::Option::Some(::std::string::String::new());
            }
            self.configURL.as_mut().unwrap()
        }

        // Take field
        pub fn take_configURL(&mut self) -> ::std::string::String {
            self.configURL.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 controllerType = 3;

        pub fn controllerType(&self) -> u32 {
            self.controllerType.unwrap_or(0)
        }

        pub fn clear_controllerType(&mut self) {
            self.controllerType = ::std::option::Option::None;
        }

        pub fn has_controllerType(&self) -> bool {
            self.controllerType.is_some()
        }

        // Param is passed by value, moved
        pub fn set_controllerType(&mut self, v: u32) {
            self.controllerType = ::std::option::Option::Some(v);
        }

        // optional string controllerData = 4;

        pub fn controllerData(&self) -> &str {
            match self.controllerData.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_controllerData(&mut self) {
            self.controllerData = ::std::option::Option::None;
        }

        pub fn has_controllerData(&self) -> bool {
            self.controllerData.is_some()
        }

        // Param is passed by value, moved
        pub fn set_controllerData(&mut self, v: ::std::string::String) {
            self.controllerData = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_controllerData(&mut self) -> &mut ::std::string::String {
            if self.controllerData.is_none() {
                self.controllerData = ::std::option::Option::Some(::std::string::String::new());
            }
            self.controllerData.as_mut().unwrap()
        }

        // Take field
        pub fn take_controllerData(&mut self) -> ::std::string::String {
            self.controllerData.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::protobuf::Message for ControllerActiveConfigMsg {
        const NAME: &'static str = "ControllerActiveConfigMsg";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.configURL = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.controllerType = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    34 => {
                        self.controllerData = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.appid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.configURL.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.controllerType {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.controllerData.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.appid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.configURL.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.controllerType {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.controllerData.as_ref() {
                os.write_string(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ControllerActiveConfigMsg {
            ControllerActiveConfigMsg::new()
        }

        fn clear(&mut self) {
            self.appid = ::std::option::Option::None;
            self.configURL = ::std::option::Option::None;
            self.controllerType = ::std::option::Option::None;
            self.controllerData = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ControllerActiveConfigMsg {
            static instance: ControllerActiveConfigMsg = ControllerActiveConfigMsg {
                appid: ::std::option::Option::None,
                configURL: ::std::option::Option::None,
                controllerType: ::std::option::Option::None,
                controllerData: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamChannel)
pub enum EStreamChannel {
    // @@protoc_insertion_point(enum_value:EStreamChannel.k_EStreamChannelInvalid)
    k_EStreamChannelInvalid = -1,
    // @@protoc_insertion_point(enum_value:EStreamChannel.k_EStreamChannelDiscovery)
    k_EStreamChannelDiscovery = 0,
    // @@protoc_insertion_point(enum_value:EStreamChannel.k_EStreamChannelControl)
    k_EStreamChannelControl = 1,
    // @@protoc_insertion_point(enum_value:EStreamChannel.k_EStreamChannelStats)
    k_EStreamChannelStats = 2,
    // @@protoc_insertion_point(enum_value:EStreamChannel.k_EStreamChannelDataChannelStart)
    k_EStreamChannelDataChannelStart = 3,
}

impl ::protobuf::Enum for EStreamChannel {
    const NAME: &'static str = "EStreamChannel";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamChannel> {
        match value {
            -1 => ::std::option::Option::Some(EStreamChannel::k_EStreamChannelInvalid),
            0 => ::std::option::Option::Some(EStreamChannel::k_EStreamChannelDiscovery),
            1 => ::std::option::Option::Some(EStreamChannel::k_EStreamChannelControl),
            2 => ::std::option::Option::Some(EStreamChannel::k_EStreamChannelStats),
            3 => ::std::option::Option::Some(EStreamChannel::k_EStreamChannelDataChannelStart),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamChannel> {
        match str {
            "k_EStreamChannelInvalid" => ::std::option::Option::Some(EStreamChannel::k_EStreamChannelInvalid),
            "k_EStreamChannelDiscovery" => ::std::option::Option::Some(EStreamChannel::k_EStreamChannelDiscovery),
            "k_EStreamChannelControl" => ::std::option::Option::Some(EStreamChannel::k_EStreamChannelControl),
            "k_EStreamChannelStats" => ::std::option::Option::Some(EStreamChannel::k_EStreamChannelStats),
            "k_EStreamChannelDataChannelStart" => ::std::option::Option::Some(EStreamChannel::k_EStreamChannelDataChannelStart),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamChannel] = &[
        EStreamChannel::k_EStreamChannelInvalid,
        EStreamChannel::k_EStreamChannelDiscovery,
        EStreamChannel::k_EStreamChannelControl,
        EStreamChannel::k_EStreamChannelStats,
        EStreamChannel::k_EStreamChannelDataChannelStart,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EStreamChannel {
    fn default() -> Self {
        EStreamChannel::k_EStreamChannelInvalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamDiscoveryMessage)
pub enum EStreamDiscoveryMessage {
    // @@protoc_insertion_point(enum_value:EStreamDiscoveryMessage.k_EStreamDiscoveryPingRequest)
    k_EStreamDiscoveryPingRequest = 1,
    // @@protoc_insertion_point(enum_value:EStreamDiscoveryMessage.k_EStreamDiscoveryPingResponse)
    k_EStreamDiscoveryPingResponse = 2,
}

impl ::protobuf::Enum for EStreamDiscoveryMessage {
    const NAME: &'static str = "EStreamDiscoveryMessage";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamDiscoveryMessage> {
        match value {
            1 => ::std::option::Option::Some(EStreamDiscoveryMessage::k_EStreamDiscoveryPingRequest),
            2 => ::std::option::Option::Some(EStreamDiscoveryMessage::k_EStreamDiscoveryPingResponse),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamDiscoveryMessage> {
        match str {
            "k_EStreamDiscoveryPingRequest" => ::std::option::Option::Some(EStreamDiscoveryMessage::k_EStreamDiscoveryPingRequest),
            "k_EStreamDiscoveryPingResponse" => ::std::option::Option::Some(EStreamDiscoveryMessage::k_EStreamDiscoveryPingResponse),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamDiscoveryMessage] = &[
        EStreamDiscoveryMessage::k_EStreamDiscoveryPingRequest,
        EStreamDiscoveryMessage::k_EStreamDiscoveryPingResponse,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EStreamDiscoveryMessage {
    fn default() -> Self {
        EStreamDiscoveryMessage::k_EStreamDiscoveryPingRequest
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamControlMessage)
pub enum EStreamControlMessage {
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlAuthenticationRequest)
    k_EStreamControlAuthenticationRequest = 1,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlAuthenticationResponse)
    k_EStreamControlAuthenticationResponse = 2,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlNegotiationInit)
    k_EStreamControlNegotiationInit = 3,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlNegotiationSetConfig)
    k_EStreamControlNegotiationSetConfig = 4,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlNegotiationComplete)
    k_EStreamControlNegotiationComplete = 5,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlClientHandshake)
    k_EStreamControlClientHandshake = 6,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlServerHandshake)
    k_EStreamControlServerHandshake = 7,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlStartNetworkTest)
    k_EStreamControlStartNetworkTest = 8,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlKeepAlive)
    k_EStreamControlKeepAlive = 9,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControl_LAST_SETUP_MESSAGE)
    k_EStreamControl_LAST_SETUP_MESSAGE = 15,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlStartAudioData)
    k_EStreamControlStartAudioData = 50,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlStopAudioData)
    k_EStreamControlStopAudioData = 51,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlStartVideoData)
    k_EStreamControlStartVideoData = 52,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlStopVideoData)
    k_EStreamControlStopVideoData = 53,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlInputMouseMotion)
    k_EStreamControlInputMouseMotion = 54,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlInputMouseWheel)
    k_EStreamControlInputMouseWheel = 55,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlInputMouseDown)
    k_EStreamControlInputMouseDown = 56,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlInputMouseUp)
    k_EStreamControlInputMouseUp = 57,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlInputKeyDown)
    k_EStreamControlInputKeyDown = 58,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlInputKeyUp)
    k_EStreamControlInputKeyUp = 59,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlInputGamepadAttached_OBSOLETE)
    k_EStreamControlInputGamepadAttached_OBSOLETE = 60,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlInputGamepadEvent_OBSOLETE)
    k_EStreamControlInputGamepadEvent_OBSOLETE = 61,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlInputGamepadDetached_OBSOLETE)
    k_EStreamControlInputGamepadDetached_OBSOLETE = 62,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlShowCursor)
    k_EStreamControlShowCursor = 63,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlHideCursor)
    k_EStreamControlHideCursor = 64,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSetCursor)
    k_EStreamControlSetCursor = 65,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlGetCursorImage)
    k_EStreamControlGetCursorImage = 66,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSetCursorImage)
    k_EStreamControlSetCursorImage = 67,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlDeleteCursor)
    k_EStreamControlDeleteCursor = 68,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSetTargetFramerate)
    k_EStreamControlSetTargetFramerate = 69,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlInputLatencyTest)
    k_EStreamControlInputLatencyTest = 70,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlGamepadRumble_OBSOLETE)
    k_EStreamControlGamepadRumble_OBSOLETE = 71,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlOverlayEnabled)
    k_EStreamControlOverlayEnabled = 74,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlInputControllerAttached_OBSOLETE)
    k_EStreamControlInputControllerAttached_OBSOLETE = 75,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlInputControllerState_OBSOLETE)
    k_EStreamControlInputControllerState_OBSOLETE = 76,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlTriggerHapticPulse_OBSOLETE)
    k_EStreamControlTriggerHapticPulse_OBSOLETE = 77,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlInputControllerDetached_OBSOLETE)
    k_EStreamControlInputControllerDetached_OBSOLETE = 78,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlVideoDecoderInfo)
    k_EStreamControlVideoDecoderInfo = 80,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSetTitle)
    k_EStreamControlSetTitle = 81,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSetIcon)
    k_EStreamControlSetIcon = 82,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlQuitRequest)
    k_EStreamControlQuitRequest = 83,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSetQoS)
    k_EStreamControlSetQoS = 87,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlInputControllerWirelessPresence_OBSOLETE)
    k_EStreamControlInputControllerWirelessPresence_OBSOLETE = 88,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSetGammaRamp)
    k_EStreamControlSetGammaRamp = 89,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlVideoEncoderInfo)
    k_EStreamControlVideoEncoderInfo = 90,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlInputControllerStateHID_OBSOLETE)
    k_EStreamControlInputControllerStateHID_OBSOLETE = 93,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSetTargetBitrate)
    k_EStreamControlSetTargetBitrate = 94,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSetControllerPairingEnabled_OBSOLETE)
    k_EStreamControlSetControllerPairingEnabled_OBSOLETE = 95,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSetControllerPairingResult_OBSOLETE)
    k_EStreamControlSetControllerPairingResult_OBSOLETE = 96,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlTriggerControllerDisconnect_OBSOLETE)
    k_EStreamControlTriggerControllerDisconnect_OBSOLETE = 97,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSetActivity)
    k_EStreamControlSetActivity = 98,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSetStreamingClientConfig)
    k_EStreamControlSetStreamingClientConfig = 99,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSystemSuspend)
    k_EStreamControlSystemSuspend = 100,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSetControllerSettings_OBSOLETE)
    k_EStreamControlSetControllerSettings_OBSOLETE = 101,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlVirtualHereRequest)
    k_EStreamControlVirtualHereRequest = 102,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlVirtualHereReady)
    k_EStreamControlVirtualHereReady = 103,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlVirtualHereShareDevice)
    k_EStreamControlVirtualHereShareDevice = 104,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSetSpectatorMode)
    k_EStreamControlSetSpectatorMode = 105,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlRemoteHID)
    k_EStreamControlRemoteHID = 106,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlStartMicrophoneData)
    k_EStreamControlStartMicrophoneData = 107,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlStopMicrophoneData)
    k_EStreamControlStopMicrophoneData = 108,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlInputText)
    k_EStreamControlInputText = 109,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlTouchConfigActive)
    k_EStreamControlTouchConfigActive = 110,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlGetTouchConfigData)
    k_EStreamControlGetTouchConfigData = 111,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSetTouchConfigData)
    k_EStreamControlSetTouchConfigData = 112,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSaveTouchConfigLayout)
    k_EStreamControlSaveTouchConfigLayout = 113,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlTouchActionSetActive)
    k_EStreamControlTouchActionSetActive = 114,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlGetTouchIconData)
    k_EStreamControlGetTouchIconData = 115,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSetTouchIconData)
    k_EStreamControlSetTouchIconData = 116,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlInputTouchFingerDown)
    k_EStreamControlInputTouchFingerDown = 117,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlInputTouchFingerMotion)
    k_EStreamControlInputTouchFingerMotion = 118,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlInputTouchFingerUp)
    k_EStreamControlInputTouchFingerUp = 119,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSetCaptureSize)
    k_EStreamControlSetCaptureSize = 120,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSetFlashState)
    k_EStreamControlSetFlashState = 121,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlPause)
    k_EStreamControlPause = 122,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlResume)
    k_EStreamControlResume = 123,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlEnableHighResCapture)
    k_EStreamControlEnableHighResCapture = 124,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlDisableHighResCapture)
    k_EStreamControlDisableHighResCapture = 125,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlToggleMagnification)
    k_EStreamControlToggleMagnification = 126,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSetCapslock)
    k_EStreamControlSetCapslock = 127,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSetKeymap)
    k_EStreamControlSetKeymap = 128,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlStopRequest)
    k_EStreamControlStopRequest = 129,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlTouchActionSetLayerAdded)
    k_EStreamControlTouchActionSetLayerAdded = 130,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlTouchActionSetLayerRemoved)
    k_EStreamControlTouchActionSetLayerRemoved = 131,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlRemotePlayTogetherGroupUpdate)
    k_EStreamControlRemotePlayTogetherGroupUpdate = 132,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSetInputTemporarilyDisabled)
    k_EStreamControlSetInputTemporarilyDisabled = 133,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSetQualityOverride)
    k_EStreamControlSetQualityOverride = 134,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSetBitrateOverride)
    k_EStreamControlSetBitrateOverride = 135,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlShowOnScreenKeyboard)
    k_EStreamControlShowOnScreenKeyboard = 136,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlControllerConfigMsg)
    k_EStreamControlControllerConfigMsg = 137,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlControllerPersonalizationUpdate)
    k_EStreamControlControllerPersonalizationUpdate = 138,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlEnableNeptuneData)
    k_EStreamControlEnableNeptuneData = 139,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlDisableNeptuneData)
    k_EStreamControlDisableNeptuneData = 140,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlStartNeptuneData)
    k_EStreamControlStartNeptuneData = 141,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlStopNeptuneData)
    k_EStreamControlStopNeptuneData = 142,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlPauseControllerInput)
    k_EStreamControlPauseControllerInput = 143,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlResumeControllerInput)
    k_EStreamControlResumeControllerInput = 144,
}

impl ::protobuf::Enum for EStreamControlMessage {
    const NAME: &'static str = "EStreamControlMessage";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamControlMessage> {
        match value {
            1 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlAuthenticationRequest),
            2 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlAuthenticationResponse),
            3 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlNegotiationInit),
            4 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlNegotiationSetConfig),
            5 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlNegotiationComplete),
            6 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlClientHandshake),
            7 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlServerHandshake),
            8 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStartNetworkTest),
            9 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlKeepAlive),
            15 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControl_LAST_SETUP_MESSAGE),
            50 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStartAudioData),
            51 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStopAudioData),
            52 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStartVideoData),
            53 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStopVideoData),
            54 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputMouseMotion),
            55 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputMouseWheel),
            56 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputMouseDown),
            57 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputMouseUp),
            58 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputKeyDown),
            59 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputKeyUp),
            60 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputGamepadAttached_OBSOLETE),
            61 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputGamepadEvent_OBSOLETE),
            62 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputGamepadDetached_OBSOLETE),
            63 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlShowCursor),
            64 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlHideCursor),
            65 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetCursor),
            66 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlGetCursorImage),
            67 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetCursorImage),
            68 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlDeleteCursor),
            69 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetTargetFramerate),
            70 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputLatencyTest),
            71 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlGamepadRumble_OBSOLETE),
            74 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlOverlayEnabled),
            75 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputControllerAttached_OBSOLETE),
            76 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputControllerState_OBSOLETE),
            77 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlTriggerHapticPulse_OBSOLETE),
            78 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputControllerDetached_OBSOLETE),
            80 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlVideoDecoderInfo),
            81 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetTitle),
            82 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetIcon),
            83 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlQuitRequest),
            87 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetQoS),
            88 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputControllerWirelessPresence_OBSOLETE),
            89 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetGammaRamp),
            90 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlVideoEncoderInfo),
            93 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputControllerStateHID_OBSOLETE),
            94 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetTargetBitrate),
            95 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetControllerPairingEnabled_OBSOLETE),
            96 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetControllerPairingResult_OBSOLETE),
            97 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlTriggerControllerDisconnect_OBSOLETE),
            98 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetActivity),
            99 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetStreamingClientConfig),
            100 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSystemSuspend),
            101 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetControllerSettings_OBSOLETE),
            102 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlVirtualHereRequest),
            103 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlVirtualHereReady),
            104 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlVirtualHereShareDevice),
            105 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetSpectatorMode),
            106 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlRemoteHID),
            107 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStartMicrophoneData),
            108 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStopMicrophoneData),
            109 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputText),
            110 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlTouchConfigActive),
            111 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlGetTouchConfigData),
            112 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetTouchConfigData),
            113 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSaveTouchConfigLayout),
            114 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlTouchActionSetActive),
            115 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlGetTouchIconData),
            116 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetTouchIconData),
            117 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputTouchFingerDown),
            118 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputTouchFingerMotion),
            119 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputTouchFingerUp),
            120 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetCaptureSize),
            121 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetFlashState),
            122 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlPause),
            123 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlResume),
            124 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlEnableHighResCapture),
            125 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlDisableHighResCapture),
            126 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlToggleMagnification),
            127 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetCapslock),
            128 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetKeymap),
            129 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStopRequest),
            130 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlTouchActionSetLayerAdded),
            131 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlTouchActionSetLayerRemoved),
            132 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlRemotePlayTogetherGroupUpdate),
            133 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetInputTemporarilyDisabled),
            134 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetQualityOverride),
            135 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetBitrateOverride),
            136 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlShowOnScreenKeyboard),
            137 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlControllerConfigMsg),
            138 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlControllerPersonalizationUpdate),
            139 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlEnableNeptuneData),
            140 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlDisableNeptuneData),
            141 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStartNeptuneData),
            142 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStopNeptuneData),
            143 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlPauseControllerInput),
            144 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlResumeControllerInput),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamControlMessage> {
        match str {
            "k_EStreamControlAuthenticationRequest" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlAuthenticationRequest),
            "k_EStreamControlAuthenticationResponse" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlAuthenticationResponse),
            "k_EStreamControlNegotiationInit" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlNegotiationInit),
            "k_EStreamControlNegotiationSetConfig" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlNegotiationSetConfig),
            "k_EStreamControlNegotiationComplete" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlNegotiationComplete),
            "k_EStreamControlClientHandshake" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlClientHandshake),
            "k_EStreamControlServerHandshake" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlServerHandshake),
            "k_EStreamControlStartNetworkTest" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStartNetworkTest),
            "k_EStreamControlKeepAlive" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlKeepAlive),
            "k_EStreamControl_LAST_SETUP_MESSAGE" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControl_LAST_SETUP_MESSAGE),
            "k_EStreamControlStartAudioData" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStartAudioData),
            "k_EStreamControlStopAudioData" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStopAudioData),
            "k_EStreamControlStartVideoData" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStartVideoData),
            "k_EStreamControlStopVideoData" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStopVideoData),
            "k_EStreamControlInputMouseMotion" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputMouseMotion),
            "k_EStreamControlInputMouseWheel" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputMouseWheel),
            "k_EStreamControlInputMouseDown" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputMouseDown),
            "k_EStreamControlInputMouseUp" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputMouseUp),
            "k_EStreamControlInputKeyDown" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputKeyDown),
            "k_EStreamControlInputKeyUp" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputKeyUp),
            "k_EStreamControlInputGamepadAttached_OBSOLETE" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputGamepadAttached_OBSOLETE),
            "k_EStreamControlInputGamepadEvent_OBSOLETE" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputGamepadEvent_OBSOLETE),
            "k_EStreamControlInputGamepadDetached_OBSOLETE" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputGamepadDetached_OBSOLETE),
            "k_EStreamControlShowCursor" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlShowCursor),
            "k_EStreamControlHideCursor" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlHideCursor),
            "k_EStreamControlSetCursor" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetCursor),
            "k_EStreamControlGetCursorImage" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlGetCursorImage),
            "k_EStreamControlSetCursorImage" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetCursorImage),
            "k_EStreamControlDeleteCursor" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlDeleteCursor),
            "k_EStreamControlSetTargetFramerate" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetTargetFramerate),
            "k_EStreamControlInputLatencyTest" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputLatencyTest),
            "k_EStreamControlGamepadRumble_OBSOLETE" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlGamepadRumble_OBSOLETE),
            "k_EStreamControlOverlayEnabled" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlOverlayEnabled),
            "k_EStreamControlInputControllerAttached_OBSOLETE" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputControllerAttached_OBSOLETE),
            "k_EStreamControlInputControllerState_OBSOLETE" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputControllerState_OBSOLETE),
            "k_EStreamControlTriggerHapticPulse_OBSOLETE" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlTriggerHapticPulse_OBSOLETE),
            "k_EStreamControlInputControllerDetached_OBSOLETE" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputControllerDetached_OBSOLETE),
            "k_EStreamControlVideoDecoderInfo" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlVideoDecoderInfo),
            "k_EStreamControlSetTitle" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetTitle),
            "k_EStreamControlSetIcon" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetIcon),
            "k_EStreamControlQuitRequest" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlQuitRequest),
            "k_EStreamControlSetQoS" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetQoS),
            "k_EStreamControlInputControllerWirelessPresence_OBSOLETE" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputControllerWirelessPresence_OBSOLETE),
            "k_EStreamControlSetGammaRamp" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetGammaRamp),
            "k_EStreamControlVideoEncoderInfo" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlVideoEncoderInfo),
            "k_EStreamControlInputControllerStateHID_OBSOLETE" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputControllerStateHID_OBSOLETE),
            "k_EStreamControlSetTargetBitrate" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetTargetBitrate),
            "k_EStreamControlSetControllerPairingEnabled_OBSOLETE" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetControllerPairingEnabled_OBSOLETE),
            "k_EStreamControlSetControllerPairingResult_OBSOLETE" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetControllerPairingResult_OBSOLETE),
            "k_EStreamControlTriggerControllerDisconnect_OBSOLETE" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlTriggerControllerDisconnect_OBSOLETE),
            "k_EStreamControlSetActivity" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetActivity),
            "k_EStreamControlSetStreamingClientConfig" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetStreamingClientConfig),
            "k_EStreamControlSystemSuspend" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSystemSuspend),
            "k_EStreamControlSetControllerSettings_OBSOLETE" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetControllerSettings_OBSOLETE),
            "k_EStreamControlVirtualHereRequest" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlVirtualHereRequest),
            "k_EStreamControlVirtualHereReady" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlVirtualHereReady),
            "k_EStreamControlVirtualHereShareDevice" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlVirtualHereShareDevice),
            "k_EStreamControlSetSpectatorMode" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetSpectatorMode),
            "k_EStreamControlRemoteHID" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlRemoteHID),
            "k_EStreamControlStartMicrophoneData" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStartMicrophoneData),
            "k_EStreamControlStopMicrophoneData" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStopMicrophoneData),
            "k_EStreamControlInputText" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputText),
            "k_EStreamControlTouchConfigActive" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlTouchConfigActive),
            "k_EStreamControlGetTouchConfigData" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlGetTouchConfigData),
            "k_EStreamControlSetTouchConfigData" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetTouchConfigData),
            "k_EStreamControlSaveTouchConfigLayout" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSaveTouchConfigLayout),
            "k_EStreamControlTouchActionSetActive" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlTouchActionSetActive),
            "k_EStreamControlGetTouchIconData" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlGetTouchIconData),
            "k_EStreamControlSetTouchIconData" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetTouchIconData),
            "k_EStreamControlInputTouchFingerDown" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputTouchFingerDown),
            "k_EStreamControlInputTouchFingerMotion" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputTouchFingerMotion),
            "k_EStreamControlInputTouchFingerUp" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputTouchFingerUp),
            "k_EStreamControlSetCaptureSize" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetCaptureSize),
            "k_EStreamControlSetFlashState" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetFlashState),
            "k_EStreamControlPause" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlPause),
            "k_EStreamControlResume" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlResume),
            "k_EStreamControlEnableHighResCapture" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlEnableHighResCapture),
            "k_EStreamControlDisableHighResCapture" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlDisableHighResCapture),
            "k_EStreamControlToggleMagnification" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlToggleMagnification),
            "k_EStreamControlSetCapslock" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetCapslock),
            "k_EStreamControlSetKeymap" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetKeymap),
            "k_EStreamControlStopRequest" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStopRequest),
            "k_EStreamControlTouchActionSetLayerAdded" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlTouchActionSetLayerAdded),
            "k_EStreamControlTouchActionSetLayerRemoved" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlTouchActionSetLayerRemoved),
            "k_EStreamControlRemotePlayTogetherGroupUpdate" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlRemotePlayTogetherGroupUpdate),
            "k_EStreamControlSetInputTemporarilyDisabled" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetInputTemporarilyDisabled),
            "k_EStreamControlSetQualityOverride" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetQualityOverride),
            "k_EStreamControlSetBitrateOverride" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetBitrateOverride),
            "k_EStreamControlShowOnScreenKeyboard" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlShowOnScreenKeyboard),
            "k_EStreamControlControllerConfigMsg" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlControllerConfigMsg),
            "k_EStreamControlControllerPersonalizationUpdate" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlControllerPersonalizationUpdate),
            "k_EStreamControlEnableNeptuneData" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlEnableNeptuneData),
            "k_EStreamControlDisableNeptuneData" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlDisableNeptuneData),
            "k_EStreamControlStartNeptuneData" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStartNeptuneData),
            "k_EStreamControlStopNeptuneData" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStopNeptuneData),
            "k_EStreamControlPauseControllerInput" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlPauseControllerInput),
            "k_EStreamControlResumeControllerInput" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlResumeControllerInput),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamControlMessage] = &[
        EStreamControlMessage::k_EStreamControlAuthenticationRequest,
        EStreamControlMessage::k_EStreamControlAuthenticationResponse,
        EStreamControlMessage::k_EStreamControlNegotiationInit,
        EStreamControlMessage::k_EStreamControlNegotiationSetConfig,
        EStreamControlMessage::k_EStreamControlNegotiationComplete,
        EStreamControlMessage::k_EStreamControlClientHandshake,
        EStreamControlMessage::k_EStreamControlServerHandshake,
        EStreamControlMessage::k_EStreamControlStartNetworkTest,
        EStreamControlMessage::k_EStreamControlKeepAlive,
        EStreamControlMessage::k_EStreamControl_LAST_SETUP_MESSAGE,
        EStreamControlMessage::k_EStreamControlStartAudioData,
        EStreamControlMessage::k_EStreamControlStopAudioData,
        EStreamControlMessage::k_EStreamControlStartVideoData,
        EStreamControlMessage::k_EStreamControlStopVideoData,
        EStreamControlMessage::k_EStreamControlInputMouseMotion,
        EStreamControlMessage::k_EStreamControlInputMouseWheel,
        EStreamControlMessage::k_EStreamControlInputMouseDown,
        EStreamControlMessage::k_EStreamControlInputMouseUp,
        EStreamControlMessage::k_EStreamControlInputKeyDown,
        EStreamControlMessage::k_EStreamControlInputKeyUp,
        EStreamControlMessage::k_EStreamControlInputGamepadAttached_OBSOLETE,
        EStreamControlMessage::k_EStreamControlInputGamepadEvent_OBSOLETE,
        EStreamControlMessage::k_EStreamControlInputGamepadDetached_OBSOLETE,
        EStreamControlMessage::k_EStreamControlShowCursor,
        EStreamControlMessage::k_EStreamControlHideCursor,
        EStreamControlMessage::k_EStreamControlSetCursor,
        EStreamControlMessage::k_EStreamControlGetCursorImage,
        EStreamControlMessage::k_EStreamControlSetCursorImage,
        EStreamControlMessage::k_EStreamControlDeleteCursor,
        EStreamControlMessage::k_EStreamControlSetTargetFramerate,
        EStreamControlMessage::k_EStreamControlInputLatencyTest,
        EStreamControlMessage::k_EStreamControlGamepadRumble_OBSOLETE,
        EStreamControlMessage::k_EStreamControlOverlayEnabled,
        EStreamControlMessage::k_EStreamControlInputControllerAttached_OBSOLETE,
        EStreamControlMessage::k_EStreamControlInputControllerState_OBSOLETE,
        EStreamControlMessage::k_EStreamControlTriggerHapticPulse_OBSOLETE,
        EStreamControlMessage::k_EStreamControlInputControllerDetached_OBSOLETE,
        EStreamControlMessage::k_EStreamControlVideoDecoderInfo,
        EStreamControlMessage::k_EStreamControlSetTitle,
        EStreamControlMessage::k_EStreamControlSetIcon,
        EStreamControlMessage::k_EStreamControlQuitRequest,
        EStreamControlMessage::k_EStreamControlSetQoS,
        EStreamControlMessage::k_EStreamControlInputControllerWirelessPresence_OBSOLETE,
        EStreamControlMessage::k_EStreamControlSetGammaRamp,
        EStreamControlMessage::k_EStreamControlVideoEncoderInfo,
        EStreamControlMessage::k_EStreamControlInputControllerStateHID_OBSOLETE,
        EStreamControlMessage::k_EStreamControlSetTargetBitrate,
        EStreamControlMessage::k_EStreamControlSetControllerPairingEnabled_OBSOLETE,
        EStreamControlMessage::k_EStreamControlSetControllerPairingResult_OBSOLETE,
        EStreamControlMessage::k_EStreamControlTriggerControllerDisconnect_OBSOLETE,
        EStreamControlMessage::k_EStreamControlSetActivity,
        EStreamControlMessage::k_EStreamControlSetStreamingClientConfig,
        EStreamControlMessage::k_EStreamControlSystemSuspend,
        EStreamControlMessage::k_EStreamControlSetControllerSettings_OBSOLETE,
        EStreamControlMessage::k_EStreamControlVirtualHereRequest,
        EStreamControlMessage::k_EStreamControlVirtualHereReady,
        EStreamControlMessage::k_EStreamControlVirtualHereShareDevice,
        EStreamControlMessage::k_EStreamControlSetSpectatorMode,
        EStreamControlMessage::k_EStreamControlRemoteHID,
        EStreamControlMessage::k_EStreamControlStartMicrophoneData,
        EStreamControlMessage::k_EStreamControlStopMicrophoneData,
        EStreamControlMessage::k_EStreamControlInputText,
        EStreamControlMessage::k_EStreamControlTouchConfigActive,
        EStreamControlMessage::k_EStreamControlGetTouchConfigData,
        EStreamControlMessage::k_EStreamControlSetTouchConfigData,
        EStreamControlMessage::k_EStreamControlSaveTouchConfigLayout,
        EStreamControlMessage::k_EStreamControlTouchActionSetActive,
        EStreamControlMessage::k_EStreamControlGetTouchIconData,
        EStreamControlMessage::k_EStreamControlSetTouchIconData,
        EStreamControlMessage::k_EStreamControlInputTouchFingerDown,
        EStreamControlMessage::k_EStreamControlInputTouchFingerMotion,
        EStreamControlMessage::k_EStreamControlInputTouchFingerUp,
        EStreamControlMessage::k_EStreamControlSetCaptureSize,
        EStreamControlMessage::k_EStreamControlSetFlashState,
        EStreamControlMessage::k_EStreamControlPause,
        EStreamControlMessage::k_EStreamControlResume,
        EStreamControlMessage::k_EStreamControlEnableHighResCapture,
        EStreamControlMessage::k_EStreamControlDisableHighResCapture,
        EStreamControlMessage::k_EStreamControlToggleMagnification,
        EStreamControlMessage::k_EStreamControlSetCapslock,
        EStreamControlMessage::k_EStreamControlSetKeymap,
        EStreamControlMessage::k_EStreamControlStopRequest,
        EStreamControlMessage::k_EStreamControlTouchActionSetLayerAdded,
        EStreamControlMessage::k_EStreamControlTouchActionSetLayerRemoved,
        EStreamControlMessage::k_EStreamControlRemotePlayTogetherGroupUpdate,
        EStreamControlMessage::k_EStreamControlSetInputTemporarilyDisabled,
        EStreamControlMessage::k_EStreamControlSetQualityOverride,
        EStreamControlMessage::k_EStreamControlSetBitrateOverride,
        EStreamControlMessage::k_EStreamControlShowOnScreenKeyboard,
        EStreamControlMessage::k_EStreamControlControllerConfigMsg,
        EStreamControlMessage::k_EStreamControlControllerPersonalizationUpdate,
        EStreamControlMessage::k_EStreamControlEnableNeptuneData,
        EStreamControlMessage::k_EStreamControlDisableNeptuneData,
        EStreamControlMessage::k_EStreamControlStartNeptuneData,
        EStreamControlMessage::k_EStreamControlStopNeptuneData,
        EStreamControlMessage::k_EStreamControlPauseControllerInput,
        EStreamControlMessage::k_EStreamControlResumeControllerInput,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EStreamControlMessage {
    fn default() -> Self {
        EStreamControlMessage::k_EStreamControlAuthenticationRequest
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamVersion)
pub enum EStreamVersion {
    // @@protoc_insertion_point(enum_value:EStreamVersion.k_EStreamVersionNone)
    k_EStreamVersionNone = 0,
    // @@protoc_insertion_point(enum_value:EStreamVersion.k_EStreamVersionCurrent)
    k_EStreamVersionCurrent = 1,
}

impl ::protobuf::Enum for EStreamVersion {
    const NAME: &'static str = "EStreamVersion";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamVersion> {
        match value {
            0 => ::std::option::Option::Some(EStreamVersion::k_EStreamVersionNone),
            1 => ::std::option::Option::Some(EStreamVersion::k_EStreamVersionCurrent),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamVersion> {
        match str {
            "k_EStreamVersionNone" => ::std::option::Option::Some(EStreamVersion::k_EStreamVersionNone),
            "k_EStreamVersionCurrent" => ::std::option::Option::Some(EStreamVersion::k_EStreamVersionCurrent),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamVersion] = &[
        EStreamVersion::k_EStreamVersionNone,
        EStreamVersion::k_EStreamVersionCurrent,
    ];
}

impl ::std::default::Default for EStreamVersion {
    fn default() -> Self {
        EStreamVersion::k_EStreamVersionNone
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamAudioCodec)
pub enum EStreamAudioCodec {
    // @@protoc_insertion_point(enum_value:EStreamAudioCodec.k_EStreamAudioCodecNone)
    k_EStreamAudioCodecNone = 0,
    // @@protoc_insertion_point(enum_value:EStreamAudioCodec.k_EStreamAudioCodecRaw)
    k_EStreamAudioCodecRaw = 1,
    // @@protoc_insertion_point(enum_value:EStreamAudioCodec.k_EStreamAudioCodecVorbis)
    k_EStreamAudioCodecVorbis = 2,
    // @@protoc_insertion_point(enum_value:EStreamAudioCodec.k_EStreamAudioCodecOpus)
    k_EStreamAudioCodecOpus = 3,
    // @@protoc_insertion_point(enum_value:EStreamAudioCodec.k_EStreamAudioCodecMP3)
    k_EStreamAudioCodecMP3 = 4,
    // @@protoc_insertion_point(enum_value:EStreamAudioCodec.k_EStreamAudioCodecAAC)
    k_EStreamAudioCodecAAC = 5,
}

impl ::protobuf::Enum for EStreamAudioCodec {
    const NAME: &'static str = "EStreamAudioCodec";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamAudioCodec> {
        match value {
            0 => ::std::option::Option::Some(EStreamAudioCodec::k_EStreamAudioCodecNone),
            1 => ::std::option::Option::Some(EStreamAudioCodec::k_EStreamAudioCodecRaw),
            2 => ::std::option::Option::Some(EStreamAudioCodec::k_EStreamAudioCodecVorbis),
            3 => ::std::option::Option::Some(EStreamAudioCodec::k_EStreamAudioCodecOpus),
            4 => ::std::option::Option::Some(EStreamAudioCodec::k_EStreamAudioCodecMP3),
            5 => ::std::option::Option::Some(EStreamAudioCodec::k_EStreamAudioCodecAAC),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamAudioCodec> {
        match str {
            "k_EStreamAudioCodecNone" => ::std::option::Option::Some(EStreamAudioCodec::k_EStreamAudioCodecNone),
            "k_EStreamAudioCodecRaw" => ::std::option::Option::Some(EStreamAudioCodec::k_EStreamAudioCodecRaw),
            "k_EStreamAudioCodecVorbis" => ::std::option::Option::Some(EStreamAudioCodec::k_EStreamAudioCodecVorbis),
            "k_EStreamAudioCodecOpus" => ::std::option::Option::Some(EStreamAudioCodec::k_EStreamAudioCodecOpus),
            "k_EStreamAudioCodecMP3" => ::std::option::Option::Some(EStreamAudioCodec::k_EStreamAudioCodecMP3),
            "k_EStreamAudioCodecAAC" => ::std::option::Option::Some(EStreamAudioCodec::k_EStreamAudioCodecAAC),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamAudioCodec] = &[
        EStreamAudioCodec::k_EStreamAudioCodecNone,
        EStreamAudioCodec::k_EStreamAudioCodecRaw,
        EStreamAudioCodec::k_EStreamAudioCodecVorbis,
        EStreamAudioCodec::k_EStreamAudioCodecOpus,
        EStreamAudioCodec::k_EStreamAudioCodecMP3,
        EStreamAudioCodec::k_EStreamAudioCodecAAC,
    ];
}

impl ::std::default::Default for EStreamAudioCodec {
    fn default() -> Self {
        EStreamAudioCodec::k_EStreamAudioCodecNone
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamVideoCodec)
pub enum EStreamVideoCodec {
    // @@protoc_insertion_point(enum_value:EStreamVideoCodec.k_EStreamVideoCodecNone)
    k_EStreamVideoCodecNone = 0,
    // @@protoc_insertion_point(enum_value:EStreamVideoCodec.k_EStreamVideoCodecRaw)
    k_EStreamVideoCodecRaw = 1,
    // @@protoc_insertion_point(enum_value:EStreamVideoCodec.k_EStreamVideoCodecVP8)
    k_EStreamVideoCodecVP8 = 2,
    // @@protoc_insertion_point(enum_value:EStreamVideoCodec.k_EStreamVideoCodecVP9)
    k_EStreamVideoCodecVP9 = 3,
    // @@protoc_insertion_point(enum_value:EStreamVideoCodec.k_EStreamVideoCodecH264)
    k_EStreamVideoCodecH264 = 4,
    // @@protoc_insertion_point(enum_value:EStreamVideoCodec.k_EStreamVideoCodecHEVC)
    k_EStreamVideoCodecHEVC = 5,
    // @@protoc_insertion_point(enum_value:EStreamVideoCodec.k_EStreamVideoCodecORBX1)
    k_EStreamVideoCodecORBX1 = 6,
    // @@protoc_insertion_point(enum_value:EStreamVideoCodec.k_EStreamVideoCodecORBX2)
    k_EStreamVideoCodecORBX2 = 7,
}

impl ::protobuf::Enum for EStreamVideoCodec {
    const NAME: &'static str = "EStreamVideoCodec";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamVideoCodec> {
        match value {
            0 => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecNone),
            1 => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecRaw),
            2 => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecVP8),
            3 => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecVP9),
            4 => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecH264),
            5 => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecHEVC),
            6 => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecORBX1),
            7 => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecORBX2),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamVideoCodec> {
        match str {
            "k_EStreamVideoCodecNone" => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecNone),
            "k_EStreamVideoCodecRaw" => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecRaw),
            "k_EStreamVideoCodecVP8" => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecVP8),
            "k_EStreamVideoCodecVP9" => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecVP9),
            "k_EStreamVideoCodecH264" => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecH264),
            "k_EStreamVideoCodecHEVC" => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecHEVC),
            "k_EStreamVideoCodecORBX1" => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecORBX1),
            "k_EStreamVideoCodecORBX2" => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecORBX2),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamVideoCodec] = &[
        EStreamVideoCodec::k_EStreamVideoCodecNone,
        EStreamVideoCodec::k_EStreamVideoCodecRaw,
        EStreamVideoCodec::k_EStreamVideoCodecVP8,
        EStreamVideoCodec::k_EStreamVideoCodecVP9,
        EStreamVideoCodec::k_EStreamVideoCodecH264,
        EStreamVideoCodec::k_EStreamVideoCodecHEVC,
        EStreamVideoCodec::k_EStreamVideoCodecORBX1,
        EStreamVideoCodec::k_EStreamVideoCodecORBX2,
    ];
}

impl ::std::default::Default for EStreamVideoCodec {
    fn default() -> Self {
        EStreamVideoCodec::k_EStreamVideoCodecNone
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamQualityPreference)
pub enum EStreamQualityPreference {
    // @@protoc_insertion_point(enum_value:EStreamQualityPreference.k_EStreamQualityAutomatic)
    k_EStreamQualityAutomatic = -1,
    // @@protoc_insertion_point(enum_value:EStreamQualityPreference.k_EStreamQualityFast)
    k_EStreamQualityFast = 1,
    // @@protoc_insertion_point(enum_value:EStreamQualityPreference.k_EStreamQualityBalanced)
    k_EStreamQualityBalanced = 2,
    // @@protoc_insertion_point(enum_value:EStreamQualityPreference.k_EStreamQualityBeautiful)
    k_EStreamQualityBeautiful = 3,
}

impl ::protobuf::Enum for EStreamQualityPreference {
    const NAME: &'static str = "EStreamQualityPreference";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamQualityPreference> {
        match value {
            -1 => ::std::option::Option::Some(EStreamQualityPreference::k_EStreamQualityAutomatic),
            1 => ::std::option::Option::Some(EStreamQualityPreference::k_EStreamQualityFast),
            2 => ::std::option::Option::Some(EStreamQualityPreference::k_EStreamQualityBalanced),
            3 => ::std::option::Option::Some(EStreamQualityPreference::k_EStreamQualityBeautiful),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamQualityPreference> {
        match str {
            "k_EStreamQualityAutomatic" => ::std::option::Option::Some(EStreamQualityPreference::k_EStreamQualityAutomatic),
            "k_EStreamQualityFast" => ::std::option::Option::Some(EStreamQualityPreference::k_EStreamQualityFast),
            "k_EStreamQualityBalanced" => ::std::option::Option::Some(EStreamQualityPreference::k_EStreamQualityBalanced),
            "k_EStreamQualityBeautiful" => ::std::option::Option::Some(EStreamQualityPreference::k_EStreamQualityBeautiful),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamQualityPreference] = &[
        EStreamQualityPreference::k_EStreamQualityAutomatic,
        EStreamQualityPreference::k_EStreamQualityFast,
        EStreamQualityPreference::k_EStreamQualityBalanced,
        EStreamQualityPreference::k_EStreamQualityBeautiful,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EStreamQualityPreference {
    fn default() -> Self {
        EStreamQualityPreference::k_EStreamQualityAutomatic
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamBitrate)
pub enum EStreamBitrate {
    // @@protoc_insertion_point(enum_value:EStreamBitrate.k_EStreamBitrateAutodetect)
    k_EStreamBitrateAutodetect = -1,
    // @@protoc_insertion_point(enum_value:EStreamBitrate.k_EStreamBitrateUnlimited)
    k_EStreamBitrateUnlimited = 0,
}

impl ::protobuf::Enum for EStreamBitrate {
    const NAME: &'static str = "EStreamBitrate";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamBitrate> {
        match value {
            -1 => ::std::option::Option::Some(EStreamBitrate::k_EStreamBitrateAutodetect),
            0 => ::std::option::Option::Some(EStreamBitrate::k_EStreamBitrateUnlimited),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamBitrate> {
        match str {
            "k_EStreamBitrateAutodetect" => ::std::option::Option::Some(EStreamBitrate::k_EStreamBitrateAutodetect),
            "k_EStreamBitrateUnlimited" => ::std::option::Option::Some(EStreamBitrate::k_EStreamBitrateUnlimited),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamBitrate] = &[
        EStreamBitrate::k_EStreamBitrateAutodetect,
        EStreamBitrate::k_EStreamBitrateUnlimited,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EStreamBitrate {
    fn default() -> Self {
        EStreamBitrate::k_EStreamBitrateAutodetect
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamColorspace)
pub enum EStreamColorspace {
    // @@protoc_insertion_point(enum_value:EStreamColorspace.k_EStreamColorspace_Unknown)
    k_EStreamColorspace_Unknown = 0,
    // @@protoc_insertion_point(enum_value:EStreamColorspace.k_EStreamColorspace_BT601)
    k_EStreamColorspace_BT601 = 1,
    // @@protoc_insertion_point(enum_value:EStreamColorspace.k_EStreamColorspace_BT601_Full)
    k_EStreamColorspace_BT601_Full = 2,
    // @@protoc_insertion_point(enum_value:EStreamColorspace.k_EStreamColorspace_BT709)
    k_EStreamColorspace_BT709 = 3,
    // @@protoc_insertion_point(enum_value:EStreamColorspace.k_EStreamColorspace_BT709_Full)
    k_EStreamColorspace_BT709_Full = 4,
}

impl ::protobuf::Enum for EStreamColorspace {
    const NAME: &'static str = "EStreamColorspace";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamColorspace> {
        match value {
            0 => ::std::option::Option::Some(EStreamColorspace::k_EStreamColorspace_Unknown),
            1 => ::std::option::Option::Some(EStreamColorspace::k_EStreamColorspace_BT601),
            2 => ::std::option::Option::Some(EStreamColorspace::k_EStreamColorspace_BT601_Full),
            3 => ::std::option::Option::Some(EStreamColorspace::k_EStreamColorspace_BT709),
            4 => ::std::option::Option::Some(EStreamColorspace::k_EStreamColorspace_BT709_Full),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamColorspace> {
        match str {
            "k_EStreamColorspace_Unknown" => ::std::option::Option::Some(EStreamColorspace::k_EStreamColorspace_Unknown),
            "k_EStreamColorspace_BT601" => ::std::option::Option::Some(EStreamColorspace::k_EStreamColorspace_BT601),
            "k_EStreamColorspace_BT601_Full" => ::std::option::Option::Some(EStreamColorspace::k_EStreamColorspace_BT601_Full),
            "k_EStreamColorspace_BT709" => ::std::option::Option::Some(EStreamColorspace::k_EStreamColorspace_BT709),
            "k_EStreamColorspace_BT709_Full" => ::std::option::Option::Some(EStreamColorspace::k_EStreamColorspace_BT709_Full),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamColorspace] = &[
        EStreamColorspace::k_EStreamColorspace_Unknown,
        EStreamColorspace::k_EStreamColorspace_BT601,
        EStreamColorspace::k_EStreamColorspace_BT601_Full,
        EStreamColorspace::k_EStreamColorspace_BT709,
        EStreamColorspace::k_EStreamColorspace_BT709_Full,
    ];
}

impl ::std::default::Default for EStreamColorspace {
    fn default() -> Self {
        EStreamColorspace::k_EStreamColorspace_Unknown
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamP2PScope)
pub enum EStreamP2PScope {
    // @@protoc_insertion_point(enum_value:EStreamP2PScope.k_EStreamP2PScopeAutomatic)
    k_EStreamP2PScopeAutomatic = 0,
    // @@protoc_insertion_point(enum_value:EStreamP2PScope.k_EStreamP2PScopeDisabled)
    k_EStreamP2PScopeDisabled = 1,
    // @@protoc_insertion_point(enum_value:EStreamP2PScope.k_EStreamP2PScopeOnlyMe)
    k_EStreamP2PScopeOnlyMe = 2,
    // @@protoc_insertion_point(enum_value:EStreamP2PScope.k_EStreamP2PScopeFriends)
    k_EStreamP2PScopeFriends = 3,
    // @@protoc_insertion_point(enum_value:EStreamP2PScope.k_EStreamP2PScopeEveryone)
    k_EStreamP2PScopeEveryone = 4,
}

impl ::protobuf::Enum for EStreamP2PScope {
    const NAME: &'static str = "EStreamP2PScope";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamP2PScope> {
        match value {
            0 => ::std::option::Option::Some(EStreamP2PScope::k_EStreamP2PScopeAutomatic),
            1 => ::std::option::Option::Some(EStreamP2PScope::k_EStreamP2PScopeDisabled),
            2 => ::std::option::Option::Some(EStreamP2PScope::k_EStreamP2PScopeOnlyMe),
            3 => ::std::option::Option::Some(EStreamP2PScope::k_EStreamP2PScopeFriends),
            4 => ::std::option::Option::Some(EStreamP2PScope::k_EStreamP2PScopeEveryone),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamP2PScope> {
        match str {
            "k_EStreamP2PScopeAutomatic" => ::std::option::Option::Some(EStreamP2PScope::k_EStreamP2PScopeAutomatic),
            "k_EStreamP2PScopeDisabled" => ::std::option::Option::Some(EStreamP2PScope::k_EStreamP2PScopeDisabled),
            "k_EStreamP2PScopeOnlyMe" => ::std::option::Option::Some(EStreamP2PScope::k_EStreamP2PScopeOnlyMe),
            "k_EStreamP2PScopeFriends" => ::std::option::Option::Some(EStreamP2PScope::k_EStreamP2PScopeFriends),
            "k_EStreamP2PScopeEveryone" => ::std::option::Option::Some(EStreamP2PScope::k_EStreamP2PScopeEveryone),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamP2PScope] = &[
        EStreamP2PScope::k_EStreamP2PScopeAutomatic,
        EStreamP2PScope::k_EStreamP2PScopeDisabled,
        EStreamP2PScope::k_EStreamP2PScopeOnlyMe,
        EStreamP2PScope::k_EStreamP2PScopeFriends,
        EStreamP2PScope::k_EStreamP2PScopeEveryone,
    ];
}

impl ::std::default::Default for EStreamP2PScope {
    fn default() -> Self {
        EStreamP2PScope::k_EStreamP2PScopeAutomatic
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamHostPlayAudioPreference)
pub enum EStreamHostPlayAudioPreference {
    // @@protoc_insertion_point(enum_value:EStreamHostPlayAudioPreference.k_EStreamHostPlayAudioDefault)
    k_EStreamHostPlayAudioDefault = 0,
    // @@protoc_insertion_point(enum_value:EStreamHostPlayAudioPreference.k_EStreamHostPlayAudioAlways)
    k_EStreamHostPlayAudioAlways = 1,
}

impl ::protobuf::Enum for EStreamHostPlayAudioPreference {
    const NAME: &'static str = "EStreamHostPlayAudioPreference";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamHostPlayAudioPreference> {
        match value {
            0 => ::std::option::Option::Some(EStreamHostPlayAudioPreference::k_EStreamHostPlayAudioDefault),
            1 => ::std::option::Option::Some(EStreamHostPlayAudioPreference::k_EStreamHostPlayAudioAlways),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamHostPlayAudioPreference> {
        match str {
            "k_EStreamHostPlayAudioDefault" => ::std::option::Option::Some(EStreamHostPlayAudioPreference::k_EStreamHostPlayAudioDefault),
            "k_EStreamHostPlayAudioAlways" => ::std::option::Option::Some(EStreamHostPlayAudioPreference::k_EStreamHostPlayAudioAlways),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamHostPlayAudioPreference] = &[
        EStreamHostPlayAudioPreference::k_EStreamHostPlayAudioDefault,
        EStreamHostPlayAudioPreference::k_EStreamHostPlayAudioAlways,
    ];
}

impl ::std::default::Default for EStreamHostPlayAudioPreference {
    fn default() -> Self {
        EStreamHostPlayAudioPreference::k_EStreamHostPlayAudioDefault
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamingDataType)
pub enum EStreamingDataType {
    // @@protoc_insertion_point(enum_value:EStreamingDataType.k_EStreamingAudioData)
    k_EStreamingAudioData = 0,
    // @@protoc_insertion_point(enum_value:EStreamingDataType.k_EStreamingVideoData)
    k_EStreamingVideoData = 1,
    // @@protoc_insertion_point(enum_value:EStreamingDataType.k_EStreamingMicrophoneData)
    k_EStreamingMicrophoneData = 2,
    // @@protoc_insertion_point(enum_value:EStreamingDataType.k_EStreamingNeptuneData)
    k_EStreamingNeptuneData = 3,
}

impl ::protobuf::Enum for EStreamingDataType {
    const NAME: &'static str = "EStreamingDataType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamingDataType> {
        match value {
            0 => ::std::option::Option::Some(EStreamingDataType::k_EStreamingAudioData),
            1 => ::std::option::Option::Some(EStreamingDataType::k_EStreamingVideoData),
            2 => ::std::option::Option::Some(EStreamingDataType::k_EStreamingMicrophoneData),
            3 => ::std::option::Option::Some(EStreamingDataType::k_EStreamingNeptuneData),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamingDataType> {
        match str {
            "k_EStreamingAudioData" => ::std::option::Option::Some(EStreamingDataType::k_EStreamingAudioData),
            "k_EStreamingVideoData" => ::std::option::Option::Some(EStreamingDataType::k_EStreamingVideoData),
            "k_EStreamingMicrophoneData" => ::std::option::Option::Some(EStreamingDataType::k_EStreamingMicrophoneData),
            "k_EStreamingNeptuneData" => ::std::option::Option::Some(EStreamingDataType::k_EStreamingNeptuneData),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamingDataType] = &[
        EStreamingDataType::k_EStreamingAudioData,
        EStreamingDataType::k_EStreamingVideoData,
        EStreamingDataType::k_EStreamingMicrophoneData,
        EStreamingDataType::k_EStreamingNeptuneData,
    ];
}

impl ::std::default::Default for EStreamingDataType {
    fn default() -> Self {
        EStreamingDataType::k_EStreamingAudioData
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamMouseButton)
pub enum EStreamMouseButton {
    // @@protoc_insertion_point(enum_value:EStreamMouseButton.k_EStreamMouseButtonLeft)
    k_EStreamMouseButtonLeft = 1,
    // @@protoc_insertion_point(enum_value:EStreamMouseButton.k_EStreamMouseButtonRight)
    k_EStreamMouseButtonRight = 2,
    // @@protoc_insertion_point(enum_value:EStreamMouseButton.k_EStreamMouseButtonMiddle)
    k_EStreamMouseButtonMiddle = 16,
    // @@protoc_insertion_point(enum_value:EStreamMouseButton.k_EStreamMouseButtonX1)
    k_EStreamMouseButtonX1 = 32,
    // @@protoc_insertion_point(enum_value:EStreamMouseButton.k_EStreamMouseButtonX2)
    k_EStreamMouseButtonX2 = 64,
    // @@protoc_insertion_point(enum_value:EStreamMouseButton.k_EStreamMouseButtonUnknown)
    k_EStreamMouseButtonUnknown = 4096,
}

impl ::protobuf::Enum for EStreamMouseButton {
    const NAME: &'static str = "EStreamMouseButton";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamMouseButton> {
        match value {
            1 => ::std::option::Option::Some(EStreamMouseButton::k_EStreamMouseButtonLeft),
            2 => ::std::option::Option::Some(EStreamMouseButton::k_EStreamMouseButtonRight),
            16 => ::std::option::Option::Some(EStreamMouseButton::k_EStreamMouseButtonMiddle),
            32 => ::std::option::Option::Some(EStreamMouseButton::k_EStreamMouseButtonX1),
            64 => ::std::option::Option::Some(EStreamMouseButton::k_EStreamMouseButtonX2),
            4096 => ::std::option::Option::Some(EStreamMouseButton::k_EStreamMouseButtonUnknown),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamMouseButton> {
        match str {
            "k_EStreamMouseButtonLeft" => ::std::option::Option::Some(EStreamMouseButton::k_EStreamMouseButtonLeft),
            "k_EStreamMouseButtonRight" => ::std::option::Option::Some(EStreamMouseButton::k_EStreamMouseButtonRight),
            "k_EStreamMouseButtonMiddle" => ::std::option::Option::Some(EStreamMouseButton::k_EStreamMouseButtonMiddle),
            "k_EStreamMouseButtonX1" => ::std::option::Option::Some(EStreamMouseButton::k_EStreamMouseButtonX1),
            "k_EStreamMouseButtonX2" => ::std::option::Option::Some(EStreamMouseButton::k_EStreamMouseButtonX2),
            "k_EStreamMouseButtonUnknown" => ::std::option::Option::Some(EStreamMouseButton::k_EStreamMouseButtonUnknown),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamMouseButton] = &[
        EStreamMouseButton::k_EStreamMouseButtonLeft,
        EStreamMouseButton::k_EStreamMouseButtonRight,
        EStreamMouseButton::k_EStreamMouseButtonMiddle,
        EStreamMouseButton::k_EStreamMouseButtonX1,
        EStreamMouseButton::k_EStreamMouseButtonX2,
        EStreamMouseButton::k_EStreamMouseButtonUnknown,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EStreamMouseButton {
    fn default() -> Self {
        EStreamMouseButton::k_EStreamMouseButtonLeft
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamMouseWheelDirection)
pub enum EStreamMouseWheelDirection {
    // @@protoc_insertion_point(enum_value:EStreamMouseWheelDirection.k_EStreamMouseWheelUp)
    k_EStreamMouseWheelUp = 120,
    // @@protoc_insertion_point(enum_value:EStreamMouseWheelDirection.k_EStreamMouseWheelDown)
    k_EStreamMouseWheelDown = -120,
    // @@protoc_insertion_point(enum_value:EStreamMouseWheelDirection.k_EStreamMouseWheelLeft)
    k_EStreamMouseWheelLeft = 3,
    // @@protoc_insertion_point(enum_value:EStreamMouseWheelDirection.k_EStreamMouseWheelRight)
    k_EStreamMouseWheelRight = 4,
}

impl ::protobuf::Enum for EStreamMouseWheelDirection {
    const NAME: &'static str = "EStreamMouseWheelDirection";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamMouseWheelDirection> {
        match value {
            120 => ::std::option::Option::Some(EStreamMouseWheelDirection::k_EStreamMouseWheelUp),
            -120 => ::std::option::Option::Some(EStreamMouseWheelDirection::k_EStreamMouseWheelDown),
            3 => ::std::option::Option::Some(EStreamMouseWheelDirection::k_EStreamMouseWheelLeft),
            4 => ::std::option::Option::Some(EStreamMouseWheelDirection::k_EStreamMouseWheelRight),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamMouseWheelDirection> {
        match str {
            "k_EStreamMouseWheelUp" => ::std::option::Option::Some(EStreamMouseWheelDirection::k_EStreamMouseWheelUp),
            "k_EStreamMouseWheelDown" => ::std::option::Option::Some(EStreamMouseWheelDirection::k_EStreamMouseWheelDown),
            "k_EStreamMouseWheelLeft" => ::std::option::Option::Some(EStreamMouseWheelDirection::k_EStreamMouseWheelLeft),
            "k_EStreamMouseWheelRight" => ::std::option::Option::Some(EStreamMouseWheelDirection::k_EStreamMouseWheelRight),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamMouseWheelDirection] = &[
        EStreamMouseWheelDirection::k_EStreamMouseWheelUp,
        EStreamMouseWheelDirection::k_EStreamMouseWheelDown,
        EStreamMouseWheelDirection::k_EStreamMouseWheelLeft,
        EStreamMouseWheelDirection::k_EStreamMouseWheelRight,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EStreamMouseWheelDirection {
    fn default() -> Self {
        EStreamMouseWheelDirection::k_EStreamMouseWheelUp
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamFramerateLimiter)
pub enum EStreamFramerateLimiter {
    // @@protoc_insertion_point(enum_value:EStreamFramerateLimiter.k_EStreamFramerateSlowCapture)
    k_EStreamFramerateSlowCapture = 1,
    // @@protoc_insertion_point(enum_value:EStreamFramerateLimiter.k_EStreamFramerateSlowConvert)
    k_EStreamFramerateSlowConvert = 2,
    // @@protoc_insertion_point(enum_value:EStreamFramerateLimiter.k_EStreamFramerateSlowEncode)
    k_EStreamFramerateSlowEncode = 4,
    // @@protoc_insertion_point(enum_value:EStreamFramerateLimiter.k_EStreamFramerateSlowNetwork)
    k_EStreamFramerateSlowNetwork = 8,
    // @@protoc_insertion_point(enum_value:EStreamFramerateLimiter.k_EStreamFramerateSlowDecode)
    k_EStreamFramerateSlowDecode = 16,
    // @@protoc_insertion_point(enum_value:EStreamFramerateLimiter.k_EStreamFramerateSlowGame)
    k_EStreamFramerateSlowGame = 32,
    // @@protoc_insertion_point(enum_value:EStreamFramerateLimiter.k_EStreamFramerateSlowDisplay)
    k_EStreamFramerateSlowDisplay = 64,
}

impl ::protobuf::Enum for EStreamFramerateLimiter {
    const NAME: &'static str = "EStreamFramerateLimiter";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamFramerateLimiter> {
        match value {
            1 => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowCapture),
            2 => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowConvert),
            4 => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowEncode),
            8 => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowNetwork),
            16 => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowDecode),
            32 => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowGame),
            64 => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowDisplay),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamFramerateLimiter> {
        match str {
            "k_EStreamFramerateSlowCapture" => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowCapture),
            "k_EStreamFramerateSlowConvert" => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowConvert),
            "k_EStreamFramerateSlowEncode" => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowEncode),
            "k_EStreamFramerateSlowNetwork" => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowNetwork),
            "k_EStreamFramerateSlowDecode" => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowDecode),
            "k_EStreamFramerateSlowGame" => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowGame),
            "k_EStreamFramerateSlowDisplay" => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowDisplay),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamFramerateLimiter] = &[
        EStreamFramerateLimiter::k_EStreamFramerateSlowCapture,
        EStreamFramerateLimiter::k_EStreamFramerateSlowConvert,
        EStreamFramerateLimiter::k_EStreamFramerateSlowEncode,
        EStreamFramerateLimiter::k_EStreamFramerateSlowNetwork,
        EStreamFramerateLimiter::k_EStreamFramerateSlowDecode,
        EStreamFramerateLimiter::k_EStreamFramerateSlowGame,
        EStreamFramerateLimiter::k_EStreamFramerateSlowDisplay,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EStreamFramerateLimiter {
    fn default() -> Self {
        EStreamFramerateLimiter::k_EStreamFramerateSlowCapture
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamActivity)
pub enum EStreamActivity {
    // @@protoc_insertion_point(enum_value:EStreamActivity.k_EStreamActivityIdle)
    k_EStreamActivityIdle = 1,
    // @@protoc_insertion_point(enum_value:EStreamActivity.k_EStreamActivityGame)
    k_EStreamActivityGame = 2,
    // @@protoc_insertion_point(enum_value:EStreamActivity.k_EStreamActivityDesktop)
    k_EStreamActivityDesktop = 3,
    // @@protoc_insertion_point(enum_value:EStreamActivity.k_EStreamActivitySecureDesktop)
    k_EStreamActivitySecureDesktop = 4,
    // @@protoc_insertion_point(enum_value:EStreamActivity.k_EStreamActivityMusic)
    k_EStreamActivityMusic = 5,
}

impl ::protobuf::Enum for EStreamActivity {
    const NAME: &'static str = "EStreamActivity";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamActivity> {
        match value {
            1 => ::std::option::Option::Some(EStreamActivity::k_EStreamActivityIdle),
            2 => ::std::option::Option::Some(EStreamActivity::k_EStreamActivityGame),
            3 => ::std::option::Option::Some(EStreamActivity::k_EStreamActivityDesktop),
            4 => ::std::option::Option::Some(EStreamActivity::k_EStreamActivitySecureDesktop),
            5 => ::std::option::Option::Some(EStreamActivity::k_EStreamActivityMusic),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamActivity> {
        match str {
            "k_EStreamActivityIdle" => ::std::option::Option::Some(EStreamActivity::k_EStreamActivityIdle),
            "k_EStreamActivityGame" => ::std::option::Option::Some(EStreamActivity::k_EStreamActivityGame),
            "k_EStreamActivityDesktop" => ::std::option::Option::Some(EStreamActivity::k_EStreamActivityDesktop),
            "k_EStreamActivitySecureDesktop" => ::std::option::Option::Some(EStreamActivity::k_EStreamActivitySecureDesktop),
            "k_EStreamActivityMusic" => ::std::option::Option::Some(EStreamActivity::k_EStreamActivityMusic),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamActivity] = &[
        EStreamActivity::k_EStreamActivityIdle,
        EStreamActivity::k_EStreamActivityGame,
        EStreamActivity::k_EStreamActivityDesktop,
        EStreamActivity::k_EStreamActivitySecureDesktop,
        EStreamActivity::k_EStreamActivityMusic,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EStreamActivity {
    fn default() -> Self {
        EStreamActivity::k_EStreamActivityIdle
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamDataMessage)
pub enum EStreamDataMessage {
    // @@protoc_insertion_point(enum_value:EStreamDataMessage.k_EStreamDataPacket)
    k_EStreamDataPacket = 1,
    // @@protoc_insertion_point(enum_value:EStreamDataMessage.k_EStreamDataLost)
    k_EStreamDataLost = 2,
}

impl ::protobuf::Enum for EStreamDataMessage {
    const NAME: &'static str = "EStreamDataMessage";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamDataMessage> {
        match value {
            1 => ::std::option::Option::Some(EStreamDataMessage::k_EStreamDataPacket),
            2 => ::std::option::Option::Some(EStreamDataMessage::k_EStreamDataLost),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamDataMessage> {
        match str {
            "k_EStreamDataPacket" => ::std::option::Option::Some(EStreamDataMessage::k_EStreamDataPacket),
            "k_EStreamDataLost" => ::std::option::Option::Some(EStreamDataMessage::k_EStreamDataLost),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamDataMessage] = &[
        EStreamDataMessage::k_EStreamDataPacket,
        EStreamDataMessage::k_EStreamDataLost,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EStreamDataMessage {
    fn default() -> Self {
        EStreamDataMessage::k_EStreamDataPacket
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EAudioFormat)
pub enum EAudioFormat {
    // @@protoc_insertion_point(enum_value:EAudioFormat.k_EAudioFormatNone)
    k_EAudioFormatNone = 0,
    // @@protoc_insertion_point(enum_value:EAudioFormat.k_EAudioFormat16BitLittleEndian)
    k_EAudioFormat16BitLittleEndian = 1,
    // @@protoc_insertion_point(enum_value:EAudioFormat.k_EAudioFormatFloat)
    k_EAudioFormatFloat = 2,
}

impl ::protobuf::Enum for EAudioFormat {
    const NAME: &'static str = "EAudioFormat";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EAudioFormat> {
        match value {
            0 => ::std::option::Option::Some(EAudioFormat::k_EAudioFormatNone),
            1 => ::std::option::Option::Some(EAudioFormat::k_EAudioFormat16BitLittleEndian),
            2 => ::std::option::Option::Some(EAudioFormat::k_EAudioFormatFloat),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EAudioFormat> {
        match str {
            "k_EAudioFormatNone" => ::std::option::Option::Some(EAudioFormat::k_EAudioFormatNone),
            "k_EAudioFormat16BitLittleEndian" => ::std::option::Option::Some(EAudioFormat::k_EAudioFormat16BitLittleEndian),
            "k_EAudioFormatFloat" => ::std::option::Option::Some(EAudioFormat::k_EAudioFormatFloat),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EAudioFormat] = &[
        EAudioFormat::k_EAudioFormatNone,
        EAudioFormat::k_EAudioFormat16BitLittleEndian,
        EAudioFormat::k_EAudioFormatFloat,
    ];
}

impl ::std::default::Default for EAudioFormat {
    fn default() -> Self {
        EAudioFormat::k_EAudioFormatNone
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EVideoFormat)
pub enum EVideoFormat {
    // @@protoc_insertion_point(enum_value:EVideoFormat.k_EVideoFormatNone)
    k_EVideoFormatNone = 0,
    // @@protoc_insertion_point(enum_value:EVideoFormat.k_EVideoFormatYV12)
    k_EVideoFormatYV12 = 1,
    // @@protoc_insertion_point(enum_value:EVideoFormat.k_EVideoFormatAccel)
    k_EVideoFormatAccel = 2,
}

impl ::protobuf::Enum for EVideoFormat {
    const NAME: &'static str = "EVideoFormat";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EVideoFormat> {
        match value {
            0 => ::std::option::Option::Some(EVideoFormat::k_EVideoFormatNone),
            1 => ::std::option::Option::Some(EVideoFormat::k_EVideoFormatYV12),
            2 => ::std::option::Option::Some(EVideoFormat::k_EVideoFormatAccel),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EVideoFormat> {
        match str {
            "k_EVideoFormatNone" => ::std::option::Option::Some(EVideoFormat::k_EVideoFormatNone),
            "k_EVideoFormatYV12" => ::std::option::Option::Some(EVideoFormat::k_EVideoFormatYV12),
            "k_EVideoFormatAccel" => ::std::option::Option::Some(EVideoFormat::k_EVideoFormatAccel),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EVideoFormat] = &[
        EVideoFormat::k_EVideoFormatNone,
        EVideoFormat::k_EVideoFormatYV12,
        EVideoFormat::k_EVideoFormatAccel,
    ];
}

impl ::std::default::Default for EVideoFormat {
    fn default() -> Self {
        EVideoFormat::k_EVideoFormatNone
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamStatsMessage)
pub enum EStreamStatsMessage {
    // @@protoc_insertion_point(enum_value:EStreamStatsMessage.k_EStreamStatsFrameEvents)
    k_EStreamStatsFrameEvents = 1,
    // @@protoc_insertion_point(enum_value:EStreamStatsMessage.k_EStreamStatsDebugDump)
    k_EStreamStatsDebugDump = 2,
    // @@protoc_insertion_point(enum_value:EStreamStatsMessage.k_EStreamStatsLogMessage)
    k_EStreamStatsLogMessage = 3,
    // @@protoc_insertion_point(enum_value:EStreamStatsMessage.k_EStreamStatsLogUploadBegin)
    k_EStreamStatsLogUploadBegin = 4,
    // @@protoc_insertion_point(enum_value:EStreamStatsMessage.k_EStreamStatsLogUploadData)
    k_EStreamStatsLogUploadData = 5,
    // @@protoc_insertion_point(enum_value:EStreamStatsMessage.k_EStreamStatsLogUploadComplete)
    k_EStreamStatsLogUploadComplete = 6,
}

impl ::protobuf::Enum for EStreamStatsMessage {
    const NAME: &'static str = "EStreamStatsMessage";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamStatsMessage> {
        match value {
            1 => ::std::option::Option::Some(EStreamStatsMessage::k_EStreamStatsFrameEvents),
            2 => ::std::option::Option::Some(EStreamStatsMessage::k_EStreamStatsDebugDump),
            3 => ::std::option::Option::Some(EStreamStatsMessage::k_EStreamStatsLogMessage),
            4 => ::std::option::Option::Some(EStreamStatsMessage::k_EStreamStatsLogUploadBegin),
            5 => ::std::option::Option::Some(EStreamStatsMessage::k_EStreamStatsLogUploadData),
            6 => ::std::option::Option::Some(EStreamStatsMessage::k_EStreamStatsLogUploadComplete),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamStatsMessage> {
        match str {
            "k_EStreamStatsFrameEvents" => ::std::option::Option::Some(EStreamStatsMessage::k_EStreamStatsFrameEvents),
            "k_EStreamStatsDebugDump" => ::std::option::Option::Some(EStreamStatsMessage::k_EStreamStatsDebugDump),
            "k_EStreamStatsLogMessage" => ::std::option::Option::Some(EStreamStatsMessage::k_EStreamStatsLogMessage),
            "k_EStreamStatsLogUploadBegin" => ::std::option::Option::Some(EStreamStatsMessage::k_EStreamStatsLogUploadBegin),
            "k_EStreamStatsLogUploadData" => ::std::option::Option::Some(EStreamStatsMessage::k_EStreamStatsLogUploadData),
            "k_EStreamStatsLogUploadComplete" => ::std::option::Option::Some(EStreamStatsMessage::k_EStreamStatsLogUploadComplete),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamStatsMessage] = &[
        EStreamStatsMessage::k_EStreamStatsFrameEvents,
        EStreamStatsMessage::k_EStreamStatsDebugDump,
        EStreamStatsMessage::k_EStreamStatsLogMessage,
        EStreamStatsMessage::k_EStreamStatsLogUploadBegin,
        EStreamStatsMessage::k_EStreamStatsLogUploadData,
        EStreamStatsMessage::k_EStreamStatsLogUploadComplete,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EStreamStatsMessage {
    fn default() -> Self {
        EStreamStatsMessage::k_EStreamStatsFrameEvents
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamFrameEvent)
pub enum EStreamFrameEvent {
    // @@protoc_insertion_point(enum_value:EStreamFrameEvent.k_EStreamInputEventStart)
    k_EStreamInputEventStart = 0,
    // @@protoc_insertion_point(enum_value:EStreamFrameEvent.k_EStreamInputEventSend)
    k_EStreamInputEventSend = 1,
    // @@protoc_insertion_point(enum_value:EStreamFrameEvent.k_EStreamInputEventRecv)
    k_EStreamInputEventRecv = 2,
    // @@protoc_insertion_point(enum_value:EStreamFrameEvent.k_EStreamInputEventQueued)
    k_EStreamInputEventQueued = 3,
    // @@protoc_insertion_point(enum_value:EStreamFrameEvent.k_EStreamInputEventHandled)
    k_EStreamInputEventHandled = 4,
    // @@protoc_insertion_point(enum_value:EStreamFrameEvent.k_EStreamFrameEventStart)
    k_EStreamFrameEventStart = 5,
    // @@protoc_insertion_point(enum_value:EStreamFrameEvent.k_EStreamFrameEventCaptureBegin)
    k_EStreamFrameEventCaptureBegin = 6,
    // @@protoc_insertion_point(enum_value:EStreamFrameEvent.k_EStreamFrameEventCaptureEnd)
    k_EStreamFrameEventCaptureEnd = 7,
    // @@protoc_insertion_point(enum_value:EStreamFrameEvent.k_EStreamFrameEventConvertBegin)
    k_EStreamFrameEventConvertBegin = 8,
    // @@protoc_insertion_point(enum_value:EStreamFrameEvent.k_EStreamFrameEventConvertEnd)
    k_EStreamFrameEventConvertEnd = 9,
    // @@protoc_insertion_point(enum_value:EStreamFrameEvent.k_EStreamFrameEventEncodeBegin)
    k_EStreamFrameEventEncodeBegin = 10,
    // @@protoc_insertion_point(enum_value:EStreamFrameEvent.k_EStreamFrameEventEncodeEnd)
    k_EStreamFrameEventEncodeEnd = 11,
    // @@protoc_insertion_point(enum_value:EStreamFrameEvent.k_EStreamFrameEventSend)
    k_EStreamFrameEventSend = 12,
    // @@protoc_insertion_point(enum_value:EStreamFrameEvent.k_EStreamFrameEventRecv)
    k_EStreamFrameEventRecv = 13,
    // @@protoc_insertion_point(enum_value:EStreamFrameEvent.k_EStreamFrameEventDecodeBegin)
    k_EStreamFrameEventDecodeBegin = 14,
    // @@protoc_insertion_point(enum_value:EStreamFrameEvent.k_EStreamFrameEventDecodeEnd)
    k_EStreamFrameEventDecodeEnd = 15,
    // @@protoc_insertion_point(enum_value:EStreamFrameEvent.k_EStreamFrameEventUploadBegin)
    k_EStreamFrameEventUploadBegin = 16,
    // @@protoc_insertion_point(enum_value:EStreamFrameEvent.k_EStreamFrameEventUploadEnd)
    k_EStreamFrameEventUploadEnd = 17,
    // @@protoc_insertion_point(enum_value:EStreamFrameEvent.k_EStreamFrameEventComplete)
    k_EStreamFrameEventComplete = 18,
}

impl ::protobuf::Enum for EStreamFrameEvent {
    const NAME: &'static str = "EStreamFrameEvent";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamFrameEvent> {
        match value {
            0 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamInputEventStart),
            1 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamInputEventSend),
            2 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamInputEventRecv),
            3 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamInputEventQueued),
            4 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamInputEventHandled),
            5 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventStart),
            6 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventCaptureBegin),
            7 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventCaptureEnd),
            8 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventConvertBegin),
            9 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventConvertEnd),
            10 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventEncodeBegin),
            11 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventEncodeEnd),
            12 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventSend),
            13 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventRecv),
            14 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventDecodeBegin),
            15 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventDecodeEnd),
            16 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventUploadBegin),
            17 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventUploadEnd),
            18 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventComplete),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamFrameEvent> {
        match str {
            "k_EStreamInputEventStart" => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamInputEventStart),
            "k_EStreamInputEventSend" => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamInputEventSend),
            "k_EStreamInputEventRecv" => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamInputEventRecv),
            "k_EStreamInputEventQueued" => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamInputEventQueued),
            "k_EStreamInputEventHandled" => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamInputEventHandled),
            "k_EStreamFrameEventStart" => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventStart),
            "k_EStreamFrameEventCaptureBegin" => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventCaptureBegin),
            "k_EStreamFrameEventCaptureEnd" => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventCaptureEnd),
            "k_EStreamFrameEventConvertBegin" => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventConvertBegin),
            "k_EStreamFrameEventConvertEnd" => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventConvertEnd),
            "k_EStreamFrameEventEncodeBegin" => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventEncodeBegin),
            "k_EStreamFrameEventEncodeEnd" => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventEncodeEnd),
            "k_EStreamFrameEventSend" => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventSend),
            "k_EStreamFrameEventRecv" => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventRecv),
            "k_EStreamFrameEventDecodeBegin" => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventDecodeBegin),
            "k_EStreamFrameEventDecodeEnd" => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventDecodeEnd),
            "k_EStreamFrameEventUploadBegin" => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventUploadBegin),
            "k_EStreamFrameEventUploadEnd" => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventUploadEnd),
            "k_EStreamFrameEventComplete" => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventComplete),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamFrameEvent] = &[
        EStreamFrameEvent::k_EStreamInputEventStart,
        EStreamFrameEvent::k_EStreamInputEventSend,
        EStreamFrameEvent::k_EStreamInputEventRecv,
        EStreamFrameEvent::k_EStreamInputEventQueued,
        EStreamFrameEvent::k_EStreamInputEventHandled,
        EStreamFrameEvent::k_EStreamFrameEventStart,
        EStreamFrameEvent::k_EStreamFrameEventCaptureBegin,
        EStreamFrameEvent::k_EStreamFrameEventCaptureEnd,
        EStreamFrameEvent::k_EStreamFrameEventConvertBegin,
        EStreamFrameEvent::k_EStreamFrameEventConvertEnd,
        EStreamFrameEvent::k_EStreamFrameEventEncodeBegin,
        EStreamFrameEvent::k_EStreamFrameEventEncodeEnd,
        EStreamFrameEvent::k_EStreamFrameEventSend,
        EStreamFrameEvent::k_EStreamFrameEventRecv,
        EStreamFrameEvent::k_EStreamFrameEventDecodeBegin,
        EStreamFrameEvent::k_EStreamFrameEventDecodeEnd,
        EStreamFrameEvent::k_EStreamFrameEventUploadBegin,
        EStreamFrameEvent::k_EStreamFrameEventUploadEnd,
        EStreamFrameEvent::k_EStreamFrameEventComplete,
    ];
}

impl ::std::default::Default for EStreamFrameEvent {
    fn default() -> Self {
        EStreamFrameEvent::k_EStreamInputEventStart
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamFrameResult)
pub enum EStreamFrameResult {
    // @@protoc_insertion_point(enum_value:EStreamFrameResult.k_EStreamFrameResultPending)
    k_EStreamFrameResultPending = 0,
    // @@protoc_insertion_point(enum_value:EStreamFrameResult.k_EStreamFrameResultDisplayed)
    k_EStreamFrameResultDisplayed = 1,
    // @@protoc_insertion_point(enum_value:EStreamFrameResult.k_EStreamFrameResultDroppedNetworkSlow)
    k_EStreamFrameResultDroppedNetworkSlow = 2,
    // @@protoc_insertion_point(enum_value:EStreamFrameResult.k_EStreamFrameResultDroppedNetworkLost)
    k_EStreamFrameResultDroppedNetworkLost = 3,
    // @@protoc_insertion_point(enum_value:EStreamFrameResult.k_EStreamFrameResultDroppedDecodeSlow)
    k_EStreamFrameResultDroppedDecodeSlow = 4,
    // @@protoc_insertion_point(enum_value:EStreamFrameResult.k_EStreamFrameResultDroppedDecodeCorrupt)
    k_EStreamFrameResultDroppedDecodeCorrupt = 5,
    // @@protoc_insertion_point(enum_value:EStreamFrameResult.k_EStreamFrameResultDroppedLate)
    k_EStreamFrameResultDroppedLate = 6,
    // @@protoc_insertion_point(enum_value:EStreamFrameResult.k_EStreamFrameResultDroppedReset)
    k_EStreamFrameResultDroppedReset = 7,
}

impl ::protobuf::Enum for EStreamFrameResult {
    const NAME: &'static str = "EStreamFrameResult";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamFrameResult> {
        match value {
            0 => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultPending),
            1 => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDisplayed),
            2 => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDroppedNetworkSlow),
            3 => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDroppedNetworkLost),
            4 => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDroppedDecodeSlow),
            5 => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDroppedDecodeCorrupt),
            6 => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDroppedLate),
            7 => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDroppedReset),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamFrameResult> {
        match str {
            "k_EStreamFrameResultPending" => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultPending),
            "k_EStreamFrameResultDisplayed" => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDisplayed),
            "k_EStreamFrameResultDroppedNetworkSlow" => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDroppedNetworkSlow),
            "k_EStreamFrameResultDroppedNetworkLost" => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDroppedNetworkLost),
            "k_EStreamFrameResultDroppedDecodeSlow" => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDroppedDecodeSlow),
            "k_EStreamFrameResultDroppedDecodeCorrupt" => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDroppedDecodeCorrupt),
            "k_EStreamFrameResultDroppedLate" => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDroppedLate),
            "k_EStreamFrameResultDroppedReset" => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDroppedReset),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamFrameResult] = &[
        EStreamFrameResult::k_EStreamFrameResultPending,
        EStreamFrameResult::k_EStreamFrameResultDisplayed,
        EStreamFrameResult::k_EStreamFrameResultDroppedNetworkSlow,
        EStreamFrameResult::k_EStreamFrameResultDroppedNetworkLost,
        EStreamFrameResult::k_EStreamFrameResultDroppedDecodeSlow,
        EStreamFrameResult::k_EStreamFrameResultDroppedDecodeCorrupt,
        EStreamFrameResult::k_EStreamFrameResultDroppedLate,
        EStreamFrameResult::k_EStreamFrameResultDroppedReset,
    ];
}

impl ::std::default::Default for EStreamFrameResult {
    fn default() -> Self {
        EStreamFrameResult::k_EStreamFrameResultPending
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EFrameAccumulatedStat)
pub enum EFrameAccumulatedStat {
    // @@protoc_insertion_point(enum_value:EFrameAccumulatedStat.k_EFrameStatFPS)
    k_EFrameStatFPS = 0,
    // @@protoc_insertion_point(enum_value:EFrameAccumulatedStat.k_EFrameStatCaptureDurationMS)
    k_EFrameStatCaptureDurationMS = 1,
    // @@protoc_insertion_point(enum_value:EFrameAccumulatedStat.k_EFrameStatConvertDurationMS)
    k_EFrameStatConvertDurationMS = 2,
    // @@protoc_insertion_point(enum_value:EFrameAccumulatedStat.k_EFrameStatEncodeDurationMS)
    k_EFrameStatEncodeDurationMS = 3,
    // @@protoc_insertion_point(enum_value:EFrameAccumulatedStat.k_EFrameStatSteamDurationMS)
    k_EFrameStatSteamDurationMS = 4,
    // @@protoc_insertion_point(enum_value:EFrameAccumulatedStat.k_EFrameStatServerDurationMS)
    k_EFrameStatServerDurationMS = 5,
    // @@protoc_insertion_point(enum_value:EFrameAccumulatedStat.k_EFrameStatNetworkDurationMS)
    k_EFrameStatNetworkDurationMS = 6,
    // @@protoc_insertion_point(enum_value:EFrameAccumulatedStat.k_EFrameStatDecodeDurationMS)
    k_EFrameStatDecodeDurationMS = 7,
    // @@protoc_insertion_point(enum_value:EFrameAccumulatedStat.k_EFrameStatDisplayDurationMS)
    k_EFrameStatDisplayDurationMS = 8,
    // @@protoc_insertion_point(enum_value:EFrameAccumulatedStat.k_EFrameStatClientDurationMS)
    k_EFrameStatClientDurationMS = 9,
    // @@protoc_insertion_point(enum_value:EFrameAccumulatedStat.k_EFrameStatFrameDurationMS)
    k_EFrameStatFrameDurationMS = 10,
    // @@protoc_insertion_point(enum_value:EFrameAccumulatedStat.k_EFrameStatInputLatencyMS)
    k_EFrameStatInputLatencyMS = 11,
    // @@protoc_insertion_point(enum_value:EFrameAccumulatedStat.k_EFrameStatGameLatencyMS)
    k_EFrameStatGameLatencyMS = 12,
    // @@protoc_insertion_point(enum_value:EFrameAccumulatedStat.k_EFrameStatRoundTripLatencyMS)
    k_EFrameStatRoundTripLatencyMS = 13,
    // @@protoc_insertion_point(enum_value:EFrameAccumulatedStat.k_EFrameStatPingTimeMS)
    k_EFrameStatPingTimeMS = 14,
    // @@protoc_insertion_point(enum_value:EFrameAccumulatedStat.k_EFrameStatServerBitrateKbitPerSec)
    k_EFrameStatServerBitrateKbitPerSec = 15,
    // @@protoc_insertion_point(enum_value:EFrameAccumulatedStat.k_EFrameStatClientBitrateKbitPerSec)
    k_EFrameStatClientBitrateKbitPerSec = 16,
    // @@protoc_insertion_point(enum_value:EFrameAccumulatedStat.k_EFrameStatLinkBandwidthKbitPerSec)
    k_EFrameStatLinkBandwidthKbitPerSec = 17,
    // @@protoc_insertion_point(enum_value:EFrameAccumulatedStat.k_EFrameStatPacketLossPercentage)
    k_EFrameStatPacketLossPercentage = 18,
}

impl ::protobuf::Enum for EFrameAccumulatedStat {
    const NAME: &'static str = "EFrameAccumulatedStat";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EFrameAccumulatedStat> {
        match value {
            0 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatFPS),
            1 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatCaptureDurationMS),
            2 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatConvertDurationMS),
            3 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatEncodeDurationMS),
            4 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatSteamDurationMS),
            5 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatServerDurationMS),
            6 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatNetworkDurationMS),
            7 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatDecodeDurationMS),
            8 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatDisplayDurationMS),
            9 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatClientDurationMS),
            10 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatFrameDurationMS),
            11 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatInputLatencyMS),
            12 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatGameLatencyMS),
            13 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatRoundTripLatencyMS),
            14 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatPingTimeMS),
            15 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatServerBitrateKbitPerSec),
            16 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatClientBitrateKbitPerSec),
            17 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatLinkBandwidthKbitPerSec),
            18 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatPacketLossPercentage),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EFrameAccumulatedStat> {
        match str {
            "k_EFrameStatFPS" => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatFPS),
            "k_EFrameStatCaptureDurationMS" => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatCaptureDurationMS),
            "k_EFrameStatConvertDurationMS" => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatConvertDurationMS),
            "k_EFrameStatEncodeDurationMS" => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatEncodeDurationMS),
            "k_EFrameStatSteamDurationMS" => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatSteamDurationMS),
            "k_EFrameStatServerDurationMS" => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatServerDurationMS),
            "k_EFrameStatNetworkDurationMS" => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatNetworkDurationMS),
            "k_EFrameStatDecodeDurationMS" => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatDecodeDurationMS),
            "k_EFrameStatDisplayDurationMS" => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatDisplayDurationMS),
            "k_EFrameStatClientDurationMS" => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatClientDurationMS),
            "k_EFrameStatFrameDurationMS" => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatFrameDurationMS),
            "k_EFrameStatInputLatencyMS" => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatInputLatencyMS),
            "k_EFrameStatGameLatencyMS" => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatGameLatencyMS),
            "k_EFrameStatRoundTripLatencyMS" => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatRoundTripLatencyMS),
            "k_EFrameStatPingTimeMS" => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatPingTimeMS),
            "k_EFrameStatServerBitrateKbitPerSec" => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatServerBitrateKbitPerSec),
            "k_EFrameStatClientBitrateKbitPerSec" => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatClientBitrateKbitPerSec),
            "k_EFrameStatLinkBandwidthKbitPerSec" => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatLinkBandwidthKbitPerSec),
            "k_EFrameStatPacketLossPercentage" => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatPacketLossPercentage),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EFrameAccumulatedStat] = &[
        EFrameAccumulatedStat::k_EFrameStatFPS,
        EFrameAccumulatedStat::k_EFrameStatCaptureDurationMS,
        EFrameAccumulatedStat::k_EFrameStatConvertDurationMS,
        EFrameAccumulatedStat::k_EFrameStatEncodeDurationMS,
        EFrameAccumulatedStat::k_EFrameStatSteamDurationMS,
        EFrameAccumulatedStat::k_EFrameStatServerDurationMS,
        EFrameAccumulatedStat::k_EFrameStatNetworkDurationMS,
        EFrameAccumulatedStat::k_EFrameStatDecodeDurationMS,
        EFrameAccumulatedStat::k_EFrameStatDisplayDurationMS,
        EFrameAccumulatedStat::k_EFrameStatClientDurationMS,
        EFrameAccumulatedStat::k_EFrameStatFrameDurationMS,
        EFrameAccumulatedStat::k_EFrameStatInputLatencyMS,
        EFrameAccumulatedStat::k_EFrameStatGameLatencyMS,
        EFrameAccumulatedStat::k_EFrameStatRoundTripLatencyMS,
        EFrameAccumulatedStat::k_EFrameStatPingTimeMS,
        EFrameAccumulatedStat::k_EFrameStatServerBitrateKbitPerSec,
        EFrameAccumulatedStat::k_EFrameStatClientBitrateKbitPerSec,
        EFrameAccumulatedStat::k_EFrameStatLinkBandwidthKbitPerSec,
        EFrameAccumulatedStat::k_EFrameStatPacketLossPercentage,
    ];
}

impl ::std::default::Default for EFrameAccumulatedStat {
    fn default() -> Self {
        EFrameAccumulatedStat::k_EFrameStatFPS
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ELogFileType)
pub enum ELogFileType {
    // @@protoc_insertion_point(enum_value:ELogFileType.k_ELogFileSystemBoot)
    k_ELogFileSystemBoot = 0,
    // @@protoc_insertion_point(enum_value:ELogFileType.k_ELogFileSystemReset)
    k_ELogFileSystemReset = 1,
    // @@protoc_insertion_point(enum_value:ELogFileType.k_ELogFileSystemDebug)
    k_ELogFileSystemDebug = 2,
}

impl ::protobuf::Enum for ELogFileType {
    const NAME: &'static str = "ELogFileType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ELogFileType> {
        match value {
            0 => ::std::option::Option::Some(ELogFileType::k_ELogFileSystemBoot),
            1 => ::std::option::Option::Some(ELogFileType::k_ELogFileSystemReset),
            2 => ::std::option::Option::Some(ELogFileType::k_ELogFileSystemDebug),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ELogFileType> {
        match str {
            "k_ELogFileSystemBoot" => ::std::option::Option::Some(ELogFileType::k_ELogFileSystemBoot),
            "k_ELogFileSystemReset" => ::std::option::Option::Some(ELogFileType::k_ELogFileSystemReset),
            "k_ELogFileSystemDebug" => ::std::option::Option::Some(ELogFileType::k_ELogFileSystemDebug),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ELogFileType] = &[
        ELogFileType::k_ELogFileSystemBoot,
        ELogFileType::k_ELogFileSystemReset,
        ELogFileType::k_ELogFileSystemDebug,
    ];
}

impl ::std::default::Default for ELogFileType {
    fn default() -> Self {
        ELogFileType::k_ELogFileSystemBoot
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamControllerConfigMsg)
pub enum EStreamControllerConfigMsg {
    // @@protoc_insertion_point(enum_value:EStreamControllerConfigMsg.k_EStreamControllerConfigMsg_RequestConfigsForApp)
    k_EStreamControllerConfigMsg_RequestConfigsForApp = 0,
    // @@protoc_insertion_point(enum_value:EStreamControllerConfigMsg.k_EStreamControllerConfigMsg_ConfigResponse)
    k_EStreamControllerConfigMsg_ConfigResponse = 1,
    // @@protoc_insertion_point(enum_value:EStreamControllerConfigMsg.k_EStreamControllerConfigMsg_PersonalizationResponse)
    k_EStreamControllerConfigMsg_PersonalizationResponse = 2,
    // @@protoc_insertion_point(enum_value:EStreamControllerConfigMsg.k_EStreamControllerConfigMsg_ActiveConfigChange)
    k_EStreamControllerConfigMsg_ActiveConfigChange = 3,
    // @@protoc_insertion_point(enum_value:EStreamControllerConfigMsg.k_EStreamControllerConfigMsg_RequestActiveConfig)
    k_EStreamControllerConfigMsg_RequestActiveConfig = 4,
}

impl ::protobuf::Enum for EStreamControllerConfigMsg {
    const NAME: &'static str = "EStreamControllerConfigMsg";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamControllerConfigMsg> {
        match value {
            0 => ::std::option::Option::Some(EStreamControllerConfigMsg::k_EStreamControllerConfigMsg_RequestConfigsForApp),
            1 => ::std::option::Option::Some(EStreamControllerConfigMsg::k_EStreamControllerConfigMsg_ConfigResponse),
            2 => ::std::option::Option::Some(EStreamControllerConfigMsg::k_EStreamControllerConfigMsg_PersonalizationResponse),
            3 => ::std::option::Option::Some(EStreamControllerConfigMsg::k_EStreamControllerConfigMsg_ActiveConfigChange),
            4 => ::std::option::Option::Some(EStreamControllerConfigMsg::k_EStreamControllerConfigMsg_RequestActiveConfig),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamControllerConfigMsg> {
        match str {
            "k_EStreamControllerConfigMsg_RequestConfigsForApp" => ::std::option::Option::Some(EStreamControllerConfigMsg::k_EStreamControllerConfigMsg_RequestConfigsForApp),
            "k_EStreamControllerConfigMsg_ConfigResponse" => ::std::option::Option::Some(EStreamControllerConfigMsg::k_EStreamControllerConfigMsg_ConfigResponse),
            "k_EStreamControllerConfigMsg_PersonalizationResponse" => ::std::option::Option::Some(EStreamControllerConfigMsg::k_EStreamControllerConfigMsg_PersonalizationResponse),
            "k_EStreamControllerConfigMsg_ActiveConfigChange" => ::std::option::Option::Some(EStreamControllerConfigMsg::k_EStreamControllerConfigMsg_ActiveConfigChange),
            "k_EStreamControllerConfigMsg_RequestActiveConfig" => ::std::option::Option::Some(EStreamControllerConfigMsg::k_EStreamControllerConfigMsg_RequestActiveConfig),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamControllerConfigMsg] = &[
        EStreamControllerConfigMsg::k_EStreamControllerConfigMsg_RequestConfigsForApp,
        EStreamControllerConfigMsg::k_EStreamControllerConfigMsg_ConfigResponse,
        EStreamControllerConfigMsg::k_EStreamControllerConfigMsg_PersonalizationResponse,
        EStreamControllerConfigMsg::k_EStreamControllerConfigMsg_ActiveConfigChange,
        EStreamControllerConfigMsg::k_EStreamControllerConfigMsg_RequestActiveConfig,
    ];
}

impl ::std::default::Default for EStreamControllerConfigMsg {
    fn default() -> Self {
        EStreamControllerConfigMsg::k_EStreamControllerConfigMsg_RequestConfigsForApp
    }
}

impl crate::RpcMessage for CDiscoveryPingRequest {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CDiscoveryPingResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStreamingClientHandshakeInfo {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClientHandshakeMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStreamingServerHandshakeInfo {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CServerHandshakeMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CAuthenticationRequestMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CAuthenticationResponseMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CKeepAliveMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStartNetworkTestMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStreamVideoMode {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStreamingClientCaps {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStreamingClientConfig {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStreamingServerConfig {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CNegotiatedConfig {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CNegotiationInitMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CNegotiationSetConfigMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CNegotiationCompleteMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStartAudioDataMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStopAudioDataMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStartVideoDataMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStopVideoDataMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStartNeptuneDataMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStopNeptuneDataMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CRecordedInput {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CRecordedInputStream {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CInputLatencyTestMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CInputTouchFingerDownMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CInputTouchFingerMotionMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CInputTouchFingerUpMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CInputMouseMotionMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CInputMouseWheelMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CInputMouseDownMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CInputMouseUpMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CInputKeyDownMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CInputKeyUpMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CInputTextMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSetTitleMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSetCaptureSizeMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSetIconMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSetFlashStateMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CShowCursorMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CHideCursorMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSetCursorMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CGetCursorImageMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSetCursorImageMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CVideoDecoderInfoMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CVideoEncoderInfoMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CPauseMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CResumeMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CEnableHighResCaptureMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CDisableHighResCaptureMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CEnableNeptuneDataMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CDisableNeptuneDataMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CPauseControllerInputMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CResumeControllerInputMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CToggleMagnificationMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSetCapslockMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStreamingKeymapEntry {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStreamingKeymap {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSetKeymapMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStopRequest {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CQuitRequest {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CDeleteCursorMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSetStreamingClientConfig {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSetQoSMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSetTargetFramerateMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSetTargetBitrateMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for COverlayEnabledMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSetGammaRampMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSetActivityMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSystemSuspendMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CVirtualHereRequestMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CVirtualHereReadyMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CVirtualHereShareDeviceMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSetSpectatorModeMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CRemoteHIDMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CTouchConfigActiveMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CGetTouchConfigDataMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSetTouchConfigDataMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSaveTouchConfigLayoutMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CTouchActionSetActiveMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CTouchActionSetLayerAddedMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CTouchActionSetLayerRemovedMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CGetTouchIconDataMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSetTouchIconDataMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CRemotePlayTogetherGroupUpdateMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSetInputTemporarilyDisabledMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSetQualityOverrideMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSetBitrateOverrideMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CShowOnScreenKeyboardMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CControllerPersonalizationUpdateMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStreamDataLostMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CAudioFormat {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CVideoFormat {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CFrameEvent {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CFrameStats {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CFrameStatAccumulatedValue {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CFrameStatsListMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CStreamingSessionStats {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CDebugDumpMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CLogMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CLogUploadMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CTransportSignalMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CControllerConfigMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
