// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_steamtv.steamclient.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

#[doc = "Create a channel on SteamTV"]
// @@protoc_insertion_point(message:CSteamTV_CreateBroadcastChannel_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_CreateBroadcastChannel_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_CreateBroadcastChannel_Request.unique_name)
    pub unique_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_CreateBroadcastChannel_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_CreateBroadcastChannel_Request {
    fn default() -> &'a CSteamTV_CreateBroadcastChannel_Request {
        <CSteamTV_CreateBroadcastChannel_Request as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_CreateBroadcastChannel_Request {
    pub fn new() -> CSteamTV_CreateBroadcastChannel_Request {
        ::std::default::Default::default()
    }

    // optional string unique_name = 1;

    pub fn unique_name(&self) -> &str {
        match self.unique_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_unique_name(&mut self) {
        self.unique_name = ::std::option::Option::None;
    }

    pub fn has_unique_name(&self) -> bool {
        self.unique_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unique_name(&mut self, v: ::std::string::String) {
        self.unique_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unique_name(&mut self) -> &mut ::std::string::String {
        if self.unique_name.is_none() {
            self.unique_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.unique_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_unique_name(&mut self) -> ::std::string::String {
        self.unique_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CSteamTV_CreateBroadcastChannel_Request {
    const NAME: &'static str = "CSteamTV_CreateBroadcastChannel_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.unique_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.unique_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.unique_name.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_CreateBroadcastChannel_Request {
        CSteamTV_CreateBroadcastChannel_Request::new()
    }

    fn clear(&mut self) {
        self.unique_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_CreateBroadcastChannel_Request {
        static instance: CSteamTV_CreateBroadcastChannel_Request = CSteamTV_CreateBroadcastChannel_Request {
            unique_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamTV_CreateBroadcastChannel_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_CreateBroadcastChannel_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_CreateBroadcastChannel_Response.broadcast_channel_id)
    pub broadcast_channel_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_CreateBroadcastChannel_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_CreateBroadcastChannel_Response {
    fn default() -> &'a CSteamTV_CreateBroadcastChannel_Response {
        <CSteamTV_CreateBroadcastChannel_Response as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_CreateBroadcastChannel_Response {
    pub fn new() -> CSteamTV_CreateBroadcastChannel_Response {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_channel_id = 1;

    pub fn broadcast_channel_id(&self) -> u64 {
        self.broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_broadcast_channel_id(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_id(&self) -> bool {
        self.broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_id(&mut self, v: u64) {
        self.broadcast_channel_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSteamTV_CreateBroadcastChannel_Response {
    const NAME: &'static str = "CSteamTV_CreateBroadcastChannel_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_channel_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_channel_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast_channel_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_CreateBroadcastChannel_Response {
        CSteamTV_CreateBroadcastChannel_Response::new()
    }

    fn clear(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_CreateBroadcastChannel_Response {
        static instance: CSteamTV_CreateBroadcastChannel_Response = CSteamTV_CreateBroadcastChannel_Response {
            broadcast_channel_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Get a broadcast channel ID for a channel by name or owner SteamID"]
// @@protoc_insertion_point(message:CSteamTV_GetBroadcastChannelID_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetBroadcastChannelID_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelID_Request.unique_name)
    pub unique_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetBroadcastChannelID_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetBroadcastChannelID_Request {
    fn default() -> &'a CSteamTV_GetBroadcastChannelID_Request {
        <CSteamTV_GetBroadcastChannelID_Request as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_GetBroadcastChannelID_Request {
    pub fn new() -> CSteamTV_GetBroadcastChannelID_Request {
        ::std::default::Default::default()
    }

    // optional string unique_name = 1;

    pub fn unique_name(&self) -> &str {
        match self.unique_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_unique_name(&mut self) {
        self.unique_name = ::std::option::Option::None;
    }

    pub fn has_unique_name(&self) -> bool {
        self.unique_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unique_name(&mut self, v: ::std::string::String) {
        self.unique_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unique_name(&mut self) -> &mut ::std::string::String {
        if self.unique_name.is_none() {
            self.unique_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.unique_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_unique_name(&mut self) -> ::std::string::String {
        self.unique_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CSteamTV_GetBroadcastChannelID_Request {
    const NAME: &'static str = "CSteamTV_GetBroadcastChannelID_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.unique_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.unique_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.unique_name.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetBroadcastChannelID_Request {
        CSteamTV_GetBroadcastChannelID_Request::new()
    }

    fn clear(&mut self) {
        self.unique_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetBroadcastChannelID_Request {
        static instance: CSteamTV_GetBroadcastChannelID_Request = CSteamTV_GetBroadcastChannelID_Request {
            unique_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamTV_GetBroadcastChannelID_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetBroadcastChannelID_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelID_Response.broadcast_channel_id)
    pub broadcast_channel_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelID_Response.unique_name)
    pub unique_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelID_Response.steamid)
    pub steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetBroadcastChannelID_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetBroadcastChannelID_Response {
    fn default() -> &'a CSteamTV_GetBroadcastChannelID_Response {
        <CSteamTV_GetBroadcastChannelID_Response as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_GetBroadcastChannelID_Response {
    pub fn new() -> CSteamTV_GetBroadcastChannelID_Response {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_channel_id = 1;

    pub fn broadcast_channel_id(&self) -> u64 {
        self.broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_broadcast_channel_id(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_id(&self) -> bool {
        self.broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_id(&mut self, v: u64) {
        self.broadcast_channel_id = ::std::option::Option::Some(v);
    }

    // optional string unique_name = 2;

    pub fn unique_name(&self) -> &str {
        match self.unique_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_unique_name(&mut self) {
        self.unique_name = ::std::option::Option::None;
    }

    pub fn has_unique_name(&self) -> bool {
        self.unique_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unique_name(&mut self, v: ::std::string::String) {
        self.unique_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unique_name(&mut self) -> &mut ::std::string::String {
        if self.unique_name.is_none() {
            self.unique_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.unique_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_unique_name(&mut self) -> ::std::string::String {
        self.unique_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 steamid = 3;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSteamTV_GetBroadcastChannelID_Response {
    const NAME: &'static str = "CSteamTV_GetBroadcastChannelID_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_channel_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    self.unique_name = ::std::option::Option::Some(is.read_string()?);
                },
                25 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_channel_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.unique_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast_channel_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.unique_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetBroadcastChannelID_Response {
        CSteamTV_GetBroadcastChannelID_Response::new()
    }

    fn clear(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
        self.unique_name = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetBroadcastChannelID_Response {
        static instance: CSteamTV_GetBroadcastChannelID_Response = CSteamTV_GetBroadcastChannelID_Response {
            broadcast_channel_id: ::std::option::Option::None,
            unique_name: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Set broadcast channel profile data"]
// @@protoc_insertion_point(message:CSteamTV_SetBroadcastChannelProfile_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_SetBroadcastChannelProfile_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelProfile_Request.broadcast_channel_id)
    pub broadcast_channel_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelProfile_Request.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelProfile_Request.language)
    pub language: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelProfile_Request.headline)
    pub headline: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelProfile_Request.summary)
    pub summary: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelProfile_Request.avatar_hash)
    pub avatar_hash: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelProfile_Request.schedule)
    pub schedule: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelProfile_Request.rules)
    pub rules: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelProfile_Request.panels)
    pub panels: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_SetBroadcastChannelProfile_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_SetBroadcastChannelProfile_Request {
    fn default() -> &'a CSteamTV_SetBroadcastChannelProfile_Request {
        <CSteamTV_SetBroadcastChannelProfile_Request as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_SetBroadcastChannelProfile_Request {
    pub fn new() -> CSteamTV_SetBroadcastChannelProfile_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_channel_id = 1;

    pub fn broadcast_channel_id(&self) -> u64 {
        self.broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_broadcast_channel_id(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_id(&self) -> bool {
        self.broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_id(&mut self, v: u64) {
        self.broadcast_channel_id = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string language = 3;

    pub fn language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language = ::std::option::Option::Some(::std::string::String::new());
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string headline = 4;

    pub fn headline(&self) -> &str {
        match self.headline.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_headline(&mut self) {
        self.headline = ::std::option::Option::None;
    }

    pub fn has_headline(&self) -> bool {
        self.headline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_headline(&mut self, v: ::std::string::String) {
        self.headline = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_headline(&mut self) -> &mut ::std::string::String {
        if self.headline.is_none() {
            self.headline = ::std::option::Option::Some(::std::string::String::new());
        }
        self.headline.as_mut().unwrap()
    }

    // Take field
    pub fn take_headline(&mut self) -> ::std::string::String {
        self.headline.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string summary = 5;

    pub fn summary(&self) -> &str {
        match self.summary.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_summary(&mut self) {
        self.summary = ::std::option::Option::None;
    }

    pub fn has_summary(&self) -> bool {
        self.summary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_summary(&mut self, v: ::std::string::String) {
        self.summary = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_summary(&mut self) -> &mut ::std::string::String {
        if self.summary.is_none() {
            self.summary = ::std::option::Option::Some(::std::string::String::new());
        }
        self.summary.as_mut().unwrap()
    }

    // Take field
    pub fn take_summary(&mut self) -> ::std::string::String {
        self.summary.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string avatar_hash = 6;

    pub fn avatar_hash(&self) -> &str {
        match self.avatar_hash.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_avatar_hash(&mut self) {
        self.avatar_hash = ::std::option::Option::None;
    }

    pub fn has_avatar_hash(&self) -> bool {
        self.avatar_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avatar_hash(&mut self, v: ::std::string::String) {
        self.avatar_hash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar_hash(&mut self) -> &mut ::std::string::String {
        if self.avatar_hash.is_none() {
            self.avatar_hash = ::std::option::Option::Some(::std::string::String::new());
        }
        self.avatar_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_avatar_hash(&mut self) -> ::std::string::String {
        self.avatar_hash.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string schedule = 7;

    pub fn schedule(&self) -> &str {
        match self.schedule.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_schedule(&mut self) {
        self.schedule = ::std::option::Option::None;
    }

    pub fn has_schedule(&self) -> bool {
        self.schedule.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schedule(&mut self, v: ::std::string::String) {
        self.schedule = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schedule(&mut self) -> &mut ::std::string::String {
        if self.schedule.is_none() {
            self.schedule = ::std::option::Option::Some(::std::string::String::new());
        }
        self.schedule.as_mut().unwrap()
    }

    // Take field
    pub fn take_schedule(&mut self) -> ::std::string::String {
        self.schedule.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string rules = 8;

    pub fn rules(&self) -> &str {
        match self.rules.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_rules(&mut self) {
        self.rules = ::std::option::Option::None;
    }

    pub fn has_rules(&self) -> bool {
        self.rules.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rules(&mut self, v: ::std::string::String) {
        self.rules = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rules(&mut self) -> &mut ::std::string::String {
        if self.rules.is_none() {
            self.rules = ::std::option::Option::Some(::std::string::String::new());
        }
        self.rules.as_mut().unwrap()
    }

    // Take field
    pub fn take_rules(&mut self) -> ::std::string::String {
        self.rules.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string panels = 9;

    pub fn panels(&self) -> &str {
        match self.panels.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_panels(&mut self) {
        self.panels = ::std::option::Option::None;
    }

    pub fn has_panels(&self) -> bool {
        self.panels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_panels(&mut self, v: ::std::string::String) {
        self.panels = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_panels(&mut self) -> &mut ::std::string::String {
        if self.panels.is_none() {
            self.panels = ::std::option::Option::Some(::std::string::String::new());
        }
        self.panels.as_mut().unwrap()
    }

    // Take field
    pub fn take_panels(&mut self) -> ::std::string::String {
        self.panels.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CSteamTV_SetBroadcastChannelProfile_Request {
    const NAME: &'static str = "CSteamTV_SetBroadcastChannelProfile_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_channel_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.language = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.headline = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.summary = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.avatar_hash = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.schedule = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.rules = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.panels = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_channel_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.language.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.headline.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.summary.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.avatar_hash.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.schedule.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.rules.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.panels.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast_channel_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.language.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.headline.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.summary.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.avatar_hash.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.schedule.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.rules.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.panels.as_ref() {
            os.write_string(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_SetBroadcastChannelProfile_Request {
        CSteamTV_SetBroadcastChannelProfile_Request::new()
    }

    fn clear(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.headline = ::std::option::Option::None;
        self.summary = ::std::option::Option::None;
        self.avatar_hash = ::std::option::Option::None;
        self.schedule = ::std::option::Option::None;
        self.rules = ::std::option::Option::None;
        self.panels = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_SetBroadcastChannelProfile_Request {
        static instance: CSteamTV_SetBroadcastChannelProfile_Request = CSteamTV_SetBroadcastChannelProfile_Request {
            broadcast_channel_id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            language: ::std::option::Option::None,
            headline: ::std::option::Option::None,
            summary: ::std::option::Option::None,
            avatar_hash: ::std::option::Option::None,
            schedule: ::std::option::Option::None,
            rules: ::std::option::Option::None,
            panels: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamTV_SetBroadcastChannelProfile_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_SetBroadcastChannelProfile_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_SetBroadcastChannelProfile_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_SetBroadcastChannelProfile_Response {
    fn default() -> &'a CSteamTV_SetBroadcastChannelProfile_Response {
        <CSteamTV_SetBroadcastChannelProfile_Response as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_SetBroadcastChannelProfile_Response {
    pub fn new() -> CSteamTV_SetBroadcastChannelProfile_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CSteamTV_SetBroadcastChannelProfile_Response {
    const NAME: &'static str = "CSteamTV_SetBroadcastChannelProfile_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_SetBroadcastChannelProfile_Response {
        CSteamTV_SetBroadcastChannelProfile_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_SetBroadcastChannelProfile_Response {
        static instance: CSteamTV_SetBroadcastChannelProfile_Response = CSteamTV_SetBroadcastChannelProfile_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Get broadcast channel profile data"]
// @@protoc_insertion_point(message:CSteamTV_GetBroadcastChannelProfile_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetBroadcastChannelProfile_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelProfile_Request.broadcast_channel_id)
    pub broadcast_channel_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetBroadcastChannelProfile_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetBroadcastChannelProfile_Request {
    fn default() -> &'a CSteamTV_GetBroadcastChannelProfile_Request {
        <CSteamTV_GetBroadcastChannelProfile_Request as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_GetBroadcastChannelProfile_Request {
    pub fn new() -> CSteamTV_GetBroadcastChannelProfile_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_channel_id = 1;

    pub fn broadcast_channel_id(&self) -> u64 {
        self.broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_broadcast_channel_id(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_id(&self) -> bool {
        self.broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_id(&mut self, v: u64) {
        self.broadcast_channel_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSteamTV_GetBroadcastChannelProfile_Request {
    const NAME: &'static str = "CSteamTV_GetBroadcastChannelProfile_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_channel_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_channel_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast_channel_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetBroadcastChannelProfile_Request {
        CSteamTV_GetBroadcastChannelProfile_Request::new()
    }

    fn clear(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetBroadcastChannelProfile_Request {
        static instance: CSteamTV_GetBroadcastChannelProfile_Request = CSteamTV_GetBroadcastChannelProfile_Request {
            broadcast_channel_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamTV_GetBroadcastChannelProfile_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetBroadcastChannelProfile_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelProfile_Response.unique_name)
    pub unique_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelProfile_Response.owner_steamid)
    pub owner_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelProfile_Response.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelProfile_Response.language)
    pub language: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelProfile_Response.headline)
    pub headline: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelProfile_Response.summary)
    pub summary: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelProfile_Response.schedule)
    pub schedule: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelProfile_Response.rules)
    pub rules: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelProfile_Response.panels)
    pub panels: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelProfile_Response.is_partnered)
    pub is_partnered: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetBroadcastChannelProfile_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetBroadcastChannelProfile_Response {
    fn default() -> &'a CSteamTV_GetBroadcastChannelProfile_Response {
        <CSteamTV_GetBroadcastChannelProfile_Response as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_GetBroadcastChannelProfile_Response {
    pub fn new() -> CSteamTV_GetBroadcastChannelProfile_Response {
        ::std::default::Default::default()
    }

    // optional string unique_name = 1;

    pub fn unique_name(&self) -> &str {
        match self.unique_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_unique_name(&mut self) {
        self.unique_name = ::std::option::Option::None;
    }

    pub fn has_unique_name(&self) -> bool {
        self.unique_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unique_name(&mut self, v: ::std::string::String) {
        self.unique_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unique_name(&mut self) -> &mut ::std::string::String {
        if self.unique_name.is_none() {
            self.unique_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.unique_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_unique_name(&mut self) -> ::std::string::String {
        self.unique_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 owner_steamid = 2;

    pub fn owner_steamid(&self) -> u64 {
        self.owner_steamid.unwrap_or(0)
    }

    pub fn clear_owner_steamid(&mut self) {
        self.owner_steamid = ::std::option::Option::None;
    }

    pub fn has_owner_steamid(&self) -> bool {
        self.owner_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_steamid(&mut self, v: u64) {
        self.owner_steamid = ::std::option::Option::Some(v);
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string language = 4;

    pub fn language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language = ::std::option::Option::Some(::std::string::String::new());
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string headline = 5;

    pub fn headline(&self) -> &str {
        match self.headline.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_headline(&mut self) {
        self.headline = ::std::option::Option::None;
    }

    pub fn has_headline(&self) -> bool {
        self.headline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_headline(&mut self, v: ::std::string::String) {
        self.headline = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_headline(&mut self) -> &mut ::std::string::String {
        if self.headline.is_none() {
            self.headline = ::std::option::Option::Some(::std::string::String::new());
        }
        self.headline.as_mut().unwrap()
    }

    // Take field
    pub fn take_headline(&mut self) -> ::std::string::String {
        self.headline.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string summary = 6;

    pub fn summary(&self) -> &str {
        match self.summary.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_summary(&mut self) {
        self.summary = ::std::option::Option::None;
    }

    pub fn has_summary(&self) -> bool {
        self.summary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_summary(&mut self, v: ::std::string::String) {
        self.summary = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_summary(&mut self) -> &mut ::std::string::String {
        if self.summary.is_none() {
            self.summary = ::std::option::Option::Some(::std::string::String::new());
        }
        self.summary.as_mut().unwrap()
    }

    // Take field
    pub fn take_summary(&mut self) -> ::std::string::String {
        self.summary.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string schedule = 7;

    pub fn schedule(&self) -> &str {
        match self.schedule.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_schedule(&mut self) {
        self.schedule = ::std::option::Option::None;
    }

    pub fn has_schedule(&self) -> bool {
        self.schedule.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schedule(&mut self, v: ::std::string::String) {
        self.schedule = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schedule(&mut self) -> &mut ::std::string::String {
        if self.schedule.is_none() {
            self.schedule = ::std::option::Option::Some(::std::string::String::new());
        }
        self.schedule.as_mut().unwrap()
    }

    // Take field
    pub fn take_schedule(&mut self) -> ::std::string::String {
        self.schedule.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string rules = 8;

    pub fn rules(&self) -> &str {
        match self.rules.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_rules(&mut self) {
        self.rules = ::std::option::Option::None;
    }

    pub fn has_rules(&self) -> bool {
        self.rules.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rules(&mut self, v: ::std::string::String) {
        self.rules = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rules(&mut self) -> &mut ::std::string::String {
        if self.rules.is_none() {
            self.rules = ::std::option::Option::Some(::std::string::String::new());
        }
        self.rules.as_mut().unwrap()
    }

    // Take field
    pub fn take_rules(&mut self) -> ::std::string::String {
        self.rules.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string panels = 9;

    pub fn panels(&self) -> &str {
        match self.panels.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_panels(&mut self) {
        self.panels = ::std::option::Option::None;
    }

    pub fn has_panels(&self) -> bool {
        self.panels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_panels(&mut self, v: ::std::string::String) {
        self.panels = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_panels(&mut self) -> &mut ::std::string::String {
        if self.panels.is_none() {
            self.panels = ::std::option::Option::Some(::std::string::String::new());
        }
        self.panels.as_mut().unwrap()
    }

    // Take field
    pub fn take_panels(&mut self) -> ::std::string::String {
        self.panels.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_partnered = 10;

    pub fn is_partnered(&self) -> bool {
        self.is_partnered.unwrap_or(false)
    }

    pub fn clear_is_partnered(&mut self) {
        self.is_partnered = ::std::option::Option::None;
    }

    pub fn has_is_partnered(&self) -> bool {
        self.is_partnered.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_partnered(&mut self, v: bool) {
        self.is_partnered = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSteamTV_GetBroadcastChannelProfile_Response {
    const NAME: &'static str = "CSteamTV_GetBroadcastChannelProfile_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.unique_name = ::std::option::Option::Some(is.read_string()?);
                },
                17 => {
                    self.owner_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.language = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.headline = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.summary = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.schedule = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.rules = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.panels = ::std::option::Option::Some(is.read_string()?);
                },
                80 => {
                    self.is_partnered = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.unique_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.owner_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.language.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.headline.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.summary.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.schedule.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.rules.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.panels.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.is_partnered {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.unique_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.owner_steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.language.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.headline.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.summary.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.schedule.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.rules.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.panels.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.is_partnered {
            os.write_bool(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetBroadcastChannelProfile_Response {
        CSteamTV_GetBroadcastChannelProfile_Response::new()
    }

    fn clear(&mut self) {
        self.unique_name = ::std::option::Option::None;
        self.owner_steamid = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.headline = ::std::option::Option::None;
        self.summary = ::std::option::Option::None;
        self.schedule = ::std::option::Option::None;
        self.rules = ::std::option::Option::None;
        self.panels = ::std::option::Option::None;
        self.is_partnered = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetBroadcastChannelProfile_Response {
        static instance: CSteamTV_GetBroadcastChannelProfile_Response = CSteamTV_GetBroadcastChannelProfile_Response {
            unique_name: ::std::option::Option::None,
            owner_steamid: ::std::option::Option::None,
            name: ::std::option::Option::None,
            language: ::std::option::Option::None,
            headline: ::std::option::Option::None,
            summary: ::std::option::Option::None,
            schedule: ::std::option::Option::None,
            rules: ::std::option::Option::None,
            panels: ::std::option::Option::None,
            is_partnered: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Set broadcast channel image hash"]
// @@protoc_insertion_point(message:CSteamTV_SetBroadcastChannelImage_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_SetBroadcastChannelImage_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelImage_Request.broadcast_channel_id)
    pub broadcast_channel_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelImage_Request.image_type)
    pub image_type: ::std::option::Option<::protobuf::EnumOrUnknown<EBroadcastImageType>>,
    // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelImage_Request.image_index)
    pub image_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelImage_Request.image_width)
    pub image_width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelImage_Request.image_height)
    pub image_height: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelImage_Request.file_size)
    pub file_size: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelImage_Request.file_extension)
    pub file_extension: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelImage_Request.file_hash)
    pub file_hash: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelImage_Request.undo)
    pub undo: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_SetBroadcastChannelImage_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_SetBroadcastChannelImage_Request {
    fn default() -> &'a CSteamTV_SetBroadcastChannelImage_Request {
        <CSteamTV_SetBroadcastChannelImage_Request as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_SetBroadcastChannelImage_Request {
    pub fn new() -> CSteamTV_SetBroadcastChannelImage_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_channel_id = 1;

    pub fn broadcast_channel_id(&self) -> u64 {
        self.broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_broadcast_channel_id(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_id(&self) -> bool {
        self.broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_id(&mut self, v: u64) {
        self.broadcast_channel_id = ::std::option::Option::Some(v);
    }

    // optional .EBroadcastImageType image_type = 2;

    pub fn image_type(&self) -> EBroadcastImageType {
        match self.image_type {
            Some(e) => e.enum_value_or(EBroadcastImageType::k_EBroadcastImageType_None),
            None => EBroadcastImageType::k_EBroadcastImageType_None,
        }
    }

    pub fn clear_image_type(&mut self) {
        self.image_type = ::std::option::Option::None;
    }

    pub fn has_image_type(&self) -> bool {
        self.image_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image_type(&mut self, v: EBroadcastImageType) {
        self.image_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 image_index = 3;

    pub fn image_index(&self) -> u32 {
        self.image_index.unwrap_or(0)
    }

    pub fn clear_image_index(&mut self) {
        self.image_index = ::std::option::Option::None;
    }

    pub fn has_image_index(&self) -> bool {
        self.image_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image_index(&mut self, v: u32) {
        self.image_index = ::std::option::Option::Some(v);
    }

    // optional uint32 image_width = 4;

    pub fn image_width(&self) -> u32 {
        self.image_width.unwrap_or(0)
    }

    pub fn clear_image_width(&mut self) {
        self.image_width = ::std::option::Option::None;
    }

    pub fn has_image_width(&self) -> bool {
        self.image_width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image_width(&mut self, v: u32) {
        self.image_width = ::std::option::Option::Some(v);
    }

    // optional uint32 image_height = 5;

    pub fn image_height(&self) -> u32 {
        self.image_height.unwrap_or(0)
    }

    pub fn clear_image_height(&mut self) {
        self.image_height = ::std::option::Option::None;
    }

    pub fn has_image_height(&self) -> bool {
        self.image_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image_height(&mut self, v: u32) {
        self.image_height = ::std::option::Option::Some(v);
    }

    // optional uint32 file_size = 6;

    pub fn file_size(&self) -> u32 {
        self.file_size.unwrap_or(0)
    }

    pub fn clear_file_size(&mut self) {
        self.file_size = ::std::option::Option::None;
    }

    pub fn has_file_size(&self) -> bool {
        self.file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_size(&mut self, v: u32) {
        self.file_size = ::std::option::Option::Some(v);
    }

    // optional string file_extension = 7;

    pub fn file_extension(&self) -> &str {
        match self.file_extension.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_file_extension(&mut self) {
        self.file_extension = ::std::option::Option::None;
    }

    pub fn has_file_extension(&self) -> bool {
        self.file_extension.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_extension(&mut self, v: ::std::string::String) {
        self.file_extension = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_extension(&mut self) -> &mut ::std::string::String {
        if self.file_extension.is_none() {
            self.file_extension = ::std::option::Option::Some(::std::string::String::new());
        }
        self.file_extension.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_extension(&mut self) -> ::std::string::String {
        self.file_extension.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string file_hash = 8;

    pub fn file_hash(&self) -> &str {
        match self.file_hash.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_file_hash(&mut self) {
        self.file_hash = ::std::option::Option::None;
    }

    pub fn has_file_hash(&self) -> bool {
        self.file_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_hash(&mut self, v: ::std::string::String) {
        self.file_hash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_hash(&mut self) -> &mut ::std::string::String {
        if self.file_hash.is_none() {
            self.file_hash = ::std::option::Option::Some(::std::string::String::new());
        }
        self.file_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_hash(&mut self) -> ::std::string::String {
        self.file_hash.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool undo = 9;

    pub fn undo(&self) -> bool {
        self.undo.unwrap_or(false)
    }

    pub fn clear_undo(&mut self) {
        self.undo = ::std::option::Option::None;
    }

    pub fn has_undo(&self) -> bool {
        self.undo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_undo(&mut self, v: bool) {
        self.undo = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSteamTV_SetBroadcastChannelImage_Request {
    const NAME: &'static str = "CSteamTV_SetBroadcastChannelImage_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_channel_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.image_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.image_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.image_width = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.image_height = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.file_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.file_extension = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.file_hash = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.undo = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_channel_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.image_type {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.image_index {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.image_width {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.image_height {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.file_size {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.file_extension.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.file_hash.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.undo {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast_channel_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.image_type {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.image_index {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.image_width {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.image_height {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.file_size {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.file_extension.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.file_hash.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.undo {
            os.write_bool(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_SetBroadcastChannelImage_Request {
        CSteamTV_SetBroadcastChannelImage_Request::new()
    }

    fn clear(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
        self.image_type = ::std::option::Option::None;
        self.image_index = ::std::option::Option::None;
        self.image_width = ::std::option::Option::None;
        self.image_height = ::std::option::Option::None;
        self.file_size = ::std::option::Option::None;
        self.file_extension = ::std::option::Option::None;
        self.file_hash = ::std::option::Option::None;
        self.undo = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_SetBroadcastChannelImage_Request {
        static instance: CSteamTV_SetBroadcastChannelImage_Request = CSteamTV_SetBroadcastChannelImage_Request {
            broadcast_channel_id: ::std::option::Option::None,
            image_type: ::std::option::Option::None,
            image_index: ::std::option::Option::None,
            image_width: ::std::option::Option::None,
            image_height: ::std::option::Option::None,
            file_size: ::std::option::Option::None,
            file_extension: ::std::option::Option::None,
            file_hash: ::std::option::Option::None,
            undo: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamTV_SetBroadcastChannelImage_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_SetBroadcastChannelImage_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelImage_Response.replace_image_hash)
    pub replace_image_hash: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_SetBroadcastChannelImage_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_SetBroadcastChannelImage_Response {
    fn default() -> &'a CSteamTV_SetBroadcastChannelImage_Response {
        <CSteamTV_SetBroadcastChannelImage_Response as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_SetBroadcastChannelImage_Response {
    pub fn new() -> CSteamTV_SetBroadcastChannelImage_Response {
        ::std::default::Default::default()
    }

    // optional string replace_image_hash = 1;

    pub fn replace_image_hash(&self) -> &str {
        match self.replace_image_hash.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_replace_image_hash(&mut self) {
        self.replace_image_hash = ::std::option::Option::None;
    }

    pub fn has_replace_image_hash(&self) -> bool {
        self.replace_image_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replace_image_hash(&mut self, v: ::std::string::String) {
        self.replace_image_hash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_replace_image_hash(&mut self) -> &mut ::std::string::String {
        if self.replace_image_hash.is_none() {
            self.replace_image_hash = ::std::option::Option::Some(::std::string::String::new());
        }
        self.replace_image_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_replace_image_hash(&mut self) -> ::std::string::String {
        self.replace_image_hash.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CSteamTV_SetBroadcastChannelImage_Response {
    const NAME: &'static str = "CSteamTV_SetBroadcastChannelImage_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.replace_image_hash = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.replace_image_hash.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.replace_image_hash.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_SetBroadcastChannelImage_Response {
        CSteamTV_SetBroadcastChannelImage_Response::new()
    }

    fn clear(&mut self) {
        self.replace_image_hash = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_SetBroadcastChannelImage_Response {
        static instance: CSteamTV_SetBroadcastChannelImage_Response = CSteamTV_SetBroadcastChannelImage_Response {
            replace_image_hash: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Get broadcast channel images"]
// @@protoc_insertion_point(message:CSteamTV_GetBroadcastChannelImages_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetBroadcastChannelImages_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelImages_Request.broadcast_channel_id)
    pub broadcast_channel_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelImages_Request.image_types)
    pub image_types: ::std::vec::Vec<::protobuf::EnumOrUnknown<EBroadcastImageType>>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetBroadcastChannelImages_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetBroadcastChannelImages_Request {
    fn default() -> &'a CSteamTV_GetBroadcastChannelImages_Request {
        <CSteamTV_GetBroadcastChannelImages_Request as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_GetBroadcastChannelImages_Request {
    pub fn new() -> CSteamTV_GetBroadcastChannelImages_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_channel_id = 1;

    pub fn broadcast_channel_id(&self) -> u64 {
        self.broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_broadcast_channel_id(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_id(&self) -> bool {
        self.broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_id(&mut self, v: u64) {
        self.broadcast_channel_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSteamTV_GetBroadcastChannelImages_Request {
    const NAME: &'static str = "CSteamTV_GetBroadcastChannelImages_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_channel_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.image_types.push(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.image_types)?
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_channel_id {
            my_size += 1 + 8;
        }
        for value in &self.image_types {
            my_size += ::protobuf::rt::int32_size(2, value.value());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast_channel_id {
            os.write_fixed64(1, v)?;
        }
        for v in &self.image_types {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(v))?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetBroadcastChannelImages_Request {
        CSteamTV_GetBroadcastChannelImages_Request::new()
    }

    fn clear(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
        self.image_types.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetBroadcastChannelImages_Request {
        static instance: CSteamTV_GetBroadcastChannelImages_Request = CSteamTV_GetBroadcastChannelImages_Request {
            broadcast_channel_id: ::std::option::Option::None,
            image_types: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamTV_GetBroadcastChannelImages_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetBroadcastChannelImages_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelImages_Response.images)
    pub images: ::std::vec::Vec<csteam_tv_get_broadcast_channel_images_response::Images>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetBroadcastChannelImages_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetBroadcastChannelImages_Response {
    fn default() -> &'a CSteamTV_GetBroadcastChannelImages_Response {
        <CSteamTV_GetBroadcastChannelImages_Response as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_GetBroadcastChannelImages_Response {
    pub fn new() -> CSteamTV_GetBroadcastChannelImages_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CSteamTV_GetBroadcastChannelImages_Response {
    const NAME: &'static str = "CSteamTV_GetBroadcastChannelImages_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.images.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.images {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.images {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetBroadcastChannelImages_Response {
        CSteamTV_GetBroadcastChannelImages_Response::new()
    }

    fn clear(&mut self) {
        self.images.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetBroadcastChannelImages_Response {
        static instance: CSteamTV_GetBroadcastChannelImages_Response = CSteamTV_GetBroadcastChannelImages_Response {
            images: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CSteamTV_GetBroadcastChannelImages_Response`
pub mod csteam_tv_get_broadcast_channel_images_response {
    // @@protoc_insertion_point(message:CSteamTV_GetBroadcastChannelImages_Response.Images)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Images {
        // message fields
        // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelImages_Response.Images.image_type)
        pub image_type: ::std::option::Option<::protobuf::EnumOrUnknown<super::EBroadcastImageType>>,
        // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelImages_Response.Images.image_path)
        pub image_path: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelImages_Response.Images.image_index)
        pub image_index: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CSteamTV_GetBroadcastChannelImages_Response.Images.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Images {
        fn default() -> &'a Images {
            <Images as ::protobuf::Message>::default_instance()
        }
    }

    impl Images {
        pub fn new() -> Images {
            ::std::default::Default::default()
        }

        // optional .EBroadcastImageType image_type = 1;

        pub fn image_type(&self) -> super::EBroadcastImageType {
            match self.image_type {
                Some(e) => e.enum_value_or(super::EBroadcastImageType::k_EBroadcastImageType_None),
                None => super::EBroadcastImageType::k_EBroadcastImageType_None,
            }
        }

        pub fn clear_image_type(&mut self) {
            self.image_type = ::std::option::Option::None;
        }

        pub fn has_image_type(&self) -> bool {
            self.image_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_image_type(&mut self, v: super::EBroadcastImageType) {
            self.image_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional string image_path = 2;

        pub fn image_path(&self) -> &str {
            match self.image_path.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_image_path(&mut self) {
            self.image_path = ::std::option::Option::None;
        }

        pub fn has_image_path(&self) -> bool {
            self.image_path.is_some()
        }

        // Param is passed by value, moved
        pub fn set_image_path(&mut self, v: ::std::string::String) {
            self.image_path = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_image_path(&mut self) -> &mut ::std::string::String {
            if self.image_path.is_none() {
                self.image_path = ::std::option::Option::Some(::std::string::String::new());
            }
            self.image_path.as_mut().unwrap()
        }

        // Take field
        pub fn take_image_path(&mut self) -> ::std::string::String {
            self.image_path.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 image_index = 3;

        pub fn image_index(&self) -> u32 {
            self.image_index.unwrap_or(0)
        }

        pub fn clear_image_index(&mut self) {
            self.image_index = ::std::option::Option::None;
        }

        pub fn has_image_index(&self) -> bool {
            self.image_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_image_index(&mut self, v: u32) {
            self.image_index = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Images {
        const NAME: &'static str = "Images";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.image_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    18 => {
                        self.image_path = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.image_index = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.image_type {
                my_size += ::protobuf::rt::int32_size(1, v.value());
            }
            if let Some(v) = self.image_path.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.image_index {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.image_type {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.image_path.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.image_index {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Images {
            Images::new()
        }

        fn clear(&mut self) {
            self.image_type = ::std::option::Option::None;
            self.image_path = ::std::option::Option::None;
            self.image_index = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Images {
            static instance: Images = Images {
                image_type: ::std::option::Option::None,
                image_path: ::std::option::Option::None,
                image_index: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

#[doc = "Set broadcast channel link regions"]
// @@protoc_insertion_point(message:CSteamTV_SetBroadcastChannelLinkRegions_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_SetBroadcastChannelLinkRegions_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelLinkRegions_Request.broadcast_channel_id)
    pub broadcast_channel_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelLinkRegions_Request.links)
    pub links: ::std::vec::Vec<csteam_tv_set_broadcast_channel_link_regions_request::Links>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_SetBroadcastChannelLinkRegions_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_SetBroadcastChannelLinkRegions_Request {
    fn default() -> &'a CSteamTV_SetBroadcastChannelLinkRegions_Request {
        <CSteamTV_SetBroadcastChannelLinkRegions_Request as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_SetBroadcastChannelLinkRegions_Request {
    pub fn new() -> CSteamTV_SetBroadcastChannelLinkRegions_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_channel_id = 1;

    pub fn broadcast_channel_id(&self) -> u64 {
        self.broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_broadcast_channel_id(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_id(&self) -> bool {
        self.broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_id(&mut self, v: u64) {
        self.broadcast_channel_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSteamTV_SetBroadcastChannelLinkRegions_Request {
    const NAME: &'static str = "CSteamTV_SetBroadcastChannelLinkRegions_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_channel_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    self.links.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_channel_id {
            my_size += 1 + 8;
        }
        for value in &self.links {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast_channel_id {
            os.write_fixed64(1, v)?;
        }
        for v in &self.links {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_SetBroadcastChannelLinkRegions_Request {
        CSteamTV_SetBroadcastChannelLinkRegions_Request::new()
    }

    fn clear(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
        self.links.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_SetBroadcastChannelLinkRegions_Request {
        static instance: CSteamTV_SetBroadcastChannelLinkRegions_Request = CSteamTV_SetBroadcastChannelLinkRegions_Request {
            broadcast_channel_id: ::std::option::Option::None,
            links: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CSteamTV_SetBroadcastChannelLinkRegions_Request`
pub mod csteam_tv_set_broadcast_channel_link_regions_request {
    // @@protoc_insertion_point(message:CSteamTV_SetBroadcastChannelLinkRegions_Request.Links)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Links {
        // message fields
        // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelLinkRegions_Request.Links.link_index)
        pub link_index: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelLinkRegions_Request.Links.url)
        pub url: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelLinkRegions_Request.Links.link_description)
        pub link_description: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelLinkRegions_Request.Links.left)
        pub left: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelLinkRegions_Request.Links.top)
        pub top: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelLinkRegions_Request.Links.width)
        pub width: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelLinkRegions_Request.Links.height)
        pub height: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CSteamTV_SetBroadcastChannelLinkRegions_Request.Links.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Links {
        fn default() -> &'a Links {
            <Links as ::protobuf::Message>::default_instance()
        }
    }

    impl Links {
        pub fn new() -> Links {
            ::std::default::Default::default()
        }

        // optional uint32 link_index = 1;

        pub fn link_index(&self) -> u32 {
            self.link_index.unwrap_or(0)
        }

        pub fn clear_link_index(&mut self) {
            self.link_index = ::std::option::Option::None;
        }

        pub fn has_link_index(&self) -> bool {
            self.link_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_link_index(&mut self, v: u32) {
            self.link_index = ::std::option::Option::Some(v);
        }

        // optional string url = 2;

        pub fn url(&self) -> &str {
            match self.url.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_url(&mut self) {
            self.url = ::std::option::Option::None;
        }

        pub fn has_url(&self) -> bool {
            self.url.is_some()
        }

        // Param is passed by value, moved
        pub fn set_url(&mut self, v: ::std::string::String) {
            self.url = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_url(&mut self) -> &mut ::std::string::String {
            if self.url.is_none() {
                self.url = ::std::option::Option::Some(::std::string::String::new());
            }
            self.url.as_mut().unwrap()
        }

        // Take field
        pub fn take_url(&mut self) -> ::std::string::String {
            self.url.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string link_description = 3;

        pub fn link_description(&self) -> &str {
            match self.link_description.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_link_description(&mut self) {
            self.link_description = ::std::option::Option::None;
        }

        pub fn has_link_description(&self) -> bool {
            self.link_description.is_some()
        }

        // Param is passed by value, moved
        pub fn set_link_description(&mut self, v: ::std::string::String) {
            self.link_description = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_link_description(&mut self) -> &mut ::std::string::String {
            if self.link_description.is_none() {
                self.link_description = ::std::option::Option::Some(::std::string::String::new());
            }
            self.link_description.as_mut().unwrap()
        }

        // Take field
        pub fn take_link_description(&mut self) -> ::std::string::String {
            self.link_description.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 left = 4;

        pub fn left(&self) -> u32 {
            self.left.unwrap_or(0)
        }

        pub fn clear_left(&mut self) {
            self.left = ::std::option::Option::None;
        }

        pub fn has_left(&self) -> bool {
            self.left.is_some()
        }

        // Param is passed by value, moved
        pub fn set_left(&mut self, v: u32) {
            self.left = ::std::option::Option::Some(v);
        }

        // optional uint32 top = 5;

        pub fn top(&self) -> u32 {
            self.top.unwrap_or(0)
        }

        pub fn clear_top(&mut self) {
            self.top = ::std::option::Option::None;
        }

        pub fn has_top(&self) -> bool {
            self.top.is_some()
        }

        // Param is passed by value, moved
        pub fn set_top(&mut self, v: u32) {
            self.top = ::std::option::Option::Some(v);
        }

        // optional uint32 width = 6;

        pub fn width(&self) -> u32 {
            self.width.unwrap_or(0)
        }

        pub fn clear_width(&mut self) {
            self.width = ::std::option::Option::None;
        }

        pub fn has_width(&self) -> bool {
            self.width.is_some()
        }

        // Param is passed by value, moved
        pub fn set_width(&mut self, v: u32) {
            self.width = ::std::option::Option::Some(v);
        }

        // optional uint32 height = 7;

        pub fn height(&self) -> u32 {
            self.height.unwrap_or(0)
        }

        pub fn clear_height(&mut self) {
            self.height = ::std::option::Option::None;
        }

        pub fn has_height(&self) -> bool {
            self.height.is_some()
        }

        // Param is passed by value, moved
        pub fn set_height(&mut self, v: u32) {
            self.height = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Links {
        const NAME: &'static str = "Links";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.link_index = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.url = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.link_description = ::std::option::Option::Some(is.read_string()?);
                    },
                    32 => {
                        self.left = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.top = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.width = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.height = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.link_index {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.url.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.link_description.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.left {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.top {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.width {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.height {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.link_index {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.url.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.link_description.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.left {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.top {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.width {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.height {
                os.write_uint32(7, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Links {
            Links::new()
        }

        fn clear(&mut self) {
            self.link_index = ::std::option::Option::None;
            self.url = ::std::option::Option::None;
            self.link_description = ::std::option::Option::None;
            self.left = ::std::option::Option::None;
            self.top = ::std::option::Option::None;
            self.width = ::std::option::Option::None;
            self.height = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Links {
            static instance: Links = Links {
                link_index: ::std::option::Option::None,
                url: ::std::option::Option::None,
                link_description: ::std::option::Option::None,
                left: ::std::option::Option::None,
                top: ::std::option::Option::None,
                width: ::std::option::Option::None,
                height: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CSteamTV_SetBroadcastChannelLinkRegions_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_SetBroadcastChannelLinkRegions_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_SetBroadcastChannelLinkRegions_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_SetBroadcastChannelLinkRegions_Response {
    fn default() -> &'a CSteamTV_SetBroadcastChannelLinkRegions_Response {
        <CSteamTV_SetBroadcastChannelLinkRegions_Response as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_SetBroadcastChannelLinkRegions_Response {
    pub fn new() -> CSteamTV_SetBroadcastChannelLinkRegions_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CSteamTV_SetBroadcastChannelLinkRegions_Response {
    const NAME: &'static str = "CSteamTV_SetBroadcastChannelLinkRegions_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_SetBroadcastChannelLinkRegions_Response {
        CSteamTV_SetBroadcastChannelLinkRegions_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_SetBroadcastChannelLinkRegions_Response {
        static instance: CSteamTV_SetBroadcastChannelLinkRegions_Response = CSteamTV_SetBroadcastChannelLinkRegions_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Get broadcast channel link regions"]
// @@protoc_insertion_point(message:CSteamTV_GetBroadcastChannelLinks_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetBroadcastChannelLinks_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelLinks_Request.broadcast_channel_id)
    pub broadcast_channel_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetBroadcastChannelLinks_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetBroadcastChannelLinks_Request {
    fn default() -> &'a CSteamTV_GetBroadcastChannelLinks_Request {
        <CSteamTV_GetBroadcastChannelLinks_Request as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_GetBroadcastChannelLinks_Request {
    pub fn new() -> CSteamTV_GetBroadcastChannelLinks_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_channel_id = 1;

    pub fn broadcast_channel_id(&self) -> u64 {
        self.broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_broadcast_channel_id(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_id(&self) -> bool {
        self.broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_id(&mut self, v: u64) {
        self.broadcast_channel_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSteamTV_GetBroadcastChannelLinks_Request {
    const NAME: &'static str = "CSteamTV_GetBroadcastChannelLinks_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_channel_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_channel_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast_channel_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetBroadcastChannelLinks_Request {
        CSteamTV_GetBroadcastChannelLinks_Request::new()
    }

    fn clear(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetBroadcastChannelLinks_Request {
        static instance: CSteamTV_GetBroadcastChannelLinks_Request = CSteamTV_GetBroadcastChannelLinks_Request {
            broadcast_channel_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamTV_GetBroadcastChannelLinks_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetBroadcastChannelLinks_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelLinks_Response.links)
    pub links: ::std::vec::Vec<csteam_tv_get_broadcast_channel_links_response::Links>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetBroadcastChannelLinks_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetBroadcastChannelLinks_Response {
    fn default() -> &'a CSteamTV_GetBroadcastChannelLinks_Response {
        <CSteamTV_GetBroadcastChannelLinks_Response as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_GetBroadcastChannelLinks_Response {
    pub fn new() -> CSteamTV_GetBroadcastChannelLinks_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CSteamTV_GetBroadcastChannelLinks_Response {
    const NAME: &'static str = "CSteamTV_GetBroadcastChannelLinks_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.links.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.links {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.links {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetBroadcastChannelLinks_Response {
        CSteamTV_GetBroadcastChannelLinks_Response::new()
    }

    fn clear(&mut self) {
        self.links.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetBroadcastChannelLinks_Response {
        static instance: CSteamTV_GetBroadcastChannelLinks_Response = CSteamTV_GetBroadcastChannelLinks_Response {
            links: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CSteamTV_GetBroadcastChannelLinks_Response`
pub mod csteam_tv_get_broadcast_channel_links_response {
    // @@protoc_insertion_point(message:CSteamTV_GetBroadcastChannelLinks_Response.Links)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Links {
        // message fields
        // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelLinks_Response.Links.link_index)
        pub link_index: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelLinks_Response.Links.url)
        pub url: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelLinks_Response.Links.link_description)
        pub link_description: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelLinks_Response.Links.left)
        pub left: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelLinks_Response.Links.top)
        pub top: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelLinks_Response.Links.width)
        pub width: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelLinks_Response.Links.height)
        pub height: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CSteamTV_GetBroadcastChannelLinks_Response.Links.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Links {
        fn default() -> &'a Links {
            <Links as ::protobuf::Message>::default_instance()
        }
    }

    impl Links {
        pub fn new() -> Links {
            ::std::default::Default::default()
        }

        // optional uint32 link_index = 1;

        pub fn link_index(&self) -> u32 {
            self.link_index.unwrap_or(0)
        }

        pub fn clear_link_index(&mut self) {
            self.link_index = ::std::option::Option::None;
        }

        pub fn has_link_index(&self) -> bool {
            self.link_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_link_index(&mut self, v: u32) {
            self.link_index = ::std::option::Option::Some(v);
        }

        // optional string url = 2;

        pub fn url(&self) -> &str {
            match self.url.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_url(&mut self) {
            self.url = ::std::option::Option::None;
        }

        pub fn has_url(&self) -> bool {
            self.url.is_some()
        }

        // Param is passed by value, moved
        pub fn set_url(&mut self, v: ::std::string::String) {
            self.url = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_url(&mut self) -> &mut ::std::string::String {
            if self.url.is_none() {
                self.url = ::std::option::Option::Some(::std::string::String::new());
            }
            self.url.as_mut().unwrap()
        }

        // Take field
        pub fn take_url(&mut self) -> ::std::string::String {
            self.url.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string link_description = 3;

        pub fn link_description(&self) -> &str {
            match self.link_description.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_link_description(&mut self) {
            self.link_description = ::std::option::Option::None;
        }

        pub fn has_link_description(&self) -> bool {
            self.link_description.is_some()
        }

        // Param is passed by value, moved
        pub fn set_link_description(&mut self, v: ::std::string::String) {
            self.link_description = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_link_description(&mut self) -> &mut ::std::string::String {
            if self.link_description.is_none() {
                self.link_description = ::std::option::Option::Some(::std::string::String::new());
            }
            self.link_description.as_mut().unwrap()
        }

        // Take field
        pub fn take_link_description(&mut self) -> ::std::string::String {
            self.link_description.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 left = 4;

        pub fn left(&self) -> u32 {
            self.left.unwrap_or(0)
        }

        pub fn clear_left(&mut self) {
            self.left = ::std::option::Option::None;
        }

        pub fn has_left(&self) -> bool {
            self.left.is_some()
        }

        // Param is passed by value, moved
        pub fn set_left(&mut self, v: u32) {
            self.left = ::std::option::Option::Some(v);
        }

        // optional uint32 top = 5;

        pub fn top(&self) -> u32 {
            self.top.unwrap_or(0)
        }

        pub fn clear_top(&mut self) {
            self.top = ::std::option::Option::None;
        }

        pub fn has_top(&self) -> bool {
            self.top.is_some()
        }

        // Param is passed by value, moved
        pub fn set_top(&mut self, v: u32) {
            self.top = ::std::option::Option::Some(v);
        }

        // optional uint32 width = 6;

        pub fn width(&self) -> u32 {
            self.width.unwrap_or(0)
        }

        pub fn clear_width(&mut self) {
            self.width = ::std::option::Option::None;
        }

        pub fn has_width(&self) -> bool {
            self.width.is_some()
        }

        // Param is passed by value, moved
        pub fn set_width(&mut self, v: u32) {
            self.width = ::std::option::Option::Some(v);
        }

        // optional uint32 height = 7;

        pub fn height(&self) -> u32 {
            self.height.unwrap_or(0)
        }

        pub fn clear_height(&mut self) {
            self.height = ::std::option::Option::None;
        }

        pub fn has_height(&self) -> bool {
            self.height.is_some()
        }

        // Param is passed by value, moved
        pub fn set_height(&mut self, v: u32) {
            self.height = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Links {
        const NAME: &'static str = "Links";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.link_index = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.url = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.link_description = ::std::option::Option::Some(is.read_string()?);
                    },
                    32 => {
                        self.left = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.top = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.width = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.height = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.link_index {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.url.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.link_description.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.left {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.top {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.width {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.height {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.link_index {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.url.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.link_description.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.left {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.top {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.width {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.height {
                os.write_uint32(7, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Links {
            Links::new()
        }

        fn clear(&mut self) {
            self.link_index = ::std::option::Option::None;
            self.url = ::std::option::Option::None;
            self.link_description = ::std::option::Option::None;
            self.left = ::std::option::Option::None;
            self.top = ::std::option::Option::None;
            self.width = ::std::option::Option::None;
            self.height = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Links {
            static instance: Links = Links {
                link_index: ::std::option::Option::None,
                url: ::std::option::Option::None,
                link_description: ::std::option::Option::None,
                left: ::std::option::Option::None,
                top: ::std::option::Option::None,
                width: ::std::option::Option::None,
                height: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

#[doc = "Get list of broadcaster info for this channel"]
// @@protoc_insertion_point(message:CSteamTV_GetBroadcastChannelBroadcasters_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetBroadcastChannelBroadcasters_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelBroadcasters_Request.broadcast_channel_id)
    pub broadcast_channel_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetBroadcastChannelBroadcasters_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetBroadcastChannelBroadcasters_Request {
    fn default() -> &'a CSteamTV_GetBroadcastChannelBroadcasters_Request {
        <CSteamTV_GetBroadcastChannelBroadcasters_Request as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_GetBroadcastChannelBroadcasters_Request {
    pub fn new() -> CSteamTV_GetBroadcastChannelBroadcasters_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_channel_id = 1;

    pub fn broadcast_channel_id(&self) -> u64 {
        self.broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_broadcast_channel_id(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_id(&self) -> bool {
        self.broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_id(&mut self, v: u64) {
        self.broadcast_channel_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSteamTV_GetBroadcastChannelBroadcasters_Request {
    const NAME: &'static str = "CSteamTV_GetBroadcastChannelBroadcasters_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_channel_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_channel_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast_channel_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetBroadcastChannelBroadcasters_Request {
        CSteamTV_GetBroadcastChannelBroadcasters_Request::new()
    }

    fn clear(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetBroadcastChannelBroadcasters_Request {
        static instance: CSteamTV_GetBroadcastChannelBroadcasters_Request = CSteamTV_GetBroadcastChannelBroadcasters_Request {
            broadcast_channel_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamTV_GetBroadcastChannelBroadcasters_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetBroadcastChannelBroadcasters_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelBroadcasters_Response.broadcasters)
    pub broadcasters: ::std::vec::Vec<csteam_tv_get_broadcast_channel_broadcasters_response::Broadcaster>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetBroadcastChannelBroadcasters_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetBroadcastChannelBroadcasters_Response {
    fn default() -> &'a CSteamTV_GetBroadcastChannelBroadcasters_Response {
        <CSteamTV_GetBroadcastChannelBroadcasters_Response as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_GetBroadcastChannelBroadcasters_Response {
    pub fn new() -> CSteamTV_GetBroadcastChannelBroadcasters_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CSteamTV_GetBroadcastChannelBroadcasters_Response {
    const NAME: &'static str = "CSteamTV_GetBroadcastChannelBroadcasters_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.broadcasters.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.broadcasters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.broadcasters {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetBroadcastChannelBroadcasters_Response {
        CSteamTV_GetBroadcastChannelBroadcasters_Response::new()
    }

    fn clear(&mut self) {
        self.broadcasters.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetBroadcastChannelBroadcasters_Response {
        static instance: CSteamTV_GetBroadcastChannelBroadcasters_Response = CSteamTV_GetBroadcastChannelBroadcasters_Response {
            broadcasters: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CSteamTV_GetBroadcastChannelBroadcasters_Response`
pub mod csteam_tv_get_broadcast_channel_broadcasters_response {
    // @@protoc_insertion_point(message:CSteamTV_GetBroadcastChannelBroadcasters_Response.Broadcaster)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Broadcaster {
        // message fields
        // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelBroadcasters_Response.Broadcaster.steamid)
        pub steamid: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelBroadcasters_Response.Broadcaster.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelBroadcasters_Response.Broadcaster.rtmp_token)
        pub rtmp_token: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CSteamTV_GetBroadcastChannelBroadcasters_Response.Broadcaster.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Broadcaster {
        fn default() -> &'a Broadcaster {
            <Broadcaster as ::protobuf::Message>::default_instance()
        }
    }

    impl Broadcaster {
        pub fn new() -> Broadcaster {
            ::std::default::Default::default()
        }

        // optional fixed64 steamid = 1;

        pub fn steamid(&self) -> u64 {
            self.steamid.unwrap_or(0)
        }

        pub fn clear_steamid(&mut self) {
            self.steamid = ::std::option::Option::None;
        }

        pub fn has_steamid(&self) -> bool {
            self.steamid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steamid(&mut self, v: u64) {
            self.steamid = ::std::option::Option::Some(v);
        }

        // optional string name = 2;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string rtmp_token = 3;

        pub fn rtmp_token(&self) -> &str {
            match self.rtmp_token.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_rtmp_token(&mut self) {
            self.rtmp_token = ::std::option::Option::None;
        }

        pub fn has_rtmp_token(&self) -> bool {
            self.rtmp_token.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rtmp_token(&mut self, v: ::std::string::String) {
            self.rtmp_token = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_rtmp_token(&mut self) -> &mut ::std::string::String {
            if self.rtmp_token.is_none() {
                self.rtmp_token = ::std::option::Option::Some(::std::string::String::new());
            }
            self.rtmp_token.as_mut().unwrap()
        }

        // Take field
        pub fn take_rtmp_token(&mut self) -> ::std::string::String {
            self.rtmp_token.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::protobuf::Message for Broadcaster {
        const NAME: &'static str = "Broadcaster";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    18 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.rtmp_token = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steamid {
                my_size += 1 + 8;
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.rtmp_token.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.steamid {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.rtmp_token.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Broadcaster {
            Broadcaster::new()
        }

        fn clear(&mut self) {
            self.steamid = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.rtmp_token = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Broadcaster {
            static instance: Broadcaster = Broadcaster {
                steamid: ::std::option::Option::None,
                name: ::std::option::Option::None,
                rtmp_token: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

#[doc = "Get list of followed channels by a viewer"]
// @@protoc_insertion_point(message:CSteamTV_GetFollowedChannels_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetFollowedChannels_Request {
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetFollowedChannels_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetFollowedChannels_Request {
    fn default() -> &'a CSteamTV_GetFollowedChannels_Request {
        <CSteamTV_GetFollowedChannels_Request as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_GetFollowedChannels_Request {
    pub fn new() -> CSteamTV_GetFollowedChannels_Request {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CSteamTV_GetFollowedChannels_Request {
    const NAME: &'static str = "CSteamTV_GetFollowedChannels_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetFollowedChannels_Request {
        CSteamTV_GetFollowedChannels_Request::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetFollowedChannels_Request {
        static instance: CSteamTV_GetFollowedChannels_Request = CSteamTV_GetFollowedChannels_Request {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:GetBroadcastChannelEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetBroadcastChannelEntry {
    // message fields
    // @@protoc_insertion_point(field:GetBroadcastChannelEntry.broadcast_channel_id)
    pub broadcast_channel_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:GetBroadcastChannelEntry.unique_name)
    pub unique_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:GetBroadcastChannelEntry.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:GetBroadcastChannelEntry.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:GetBroadcastChannelEntry.viewers)
    pub viewers: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:GetBroadcastChannelEntry.views)
    pub views: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:GetBroadcastChannelEntry.thumbnail_url)
    pub thumbnail_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:GetBroadcastChannelEntry.followers)
    pub followers: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:GetBroadcastChannelEntry.headline)
    pub headline: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:GetBroadcastChannelEntry.avatar_url)
    pub avatar_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:GetBroadcastChannelEntry.broadcaster_steamid)
    pub broadcaster_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:GetBroadcastChannelEntry.subscribers)
    pub subscribers: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:GetBroadcastChannelEntry.background_url)
    pub background_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:GetBroadcastChannelEntry.is_featured)
    pub is_featured: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:GetBroadcastChannelEntry.is_disabled)
    pub is_disabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:GetBroadcastChannelEntry.is_live)
    pub is_live: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:GetBroadcastChannelEntry.language)
    pub language: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:GetBroadcastChannelEntry.reports)
    pub reports: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:GetBroadcastChannelEntry.is_partnered)
    pub is_partnered: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:GetBroadcastChannelEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetBroadcastChannelEntry {
    fn default() -> &'a GetBroadcastChannelEntry {
        <GetBroadcastChannelEntry as ::protobuf::Message>::default_instance()
    }
}

impl GetBroadcastChannelEntry {
    pub fn new() -> GetBroadcastChannelEntry {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_channel_id = 1;

    pub fn broadcast_channel_id(&self) -> u64 {
        self.broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_broadcast_channel_id(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_id(&self) -> bool {
        self.broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_id(&mut self, v: u64) {
        self.broadcast_channel_id = ::std::option::Option::Some(v);
    }

    // optional string unique_name = 2;

    pub fn unique_name(&self) -> &str {
        match self.unique_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_unique_name(&mut self) {
        self.unique_name = ::std::option::Option::None;
    }

    pub fn has_unique_name(&self) -> bool {
        self.unique_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unique_name(&mut self, v: ::std::string::String) {
        self.unique_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unique_name(&mut self) -> &mut ::std::string::String {
        if self.unique_name.is_none() {
            self.unique_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.unique_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_unique_name(&mut self) -> ::std::string::String {
        self.unique_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 appid = 4;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint64 viewers = 5;

    pub fn viewers(&self) -> u64 {
        self.viewers.unwrap_or(0)
    }

    pub fn clear_viewers(&mut self) {
        self.viewers = ::std::option::Option::None;
    }

    pub fn has_viewers(&self) -> bool {
        self.viewers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_viewers(&mut self, v: u64) {
        self.viewers = ::std::option::Option::Some(v);
    }

    // optional uint64 views = 6;

    pub fn views(&self) -> u64 {
        self.views.unwrap_or(0)
    }

    pub fn clear_views(&mut self) {
        self.views = ::std::option::Option::None;
    }

    pub fn has_views(&self) -> bool {
        self.views.is_some()
    }

    // Param is passed by value, moved
    pub fn set_views(&mut self, v: u64) {
        self.views = ::std::option::Option::Some(v);
    }

    // optional string thumbnail_url = 7;

    pub fn thumbnail_url(&self) -> &str {
        match self.thumbnail_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_thumbnail_url(&mut self) {
        self.thumbnail_url = ::std::option::Option::None;
    }

    pub fn has_thumbnail_url(&self) -> bool {
        self.thumbnail_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnail_url(&mut self, v: ::std::string::String) {
        self.thumbnail_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnail_url(&mut self) -> &mut ::std::string::String {
        if self.thumbnail_url.is_none() {
            self.thumbnail_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.thumbnail_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnail_url(&mut self) -> ::std::string::String {
        self.thumbnail_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 followers = 8;

    pub fn followers(&self) -> u64 {
        self.followers.unwrap_or(0)
    }

    pub fn clear_followers(&mut self) {
        self.followers = ::std::option::Option::None;
    }

    pub fn has_followers(&self) -> bool {
        self.followers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_followers(&mut self, v: u64) {
        self.followers = ::std::option::Option::Some(v);
    }

    // optional string headline = 9;

    pub fn headline(&self) -> &str {
        match self.headline.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_headline(&mut self) {
        self.headline = ::std::option::Option::None;
    }

    pub fn has_headline(&self) -> bool {
        self.headline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_headline(&mut self, v: ::std::string::String) {
        self.headline = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_headline(&mut self) -> &mut ::std::string::String {
        if self.headline.is_none() {
            self.headline = ::std::option::Option::Some(::std::string::String::new());
        }
        self.headline.as_mut().unwrap()
    }

    // Take field
    pub fn take_headline(&mut self) -> ::std::string::String {
        self.headline.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string avatar_url = 10;

    pub fn avatar_url(&self) -> &str {
        match self.avatar_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_avatar_url(&mut self) {
        self.avatar_url = ::std::option::Option::None;
    }

    pub fn has_avatar_url(&self) -> bool {
        self.avatar_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avatar_url(&mut self, v: ::std::string::String) {
        self.avatar_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar_url(&mut self) -> &mut ::std::string::String {
        if self.avatar_url.is_none() {
            self.avatar_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.avatar_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_avatar_url(&mut self) -> ::std::string::String {
        self.avatar_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 broadcaster_steamid = 11;

    pub fn broadcaster_steamid(&self) -> u64 {
        self.broadcaster_steamid.unwrap_or(0)
    }

    pub fn clear_broadcaster_steamid(&mut self) {
        self.broadcaster_steamid = ::std::option::Option::None;
    }

    pub fn has_broadcaster_steamid(&self) -> bool {
        self.broadcaster_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcaster_steamid(&mut self, v: u64) {
        self.broadcaster_steamid = ::std::option::Option::Some(v);
    }

    // optional uint64 subscribers = 12;

    pub fn subscribers(&self) -> u64 {
        self.subscribers.unwrap_or(0)
    }

    pub fn clear_subscribers(&mut self) {
        self.subscribers = ::std::option::Option::None;
    }

    pub fn has_subscribers(&self) -> bool {
        self.subscribers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subscribers(&mut self, v: u64) {
        self.subscribers = ::std::option::Option::Some(v);
    }

    // optional string background_url = 13;

    pub fn background_url(&self) -> &str {
        match self.background_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_background_url(&mut self) {
        self.background_url = ::std::option::Option::None;
    }

    pub fn has_background_url(&self) -> bool {
        self.background_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_background_url(&mut self, v: ::std::string::String) {
        self.background_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_background_url(&mut self) -> &mut ::std::string::String {
        if self.background_url.is_none() {
            self.background_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.background_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_background_url(&mut self) -> ::std::string::String {
        self.background_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_featured = 14;

    pub fn is_featured(&self) -> bool {
        self.is_featured.unwrap_or(false)
    }

    pub fn clear_is_featured(&mut self) {
        self.is_featured = ::std::option::Option::None;
    }

    pub fn has_is_featured(&self) -> bool {
        self.is_featured.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_featured(&mut self, v: bool) {
        self.is_featured = ::std::option::Option::Some(v);
    }

    // optional bool is_disabled = 15;

    pub fn is_disabled(&self) -> bool {
        self.is_disabled.unwrap_or(false)
    }

    pub fn clear_is_disabled(&mut self) {
        self.is_disabled = ::std::option::Option::None;
    }

    pub fn has_is_disabled(&self) -> bool {
        self.is_disabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_disabled(&mut self, v: bool) {
        self.is_disabled = ::std::option::Option::Some(v);
    }

    // optional bool is_live = 16;

    pub fn is_live(&self) -> bool {
        self.is_live.unwrap_or(false)
    }

    pub fn clear_is_live(&mut self) {
        self.is_live = ::std::option::Option::None;
    }

    pub fn has_is_live(&self) -> bool {
        self.is_live.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_live(&mut self, v: bool) {
        self.is_live = ::std::option::Option::Some(v);
    }

    // optional string language = 17;

    pub fn language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language = ::std::option::Option::Some(::std::string::String::new());
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 reports = 18;

    pub fn reports(&self) -> u32 {
        self.reports.unwrap_or(0)
    }

    pub fn clear_reports(&mut self) {
        self.reports = ::std::option::Option::None;
    }

    pub fn has_reports(&self) -> bool {
        self.reports.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reports(&mut self, v: u32) {
        self.reports = ::std::option::Option::Some(v);
    }

    // optional bool is_partnered = 19;

    pub fn is_partnered(&self) -> bool {
        self.is_partnered.unwrap_or(false)
    }

    pub fn clear_is_partnered(&mut self) {
        self.is_partnered = ::std::option::Option::None;
    }

    pub fn has_is_partnered(&self) -> bool {
        self.is_partnered.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_partnered(&mut self, v: bool) {
        self.is_partnered = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GetBroadcastChannelEntry {
    const NAME: &'static str = "GetBroadcastChannelEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_channel_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    self.unique_name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.viewers = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.views = ::std::option::Option::Some(is.read_uint64()?);
                },
                58 => {
                    self.thumbnail_url = ::std::option::Option::Some(is.read_string()?);
                },
                64 => {
                    self.followers = ::std::option::Option::Some(is.read_uint64()?);
                },
                74 => {
                    self.headline = ::std::option::Option::Some(is.read_string()?);
                },
                82 => {
                    self.avatar_url = ::std::option::Option::Some(is.read_string()?);
                },
                89 => {
                    self.broadcaster_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                96 => {
                    self.subscribers = ::std::option::Option::Some(is.read_uint64()?);
                },
                106 => {
                    self.background_url = ::std::option::Option::Some(is.read_string()?);
                },
                112 => {
                    self.is_featured = ::std::option::Option::Some(is.read_bool()?);
                },
                120 => {
                    self.is_disabled = ::std::option::Option::Some(is.read_bool()?);
                },
                128 => {
                    self.is_live = ::std::option::Option::Some(is.read_bool()?);
                },
                138 => {
                    self.language = ::std::option::Option::Some(is.read_string()?);
                },
                144 => {
                    self.reports = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.is_partnered = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_channel_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.unique_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.viewers {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.views {
            my_size += ::protobuf::rt::uint64_size(6, v);
        }
        if let Some(v) = self.thumbnail_url.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.followers {
            my_size += ::protobuf::rt::uint64_size(8, v);
        }
        if let Some(v) = self.headline.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.avatar_url.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.broadcaster_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.subscribers {
            my_size += ::protobuf::rt::uint64_size(12, v);
        }
        if let Some(v) = self.background_url.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.is_featured {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_disabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_live {
            my_size += 2 + 1;
        }
        if let Some(v) = self.language.as_ref() {
            my_size += ::protobuf::rt::string_size(17, &v);
        }
        if let Some(v) = self.reports {
            my_size += ::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.is_partnered {
            my_size += 2 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast_channel_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.unique_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.viewers {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.views {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.thumbnail_url.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.followers {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.headline.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.avatar_url.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.broadcaster_steamid {
            os.write_fixed64(11, v)?;
        }
        if let Some(v) = self.subscribers {
            os.write_uint64(12, v)?;
        }
        if let Some(v) = self.background_url.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.is_featured {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.is_disabled {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.is_live {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.language.as_ref() {
            os.write_string(17, v)?;
        }
        if let Some(v) = self.reports {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.is_partnered {
            os.write_bool(19, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetBroadcastChannelEntry {
        GetBroadcastChannelEntry::new()
    }

    fn clear(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
        self.unique_name = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.viewers = ::std::option::Option::None;
        self.views = ::std::option::Option::None;
        self.thumbnail_url = ::std::option::Option::None;
        self.followers = ::std::option::Option::None;
        self.headline = ::std::option::Option::None;
        self.avatar_url = ::std::option::Option::None;
        self.broadcaster_steamid = ::std::option::Option::None;
        self.subscribers = ::std::option::Option::None;
        self.background_url = ::std::option::Option::None;
        self.is_featured = ::std::option::Option::None;
        self.is_disabled = ::std::option::Option::None;
        self.is_live = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.reports = ::std::option::Option::None;
        self.is_partnered = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetBroadcastChannelEntry {
        static instance: GetBroadcastChannelEntry = GetBroadcastChannelEntry {
            broadcast_channel_id: ::std::option::Option::None,
            unique_name: ::std::option::Option::None,
            name: ::std::option::Option::None,
            appid: ::std::option::Option::None,
            viewers: ::std::option::Option::None,
            views: ::std::option::Option::None,
            thumbnail_url: ::std::option::Option::None,
            followers: ::std::option::Option::None,
            headline: ::std::option::Option::None,
            avatar_url: ::std::option::Option::None,
            broadcaster_steamid: ::std::option::Option::None,
            subscribers: ::std::option::Option::None,
            background_url: ::std::option::Option::None,
            is_featured: ::std::option::Option::None,
            is_disabled: ::std::option::Option::None,
            is_live: ::std::option::Option::None,
            language: ::std::option::Option::None,
            reports: ::std::option::Option::None,
            is_partnered: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamTV_GetFollowedChannels_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetFollowedChannels_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetFollowedChannels_Response.results)
    pub results: ::std::vec::Vec<GetBroadcastChannelEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetFollowedChannels_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetFollowedChannels_Response {
    fn default() -> &'a CSteamTV_GetFollowedChannels_Response {
        <CSteamTV_GetFollowedChannels_Response as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_GetFollowedChannels_Response {
    pub fn new() -> CSteamTV_GetFollowedChannels_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CSteamTV_GetFollowedChannels_Response {
    const NAME: &'static str = "CSteamTV_GetFollowedChannels_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.results.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.results {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetFollowedChannels_Response {
        CSteamTV_GetFollowedChannels_Response::new()
    }

    fn clear(&mut self) {
        self.results.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetFollowedChannels_Response {
        static instance: CSteamTV_GetFollowedChannels_Response = CSteamTV_GetFollowedChannels_Response {
            results: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Get list of channels a user is subscribed to"]
// @@protoc_insertion_point(message:CSteamTV_GetSubscribedChannels_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetSubscribedChannels_Request {
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetSubscribedChannels_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetSubscribedChannels_Request {
    fn default() -> &'a CSteamTV_GetSubscribedChannels_Request {
        <CSteamTV_GetSubscribedChannels_Request as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_GetSubscribedChannels_Request {
    pub fn new() -> CSteamTV_GetSubscribedChannels_Request {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CSteamTV_GetSubscribedChannels_Request {
    const NAME: &'static str = "CSteamTV_GetSubscribedChannels_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetSubscribedChannels_Request {
        CSteamTV_GetSubscribedChannels_Request::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetSubscribedChannels_Request {
        static instance: CSteamTV_GetSubscribedChannels_Request = CSteamTV_GetSubscribedChannels_Request {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamTV_GetSubscribedChannels_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetSubscribedChannels_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetSubscribedChannels_Response.results)
    pub results: ::std::vec::Vec<GetBroadcastChannelEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetSubscribedChannels_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetSubscribedChannels_Response {
    fn default() -> &'a CSteamTV_GetSubscribedChannels_Response {
        <CSteamTV_GetSubscribedChannels_Response as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_GetSubscribedChannels_Response {
    pub fn new() -> CSteamTV_GetSubscribedChannels_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CSteamTV_GetSubscribedChannels_Response {
    const NAME: &'static str = "CSteamTV_GetSubscribedChannels_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.results.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.results {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetSubscribedChannels_Response {
        CSteamTV_GetSubscribedChannels_Response::new()
    }

    fn clear(&mut self) {
        self.results.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetSubscribedChannels_Response {
        static instance: CSteamTV_GetSubscribedChannels_Response = CSteamTV_GetSubscribedChannels_Response {
            results: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Get broadcast channel live status"]
// @@protoc_insertion_point(message:CSteamTV_GetBroadcastChannelStatus_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetBroadcastChannelStatus_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelStatus_Request.broadcast_channel_id)
    pub broadcast_channel_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetBroadcastChannelStatus_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetBroadcastChannelStatus_Request {
    fn default() -> &'a CSteamTV_GetBroadcastChannelStatus_Request {
        <CSteamTV_GetBroadcastChannelStatus_Request as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_GetBroadcastChannelStatus_Request {
    pub fn new() -> CSteamTV_GetBroadcastChannelStatus_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_channel_id = 1;

    pub fn broadcast_channel_id(&self) -> u64 {
        self.broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_broadcast_channel_id(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_id(&self) -> bool {
        self.broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_id(&mut self, v: u64) {
        self.broadcast_channel_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSteamTV_GetBroadcastChannelStatus_Request {
    const NAME: &'static str = "CSteamTV_GetBroadcastChannelStatus_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_channel_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_channel_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast_channel_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetBroadcastChannelStatus_Request {
        CSteamTV_GetBroadcastChannelStatus_Request::new()
    }

    fn clear(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetBroadcastChannelStatus_Request {
        static instance: CSteamTV_GetBroadcastChannelStatus_Request = CSteamTV_GetBroadcastChannelStatus_Request {
            broadcast_channel_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamTV_GetBroadcastChannelStatus_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetBroadcastChannelStatus_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelStatus_Response.is_live)
    pub is_live: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelStatus_Response.is_disabled)
    pub is_disabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelStatus_Response.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelStatus_Response.viewers)
    pub viewers: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelStatus_Response.views)
    pub views: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelStatus_Response.broadcaster_steamid)
    pub broadcaster_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelStatus_Response.thumbnail_url)
    pub thumbnail_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelStatus_Response.followers)
    pub followers: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelStatus_Response.subscribers)
    pub subscribers: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelStatus_Response.unique_name)
    pub unique_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelStatus_Response.broadcast_session_id)
    pub broadcast_session_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetBroadcastChannelStatus_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetBroadcastChannelStatus_Response {
    fn default() -> &'a CSteamTV_GetBroadcastChannelStatus_Response {
        <CSteamTV_GetBroadcastChannelStatus_Response as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_GetBroadcastChannelStatus_Response {
    pub fn new() -> CSteamTV_GetBroadcastChannelStatus_Response {
        ::std::default::Default::default()
    }

    // optional bool is_live = 1;

    pub fn is_live(&self) -> bool {
        self.is_live.unwrap_or(false)
    }

    pub fn clear_is_live(&mut self) {
        self.is_live = ::std::option::Option::None;
    }

    pub fn has_is_live(&self) -> bool {
        self.is_live.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_live(&mut self, v: bool) {
        self.is_live = ::std::option::Option::Some(v);
    }

    // optional bool is_disabled = 2;

    pub fn is_disabled(&self) -> bool {
        self.is_disabled.unwrap_or(false)
    }

    pub fn clear_is_disabled(&mut self) {
        self.is_disabled = ::std::option::Option::None;
    }

    pub fn has_is_disabled(&self) -> bool {
        self.is_disabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_disabled(&mut self, v: bool) {
        self.is_disabled = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 3;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint64 viewers = 4;

    pub fn viewers(&self) -> u64 {
        self.viewers.unwrap_or(0)
    }

    pub fn clear_viewers(&mut self) {
        self.viewers = ::std::option::Option::None;
    }

    pub fn has_viewers(&self) -> bool {
        self.viewers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_viewers(&mut self, v: u64) {
        self.viewers = ::std::option::Option::Some(v);
    }

    // optional uint64 views = 5;

    pub fn views(&self) -> u64 {
        self.views.unwrap_or(0)
    }

    pub fn clear_views(&mut self) {
        self.views = ::std::option::Option::None;
    }

    pub fn has_views(&self) -> bool {
        self.views.is_some()
    }

    // Param is passed by value, moved
    pub fn set_views(&mut self, v: u64) {
        self.views = ::std::option::Option::Some(v);
    }

    // optional fixed64 broadcaster_steamid = 6;

    pub fn broadcaster_steamid(&self) -> u64 {
        self.broadcaster_steamid.unwrap_or(0)
    }

    pub fn clear_broadcaster_steamid(&mut self) {
        self.broadcaster_steamid = ::std::option::Option::None;
    }

    pub fn has_broadcaster_steamid(&self) -> bool {
        self.broadcaster_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcaster_steamid(&mut self, v: u64) {
        self.broadcaster_steamid = ::std::option::Option::Some(v);
    }

    // optional string thumbnail_url = 7;

    pub fn thumbnail_url(&self) -> &str {
        match self.thumbnail_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_thumbnail_url(&mut self) {
        self.thumbnail_url = ::std::option::Option::None;
    }

    pub fn has_thumbnail_url(&self) -> bool {
        self.thumbnail_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnail_url(&mut self, v: ::std::string::String) {
        self.thumbnail_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnail_url(&mut self) -> &mut ::std::string::String {
        if self.thumbnail_url.is_none() {
            self.thumbnail_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.thumbnail_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnail_url(&mut self) -> ::std::string::String {
        self.thumbnail_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 followers = 8;

    pub fn followers(&self) -> u64 {
        self.followers.unwrap_or(0)
    }

    pub fn clear_followers(&mut self) {
        self.followers = ::std::option::Option::None;
    }

    pub fn has_followers(&self) -> bool {
        self.followers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_followers(&mut self, v: u64) {
        self.followers = ::std::option::Option::Some(v);
    }

    // optional uint64 subscribers = 9;

    pub fn subscribers(&self) -> u64 {
        self.subscribers.unwrap_or(0)
    }

    pub fn clear_subscribers(&mut self) {
        self.subscribers = ::std::option::Option::None;
    }

    pub fn has_subscribers(&self) -> bool {
        self.subscribers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subscribers(&mut self, v: u64) {
        self.subscribers = ::std::option::Option::Some(v);
    }

    // optional string unique_name = 10;

    pub fn unique_name(&self) -> &str {
        match self.unique_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_unique_name(&mut self) {
        self.unique_name = ::std::option::Option::None;
    }

    pub fn has_unique_name(&self) -> bool {
        self.unique_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unique_name(&mut self, v: ::std::string::String) {
        self.unique_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unique_name(&mut self) -> &mut ::std::string::String {
        if self.unique_name.is_none() {
            self.unique_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.unique_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_unique_name(&mut self) -> ::std::string::String {
        self.unique_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 broadcast_session_id = 11;

    pub fn broadcast_session_id(&self) -> u64 {
        self.broadcast_session_id.unwrap_or(0)
    }

    pub fn clear_broadcast_session_id(&mut self) {
        self.broadcast_session_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_session_id(&self) -> bool {
        self.broadcast_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_session_id(&mut self, v: u64) {
        self.broadcast_session_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSteamTV_GetBroadcastChannelStatus_Response {
    const NAME: &'static str = "CSteamTV_GetBroadcastChannelStatus_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.is_live = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.is_disabled = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.viewers = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.views = ::std::option::Option::Some(is.read_uint64()?);
                },
                49 => {
                    self.broadcaster_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                58 => {
                    self.thumbnail_url = ::std::option::Option::Some(is.read_string()?);
                },
                64 => {
                    self.followers = ::std::option::Option::Some(is.read_uint64()?);
                },
                72 => {
                    self.subscribers = ::std::option::Option::Some(is.read_uint64()?);
                },
                82 => {
                    self.unique_name = ::std::option::Option::Some(is.read_string()?);
                },
                88 => {
                    self.broadcast_session_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.is_live {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_disabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.viewers {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.views {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.broadcaster_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.thumbnail_url.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.followers {
            my_size += ::protobuf::rt::uint64_size(8, v);
        }
        if let Some(v) = self.subscribers {
            my_size += ::protobuf::rt::uint64_size(9, v);
        }
        if let Some(v) = self.unique_name.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.broadcast_session_id {
            my_size += ::protobuf::rt::uint64_size(11, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.is_live {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.is_disabled {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.viewers {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.views {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.broadcaster_steamid {
            os.write_fixed64(6, v)?;
        }
        if let Some(v) = self.thumbnail_url.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.followers {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.subscribers {
            os.write_uint64(9, v)?;
        }
        if let Some(v) = self.unique_name.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.broadcast_session_id {
            os.write_uint64(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetBroadcastChannelStatus_Response {
        CSteamTV_GetBroadcastChannelStatus_Response::new()
    }

    fn clear(&mut self) {
        self.is_live = ::std::option::Option::None;
        self.is_disabled = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.viewers = ::std::option::Option::None;
        self.views = ::std::option::Option::None;
        self.broadcaster_steamid = ::std::option::Option::None;
        self.thumbnail_url = ::std::option::Option::None;
        self.followers = ::std::option::Option::None;
        self.subscribers = ::std::option::Option::None;
        self.unique_name = ::std::option::Option::None;
        self.broadcast_session_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetBroadcastChannelStatus_Response {
        static instance: CSteamTV_GetBroadcastChannelStatus_Response = CSteamTV_GetBroadcastChannelStatus_Response {
            is_live: ::std::option::Option::None,
            is_disabled: ::std::option::Option::None,
            appid: ::std::option::Option::None,
            viewers: ::std::option::Option::None,
            views: ::std::option::Option::None,
            broadcaster_steamid: ::std::option::Option::None,
            thumbnail_url: ::std::option::Option::None,
            followers: ::std::option::Option::None,
            subscribers: ::std::option::Option::None,
            unique_name: ::std::option::Option::None,
            broadcast_session_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Follow a broadcast channel"]
// @@protoc_insertion_point(message:CSteamTV_FollowBroadcastChannel_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_FollowBroadcastChannel_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_FollowBroadcastChannel_Request.broadcast_channel_id)
    pub broadcast_channel_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_FollowBroadcastChannel_Request.undo)
    pub undo: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_FollowBroadcastChannel_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_FollowBroadcastChannel_Request {
    fn default() -> &'a CSteamTV_FollowBroadcastChannel_Request {
        <CSteamTV_FollowBroadcastChannel_Request as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_FollowBroadcastChannel_Request {
    pub fn new() -> CSteamTV_FollowBroadcastChannel_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_channel_id = 1;

    pub fn broadcast_channel_id(&self) -> u64 {
        self.broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_broadcast_channel_id(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_id(&self) -> bool {
        self.broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_id(&mut self, v: u64) {
        self.broadcast_channel_id = ::std::option::Option::Some(v);
    }

    // optional bool undo = 2;

    pub fn undo(&self) -> bool {
        self.undo.unwrap_or(false)
    }

    pub fn clear_undo(&mut self) {
        self.undo = ::std::option::Option::None;
    }

    pub fn has_undo(&self) -> bool {
        self.undo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_undo(&mut self, v: bool) {
        self.undo = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSteamTV_FollowBroadcastChannel_Request {
    const NAME: &'static str = "CSteamTV_FollowBroadcastChannel_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_channel_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.undo = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_channel_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.undo {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast_channel_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.undo {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_FollowBroadcastChannel_Request {
        CSteamTV_FollowBroadcastChannel_Request::new()
    }

    fn clear(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
        self.undo = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_FollowBroadcastChannel_Request {
        static instance: CSteamTV_FollowBroadcastChannel_Request = CSteamTV_FollowBroadcastChannel_Request {
            broadcast_channel_id: ::std::option::Option::None,
            undo: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamTV_FollowBroadcastChannel_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_FollowBroadcastChannel_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_FollowBroadcastChannel_Response.is_followed)
    pub is_followed: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_FollowBroadcastChannel_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_FollowBroadcastChannel_Response {
    fn default() -> &'a CSteamTV_FollowBroadcastChannel_Response {
        <CSteamTV_FollowBroadcastChannel_Response as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_FollowBroadcastChannel_Response {
    pub fn new() -> CSteamTV_FollowBroadcastChannel_Response {
        ::std::default::Default::default()
    }

    // optional bool is_followed = 1;

    pub fn is_followed(&self) -> bool {
        self.is_followed.unwrap_or(false)
    }

    pub fn clear_is_followed(&mut self) {
        self.is_followed = ::std::option::Option::None;
    }

    pub fn has_is_followed(&self) -> bool {
        self.is_followed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_followed(&mut self, v: bool) {
        self.is_followed = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSteamTV_FollowBroadcastChannel_Response {
    const NAME: &'static str = "CSteamTV_FollowBroadcastChannel_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.is_followed = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.is_followed {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.is_followed {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_FollowBroadcastChannel_Response {
        CSteamTV_FollowBroadcastChannel_Response::new()
    }

    fn clear(&mut self) {
        self.is_followed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_FollowBroadcastChannel_Response {
        static instance: CSteamTV_FollowBroadcastChannel_Response = CSteamTV_FollowBroadcastChannel_Response {
            is_followed: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Subscribe to a broadcast channel"]
// @@protoc_insertion_point(message:CSteamTV_SubscribeBroadcastChannel_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_SubscribeBroadcastChannel_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_SubscribeBroadcastChannel_Request.broadcast_channel_id)
    pub broadcast_channel_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_SubscribeBroadcastChannel_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_SubscribeBroadcastChannel_Request {
    fn default() -> &'a CSteamTV_SubscribeBroadcastChannel_Request {
        <CSteamTV_SubscribeBroadcastChannel_Request as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_SubscribeBroadcastChannel_Request {
    pub fn new() -> CSteamTV_SubscribeBroadcastChannel_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_channel_id = 1;

    pub fn broadcast_channel_id(&self) -> u64 {
        self.broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_broadcast_channel_id(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_id(&self) -> bool {
        self.broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_id(&mut self, v: u64) {
        self.broadcast_channel_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSteamTV_SubscribeBroadcastChannel_Request {
    const NAME: &'static str = "CSteamTV_SubscribeBroadcastChannel_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_channel_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_channel_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast_channel_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_SubscribeBroadcastChannel_Request {
        CSteamTV_SubscribeBroadcastChannel_Request::new()
    }

    fn clear(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_SubscribeBroadcastChannel_Request {
        static instance: CSteamTV_SubscribeBroadcastChannel_Request = CSteamTV_SubscribeBroadcastChannel_Request {
            broadcast_channel_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamTV_SubscribeBroadcastChannel_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_SubscribeBroadcastChannel_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_SubscribeBroadcastChannel_Response.is_subscribed)
    pub is_subscribed: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_SubscribeBroadcastChannel_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_SubscribeBroadcastChannel_Response {
    fn default() -> &'a CSteamTV_SubscribeBroadcastChannel_Response {
        <CSteamTV_SubscribeBroadcastChannel_Response as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_SubscribeBroadcastChannel_Response {
    pub fn new() -> CSteamTV_SubscribeBroadcastChannel_Response {
        ::std::default::Default::default()
    }

    // optional bool is_subscribed = 1;

    pub fn is_subscribed(&self) -> bool {
        self.is_subscribed.unwrap_or(false)
    }

    pub fn clear_is_subscribed(&mut self) {
        self.is_subscribed = ::std::option::Option::None;
    }

    pub fn has_is_subscribed(&self) -> bool {
        self.is_subscribed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_subscribed(&mut self, v: bool) {
        self.is_subscribed = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSteamTV_SubscribeBroadcastChannel_Response {
    const NAME: &'static str = "CSteamTV_SubscribeBroadcastChannel_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.is_subscribed = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.is_subscribed {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.is_subscribed {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_SubscribeBroadcastChannel_Response {
        CSteamTV_SubscribeBroadcastChannel_Response::new()
    }

    fn clear(&mut self) {
        self.is_subscribed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_SubscribeBroadcastChannel_Response {
        static instance: CSteamTV_SubscribeBroadcastChannel_Response = CSteamTV_SubscribeBroadcastChannel_Response {
            is_subscribed: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Get broadcast channel clips"]
// @@protoc_insertion_point(message:CSteamTV_GetBroadcastChannelClips_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetBroadcastChannelClips_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelClips_Request.broadcast_channel_id)
    pub broadcast_channel_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetBroadcastChannelClips_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetBroadcastChannelClips_Request {
    fn default() -> &'a CSteamTV_GetBroadcastChannelClips_Request {
        <CSteamTV_GetBroadcastChannelClips_Request as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_GetBroadcastChannelClips_Request {
    pub fn new() -> CSteamTV_GetBroadcastChannelClips_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_channel_id = 1;

    pub fn broadcast_channel_id(&self) -> u64 {
        self.broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_broadcast_channel_id(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_id(&self) -> bool {
        self.broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_id(&mut self, v: u64) {
        self.broadcast_channel_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSteamTV_GetBroadcastChannelClips_Request {
    const NAME: &'static str = "CSteamTV_GetBroadcastChannelClips_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_channel_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_channel_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast_channel_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetBroadcastChannelClips_Request {
        CSteamTV_GetBroadcastChannelClips_Request::new()
    }

    fn clear(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetBroadcastChannelClips_Request {
        static instance: CSteamTV_GetBroadcastChannelClips_Request = CSteamTV_GetBroadcastChannelClips_Request {
            broadcast_channel_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamTV_BroadcastClipInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_BroadcastClipInfo {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_BroadcastClipInfo.broadcast_clip_id)
    pub broadcast_clip_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_BroadcastClipInfo.channel_id)
    pub channel_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_BroadcastClipInfo.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSteamTV_BroadcastClipInfo.broadcaster_steamid)
    pub broadcaster_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_BroadcastClipInfo.creator_steamid)
    pub creator_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_BroadcastClipInfo.video_description)
    pub video_description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_BroadcastClipInfo.live_time)
    pub live_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSteamTV_BroadcastClipInfo.length_ms)
    pub length_ms: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSteamTV_BroadcastClipInfo.thumbnail_path)
    pub thumbnail_path: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_BroadcastClipInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_BroadcastClipInfo {
    fn default() -> &'a CSteamTV_BroadcastClipInfo {
        <CSteamTV_BroadcastClipInfo as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_BroadcastClipInfo {
    pub fn new() -> CSteamTV_BroadcastClipInfo {
        ::std::default::Default::default()
    }

    // optional uint64 broadcast_clip_id = 1;

    pub fn broadcast_clip_id(&self) -> u64 {
        self.broadcast_clip_id.unwrap_or(0)
    }

    pub fn clear_broadcast_clip_id(&mut self) {
        self.broadcast_clip_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_clip_id(&self) -> bool {
        self.broadcast_clip_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_clip_id(&mut self, v: u64) {
        self.broadcast_clip_id = ::std::option::Option::Some(v);
    }

    // optional uint64 channel_id = 2;

    pub fn channel_id(&self) -> u64 {
        self.channel_id.unwrap_or(0)
    }

    pub fn clear_channel_id(&mut self) {
        self.channel_id = ::std::option::Option::None;
    }

    pub fn has_channel_id(&self) -> bool {
        self.channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: u64) {
        self.channel_id = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 3;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 broadcaster_steamid = 4;

    pub fn broadcaster_steamid(&self) -> u64 {
        self.broadcaster_steamid.unwrap_or(0)
    }

    pub fn clear_broadcaster_steamid(&mut self) {
        self.broadcaster_steamid = ::std::option::Option::None;
    }

    pub fn has_broadcaster_steamid(&self) -> bool {
        self.broadcaster_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcaster_steamid(&mut self, v: u64) {
        self.broadcaster_steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 creator_steamid = 5;

    pub fn creator_steamid(&self) -> u64 {
        self.creator_steamid.unwrap_or(0)
    }

    pub fn clear_creator_steamid(&mut self) {
        self.creator_steamid = ::std::option::Option::None;
    }

    pub fn has_creator_steamid(&self) -> bool {
        self.creator_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creator_steamid(&mut self, v: u64) {
        self.creator_steamid = ::std::option::Option::Some(v);
    }

    // optional string video_description = 6;

    pub fn video_description(&self) -> &str {
        match self.video_description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_video_description(&mut self) {
        self.video_description = ::std::option::Option::None;
    }

    pub fn has_video_description(&self) -> bool {
        self.video_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_video_description(&mut self, v: ::std::string::String) {
        self.video_description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_video_description(&mut self) -> &mut ::std::string::String {
        if self.video_description.is_none() {
            self.video_description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.video_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_video_description(&mut self) -> ::std::string::String {
        self.video_description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 live_time = 7;

    pub fn live_time(&self) -> u32 {
        self.live_time.unwrap_or(0)
    }

    pub fn clear_live_time(&mut self) {
        self.live_time = ::std::option::Option::None;
    }

    pub fn has_live_time(&self) -> bool {
        self.live_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_live_time(&mut self, v: u32) {
        self.live_time = ::std::option::Option::Some(v);
    }

    // optional uint32 length_ms = 8;

    pub fn length_ms(&self) -> u32 {
        self.length_ms.unwrap_or(0)
    }

    pub fn clear_length_ms(&mut self) {
        self.length_ms = ::std::option::Option::None;
    }

    pub fn has_length_ms(&self) -> bool {
        self.length_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_length_ms(&mut self, v: u32) {
        self.length_ms = ::std::option::Option::Some(v);
    }

    // optional string thumbnail_path = 9;

    pub fn thumbnail_path(&self) -> &str {
        match self.thumbnail_path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_thumbnail_path(&mut self) {
        self.thumbnail_path = ::std::option::Option::None;
    }

    pub fn has_thumbnail_path(&self) -> bool {
        self.thumbnail_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnail_path(&mut self, v: ::std::string::String) {
        self.thumbnail_path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnail_path(&mut self) -> &mut ::std::string::String {
        if self.thumbnail_path.is_none() {
            self.thumbnail_path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.thumbnail_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnail_path(&mut self) -> ::std::string::String {
        self.thumbnail_path.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CSteamTV_BroadcastClipInfo {
    const NAME: &'static str = "CSteamTV_BroadcastClipInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.broadcast_clip_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.channel_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                33 => {
                    self.broadcaster_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                41 => {
                    self.creator_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                50 => {
                    self.video_description = ::std::option::Option::Some(is.read_string()?);
                },
                56 => {
                    self.live_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.length_ms = ::std::option::Option::Some(is.read_uint32()?);
                },
                74 => {
                    self.thumbnail_path = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_clip_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.channel_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.broadcaster_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.creator_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.video_description.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.live_time {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.length_ms {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.thumbnail_path.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast_clip_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.channel_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.broadcaster_steamid {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.creator_steamid {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.video_description.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.live_time {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.length_ms {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.thumbnail_path.as_ref() {
            os.write_string(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_BroadcastClipInfo {
        CSteamTV_BroadcastClipInfo::new()
    }

    fn clear(&mut self) {
        self.broadcast_clip_id = ::std::option::Option::None;
        self.channel_id = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.broadcaster_steamid = ::std::option::Option::None;
        self.creator_steamid = ::std::option::Option::None;
        self.video_description = ::std::option::Option::None;
        self.live_time = ::std::option::Option::None;
        self.length_ms = ::std::option::Option::None;
        self.thumbnail_path = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_BroadcastClipInfo {
        static instance: CSteamTV_BroadcastClipInfo = CSteamTV_BroadcastClipInfo {
            broadcast_clip_id: ::std::option::Option::None,
            channel_id: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            broadcaster_steamid: ::std::option::Option::None,
            creator_steamid: ::std::option::Option::None,
            video_description: ::std::option::Option::None,
            live_time: ::std::option::Option::None,
            length_ms: ::std::option::Option::None,
            thumbnail_path: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamTV_GetBroadcastChannelClips_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetBroadcastChannelClips_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelClips_Response.clips)
    pub clips: ::std::vec::Vec<CSteamTV_BroadcastClipInfo>,
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelClips_Response.thumbnail_host)
    pub thumbnail_host: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetBroadcastChannelClips_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetBroadcastChannelClips_Response {
    fn default() -> &'a CSteamTV_GetBroadcastChannelClips_Response {
        <CSteamTV_GetBroadcastChannelClips_Response as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_GetBroadcastChannelClips_Response {
    pub fn new() -> CSteamTV_GetBroadcastChannelClips_Response {
        ::std::default::Default::default()
    }

    // optional string thumbnail_host = 2;

    pub fn thumbnail_host(&self) -> &str {
        match self.thumbnail_host.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_thumbnail_host(&mut self) {
        self.thumbnail_host = ::std::option::Option::None;
    }

    pub fn has_thumbnail_host(&self) -> bool {
        self.thumbnail_host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnail_host(&mut self, v: ::std::string::String) {
        self.thumbnail_host = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnail_host(&mut self) -> &mut ::std::string::String {
        if self.thumbnail_host.is_none() {
            self.thumbnail_host = ::std::option::Option::Some(::std::string::String::new());
        }
        self.thumbnail_host.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnail_host(&mut self) -> ::std::string::String {
        self.thumbnail_host.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CSteamTV_GetBroadcastChannelClips_Response {
    const NAME: &'static str = "CSteamTV_GetBroadcastChannelClips_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.clips.push(is.read_message()?);
                },
                18 => {
                    self.thumbnail_host = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.clips {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.thumbnail_host.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.clips {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.thumbnail_host.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetBroadcastChannelClips_Response {
        CSteamTV_GetBroadcastChannelClips_Response::new()
    }

    fn clear(&mut self) {
        self.clips.clear();
        self.thumbnail_host = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetBroadcastChannelClips_Response {
        static instance: CSteamTV_GetBroadcastChannelClips_Response = CSteamTV_GetBroadcastChannelClips_Response {
            clips: ::std::vec::Vec::new(),
            thumbnail_host: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Report a broadcast channel"]
// @@protoc_insertion_point(message:CSteamTV_ReportBroadcastChannel_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_ReportBroadcastChannel_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_ReportBroadcastChannel_Request.broadcast_channel_id)
    pub broadcast_channel_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_ReportBroadcastChannel_Request.reason)
    pub reason: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_ReportBroadcastChannel_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_ReportBroadcastChannel_Request {
    fn default() -> &'a CSteamTV_ReportBroadcastChannel_Request {
        <CSteamTV_ReportBroadcastChannel_Request as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_ReportBroadcastChannel_Request {
    pub fn new() -> CSteamTV_ReportBroadcastChannel_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_channel_id = 1;

    pub fn broadcast_channel_id(&self) -> u64 {
        self.broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_broadcast_channel_id(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_id(&self) -> bool {
        self.broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_id(&mut self, v: u64) {
        self.broadcast_channel_id = ::std::option::Option::Some(v);
    }

    // optional string reason = 2;

    pub fn reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CSteamTV_ReportBroadcastChannel_Request {
    const NAME: &'static str = "CSteamTV_ReportBroadcastChannel_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_channel_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    self.reason = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_channel_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast_channel_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.reason.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_ReportBroadcastChannel_Request {
        CSteamTV_ReportBroadcastChannel_Request::new()
    }

    fn clear(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_ReportBroadcastChannel_Request {
        static instance: CSteamTV_ReportBroadcastChannel_Request = CSteamTV_ReportBroadcastChannel_Request {
            broadcast_channel_id: ::std::option::Option::None,
            reason: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamTV_ReportBroadcastChannel_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_ReportBroadcastChannel_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_ReportBroadcastChannel_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_ReportBroadcastChannel_Response {
    fn default() -> &'a CSteamTV_ReportBroadcastChannel_Response {
        <CSteamTV_ReportBroadcastChannel_Response as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_ReportBroadcastChannel_Response {
    pub fn new() -> CSteamTV_ReportBroadcastChannel_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CSteamTV_ReportBroadcastChannel_Response {
    const NAME: &'static str = "CSteamTV_ReportBroadcastChannel_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_ReportBroadcastChannel_Response {
        CSteamTV_ReportBroadcastChannel_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_ReportBroadcastChannel_Response {
        static instance: CSteamTV_ReportBroadcastChannel_Response = CSteamTV_ReportBroadcastChannel_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Get user's interaction status with a broadcast channel"]
// @@protoc_insertion_point(message:CSteamTV_GetBroadcastChannelInteraction_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetBroadcastChannelInteraction_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelInteraction_Request.broadcast_channel_id)
    pub broadcast_channel_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetBroadcastChannelInteraction_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetBroadcastChannelInteraction_Request {
    fn default() -> &'a CSteamTV_GetBroadcastChannelInteraction_Request {
        <CSteamTV_GetBroadcastChannelInteraction_Request as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_GetBroadcastChannelInteraction_Request {
    pub fn new() -> CSteamTV_GetBroadcastChannelInteraction_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_channel_id = 1;

    pub fn broadcast_channel_id(&self) -> u64 {
        self.broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_broadcast_channel_id(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_id(&self) -> bool {
        self.broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_id(&mut self, v: u64) {
        self.broadcast_channel_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSteamTV_GetBroadcastChannelInteraction_Request {
    const NAME: &'static str = "CSteamTV_GetBroadcastChannelInteraction_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_channel_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_channel_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast_channel_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetBroadcastChannelInteraction_Request {
        CSteamTV_GetBroadcastChannelInteraction_Request::new()
    }

    fn clear(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetBroadcastChannelInteraction_Request {
        static instance: CSteamTV_GetBroadcastChannelInteraction_Request = CSteamTV_GetBroadcastChannelInteraction_Request {
            broadcast_channel_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamTV_GetBroadcastChannelInteraction_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetBroadcastChannelInteraction_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelInteraction_Response.is_followed)
    pub is_followed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelInteraction_Response.is_subscribed)
    pub is_subscribed: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetBroadcastChannelInteraction_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetBroadcastChannelInteraction_Response {
    fn default() -> &'a CSteamTV_GetBroadcastChannelInteraction_Response {
        <CSteamTV_GetBroadcastChannelInteraction_Response as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_GetBroadcastChannelInteraction_Response {
    pub fn new() -> CSteamTV_GetBroadcastChannelInteraction_Response {
        ::std::default::Default::default()
    }

    // optional bool is_followed = 1;

    pub fn is_followed(&self) -> bool {
        self.is_followed.unwrap_or(false)
    }

    pub fn clear_is_followed(&mut self) {
        self.is_followed = ::std::option::Option::None;
    }

    pub fn has_is_followed(&self) -> bool {
        self.is_followed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_followed(&mut self, v: bool) {
        self.is_followed = ::std::option::Option::Some(v);
    }

    // optional bool is_subscribed = 2;

    pub fn is_subscribed(&self) -> bool {
        self.is_subscribed.unwrap_or(false)
    }

    pub fn clear_is_subscribed(&mut self) {
        self.is_subscribed = ::std::option::Option::None;
    }

    pub fn has_is_subscribed(&self) -> bool {
        self.is_subscribed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_subscribed(&mut self, v: bool) {
        self.is_subscribed = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSteamTV_GetBroadcastChannelInteraction_Response {
    const NAME: &'static str = "CSteamTV_GetBroadcastChannelInteraction_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.is_followed = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.is_subscribed = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.is_followed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_subscribed {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.is_followed {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.is_subscribed {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetBroadcastChannelInteraction_Response {
        CSteamTV_GetBroadcastChannelInteraction_Response::new()
    }

    fn clear(&mut self) {
        self.is_followed = ::std::option::Option::None;
        self.is_subscribed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetBroadcastChannelInteraction_Response {
        static instance: CSteamTV_GetBroadcastChannelInteraction_Response = CSteamTV_GetBroadcastChannelInteraction_Response {
            is_followed: ::std::option::Option::None,
            is_subscribed: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Get list of games with active broadcasters"]
// @@protoc_insertion_point(message:CSteamTV_GetGames_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetGames_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetGames_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSteamTV_GetGames_Request.algorithm)
    pub algorithm: ::std::option::Option<::protobuf::EnumOrUnknown<EGetGamesAlgorithm>>,
    // @@protoc_insertion_point(field:CSteamTV_GetGames_Request.count)
    pub count: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetGames_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetGames_Request {
    fn default() -> &'a CSteamTV_GetGames_Request {
        <CSteamTV_GetGames_Request as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_GetGames_Request {
    pub fn new() -> CSteamTV_GetGames_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional .EGetGamesAlgorithm algorithm = 2;

    pub fn algorithm(&self) -> EGetGamesAlgorithm {
        match self.algorithm {
            Some(e) => e.enum_value_or(EGetGamesAlgorithm::k_EGetGamesAlgorithm_Default),
            None => EGetGamesAlgorithm::k_EGetGamesAlgorithm_Default,
        }
    }

    pub fn clear_algorithm(&mut self) {
        self.algorithm = ::std::option::Option::None;
    }

    pub fn has_algorithm(&self) -> bool {
        self.algorithm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_algorithm(&mut self, v: EGetGamesAlgorithm) {
        self.algorithm = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 count = 3;

    pub fn count(&self) -> u32 {
        self.count.unwrap_or(0)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u32) {
        self.count = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSteamTV_GetGames_Request {
    const NAME: &'static str = "CSteamTV_GetGames_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.algorithm = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.count = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.algorithm {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.algorithm {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.count {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetGames_Request {
        CSteamTV_GetGames_Request::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.algorithm = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetGames_Request {
        static instance: CSteamTV_GetGames_Request = CSteamTV_GetGames_Request {
            appid: ::std::option::Option::None,
            algorithm: ::std::option::Option::None,
            count: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamTV_Game)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_Game {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_Game.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSteamTV_Game.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_Game.image)
    pub image: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_Game.viewers)
    pub viewers: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_Game.channels)
    pub channels: ::std::vec::Vec<GetBroadcastChannelEntry>,
    // @@protoc_insertion_point(field:CSteamTV_Game.release_date)
    pub release_date: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_Game.developer)
    pub developer: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_Game.publisher)
    pub publisher: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_Game.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_Game {
    fn default() -> &'a CSteamTV_Game {
        <CSteamTV_Game as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_Game {
    pub fn new() -> CSteamTV_Game {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string image = 3;

    pub fn image(&self) -> &str {
        match self.image.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_image(&mut self) {
        self.image = ::std::option::Option::None;
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ::std::string::String) {
        self.image = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ::std::string::String {
        if self.image.is_none() {
            self.image = ::std::option::Option::Some(::std::string::String::new());
        }
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> ::std::string::String {
        self.image.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 viewers = 4;

    pub fn viewers(&self) -> u64 {
        self.viewers.unwrap_or(0)
    }

    pub fn clear_viewers(&mut self) {
        self.viewers = ::std::option::Option::None;
    }

    pub fn has_viewers(&self) -> bool {
        self.viewers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_viewers(&mut self, v: u64) {
        self.viewers = ::std::option::Option::Some(v);
    }

    // optional string release_date = 6;

    pub fn release_date(&self) -> &str {
        match self.release_date.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_release_date(&mut self) {
        self.release_date = ::std::option::Option::None;
    }

    pub fn has_release_date(&self) -> bool {
        self.release_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_release_date(&mut self, v: ::std::string::String) {
        self.release_date = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_release_date(&mut self) -> &mut ::std::string::String {
        if self.release_date.is_none() {
            self.release_date = ::std::option::Option::Some(::std::string::String::new());
        }
        self.release_date.as_mut().unwrap()
    }

    // Take field
    pub fn take_release_date(&mut self) -> ::std::string::String {
        self.release_date.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string developer = 7;

    pub fn developer(&self) -> &str {
        match self.developer.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_developer(&mut self) {
        self.developer = ::std::option::Option::None;
    }

    pub fn has_developer(&self) -> bool {
        self.developer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_developer(&mut self, v: ::std::string::String) {
        self.developer = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_developer(&mut self) -> &mut ::std::string::String {
        if self.developer.is_none() {
            self.developer = ::std::option::Option::Some(::std::string::String::new());
        }
        self.developer.as_mut().unwrap()
    }

    // Take field
    pub fn take_developer(&mut self) -> ::std::string::String {
        self.developer.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string publisher = 8;

    pub fn publisher(&self) -> &str {
        match self.publisher.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_publisher(&mut self) {
        self.publisher = ::std::option::Option::None;
    }

    pub fn has_publisher(&self) -> bool {
        self.publisher.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publisher(&mut self, v: ::std::string::String) {
        self.publisher = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_publisher(&mut self) -> &mut ::std::string::String {
        if self.publisher.is_none() {
            self.publisher = ::std::option::Option::Some(::std::string::String::new());
        }
        self.publisher.as_mut().unwrap()
    }

    // Take field
    pub fn take_publisher(&mut self) -> ::std::string::String {
        self.publisher.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CSteamTV_Game {
    const NAME: &'static str = "CSteamTV_Game";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.image = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.viewers = ::std::option::Option::Some(is.read_uint64()?);
                },
                42 => {
                    self.channels.push(is.read_message()?);
                },
                50 => {
                    self.release_date = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.developer = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.publisher = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.image.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.viewers {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        for value in &self.channels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.release_date.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.developer.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.publisher.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.image.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.viewers {
            os.write_uint64(4, v)?;
        }
        for v in &self.channels {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.release_date.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.developer.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.publisher.as_ref() {
            os.write_string(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_Game {
        CSteamTV_Game::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.image = ::std::option::Option::None;
        self.viewers = ::std::option::Option::None;
        self.channels.clear();
        self.release_date = ::std::option::Option::None;
        self.developer = ::std::option::Option::None;
        self.publisher = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_Game {
        static instance: CSteamTV_Game = CSteamTV_Game {
            appid: ::std::option::Option::None,
            name: ::std::option::Option::None,
            image: ::std::option::Option::None,
            viewers: ::std::option::Option::None,
            channels: ::std::vec::Vec::new(),
            release_date: ::std::option::Option::None,
            developer: ::std::option::Option::None,
            publisher: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamTV_GetGames_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetGames_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetGames_Response.results)
    pub results: ::std::vec::Vec<CSteamTV_Game>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetGames_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetGames_Response {
    fn default() -> &'a CSteamTV_GetGames_Response {
        <CSteamTV_GetGames_Response as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_GetGames_Response {
    pub fn new() -> CSteamTV_GetGames_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CSteamTV_GetGames_Response {
    const NAME: &'static str = "CSteamTV_GetGames_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.results.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.results {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetGames_Response {
        CSteamTV_GetGames_Response::new()
    }

    fn clear(&mut self) {
        self.results.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetGames_Response {
        static instance: CSteamTV_GetGames_Response = CSteamTV_GetGames_Response {
            results: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Get the list of featured broadcast channels"]
// @@protoc_insertion_point(message:CSteamTV_GetChannels_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetChannels_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetChannels_Request.algorithm)
    pub algorithm: ::std::option::Option<::protobuf::EnumOrUnknown<EGetChannelsAlgorithm>>,
    // @@protoc_insertion_point(field:CSteamTV_GetChannels_Request.count)
    pub count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSteamTV_GetChannels_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetChannels_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetChannels_Request {
    fn default() -> &'a CSteamTV_GetChannels_Request {
        <CSteamTV_GetChannels_Request as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_GetChannels_Request {
    pub fn new() -> CSteamTV_GetChannels_Request {
        ::std::default::Default::default()
    }

    // optional .EGetChannelsAlgorithm algorithm = 1;

    pub fn algorithm(&self) -> EGetChannelsAlgorithm {
        match self.algorithm {
            Some(e) => e.enum_value_or(EGetChannelsAlgorithm::k_EGetChannelsAlgorithm_Default),
            None => EGetChannelsAlgorithm::k_EGetChannelsAlgorithm_Default,
        }
    }

    pub fn clear_algorithm(&mut self) {
        self.algorithm = ::std::option::Option::None;
    }

    pub fn has_algorithm(&self) -> bool {
        self.algorithm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_algorithm(&mut self, v: EGetChannelsAlgorithm) {
        self.algorithm = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 count = 2;

    pub fn count(&self) -> u32 {
        self.count.unwrap_or(0)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 3;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSteamTV_GetChannels_Request {
    const NAME: &'static str = "CSteamTV_GetChannels_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.algorithm = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.count = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.algorithm {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.algorithm {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.count {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetChannels_Request {
        CSteamTV_GetChannels_Request::new()
    }

    fn clear(&mut self) {
        self.algorithm = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetChannels_Request {
        static instance: CSteamTV_GetChannels_Request = CSteamTV_GetChannels_Request {
            algorithm: ::std::option::Option::None,
            count: ::std::option::Option::None,
            appid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamTV_GetChannels_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetChannels_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetChannels_Response.results)
    pub results: ::std::vec::Vec<GetBroadcastChannelEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetChannels_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetChannels_Response {
    fn default() -> &'a CSteamTV_GetChannels_Response {
        <CSteamTV_GetChannels_Response as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_GetChannels_Response {
    pub fn new() -> CSteamTV_GetChannels_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CSteamTV_GetChannels_Response {
    const NAME: &'static str = "CSteamTV_GetChannels_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.results.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.results {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetChannels_Response {
        CSteamTV_GetChannels_Response::new()
    }

    fn clear(&mut self) {
        self.results.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetChannels_Response {
        static instance: CSteamTV_GetChannels_Response = CSteamTV_GetChannels_Response {
            results: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Set the ban for a specific broadcaster. The issuer is the logged in steam account"]
// @@protoc_insertion_point(message:CSteamTV_AddChatBan_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_AddChatBan_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_AddChatBan_Request.broadcast_channel_id)
    pub broadcast_channel_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_AddChatBan_Request.chatter_steamid)
    pub chatter_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_AddChatBan_Request.duration)
    pub duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSteamTV_AddChatBan_Request.permanent)
    pub permanent: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamTV_AddChatBan_Request.undo)
    pub undo: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_AddChatBan_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_AddChatBan_Request {
    fn default() -> &'a CSteamTV_AddChatBan_Request {
        <CSteamTV_AddChatBan_Request as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_AddChatBan_Request {
    pub fn new() -> CSteamTV_AddChatBan_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_channel_id = 1;

    pub fn broadcast_channel_id(&self) -> u64 {
        self.broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_broadcast_channel_id(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_id(&self) -> bool {
        self.broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_id(&mut self, v: u64) {
        self.broadcast_channel_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 chatter_steamid = 2;

    pub fn chatter_steamid(&self) -> u64 {
        self.chatter_steamid.unwrap_or(0)
    }

    pub fn clear_chatter_steamid(&mut self) {
        self.chatter_steamid = ::std::option::Option::None;
    }

    pub fn has_chatter_steamid(&self) -> bool {
        self.chatter_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chatter_steamid(&mut self, v: u64) {
        self.chatter_steamid = ::std::option::Option::Some(v);
    }

    // optional uint32 duration = 3;

    pub fn duration(&self) -> u32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: u32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional bool permanent = 4;

    pub fn permanent(&self) -> bool {
        self.permanent.unwrap_or(false)
    }

    pub fn clear_permanent(&mut self) {
        self.permanent = ::std::option::Option::None;
    }

    pub fn has_permanent(&self) -> bool {
        self.permanent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permanent(&mut self, v: bool) {
        self.permanent = ::std::option::Option::Some(v);
    }

    // optional bool undo = 5;

    pub fn undo(&self) -> bool {
        self.undo.unwrap_or(false)
    }

    pub fn clear_undo(&mut self) {
        self.undo = ::std::option::Option::None;
    }

    pub fn has_undo(&self) -> bool {
        self.undo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_undo(&mut self, v: bool) {
        self.undo = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSteamTV_AddChatBan_Request {
    const NAME: &'static str = "CSteamTV_AddChatBan_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_channel_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.chatter_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.permanent = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.undo = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_channel_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.chatter_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.permanent {
            my_size += 1 + 1;
        }
        if let Some(v) = self.undo {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast_channel_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.chatter_steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.duration {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.permanent {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.undo {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_AddChatBan_Request {
        CSteamTV_AddChatBan_Request::new()
    }

    fn clear(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
        self.chatter_steamid = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.permanent = ::std::option::Option::None;
        self.undo = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_AddChatBan_Request {
        static instance: CSteamTV_AddChatBan_Request = CSteamTV_AddChatBan_Request {
            broadcast_channel_id: ::std::option::Option::None,
            chatter_steamid: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            permanent: ::std::option::Option::None,
            undo: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamTV_AddChatBan_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_AddChatBan_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_AddChatBan_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_AddChatBan_Response {
    fn default() -> &'a CSteamTV_AddChatBan_Response {
        <CSteamTV_AddChatBan_Response as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_AddChatBan_Response {
    pub fn new() -> CSteamTV_AddChatBan_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CSteamTV_AddChatBan_Response {
    const NAME: &'static str = "CSteamTV_AddChatBan_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_AddChatBan_Response {
        CSteamTV_AddChatBan_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_AddChatBan_Response {
        static instance: CSteamTV_AddChatBan_Response = CSteamTV_AddChatBan_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Get list of bans for a specific broadcaster. "]
// @@protoc_insertion_point(message:CSteamTV_GetChatBans_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetChatBans_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetChatBans_Request.broadcast_channel_id)
    pub broadcast_channel_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetChatBans_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetChatBans_Request {
    fn default() -> &'a CSteamTV_GetChatBans_Request {
        <CSteamTV_GetChatBans_Request as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_GetChatBans_Request {
    pub fn new() -> CSteamTV_GetChatBans_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_channel_id = 1;

    pub fn broadcast_channel_id(&self) -> u64 {
        self.broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_broadcast_channel_id(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_id(&self) -> bool {
        self.broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_id(&mut self, v: u64) {
        self.broadcast_channel_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSteamTV_GetChatBans_Request {
    const NAME: &'static str = "CSteamTV_GetChatBans_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_channel_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_channel_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast_channel_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetChatBans_Request {
        CSteamTV_GetChatBans_Request::new()
    }

    fn clear(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetChatBans_Request {
        static instance: CSteamTV_GetChatBans_Request = CSteamTV_GetChatBans_Request {
            broadcast_channel_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamTV_ChatBan)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_ChatBan {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_ChatBan.issuer_steamid)
    pub issuer_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_ChatBan.chatter_steamid)
    pub chatter_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_ChatBan.time_expires)
    pub time_expires: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_ChatBan.permanent)
    pub permanent: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamTV_ChatBan.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_ChatBan.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_ChatBan {
    fn default() -> &'a CSteamTV_ChatBan {
        <CSteamTV_ChatBan as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_ChatBan {
    pub fn new() -> CSteamTV_ChatBan {
        ::std::default::Default::default()
    }

    // optional fixed64 issuer_steamid = 1;

    pub fn issuer_steamid(&self) -> u64 {
        self.issuer_steamid.unwrap_or(0)
    }

    pub fn clear_issuer_steamid(&mut self) {
        self.issuer_steamid = ::std::option::Option::None;
    }

    pub fn has_issuer_steamid(&self) -> bool {
        self.issuer_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_issuer_steamid(&mut self, v: u64) {
        self.issuer_steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 chatter_steamid = 2;

    pub fn chatter_steamid(&self) -> u64 {
        self.chatter_steamid.unwrap_or(0)
    }

    pub fn clear_chatter_steamid(&mut self) {
        self.chatter_steamid = ::std::option::Option::None;
    }

    pub fn has_chatter_steamid(&self) -> bool {
        self.chatter_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chatter_steamid(&mut self, v: u64) {
        self.chatter_steamid = ::std::option::Option::Some(v);
    }

    // optional string time_expires = 3;

    pub fn time_expires(&self) -> &str {
        match self.time_expires.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_time_expires(&mut self) {
        self.time_expires = ::std::option::Option::None;
    }

    pub fn has_time_expires(&self) -> bool {
        self.time_expires.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_expires(&mut self, v: ::std::string::String) {
        self.time_expires = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_time_expires(&mut self) -> &mut ::std::string::String {
        if self.time_expires.is_none() {
            self.time_expires = ::std::option::Option::Some(::std::string::String::new());
        }
        self.time_expires.as_mut().unwrap()
    }

    // Take field
    pub fn take_time_expires(&mut self) -> ::std::string::String {
        self.time_expires.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool permanent = 4;

    pub fn permanent(&self) -> bool {
        self.permanent.unwrap_or(false)
    }

    pub fn clear_permanent(&mut self) {
        self.permanent = ::std::option::Option::None;
    }

    pub fn has_permanent(&self) -> bool {
        self.permanent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permanent(&mut self, v: bool) {
        self.permanent = ::std::option::Option::Some(v);
    }

    // optional string name = 5;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CSteamTV_ChatBan {
    const NAME: &'static str = "CSteamTV_ChatBan";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.issuer_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.chatter_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    self.time_expires = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.permanent = ::std::option::Option::Some(is.read_bool()?);
                },
                42 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.issuer_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.chatter_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.time_expires.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.permanent {
            my_size += 1 + 1;
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.issuer_steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.chatter_steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.time_expires.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.permanent {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_ChatBan {
        CSteamTV_ChatBan::new()
    }

    fn clear(&mut self) {
        self.issuer_steamid = ::std::option::Option::None;
        self.chatter_steamid = ::std::option::Option::None;
        self.time_expires = ::std::option::Option::None;
        self.permanent = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_ChatBan {
        static instance: CSteamTV_ChatBan = CSteamTV_ChatBan {
            issuer_steamid: ::std::option::Option::None,
            chatter_steamid: ::std::option::Option::None,
            time_expires: ::std::option::Option::None,
            permanent: ::std::option::Option::None,
            name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamTV_GetChatBans_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetChatBans_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetChatBans_Response.results)
    pub results: ::std::vec::Vec<CSteamTV_ChatBan>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetChatBans_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetChatBans_Response {
    fn default() -> &'a CSteamTV_GetChatBans_Response {
        <CSteamTV_GetChatBans_Response as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_GetChatBans_Response {
    pub fn new() -> CSteamTV_GetChatBans_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CSteamTV_GetChatBans_Response {
    const NAME: &'static str = "CSteamTV_GetChatBans_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.results.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.results {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetChatBans_Response {
        CSteamTV_GetChatBans_Response::new()
    }

    fn clear(&mut self) {
        self.results.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetChatBans_Response {
        static instance: CSteamTV_GetChatBans_Response = CSteamTV_GetChatBans_Response {
            results: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Add or remove a moderator for this broadcast channel"]
// @@protoc_insertion_point(message:CSteamTV_AddChatModerator_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_AddChatModerator_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_AddChatModerator_Request.broadcast_channel_id)
    pub broadcast_channel_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_AddChatModerator_Request.moderator_steamid)
    pub moderator_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_AddChatModerator_Request.undo)
    pub undo: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_AddChatModerator_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_AddChatModerator_Request {
    fn default() -> &'a CSteamTV_AddChatModerator_Request {
        <CSteamTV_AddChatModerator_Request as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_AddChatModerator_Request {
    pub fn new() -> CSteamTV_AddChatModerator_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_channel_id = 1;

    pub fn broadcast_channel_id(&self) -> u64 {
        self.broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_broadcast_channel_id(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_id(&self) -> bool {
        self.broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_id(&mut self, v: u64) {
        self.broadcast_channel_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 moderator_steamid = 2;

    pub fn moderator_steamid(&self) -> u64 {
        self.moderator_steamid.unwrap_or(0)
    }

    pub fn clear_moderator_steamid(&mut self) {
        self.moderator_steamid = ::std::option::Option::None;
    }

    pub fn has_moderator_steamid(&self) -> bool {
        self.moderator_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_moderator_steamid(&mut self, v: u64) {
        self.moderator_steamid = ::std::option::Option::Some(v);
    }

    // optional bool undo = 3;

    pub fn undo(&self) -> bool {
        self.undo.unwrap_or(false)
    }

    pub fn clear_undo(&mut self) {
        self.undo = ::std::option::Option::None;
    }

    pub fn has_undo(&self) -> bool {
        self.undo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_undo(&mut self, v: bool) {
        self.undo = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSteamTV_AddChatModerator_Request {
    const NAME: &'static str = "CSteamTV_AddChatModerator_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_channel_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.moderator_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.undo = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_channel_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.moderator_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.undo {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast_channel_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.moderator_steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.undo {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_AddChatModerator_Request {
        CSteamTV_AddChatModerator_Request::new()
    }

    fn clear(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
        self.moderator_steamid = ::std::option::Option::None;
        self.undo = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_AddChatModerator_Request {
        static instance: CSteamTV_AddChatModerator_Request = CSteamTV_AddChatModerator_Request {
            broadcast_channel_id: ::std::option::Option::None,
            moderator_steamid: ::std::option::Option::None,
            undo: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamTV_AddChatModerator_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_AddChatModerator_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_AddChatModerator_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_AddChatModerator_Response {
    fn default() -> &'a CSteamTV_AddChatModerator_Response {
        <CSteamTV_AddChatModerator_Response as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_AddChatModerator_Response {
    pub fn new() -> CSteamTV_AddChatModerator_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CSteamTV_AddChatModerator_Response {
    const NAME: &'static str = "CSteamTV_AddChatModerator_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_AddChatModerator_Response {
        CSteamTV_AddChatModerator_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_AddChatModerator_Response {
        static instance: CSteamTV_AddChatModerator_Response = CSteamTV_AddChatModerator_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Returns the list of moderators for this broadcast channel"]
// @@protoc_insertion_point(message:CSteamTV_GetChatModerators_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetChatModerators_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetChatModerators_Request.broadcast_channel_id)
    pub broadcast_channel_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetChatModerators_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetChatModerators_Request {
    fn default() -> &'a CSteamTV_GetChatModerators_Request {
        <CSteamTV_GetChatModerators_Request as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_GetChatModerators_Request {
    pub fn new() -> CSteamTV_GetChatModerators_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_channel_id = 1;

    pub fn broadcast_channel_id(&self) -> u64 {
        self.broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_broadcast_channel_id(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_id(&self) -> bool {
        self.broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_id(&mut self, v: u64) {
        self.broadcast_channel_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSteamTV_GetChatModerators_Request {
    const NAME: &'static str = "CSteamTV_GetChatModerators_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_channel_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_channel_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast_channel_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetChatModerators_Request {
        CSteamTV_GetChatModerators_Request::new()
    }

    fn clear(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetChatModerators_Request {
        static instance: CSteamTV_GetChatModerators_Request = CSteamTV_GetChatModerators_Request {
            broadcast_channel_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamTV_ChatModerator)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_ChatModerator {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_ChatModerator.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_ChatModerator.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_ChatModerator.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_ChatModerator {
    fn default() -> &'a CSteamTV_ChatModerator {
        <CSteamTV_ChatModerator as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_ChatModerator {
    pub fn new() -> CSteamTV_ChatModerator {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CSteamTV_ChatModerator {
    const NAME: &'static str = "CSteamTV_ChatModerator";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_ChatModerator {
        CSteamTV_ChatModerator::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_ChatModerator {
        static instance: CSteamTV_ChatModerator = CSteamTV_ChatModerator {
            steamid: ::std::option::Option::None,
            name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamTV_GetChatModerators_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetChatModerators_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetChatModerators_Response.results)
    pub results: ::std::vec::Vec<CSteamTV_ChatModerator>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetChatModerators_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetChatModerators_Response {
    fn default() -> &'a CSteamTV_GetChatModerators_Response {
        <CSteamTV_GetChatModerators_Response as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_GetChatModerators_Response {
    pub fn new() -> CSteamTV_GetChatModerators_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CSteamTV_GetChatModerators_Response {
    const NAME: &'static str = "CSteamTV_GetChatModerators_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.results.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.results {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetChatModerators_Response {
        CSteamTV_GetChatModerators_Response::new()
    }

    fn clear(&mut self) {
        self.results.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetChatModerators_Response {
        static instance: CSteamTV_GetChatModerators_Response = CSteamTV_GetChatModerators_Response {
            results: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Add or remove a banned keyword in this broadcast channel chat"]
// @@protoc_insertion_point(message:CSteamTV_AddWordBan_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_AddWordBan_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_AddWordBan_Request.broadcast_channel_id)
    pub broadcast_channel_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_AddWordBan_Request.word)
    pub word: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_AddWordBan_Request.undo)
    pub undo: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_AddWordBan_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_AddWordBan_Request {
    fn default() -> &'a CSteamTV_AddWordBan_Request {
        <CSteamTV_AddWordBan_Request as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_AddWordBan_Request {
    pub fn new() -> CSteamTV_AddWordBan_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_channel_id = 1;

    pub fn broadcast_channel_id(&self) -> u64 {
        self.broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_broadcast_channel_id(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_id(&self) -> bool {
        self.broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_id(&mut self, v: u64) {
        self.broadcast_channel_id = ::std::option::Option::Some(v);
    }

    // optional string word = 2;

    pub fn word(&self) -> &str {
        match self.word.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_word(&mut self) {
        self.word = ::std::option::Option::None;
    }

    pub fn has_word(&self) -> bool {
        self.word.is_some()
    }

    // Param is passed by value, moved
    pub fn set_word(&mut self, v: ::std::string::String) {
        self.word = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_word(&mut self) -> &mut ::std::string::String {
        if self.word.is_none() {
            self.word = ::std::option::Option::Some(::std::string::String::new());
        }
        self.word.as_mut().unwrap()
    }

    // Take field
    pub fn take_word(&mut self) -> ::std::string::String {
        self.word.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool undo = 3;

    pub fn undo(&self) -> bool {
        self.undo.unwrap_or(false)
    }

    pub fn clear_undo(&mut self) {
        self.undo = ::std::option::Option::None;
    }

    pub fn has_undo(&self) -> bool {
        self.undo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_undo(&mut self, v: bool) {
        self.undo = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSteamTV_AddWordBan_Request {
    const NAME: &'static str = "CSteamTV_AddWordBan_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_channel_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    self.word = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.undo = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_channel_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.word.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.undo {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast_channel_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.word.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.undo {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_AddWordBan_Request {
        CSteamTV_AddWordBan_Request::new()
    }

    fn clear(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
        self.word = ::std::option::Option::None;
        self.undo = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_AddWordBan_Request {
        static instance: CSteamTV_AddWordBan_Request = CSteamTV_AddWordBan_Request {
            broadcast_channel_id: ::std::option::Option::None,
            word: ::std::option::Option::None,
            undo: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamTV_AddWordBan_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_AddWordBan_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_AddWordBan_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_AddWordBan_Response {
    fn default() -> &'a CSteamTV_AddWordBan_Response {
        <CSteamTV_AddWordBan_Response as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_AddWordBan_Response {
    pub fn new() -> CSteamTV_AddWordBan_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CSteamTV_AddWordBan_Response {
    const NAME: &'static str = "CSteamTV_AddWordBan_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_AddWordBan_Response {
        CSteamTV_AddWordBan_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_AddWordBan_Response {
        static instance: CSteamTV_AddWordBan_Response = CSteamTV_AddWordBan_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Returns the list of banned keywords for this broadcast channel"]
// @@protoc_insertion_point(message:CSteamTV_GetWordBans_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetWordBans_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetWordBans_Request.broadcast_channel_id)
    pub broadcast_channel_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetWordBans_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetWordBans_Request {
    fn default() -> &'a CSteamTV_GetWordBans_Request {
        <CSteamTV_GetWordBans_Request as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_GetWordBans_Request {
    pub fn new() -> CSteamTV_GetWordBans_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_channel_id = 1;

    pub fn broadcast_channel_id(&self) -> u64 {
        self.broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_broadcast_channel_id(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_id(&self) -> bool {
        self.broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_id(&mut self, v: u64) {
        self.broadcast_channel_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSteamTV_GetWordBans_Request {
    const NAME: &'static str = "CSteamTV_GetWordBans_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_channel_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_channel_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast_channel_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetWordBans_Request {
        CSteamTV_GetWordBans_Request::new()
    }

    fn clear(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetWordBans_Request {
        static instance: CSteamTV_GetWordBans_Request = CSteamTV_GetWordBans_Request {
            broadcast_channel_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamTV_GetWordBans_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetWordBans_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetWordBans_Response.results)
    pub results: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetWordBans_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetWordBans_Response {
    fn default() -> &'a CSteamTV_GetWordBans_Response {
        <CSteamTV_GetWordBans_Response as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_GetWordBans_Response {
    pub fn new() -> CSteamTV_GetWordBans_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CSteamTV_GetWordBans_Response {
    const NAME: &'static str = "CSteamTV_GetWordBans_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.results.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.results {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.results {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetWordBans_Response {
        CSteamTV_GetWordBans_Response::new()
    }

    fn clear(&mut self) {
        self.results.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetWordBans_Response {
        static instance: CSteamTV_GetWordBans_Response = CSteamTV_GetWordBans_Response {
            results: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Joins the chat channel for a broadcast"]
// @@protoc_insertion_point(message:CSteamTV_JoinChat_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_JoinChat_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_JoinChat_Request.broadcast_channel_id)
    pub broadcast_channel_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_JoinChat_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_JoinChat_Request {
    fn default() -> &'a CSteamTV_JoinChat_Request {
        <CSteamTV_JoinChat_Request as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_JoinChat_Request {
    pub fn new() -> CSteamTV_JoinChat_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_channel_id = 1;

    pub fn broadcast_channel_id(&self) -> u64 {
        self.broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_broadcast_channel_id(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_id(&self) -> bool {
        self.broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_id(&mut self, v: u64) {
        self.broadcast_channel_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSteamTV_JoinChat_Request {
    const NAME: &'static str = "CSteamTV_JoinChat_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_channel_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_channel_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast_channel_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_JoinChat_Request {
        CSteamTV_JoinChat_Request::new()
    }

    fn clear(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_JoinChat_Request {
        static instance: CSteamTV_JoinChat_Request = CSteamTV_JoinChat_Request {
            broadcast_channel_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamTV_JoinChat_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_JoinChat_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_JoinChat_Response.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_JoinChat_Response.view_url_template)
    pub view_url_template: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_JoinChat_Response.flair_group_ids)
    pub flair_group_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_JoinChat_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_JoinChat_Response {
    fn default() -> &'a CSteamTV_JoinChat_Response {
        <CSteamTV_JoinChat_Response as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_JoinChat_Response {
    pub fn new() -> CSteamTV_JoinChat_Response {
        ::std::default::Default::default()
    }

    // optional fixed64 chat_id = 1;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional string view_url_template = 2;

    pub fn view_url_template(&self) -> &str {
        match self.view_url_template.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_view_url_template(&mut self) {
        self.view_url_template = ::std::option::Option::None;
    }

    pub fn has_view_url_template(&self) -> bool {
        self.view_url_template.is_some()
    }

    // Param is passed by value, moved
    pub fn set_view_url_template(&mut self, v: ::std::string::String) {
        self.view_url_template = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_view_url_template(&mut self) -> &mut ::std::string::String {
        if self.view_url_template.is_none() {
            self.view_url_template = ::std::option::Option::Some(::std::string::String::new());
        }
        self.view_url_template.as_mut().unwrap()
    }

    // Take field
    pub fn take_view_url_template(&mut self) -> ::std::string::String {
        self.view_url_template.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CSteamTV_JoinChat_Response {
    const NAME: &'static str = "CSteamTV_JoinChat_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.chat_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    self.view_url_template = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    is.read_repeated_packed_uint64_into(&mut self.flair_group_ids)?;
                },
                24 => {
                    self.flair_group_ids.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.view_url_template.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.flair_group_ids {
            my_size += ::protobuf::rt::uint64_size(3, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.view_url_template.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.flair_group_ids {
            os.write_uint64(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_JoinChat_Response {
        CSteamTV_JoinChat_Response::new()
    }

    fn clear(&mut self) {
        self.chat_id = ::std::option::Option::None;
        self.view_url_template = ::std::option::Option::None;
        self.flair_group_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_JoinChat_Response {
        static instance: CSteamTV_JoinChat_Response = CSteamTV_JoinChat_Response {
            chat_id: ::std::option::Option::None,
            view_url_template: ::std::option::Option::None,
            flair_group_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Searches for broadcast channels based on input keywords"]
// @@protoc_insertion_point(message:CSteamTV_Search_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_Search_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_Search_Request.term)
    pub term: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_Search_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_Search_Request {
    fn default() -> &'a CSteamTV_Search_Request {
        <CSteamTV_Search_Request as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_Search_Request {
    pub fn new() -> CSteamTV_Search_Request {
        ::std::default::Default::default()
    }

    // optional string term = 1;

    pub fn term(&self) -> &str {
        match self.term.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_term(&mut self) {
        self.term = ::std::option::Option::None;
    }

    pub fn has_term(&self) -> bool {
        self.term.is_some()
    }

    // Param is passed by value, moved
    pub fn set_term(&mut self, v: ::std::string::String) {
        self.term = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_term(&mut self) -> &mut ::std::string::String {
        if self.term.is_none() {
            self.term = ::std::option::Option::Some(::std::string::String::new());
        }
        self.term.as_mut().unwrap()
    }

    // Take field
    pub fn take_term(&mut self) -> ::std::string::String {
        self.term.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CSteamTV_Search_Request {
    const NAME: &'static str = "CSteamTV_Search_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.term = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.term.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.term.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_Search_Request {
        CSteamTV_Search_Request::new()
    }

    fn clear(&mut self) {
        self.term = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_Search_Request {
        static instance: CSteamTV_Search_Request = CSteamTV_Search_Request {
            term: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamTV_Search_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_Search_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_Search_Response.results)
    pub results: ::std::vec::Vec<GetBroadcastChannelEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_Search_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_Search_Response {
    fn default() -> &'a CSteamTV_Search_Response {
        <CSteamTV_Search_Response as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_Search_Response {
    pub fn new() -> CSteamTV_Search_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CSteamTV_Search_Response {
    const NAME: &'static str = "CSteamTV_Search_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.results.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.results {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_Search_Response {
        CSteamTV_Search_Response::new()
    }

    fn clear(&mut self) {
        self.results.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_Search_Response {
        static instance: CSteamTV_Search_Response = CSteamTV_Search_Response {
            results: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Returns a user's SteamTV settings"]
// @@protoc_insertion_point(message:CSteamTV_GetSteamTVUserSettings_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetSteamTVUserSettings_Request {
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetSteamTVUserSettings_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetSteamTVUserSettings_Request {
    fn default() -> &'a CSteamTV_GetSteamTVUserSettings_Request {
        <CSteamTV_GetSteamTVUserSettings_Request as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_GetSteamTVUserSettings_Request {
    pub fn new() -> CSteamTV_GetSteamTVUserSettings_Request {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CSteamTV_GetSteamTVUserSettings_Request {
    const NAME: &'static str = "CSteamTV_GetSteamTVUserSettings_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetSteamTVUserSettings_Request {
        CSteamTV_GetSteamTVUserSettings_Request::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetSteamTVUserSettings_Request {
        static instance: CSteamTV_GetSteamTVUserSettings_Request = CSteamTV_GetSteamTVUserSettings_Request {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamTV_GetSteamTVUserSettings_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetSteamTVUserSettings_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetSteamTVUserSettings_Response.stream_live_email)
    pub stream_live_email: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamTV_GetSteamTVUserSettings_Response.stream_live_notification)
    pub stream_live_notification: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetSteamTVUserSettings_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetSteamTVUserSettings_Response {
    fn default() -> &'a CSteamTV_GetSteamTVUserSettings_Response {
        <CSteamTV_GetSteamTVUserSettings_Response as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_GetSteamTVUserSettings_Response {
    pub fn new() -> CSteamTV_GetSteamTVUserSettings_Response {
        ::std::default::Default::default()
    }

    // optional bool stream_live_email = 1;

    pub fn stream_live_email(&self) -> bool {
        self.stream_live_email.unwrap_or(false)
    }

    pub fn clear_stream_live_email(&mut self) {
        self.stream_live_email = ::std::option::Option::None;
    }

    pub fn has_stream_live_email(&self) -> bool {
        self.stream_live_email.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stream_live_email(&mut self, v: bool) {
        self.stream_live_email = ::std::option::Option::Some(v);
    }

    // optional bool stream_live_notification = 2;

    pub fn stream_live_notification(&self) -> bool {
        self.stream_live_notification.unwrap_or(false)
    }

    pub fn clear_stream_live_notification(&mut self) {
        self.stream_live_notification = ::std::option::Option::None;
    }

    pub fn has_stream_live_notification(&self) -> bool {
        self.stream_live_notification.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stream_live_notification(&mut self, v: bool) {
        self.stream_live_notification = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSteamTV_GetSteamTVUserSettings_Response {
    const NAME: &'static str = "CSteamTV_GetSteamTVUserSettings_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.stream_live_email = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.stream_live_notification = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.stream_live_email {
            my_size += 1 + 1;
        }
        if let Some(v) = self.stream_live_notification {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.stream_live_email {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.stream_live_notification {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetSteamTVUserSettings_Response {
        CSteamTV_GetSteamTVUserSettings_Response::new()
    }

    fn clear(&mut self) {
        self.stream_live_email = ::std::option::Option::None;
        self.stream_live_notification = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetSteamTVUserSettings_Response {
        static instance: CSteamTV_GetSteamTVUserSettings_Response = CSteamTV_GetSteamTVUserSettings_Response {
            stream_live_email: ::std::option::Option::None,
            stream_live_notification: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Sets a user's SteamTV settings"]
// @@protoc_insertion_point(message:CSteamTV_SetSteamTVUserSettings_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_SetSteamTVUserSettings_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_SetSteamTVUserSettings_Request.stream_live_email)
    pub stream_live_email: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamTV_SetSteamTVUserSettings_Request.stream_live_notification)
    pub stream_live_notification: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_SetSteamTVUserSettings_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_SetSteamTVUserSettings_Request {
    fn default() -> &'a CSteamTV_SetSteamTVUserSettings_Request {
        <CSteamTV_SetSteamTVUserSettings_Request as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_SetSteamTVUserSettings_Request {
    pub fn new() -> CSteamTV_SetSteamTVUserSettings_Request {
        ::std::default::Default::default()
    }

    // optional bool stream_live_email = 1;

    pub fn stream_live_email(&self) -> bool {
        self.stream_live_email.unwrap_or(false)
    }

    pub fn clear_stream_live_email(&mut self) {
        self.stream_live_email = ::std::option::Option::None;
    }

    pub fn has_stream_live_email(&self) -> bool {
        self.stream_live_email.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stream_live_email(&mut self, v: bool) {
        self.stream_live_email = ::std::option::Option::Some(v);
    }

    // optional bool stream_live_notification = 2;

    pub fn stream_live_notification(&self) -> bool {
        self.stream_live_notification.unwrap_or(false)
    }

    pub fn clear_stream_live_notification(&mut self) {
        self.stream_live_notification = ::std::option::Option::None;
    }

    pub fn has_stream_live_notification(&self) -> bool {
        self.stream_live_notification.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stream_live_notification(&mut self, v: bool) {
        self.stream_live_notification = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSteamTV_SetSteamTVUserSettings_Request {
    const NAME: &'static str = "CSteamTV_SetSteamTVUserSettings_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.stream_live_email = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.stream_live_notification = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.stream_live_email {
            my_size += 1 + 1;
        }
        if let Some(v) = self.stream_live_notification {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.stream_live_email {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.stream_live_notification {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_SetSteamTVUserSettings_Request {
        CSteamTV_SetSteamTVUserSettings_Request::new()
    }

    fn clear(&mut self) {
        self.stream_live_email = ::std::option::Option::None;
        self.stream_live_notification = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_SetSteamTVUserSettings_Request {
        static instance: CSteamTV_SetSteamTVUserSettings_Request = CSteamTV_SetSteamTVUserSettings_Request {
            stream_live_email: ::std::option::Option::None,
            stream_live_notification: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamTV_SetSteamTVUserSettings_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_SetSteamTVUserSettings_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_SetSteamTVUserSettings_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_SetSteamTVUserSettings_Response {
    fn default() -> &'a CSteamTV_SetSteamTVUserSettings_Response {
        <CSteamTV_SetSteamTVUserSettings_Response as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_SetSteamTVUserSettings_Response {
    pub fn new() -> CSteamTV_SetSteamTVUserSettings_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CSteamTV_SetSteamTVUserSettings_Response {
    const NAME: &'static str = "CSteamTV_SetSteamTVUserSettings_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_SetSteamTVUserSettings_Response {
        CSteamTV_SetSteamTVUserSettings_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_SetSteamTVUserSettings_Response {
        static instance: CSteamTV_SetSteamTVUserSettings_Response = CSteamTV_SetSteamTVUserSettings_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Gets the broadcast channels that the current user owns"]
// @@protoc_insertion_point(message:CSteamTV_GetMyBroadcastChannels_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetMyBroadcastChannels_Request {
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetMyBroadcastChannels_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetMyBroadcastChannels_Request {
    fn default() -> &'a CSteamTV_GetMyBroadcastChannels_Request {
        <CSteamTV_GetMyBroadcastChannels_Request as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_GetMyBroadcastChannels_Request {
    pub fn new() -> CSteamTV_GetMyBroadcastChannels_Request {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CSteamTV_GetMyBroadcastChannels_Request {
    const NAME: &'static str = "CSteamTV_GetMyBroadcastChannels_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetMyBroadcastChannels_Request {
        CSteamTV_GetMyBroadcastChannels_Request::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetMyBroadcastChannels_Request {
        static instance: CSteamTV_GetMyBroadcastChannels_Request = CSteamTV_GetMyBroadcastChannels_Request {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamTV_GetMyBroadcastChannels_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetMyBroadcastChannels_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetMyBroadcastChannels_Response.results)
    pub results: ::std::vec::Vec<GetBroadcastChannelEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetMyBroadcastChannels_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetMyBroadcastChannels_Response {
    fn default() -> &'a CSteamTV_GetMyBroadcastChannels_Response {
        <CSteamTV_GetMyBroadcastChannels_Response as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_GetMyBroadcastChannels_Response {
    pub fn new() -> CSteamTV_GetMyBroadcastChannels_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CSteamTV_GetMyBroadcastChannels_Response {
    const NAME: &'static str = "CSteamTV_GetMyBroadcastChannels_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.results.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.results {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetMyBroadcastChannels_Response {
        CSteamTV_GetMyBroadcastChannels_Response::new()
    }

    fn clear(&mut self) {
        self.results.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetMyBroadcastChannels_Response {
        static instance: CSteamTV_GetMyBroadcastChannels_Response = CSteamTV_GetMyBroadcastChannels_Response {
            results: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Returns homepage contents for user"]
// @@protoc_insertion_point(message:CSteamTV_GetHomePageContents_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetHomePageContents_Request {
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetHomePageContents_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetHomePageContents_Request {
    fn default() -> &'a CSteamTV_GetHomePageContents_Request {
        <CSteamTV_GetHomePageContents_Request as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_GetHomePageContents_Request {
    pub fn new() -> CSteamTV_GetHomePageContents_Request {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CSteamTV_GetHomePageContents_Request {
    const NAME: &'static str = "CSteamTV_GetHomePageContents_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetHomePageContents_Request {
        CSteamTV_GetHomePageContents_Request::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetHomePageContents_Request {
        static instance: CSteamTV_GetHomePageContents_Request = CSteamTV_GetHomePageContents_Request {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamTV_HomePageTemplate_Takeover)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_HomePageTemplate_Takeover {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_HomePageTemplate_Takeover.broadcasts)
    pub broadcasts: ::std::vec::Vec<GetBroadcastChannelEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_HomePageTemplate_Takeover.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_HomePageTemplate_Takeover {
    fn default() -> &'a CSteamTV_HomePageTemplate_Takeover {
        <CSteamTV_HomePageTemplate_Takeover as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_HomePageTemplate_Takeover {
    pub fn new() -> CSteamTV_HomePageTemplate_Takeover {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CSteamTV_HomePageTemplate_Takeover {
    const NAME: &'static str = "CSteamTV_HomePageTemplate_Takeover";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.broadcasts.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.broadcasts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.broadcasts {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_HomePageTemplate_Takeover {
        CSteamTV_HomePageTemplate_Takeover::new()
    }

    fn clear(&mut self) {
        self.broadcasts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_HomePageTemplate_Takeover {
        static instance: CSteamTV_HomePageTemplate_Takeover = CSteamTV_HomePageTemplate_Takeover {
            broadcasts: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamTV_HomePageTemplate_SingleGame)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_HomePageTemplate_SingleGame {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_HomePageTemplate_SingleGame.broadcasts)
    pub broadcasts: ::std::vec::Vec<GetBroadcastChannelEntry>,
    // @@protoc_insertion_point(field:CSteamTV_HomePageTemplate_SingleGame.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSteamTV_HomePageTemplate_SingleGame.title)
    pub title: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_HomePageTemplate_SingleGame.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_HomePageTemplate_SingleGame {
    fn default() -> &'a CSteamTV_HomePageTemplate_SingleGame {
        <CSteamTV_HomePageTemplate_SingleGame as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_HomePageTemplate_SingleGame {
    pub fn new() -> CSteamTV_HomePageTemplate_SingleGame {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 2;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string title = 3;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CSteamTV_HomePageTemplate_SingleGame {
    const NAME: &'static str = "CSteamTV_HomePageTemplate_SingleGame";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.broadcasts.push(is.read_message()?);
                },
                16 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.broadcasts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.broadcasts {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.appid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_HomePageTemplate_SingleGame {
        CSteamTV_HomePageTemplate_SingleGame::new()
    }

    fn clear(&mut self) {
        self.broadcasts.clear();
        self.appid = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_HomePageTemplate_SingleGame {
        static instance: CSteamTV_HomePageTemplate_SingleGame = CSteamTV_HomePageTemplate_SingleGame {
            broadcasts: ::std::vec::Vec::new(),
            appid: ::std::option::Option::None,
            title: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:GameListEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GameListEntry {
    // message fields
    // @@protoc_insertion_point(field:GameListEntry.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:GameListEntry.game_name)
    pub game_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:GameListEntry.broadcast)
    pub broadcast: ::protobuf::MessageField<GetBroadcastChannelEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:GameListEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GameListEntry {
    fn default() -> &'a GameListEntry {
        <GameListEntry as ::protobuf::Message>::default_instance()
    }
}

impl GameListEntry {
    pub fn new() -> GameListEntry {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string game_name = 2;

    pub fn game_name(&self) -> &str {
        match self.game_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_name(&mut self) {
        self.game_name = ::std::option::Option::None;
    }

    pub fn has_game_name(&self) -> bool {
        self.game_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_name(&mut self, v: ::std::string::String) {
        self.game_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_name(&mut self) -> &mut ::std::string::String {
        if self.game_name.is_none() {
            self.game_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_name(&mut self) -> ::std::string::String {
        self.game_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GameListEntry {
    const NAME: &'static str = "GameListEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.game_name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.broadcast)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.game_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.broadcast.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.game_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.broadcast.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GameListEntry {
        GameListEntry::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.game_name = ::std::option::Option::None;
        self.broadcast.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GameListEntry {
        static instance: GameListEntry = GameListEntry {
            appid: ::std::option::Option::None,
            game_name: ::std::option::Option::None,
            broadcast: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamTV_HomePageTemplate_GameList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_HomePageTemplate_GameList {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_HomePageTemplate_GameList.entries)
    pub entries: ::std::vec::Vec<GameListEntry>,
    // @@protoc_insertion_point(field:CSteamTV_HomePageTemplate_GameList.title)
    pub title: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_HomePageTemplate_GameList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_HomePageTemplate_GameList {
    fn default() -> &'a CSteamTV_HomePageTemplate_GameList {
        <CSteamTV_HomePageTemplate_GameList as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_HomePageTemplate_GameList {
    pub fn new() -> CSteamTV_HomePageTemplate_GameList {
        ::std::default::Default::default()
    }

    // optional string title = 2;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CSteamTV_HomePageTemplate_GameList {
    const NAME: &'static str = "CSteamTV_HomePageTemplate_GameList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.entries.push(is.read_message()?);
                },
                18 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.entries {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.title.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_HomePageTemplate_GameList {
        CSteamTV_HomePageTemplate_GameList::new()
    }

    fn clear(&mut self) {
        self.entries.clear();
        self.title = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_HomePageTemplate_GameList {
        static instance: CSteamTV_HomePageTemplate_GameList = CSteamTV_HomePageTemplate_GameList {
            entries: ::std::vec::Vec::new(),
            title: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamTV_HomePageTemplate_QuickExplore)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_HomePageTemplate_QuickExplore {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_HomePageTemplate_QuickExplore.broadcasts)
    pub broadcasts: ::std::vec::Vec<GetBroadcastChannelEntry>,
    // @@protoc_insertion_point(field:CSteamTV_HomePageTemplate_QuickExplore.title)
    pub title: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_HomePageTemplate_QuickExplore.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_HomePageTemplate_QuickExplore {
    fn default() -> &'a CSteamTV_HomePageTemplate_QuickExplore {
        <CSteamTV_HomePageTemplate_QuickExplore as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_HomePageTemplate_QuickExplore {
    pub fn new() -> CSteamTV_HomePageTemplate_QuickExplore {
        ::std::default::Default::default()
    }

    // optional string title = 2;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CSteamTV_HomePageTemplate_QuickExplore {
    const NAME: &'static str = "CSteamTV_HomePageTemplate_QuickExplore";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.broadcasts.push(is.read_message()?);
                },
                18 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.broadcasts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.broadcasts {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.title.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_HomePageTemplate_QuickExplore {
        CSteamTV_HomePageTemplate_QuickExplore::new()
    }

    fn clear(&mut self) {
        self.broadcasts.clear();
        self.title = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_HomePageTemplate_QuickExplore {
        static instance: CSteamTV_HomePageTemplate_QuickExplore = CSteamTV_HomePageTemplate_QuickExplore {
            broadcasts: ::std::vec::Vec::new(),
            title: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamTV_HomePageTemplate_ConveyorBelt)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_HomePageTemplate_ConveyorBelt {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_HomePageTemplate_ConveyorBelt.broadcasts)
    pub broadcasts: ::std::vec::Vec<GetBroadcastChannelEntry>,
    // @@protoc_insertion_point(field:CSteamTV_HomePageTemplate_ConveyorBelt.title)
    pub title: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_HomePageTemplate_ConveyorBelt.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_HomePageTemplate_ConveyorBelt {
    fn default() -> &'a CSteamTV_HomePageTemplate_ConveyorBelt {
        <CSteamTV_HomePageTemplate_ConveyorBelt as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_HomePageTemplate_ConveyorBelt {
    pub fn new() -> CSteamTV_HomePageTemplate_ConveyorBelt {
        ::std::default::Default::default()
    }

    // optional string title = 2;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CSteamTV_HomePageTemplate_ConveyorBelt {
    const NAME: &'static str = "CSteamTV_HomePageTemplate_ConveyorBelt";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.broadcasts.push(is.read_message()?);
                },
                18 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.broadcasts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.broadcasts {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.title.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_HomePageTemplate_ConveyorBelt {
        CSteamTV_HomePageTemplate_ConveyorBelt::new()
    }

    fn clear(&mut self) {
        self.broadcasts.clear();
        self.title = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_HomePageTemplate_ConveyorBelt {
        static instance: CSteamTV_HomePageTemplate_ConveyorBelt = CSteamTV_HomePageTemplate_ConveyorBelt {
            broadcasts: ::std::vec::Vec::new(),
            title: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamTV_HomePageTemplate_WatchParty)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_HomePageTemplate_WatchParty {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_HomePageTemplate_WatchParty.broadcast)
    pub broadcast: ::protobuf::MessageField<GetBroadcastChannelEntry>,
    // @@protoc_insertion_point(field:CSteamTV_HomePageTemplate_WatchParty.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_HomePageTemplate_WatchParty.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_HomePageTemplate_WatchParty.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_HomePageTemplate_WatchParty {
    fn default() -> &'a CSteamTV_HomePageTemplate_WatchParty {
        <CSteamTV_HomePageTemplate_WatchParty as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_HomePageTemplate_WatchParty {
    pub fn new() -> CSteamTV_HomePageTemplate_WatchParty {
        ::std::default::Default::default()
    }

    // optional string title = 2;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 chat_group_id = 3;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSteamTV_HomePageTemplate_WatchParty {
    const NAME: &'static str = "CSteamTV_HomePageTemplate_WatchParty";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.broadcast)?;
                },
                18 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.chat_group_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_HomePageTemplate_WatchParty {
        CSteamTV_HomePageTemplate_WatchParty::new()
    }

    fn clear(&mut self) {
        self.broadcast.clear();
        self.title = ::std::option::Option::None;
        self.chat_group_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_HomePageTemplate_WatchParty {
        static instance: CSteamTV_HomePageTemplate_WatchParty = CSteamTV_HomePageTemplate_WatchParty {
            broadcast: ::protobuf::MessageField::none(),
            title: ::std::option::Option::None,
            chat_group_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamTV_HomePageTemplate_Developer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_HomePageTemplate_Developer {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_HomePageTemplate_Developer.broadcast)
    pub broadcast: ::protobuf::MessageField<GetBroadcastChannelEntry>,
    // @@protoc_insertion_point(field:CSteamTV_HomePageTemplate_Developer.title)
    pub title: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_HomePageTemplate_Developer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_HomePageTemplate_Developer {
    fn default() -> &'a CSteamTV_HomePageTemplate_Developer {
        <CSteamTV_HomePageTemplate_Developer as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_HomePageTemplate_Developer {
    pub fn new() -> CSteamTV_HomePageTemplate_Developer {
        ::std::default::Default::default()
    }

    // optional string title = 2;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CSteamTV_HomePageTemplate_Developer {
    const NAME: &'static str = "CSteamTV_HomePageTemplate_Developer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.broadcast)?;
                },
                18 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_HomePageTemplate_Developer {
        CSteamTV_HomePageTemplate_Developer::new()
    }

    fn clear(&mut self) {
        self.broadcast.clear();
        self.title = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_HomePageTemplate_Developer {
        static instance: CSteamTV_HomePageTemplate_Developer = CSteamTV_HomePageTemplate_Developer {
            broadcast: ::protobuf::MessageField::none(),
            title: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamTV_HomePageTemplate_Event)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_HomePageTemplate_Event {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_HomePageTemplate_Event.title)
    pub title: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_HomePageTemplate_Event.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_HomePageTemplate_Event {
    fn default() -> &'a CSteamTV_HomePageTemplate_Event {
        <CSteamTV_HomePageTemplate_Event as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_HomePageTemplate_Event {
    pub fn new() -> CSteamTV_HomePageTemplate_Event {
        ::std::default::Default::default()
    }

    // optional string title = 1;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CSteamTV_HomePageTemplate_Event {
    const NAME: &'static str = "CSteamTV_HomePageTemplate_Event";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.title.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_HomePageTemplate_Event {
        CSteamTV_HomePageTemplate_Event::new()
    }

    fn clear(&mut self) {
        self.title = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_HomePageTemplate_Event {
        static instance: CSteamTV_HomePageTemplate_Event = CSteamTV_HomePageTemplate_Event {
            title: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamTV_HomePageContentRow)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_HomePageContentRow {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_HomePageContentRow.template_type)
    pub template_type: ::std::option::Option<::protobuf::EnumOrUnknown<ESteamTVContentTemplate>>,
    // @@protoc_insertion_point(field:CSteamTV_HomePageContentRow.takeover)
    pub takeover: ::protobuf::MessageField<CSteamTV_HomePageTemplate_Takeover>,
    // @@protoc_insertion_point(field:CSteamTV_HomePageContentRow.single_game)
    pub single_game: ::protobuf::MessageField<CSteamTV_HomePageTemplate_SingleGame>,
    // @@protoc_insertion_point(field:CSteamTV_HomePageContentRow.game_list)
    pub game_list: ::protobuf::MessageField<CSteamTV_HomePageTemplate_GameList>,
    // @@protoc_insertion_point(field:CSteamTV_HomePageContentRow.quick_explore)
    pub quick_explore: ::protobuf::MessageField<CSteamTV_HomePageTemplate_QuickExplore>,
    // @@protoc_insertion_point(field:CSteamTV_HomePageContentRow.conveyor_belt)
    pub conveyor_belt: ::protobuf::MessageField<CSteamTV_HomePageTemplate_ConveyorBelt>,
    // @@protoc_insertion_point(field:CSteamTV_HomePageContentRow.watch_party)
    pub watch_party: ::protobuf::MessageField<CSteamTV_HomePageTemplate_WatchParty>,
    // @@protoc_insertion_point(field:CSteamTV_HomePageContentRow.developer)
    pub developer: ::protobuf::MessageField<CSteamTV_HomePageTemplate_Developer>,
    // @@protoc_insertion_point(field:CSteamTV_HomePageContentRow.event)
    pub event: ::protobuf::MessageField<CSteamTV_HomePageTemplate_Event>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_HomePageContentRow.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_HomePageContentRow {
    fn default() -> &'a CSteamTV_HomePageContentRow {
        <CSteamTV_HomePageContentRow as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_HomePageContentRow {
    pub fn new() -> CSteamTV_HomePageContentRow {
        ::std::default::Default::default()
    }

    // optional .ESteamTVContentTemplate template_type = 1;

    pub fn template_type(&self) -> ESteamTVContentTemplate {
        match self.template_type {
            Some(e) => e.enum_value_or(ESteamTVContentTemplate::k_ESteamTVContentTemplate_Invalid),
            None => ESteamTVContentTemplate::k_ESteamTVContentTemplate_Invalid,
        }
    }

    pub fn clear_template_type(&mut self) {
        self.template_type = ::std::option::Option::None;
    }

    pub fn has_template_type(&self) -> bool {
        self.template_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_template_type(&mut self, v: ESteamTVContentTemplate) {
        self.template_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::protobuf::Message for CSteamTV_HomePageContentRow {
    const NAME: &'static str = "CSteamTV_HomePageContentRow";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.template_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.takeover)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.single_game)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.game_list)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.quick_explore)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.conveyor_belt)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.watch_party)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.developer)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.event)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.template_type {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.takeover.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.single_game.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.game_list.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.quick_explore.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.conveyor_belt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.watch_party.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.developer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.event.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.template_type {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.takeover.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.single_game.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.game_list.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.quick_explore.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.conveyor_belt.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.watch_party.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.developer.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.event.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_HomePageContentRow {
        CSteamTV_HomePageContentRow::new()
    }

    fn clear(&mut self) {
        self.template_type = ::std::option::Option::None;
        self.takeover.clear();
        self.single_game.clear();
        self.game_list.clear();
        self.quick_explore.clear();
        self.conveyor_belt.clear();
        self.watch_party.clear();
        self.developer.clear();
        self.event.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_HomePageContentRow {
        static instance: CSteamTV_HomePageContentRow = CSteamTV_HomePageContentRow {
            template_type: ::std::option::Option::None,
            takeover: ::protobuf::MessageField::none(),
            single_game: ::protobuf::MessageField::none(),
            game_list: ::protobuf::MessageField::none(),
            quick_explore: ::protobuf::MessageField::none(),
            conveyor_belt: ::protobuf::MessageField::none(),
            watch_party: ::protobuf::MessageField::none(),
            developer: ::protobuf::MessageField::none(),
            event: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamTV_GetHomePageContents_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetHomePageContents_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetHomePageContents_Response.rows)
    pub rows: ::std::vec::Vec<CSteamTV_HomePageContentRow>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetHomePageContents_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetHomePageContents_Response {
    fn default() -> &'a CSteamTV_GetHomePageContents_Response {
        <CSteamTV_GetHomePageContents_Response as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_GetHomePageContents_Response {
    pub fn new() -> CSteamTV_GetHomePageContents_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CSteamTV_GetHomePageContents_Response {
    const NAME: &'static str = "CSteamTV_GetHomePageContents_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.rows.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.rows {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.rows {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetHomePageContents_Response {
        CSteamTV_GetHomePageContents_Response::new()
    }

    fn clear(&mut self) {
        self.rows.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetHomePageContents_Response {
        static instance: CSteamTV_GetHomePageContents_Response = CSteamTV_GetHomePageContents_Response {
            rows: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamTV_AppCheer_SingleCheerType)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_AppCheer_SingleCheerType {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_AppCheer_SingleCheerType.cheer_type)
    pub cheer_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSteamTV_AppCheer_SingleCheerType.cheer_amount)
    pub cheer_amount: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_AppCheer_SingleCheerType.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_AppCheer_SingleCheerType {
    fn default() -> &'a CSteamTV_AppCheer_SingleCheerType {
        <CSteamTV_AppCheer_SingleCheerType as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_AppCheer_SingleCheerType {
    pub fn new() -> CSteamTV_AppCheer_SingleCheerType {
        ::std::default::Default::default()
    }

    // optional uint32 cheer_type = 1;

    pub fn cheer_type(&self) -> u32 {
        self.cheer_type.unwrap_or(0)
    }

    pub fn clear_cheer_type(&mut self) {
        self.cheer_type = ::std::option::Option::None;
    }

    pub fn has_cheer_type(&self) -> bool {
        self.cheer_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cheer_type(&mut self, v: u32) {
        self.cheer_type = ::std::option::Option::Some(v);
    }

    // optional uint32 cheer_amount = 2;

    pub fn cheer_amount(&self) -> u32 {
        self.cheer_amount.unwrap_or(0)
    }

    pub fn clear_cheer_amount(&mut self) {
        self.cheer_amount = ::std::option::Option::None;
    }

    pub fn has_cheer_amount(&self) -> bool {
        self.cheer_amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cheer_amount(&mut self, v: u32) {
        self.cheer_amount = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSteamTV_AppCheer_SingleCheerType {
    const NAME: &'static str = "CSteamTV_AppCheer_SingleCheerType";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.cheer_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.cheer_amount = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cheer_type {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.cheer_amount {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cheer_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.cheer_amount {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_AppCheer_SingleCheerType {
        CSteamTV_AppCheer_SingleCheerType::new()
    }

    fn clear(&mut self) {
        self.cheer_type = ::std::option::Option::None;
        self.cheer_amount = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_AppCheer_SingleCheerType {
        static instance: CSteamTV_AppCheer_SingleCheerType = CSteamTV_AppCheer_SingleCheerType {
            cheer_type: ::std::option::Option::None,
            cheer_amount: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "The user is cheering for a specific broadcast for a specific app."]
// @@protoc_insertion_point(message:CSteamTV_AppCheer_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_AppCheer_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_AppCheer_Request.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSteamTV_AppCheer_Request.cheer_target_id)
    pub cheer_target_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_AppCheer_Request.cheers)
    pub cheers: ::std::vec::Vec<CSteamTV_AppCheer_SingleCheerType>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_AppCheer_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_AppCheer_Request {
    fn default() -> &'a CSteamTV_AppCheer_Request {
        <CSteamTV_AppCheer_Request as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_AppCheer_Request {
    pub fn new() -> CSteamTV_AppCheer_Request {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 cheer_target_id = 2;

    pub fn cheer_target_id(&self) -> u64 {
        self.cheer_target_id.unwrap_or(0)
    }

    pub fn clear_cheer_target_id(&mut self) {
        self.cheer_target_id = ::std::option::Option::None;
    }

    pub fn has_cheer_target_id(&self) -> bool {
        self.cheer_target_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cheer_target_id(&mut self, v: u64) {
        self.cheer_target_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSteamTV_AppCheer_Request {
    const NAME: &'static str = "CSteamTV_AppCheer_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.cheer_target_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    self.cheers.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.cheer_target_id {
            my_size += 1 + 8;
        }
        for value in &self.cheers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.cheer_target_id {
            os.write_fixed64(2, v)?;
        }
        for v in &self.cheers {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_AppCheer_Request {
        CSteamTV_AppCheer_Request::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.cheer_target_id = ::std::option::Option::None;
        self.cheers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_AppCheer_Request {
        static instance: CSteamTV_AppCheer_Request = CSteamTV_AppCheer_Request {
            app_id: ::std::option::Option::None,
            cheer_target_id: ::std::option::Option::None,
            cheers: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamTV_AppCheer_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_AppCheer_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_AppCheer_Response.aggregation_delay_ms)
    pub aggregation_delay_ms: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_AppCheer_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_AppCheer_Response {
    fn default() -> &'a CSteamTV_AppCheer_Response {
        <CSteamTV_AppCheer_Response as ::protobuf::Message>::default_instance()
    }
}

impl CSteamTV_AppCheer_Response {
    pub fn new() -> CSteamTV_AppCheer_Response {
        ::std::default::Default::default()
    }

    // optional uint32 aggregation_delay_ms = 1;

    pub fn aggregation_delay_ms(&self) -> u32 {
        self.aggregation_delay_ms.unwrap_or(0)
    }

    pub fn clear_aggregation_delay_ms(&mut self) {
        self.aggregation_delay_ms = ::std::option::Option::None;
    }

    pub fn has_aggregation_delay_ms(&self) -> bool {
        self.aggregation_delay_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_aggregation_delay_ms(&mut self, v: u32) {
        self.aggregation_delay_ms = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSteamTV_AppCheer_Response {
    const NAME: &'static str = "CSteamTV_AppCheer_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.aggregation_delay_ms = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.aggregation_delay_ms {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.aggregation_delay_ms {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_AppCheer_Response {
        CSteamTV_AppCheer_Response::new()
    }

    fn clear(&mut self) {
        self.aggregation_delay_ms = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_AppCheer_Response {
        static instance: CSteamTV_AppCheer_Response = CSteamTV_AppCheer_Response {
            aggregation_delay_ms: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EBroadcastImageType)
pub enum EBroadcastImageType {
    // @@protoc_insertion_point(enum_value:EBroadcastImageType.k_EBroadcastImageType_None)
    k_EBroadcastImageType_None = 0,
    // @@protoc_insertion_point(enum_value:EBroadcastImageType.k_EBroadcastImageType_Offline)
    k_EBroadcastImageType_Offline = 1,
    // @@protoc_insertion_point(enum_value:EBroadcastImageType.k_EBroadcastImageType_Standby)
    k_EBroadcastImageType_Standby = 2,
    // @@protoc_insertion_point(enum_value:EBroadcastImageType.k_EBroadcastImageType_Avatar)
    k_EBroadcastImageType_Avatar = 3,
    // @@protoc_insertion_point(enum_value:EBroadcastImageType.k_EBroadcastImageType_Summary)
    k_EBroadcastImageType_Summary = 4,
    // @@protoc_insertion_point(enum_value:EBroadcastImageType.k_EBroadcastImageType_Background)
    k_EBroadcastImageType_Background = 5,
    // @@protoc_insertion_point(enum_value:EBroadcastImageType.k_EBroadcastImageType_Emoticon)
    k_EBroadcastImageType_Emoticon = 6,
}

impl ::protobuf::Enum for EBroadcastImageType {
    const NAME: &'static str = "EBroadcastImageType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EBroadcastImageType> {
        match value {
            0 => ::std::option::Option::Some(EBroadcastImageType::k_EBroadcastImageType_None),
            1 => ::std::option::Option::Some(EBroadcastImageType::k_EBroadcastImageType_Offline),
            2 => ::std::option::Option::Some(EBroadcastImageType::k_EBroadcastImageType_Standby),
            3 => ::std::option::Option::Some(EBroadcastImageType::k_EBroadcastImageType_Avatar),
            4 => ::std::option::Option::Some(EBroadcastImageType::k_EBroadcastImageType_Summary),
            5 => ::std::option::Option::Some(EBroadcastImageType::k_EBroadcastImageType_Background),
            6 => ::std::option::Option::Some(EBroadcastImageType::k_EBroadcastImageType_Emoticon),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EBroadcastImageType> {
        match str {
            "k_EBroadcastImageType_None" => ::std::option::Option::Some(EBroadcastImageType::k_EBroadcastImageType_None),
            "k_EBroadcastImageType_Offline" => ::std::option::Option::Some(EBroadcastImageType::k_EBroadcastImageType_Offline),
            "k_EBroadcastImageType_Standby" => ::std::option::Option::Some(EBroadcastImageType::k_EBroadcastImageType_Standby),
            "k_EBroadcastImageType_Avatar" => ::std::option::Option::Some(EBroadcastImageType::k_EBroadcastImageType_Avatar),
            "k_EBroadcastImageType_Summary" => ::std::option::Option::Some(EBroadcastImageType::k_EBroadcastImageType_Summary),
            "k_EBroadcastImageType_Background" => ::std::option::Option::Some(EBroadcastImageType::k_EBroadcastImageType_Background),
            "k_EBroadcastImageType_Emoticon" => ::std::option::Option::Some(EBroadcastImageType::k_EBroadcastImageType_Emoticon),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EBroadcastImageType] = &[
        EBroadcastImageType::k_EBroadcastImageType_None,
        EBroadcastImageType::k_EBroadcastImageType_Offline,
        EBroadcastImageType::k_EBroadcastImageType_Standby,
        EBroadcastImageType::k_EBroadcastImageType_Avatar,
        EBroadcastImageType::k_EBroadcastImageType_Summary,
        EBroadcastImageType::k_EBroadcastImageType_Background,
        EBroadcastImageType::k_EBroadcastImageType_Emoticon,
    ];
}

impl ::std::default::Default for EBroadcastImageType {
    fn default() -> Self {
        EBroadcastImageType::k_EBroadcastImageType_None
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EGetGamesAlgorithm)
pub enum EGetGamesAlgorithm {
    // @@protoc_insertion_point(enum_value:EGetGamesAlgorithm.k_EGetGamesAlgorithm_Default)
    k_EGetGamesAlgorithm_Default = 1,
    // @@protoc_insertion_point(enum_value:EGetGamesAlgorithm.k_EGetGamesAlgorithm_MostPlayed)
    k_EGetGamesAlgorithm_MostPlayed = 2,
    // @@protoc_insertion_point(enum_value:EGetGamesAlgorithm.k_EGetGamesAlgorithm_PopularNew)
    k_EGetGamesAlgorithm_PopularNew = 3,
}

impl ::protobuf::Enum for EGetGamesAlgorithm {
    const NAME: &'static str = "EGetGamesAlgorithm";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EGetGamesAlgorithm> {
        match value {
            1 => ::std::option::Option::Some(EGetGamesAlgorithm::k_EGetGamesAlgorithm_Default),
            2 => ::std::option::Option::Some(EGetGamesAlgorithm::k_EGetGamesAlgorithm_MostPlayed),
            3 => ::std::option::Option::Some(EGetGamesAlgorithm::k_EGetGamesAlgorithm_PopularNew),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EGetGamesAlgorithm> {
        match str {
            "k_EGetGamesAlgorithm_Default" => ::std::option::Option::Some(EGetGamesAlgorithm::k_EGetGamesAlgorithm_Default),
            "k_EGetGamesAlgorithm_MostPlayed" => ::std::option::Option::Some(EGetGamesAlgorithm::k_EGetGamesAlgorithm_MostPlayed),
            "k_EGetGamesAlgorithm_PopularNew" => ::std::option::Option::Some(EGetGamesAlgorithm::k_EGetGamesAlgorithm_PopularNew),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EGetGamesAlgorithm] = &[
        EGetGamesAlgorithm::k_EGetGamesAlgorithm_Default,
        EGetGamesAlgorithm::k_EGetGamesAlgorithm_MostPlayed,
        EGetGamesAlgorithm::k_EGetGamesAlgorithm_PopularNew,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EGetGamesAlgorithm {
    fn default() -> Self {
        EGetGamesAlgorithm::k_EGetGamesAlgorithm_Default
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EGetChannelsAlgorithm)
pub enum EGetChannelsAlgorithm {
    // @@protoc_insertion_point(enum_value:EGetChannelsAlgorithm.k_EGetChannelsAlgorithm_Default)
    k_EGetChannelsAlgorithm_Default = 1,
    // @@protoc_insertion_point(enum_value:EGetChannelsAlgorithm.k_EGetChannelsAlgorithm_Friends)
    k_EGetChannelsAlgorithm_Friends = 2,
    // @@protoc_insertion_point(enum_value:EGetChannelsAlgorithm.k_EGetChannelsAlgorithm_Featured)
    k_EGetChannelsAlgorithm_Featured = 3,
    // @@protoc_insertion_point(enum_value:EGetChannelsAlgorithm.k_EGetChannelsAlgorithm_Developer)
    k_EGetChannelsAlgorithm_Developer = 4,
    // @@protoc_insertion_point(enum_value:EGetChannelsAlgorithm.k_EGetChannelsAlgorithm_Following)
    k_EGetChannelsAlgorithm_Following = 5,
}

impl ::protobuf::Enum for EGetChannelsAlgorithm {
    const NAME: &'static str = "EGetChannelsAlgorithm";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EGetChannelsAlgorithm> {
        match value {
            1 => ::std::option::Option::Some(EGetChannelsAlgorithm::k_EGetChannelsAlgorithm_Default),
            2 => ::std::option::Option::Some(EGetChannelsAlgorithm::k_EGetChannelsAlgorithm_Friends),
            3 => ::std::option::Option::Some(EGetChannelsAlgorithm::k_EGetChannelsAlgorithm_Featured),
            4 => ::std::option::Option::Some(EGetChannelsAlgorithm::k_EGetChannelsAlgorithm_Developer),
            5 => ::std::option::Option::Some(EGetChannelsAlgorithm::k_EGetChannelsAlgorithm_Following),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EGetChannelsAlgorithm> {
        match str {
            "k_EGetChannelsAlgorithm_Default" => ::std::option::Option::Some(EGetChannelsAlgorithm::k_EGetChannelsAlgorithm_Default),
            "k_EGetChannelsAlgorithm_Friends" => ::std::option::Option::Some(EGetChannelsAlgorithm::k_EGetChannelsAlgorithm_Friends),
            "k_EGetChannelsAlgorithm_Featured" => ::std::option::Option::Some(EGetChannelsAlgorithm::k_EGetChannelsAlgorithm_Featured),
            "k_EGetChannelsAlgorithm_Developer" => ::std::option::Option::Some(EGetChannelsAlgorithm::k_EGetChannelsAlgorithm_Developer),
            "k_EGetChannelsAlgorithm_Following" => ::std::option::Option::Some(EGetChannelsAlgorithm::k_EGetChannelsAlgorithm_Following),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EGetChannelsAlgorithm] = &[
        EGetChannelsAlgorithm::k_EGetChannelsAlgorithm_Default,
        EGetChannelsAlgorithm::k_EGetChannelsAlgorithm_Friends,
        EGetChannelsAlgorithm::k_EGetChannelsAlgorithm_Featured,
        EGetChannelsAlgorithm::k_EGetChannelsAlgorithm_Developer,
        EGetChannelsAlgorithm::k_EGetChannelsAlgorithm_Following,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EGetChannelsAlgorithm {
    fn default() -> Self {
        EGetChannelsAlgorithm::k_EGetChannelsAlgorithm_Default
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESteamTVContentTemplate)
pub enum ESteamTVContentTemplate {
    // @@protoc_insertion_point(enum_value:ESteamTVContentTemplate.k_ESteamTVContentTemplate_Invalid)
    k_ESteamTVContentTemplate_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ESteamTVContentTemplate.k_ESteamTVContentTemplate_Takeover)
    k_ESteamTVContentTemplate_Takeover = 1,
    // @@protoc_insertion_point(enum_value:ESteamTVContentTemplate.k_ESteamTVContentTemplate_SingleGame)
    k_ESteamTVContentTemplate_SingleGame = 2,
    // @@protoc_insertion_point(enum_value:ESteamTVContentTemplate.k_ESteamTVContentTemplate_GameList)
    k_ESteamTVContentTemplate_GameList = 3,
    // @@protoc_insertion_point(enum_value:ESteamTVContentTemplate.k_ESteamTVContentTemplate_QuickExplore)
    k_ESteamTVContentTemplate_QuickExplore = 4,
    // @@protoc_insertion_point(enum_value:ESteamTVContentTemplate.k_ESteamTVContentTemplate_ConveyorBelt)
    k_ESteamTVContentTemplate_ConveyorBelt = 5,
    // @@protoc_insertion_point(enum_value:ESteamTVContentTemplate.k_ESteamTVContentTemplate_WatchParty)
    k_ESteamTVContentTemplate_WatchParty = 6,
    // @@protoc_insertion_point(enum_value:ESteamTVContentTemplate.k_ESteamTVContentTemplate_Developer)
    k_ESteamTVContentTemplate_Developer = 7,
    // @@protoc_insertion_point(enum_value:ESteamTVContentTemplate.k_ESteamTVContentTemplate_Event)
    k_ESteamTVContentTemplate_Event = 8,
}

impl ::protobuf::Enum for ESteamTVContentTemplate {
    const NAME: &'static str = "ESteamTVContentTemplate";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESteamTVContentTemplate> {
        match value {
            0 => ::std::option::Option::Some(ESteamTVContentTemplate::k_ESteamTVContentTemplate_Invalid),
            1 => ::std::option::Option::Some(ESteamTVContentTemplate::k_ESteamTVContentTemplate_Takeover),
            2 => ::std::option::Option::Some(ESteamTVContentTemplate::k_ESteamTVContentTemplate_SingleGame),
            3 => ::std::option::Option::Some(ESteamTVContentTemplate::k_ESteamTVContentTemplate_GameList),
            4 => ::std::option::Option::Some(ESteamTVContentTemplate::k_ESteamTVContentTemplate_QuickExplore),
            5 => ::std::option::Option::Some(ESteamTVContentTemplate::k_ESteamTVContentTemplate_ConveyorBelt),
            6 => ::std::option::Option::Some(ESteamTVContentTemplate::k_ESteamTVContentTemplate_WatchParty),
            7 => ::std::option::Option::Some(ESteamTVContentTemplate::k_ESteamTVContentTemplate_Developer),
            8 => ::std::option::Option::Some(ESteamTVContentTemplate::k_ESteamTVContentTemplate_Event),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESteamTVContentTemplate> {
        match str {
            "k_ESteamTVContentTemplate_Invalid" => ::std::option::Option::Some(ESteamTVContentTemplate::k_ESteamTVContentTemplate_Invalid),
            "k_ESteamTVContentTemplate_Takeover" => ::std::option::Option::Some(ESteamTVContentTemplate::k_ESteamTVContentTemplate_Takeover),
            "k_ESteamTVContentTemplate_SingleGame" => ::std::option::Option::Some(ESteamTVContentTemplate::k_ESteamTVContentTemplate_SingleGame),
            "k_ESteamTVContentTemplate_GameList" => ::std::option::Option::Some(ESteamTVContentTemplate::k_ESteamTVContentTemplate_GameList),
            "k_ESteamTVContentTemplate_QuickExplore" => ::std::option::Option::Some(ESteamTVContentTemplate::k_ESteamTVContentTemplate_QuickExplore),
            "k_ESteamTVContentTemplate_ConveyorBelt" => ::std::option::Option::Some(ESteamTVContentTemplate::k_ESteamTVContentTemplate_ConveyorBelt),
            "k_ESteamTVContentTemplate_WatchParty" => ::std::option::Option::Some(ESteamTVContentTemplate::k_ESteamTVContentTemplate_WatchParty),
            "k_ESteamTVContentTemplate_Developer" => ::std::option::Option::Some(ESteamTVContentTemplate::k_ESteamTVContentTemplate_Developer),
            "k_ESteamTVContentTemplate_Event" => ::std::option::Option::Some(ESteamTVContentTemplate::k_ESteamTVContentTemplate_Event),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESteamTVContentTemplate] = &[
        ESteamTVContentTemplate::k_ESteamTVContentTemplate_Invalid,
        ESteamTVContentTemplate::k_ESteamTVContentTemplate_Takeover,
        ESteamTVContentTemplate::k_ESteamTVContentTemplate_SingleGame,
        ESteamTVContentTemplate::k_ESteamTVContentTemplate_GameList,
        ESteamTVContentTemplate::k_ESteamTVContentTemplate_QuickExplore,
        ESteamTVContentTemplate::k_ESteamTVContentTemplate_ConveyorBelt,
        ESteamTVContentTemplate::k_ESteamTVContentTemplate_WatchParty,
        ESteamTVContentTemplate::k_ESteamTVContentTemplate_Developer,
        ESteamTVContentTemplate::k_ESteamTVContentTemplate_Event,
    ];
}

impl ::std::default::Default for ESteamTVContentTemplate {
    fn default() -> Self {
        ESteamTVContentTemplate::k_ESteamTVContentTemplate_Invalid
    }
}

#[allow(unused_imports)]
use crate::steammessages_base::*;
#[allow(unused_imports)]
use crate::steammessages_unified_base_steamclient::*;
impl crate::RpcMessage for CSteamTV_CreateBroadcastChannel_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_CreateBroadcastChannel_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_GetBroadcastChannelID_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_GetBroadcastChannelID_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_SetBroadcastChannelProfile_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_SetBroadcastChannelProfile_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_GetBroadcastChannelProfile_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_GetBroadcastChannelProfile_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_SetBroadcastChannelImage_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_SetBroadcastChannelImage_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_GetBroadcastChannelImages_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_GetBroadcastChannelImages_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_SetBroadcastChannelLinkRegions_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_SetBroadcastChannelLinkRegions_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_GetBroadcastChannelLinks_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_GetBroadcastChannelLinks_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_GetBroadcastChannelBroadcasters_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_GetBroadcastChannelBroadcasters_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_GetFollowedChannels_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for GetBroadcastChannelEntry {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_GetFollowedChannels_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_GetSubscribedChannels_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_GetSubscribedChannels_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_GetBroadcastChannelStatus_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_GetBroadcastChannelStatus_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_FollowBroadcastChannel_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_FollowBroadcastChannel_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_SubscribeBroadcastChannel_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_SubscribeBroadcastChannel_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_GetBroadcastChannelClips_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_BroadcastClipInfo {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_GetBroadcastChannelClips_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_ReportBroadcastChannel_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_ReportBroadcastChannel_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_GetBroadcastChannelInteraction_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_GetBroadcastChannelInteraction_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_GetGames_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_Game {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_GetGames_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_GetChannels_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_GetChannels_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_AddChatBan_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_AddChatBan_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_GetChatBans_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_ChatBan {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_GetChatBans_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_AddChatModerator_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_AddChatModerator_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_GetChatModerators_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_ChatModerator {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_GetChatModerators_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_AddWordBan_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_AddWordBan_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_GetWordBans_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_GetWordBans_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_JoinChat_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_JoinChat_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_Search_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_Search_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_GetSteamTVUserSettings_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_GetSteamTVUserSettings_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_SetSteamTVUserSettings_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_SetSteamTVUserSettings_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_GetMyBroadcastChannels_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_GetMyBroadcastChannels_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_GetHomePageContents_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_HomePageTemplate_Takeover {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_HomePageTemplate_SingleGame {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for GameListEntry {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_HomePageTemplate_GameList {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_HomePageTemplate_QuickExplore {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_HomePageTemplate_ConveyorBelt {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_HomePageTemplate_WatchParty {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_HomePageTemplate_Developer {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_HomePageTemplate_Event {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_HomePageContentRow {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_GetHomePageContents_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_AppCheer_SingleCheerType {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_AppCheer_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CSteamTV_AppCheer_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
///Methods for Steam TV operations
struct SteamTV {}
impl crate::RpcService for SteamTV {
    const SERVICE_NAME: &'static str = "SteamTV";
}
impl crate::RpcMethod for CSteamTV_AddChatBan_Request {
    const METHOD_NAME: &'static str = "SteamTV.AddChatBan#1";
    type Response = CSteamTV_AddChatBan_Response;
}
impl crate::RpcMethod for CSteamTV_AddChatModerator_Request {
    const METHOD_NAME: &'static str = "SteamTV.AddChatModerator#1";
    type Response = CSteamTV_AddChatModerator_Response;
}
impl crate::RpcMethod for CSteamTV_AddWordBan_Request {
    const METHOD_NAME: &'static str = "SteamTV.AddWordBan#1";
    type Response = CSteamTV_AddWordBan_Response;
}
impl crate::RpcMethod for CSteamTV_AppCheer_Request {
    const METHOD_NAME: &'static str = "SteamTV.AppCheer#1";
    type Response = CSteamTV_AppCheer_Response;
}
impl crate::RpcMethod for CSteamTV_CreateBroadcastChannel_Request {
    const METHOD_NAME: &'static str = "SteamTV.CreateBroadcastChannel#1";
    type Response = CSteamTV_CreateBroadcastChannel_Response;
}
impl crate::RpcMethod for CSteamTV_FollowBroadcastChannel_Request {
    const METHOD_NAME: &'static str = "SteamTV.FollowBroadcastChannel#1";
    type Response = CSteamTV_FollowBroadcastChannel_Response;
}
impl crate::RpcMethod for CSteamTV_GetBroadcastChannelBroadcasters_Request {
    const METHOD_NAME: &'static str = "SteamTV.GetBroadcastChannelBroadcasters#1";
    type Response = CSteamTV_GetBroadcastChannelBroadcasters_Response;
}
impl crate::RpcMethod for CSteamTV_GetBroadcastChannelClips_Request {
    const METHOD_NAME: &'static str = "SteamTV.GetBroadcastChannelClips#1";
    type Response = CSteamTV_GetBroadcastChannelClips_Response;
}
impl crate::RpcMethod for CSteamTV_GetBroadcastChannelID_Request {
    const METHOD_NAME: &'static str = "SteamTV.GetBroadcastChannelID#1";
    type Response = CSteamTV_GetBroadcastChannelID_Response;
}
impl crate::RpcMethod for CSteamTV_GetBroadcastChannelImages_Request {
    const METHOD_NAME: &'static str = "SteamTV.GetBroadcastChannelImages#1";
    type Response = CSteamTV_GetBroadcastChannelImages_Response;
}
impl crate::RpcMethod for CSteamTV_GetBroadcastChannelInteraction_Request {
    const METHOD_NAME: &'static str = "SteamTV.GetBroadcastChannelInteraction#1";
    type Response = CSteamTV_GetBroadcastChannelInteraction_Response;
}
impl crate::RpcMethod for CSteamTV_GetBroadcastChannelLinks_Request {
    const METHOD_NAME: &'static str = "SteamTV.GetBroadcastChannelLinks#1";
    type Response = CSteamTV_GetBroadcastChannelLinks_Response;
}
impl crate::RpcMethod for CSteamTV_GetBroadcastChannelProfile_Request {
    const METHOD_NAME: &'static str = "SteamTV.GetBroadcastChannelProfile#1";
    type Response = CSteamTV_GetBroadcastChannelProfile_Response;
}
impl crate::RpcMethod for CSteamTV_GetBroadcastChannelStatus_Request {
    const METHOD_NAME: &'static str = "SteamTV.GetBroadcastChannelStatus#1";
    type Response = CSteamTV_GetBroadcastChannelStatus_Response;
}
impl crate::RpcMethod for CSteamTV_GetChannels_Request {
    const METHOD_NAME: &'static str = "SteamTV.GetChannels#1";
    type Response = CSteamTV_GetChannels_Response;
}
impl crate::RpcMethod for CSteamTV_GetChatBans_Request {
    const METHOD_NAME: &'static str = "SteamTV.GetChatBans#1";
    type Response = CSteamTV_GetChatBans_Response;
}
impl crate::RpcMethod for CSteamTV_GetChatModerators_Request {
    const METHOD_NAME: &'static str = "SteamTV.GetChatModerators#1";
    type Response = CSteamTV_GetChatModerators_Response;
}
impl crate::RpcMethod for CSteamTV_GetFollowedChannels_Request {
    const METHOD_NAME: &'static str = "SteamTV.GetFollowedChannels#1";
    type Response = CSteamTV_GetFollowedChannels_Response;
}
impl crate::RpcMethod for CSteamTV_GetGames_Request {
    const METHOD_NAME: &'static str = "SteamTV.GetGames#1";
    type Response = CSteamTV_GetGames_Response;
}
impl crate::RpcMethod for CSteamTV_GetHomePageContents_Request {
    const METHOD_NAME: &'static str = "SteamTV.GetHomePageContents#1";
    type Response = CSteamTV_GetHomePageContents_Response;
}
impl crate::RpcMethod for CSteamTV_GetMyBroadcastChannels_Request {
    const METHOD_NAME: &'static str = "SteamTV.GetMyBroadcastChannels#1";
    type Response = CSteamTV_GetMyBroadcastChannels_Response;
}
impl crate::RpcMethod for CSteamTV_GetSteamTVUserSettings_Request {
    const METHOD_NAME: &'static str = "SteamTV.GetSteamTVUserSettings#1";
    type Response = CSteamTV_GetSteamTVUserSettings_Response;
}
impl crate::RpcMethod for CSteamTV_GetSubscribedChannels_Request {
    const METHOD_NAME: &'static str = "SteamTV.GetSubscribedChannels#1";
    type Response = CSteamTV_GetSubscribedChannels_Response;
}
impl crate::RpcMethod for CSteamTV_GetWordBans_Request {
    const METHOD_NAME: &'static str = "SteamTV.GetWordBans#1";
    type Response = CSteamTV_GetWordBans_Response;
}
impl crate::RpcMethod for CSteamTV_JoinChat_Request {
    const METHOD_NAME: &'static str = "SteamTV.JoinChat#1";
    type Response = CSteamTV_JoinChat_Response;
}
impl crate::RpcMethod for CSteamTV_ReportBroadcastChannel_Request {
    const METHOD_NAME: &'static str = "SteamTV.ReportBroadcastChannel#1";
    type Response = CSteamTV_ReportBroadcastChannel_Response;
}
impl crate::RpcMethod for CSteamTV_Search_Request {
    const METHOD_NAME: &'static str = "SteamTV.Search#1";
    type Response = CSteamTV_Search_Response;
}
impl crate::RpcMethod for CSteamTV_SetBroadcastChannelImage_Request {
    const METHOD_NAME: &'static str = "SteamTV.SetBroadcastChannelImage#1";
    type Response = CSteamTV_SetBroadcastChannelImage_Response;
}
impl crate::RpcMethod for CSteamTV_SetBroadcastChannelLinkRegions_Request {
    const METHOD_NAME: &'static str = "SteamTV.SetBroadcastChannelLinkRegions#1";
    type Response = CSteamTV_SetBroadcastChannelLinkRegions_Response;
}
impl crate::RpcMethod for CSteamTV_SetBroadcastChannelProfile_Request {
    const METHOD_NAME: &'static str = "SteamTV.SetBroadcastChannelProfile#1";
    type Response = CSteamTV_SetBroadcastChannelProfile_Response;
}
impl crate::RpcMethod for CSteamTV_SetSteamTVUserSettings_Request {
    const METHOD_NAME: &'static str = "SteamTV.SetSteamTVUserSettings#1";
    type Response = CSteamTV_SetSteamTVUserSettings_Response;
}
impl crate::RpcMethod for CSteamTV_SubscribeBroadcastChannel_Request {
    const METHOD_NAME: &'static str = "SteamTV.SubscribeBroadcastChannel#1";
    type Response = CSteamTV_SubscribeBroadcastChannel_Response;
}
