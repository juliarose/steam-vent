// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_marketingmessages.steamclient.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

#[doc = "Get a list of active marketing messages."]
// @@protoc_insertion_point(message:CMarketingMessages_GetActiveMarketingMessages_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_GetActiveMarketingMessages_Request {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessages_GetActiveMarketingMessages_Request.country)
    pub country: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMarketingMessages_GetActiveMarketingMessages_Request.anonymous_user)
    pub anonymous_user: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_GetActiveMarketingMessages_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_GetActiveMarketingMessages_Request {
    fn default() -> &'a CMarketingMessages_GetActiveMarketingMessages_Request {
        <CMarketingMessages_GetActiveMarketingMessages_Request as ::protobuf::Message>::default_instance()
    }
}

impl CMarketingMessages_GetActiveMarketingMessages_Request {
    pub fn new() -> CMarketingMessages_GetActiveMarketingMessages_Request {
        ::std::default::Default::default()
    }

    // optional string country = 1;

    pub fn country(&self) -> &str {
        match self.country.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_country(&mut self) {
        self.country = ::std::option::Option::None;
    }

    pub fn has_country(&self) -> bool {
        self.country.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country(&mut self, v: ::std::string::String) {
        self.country = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country(&mut self) -> &mut ::std::string::String {
        if self.country.is_none() {
            self.country = ::std::option::Option::Some(::std::string::String::new());
        }
        self.country.as_mut().unwrap()
    }

    // Take field
    pub fn take_country(&mut self) -> ::std::string::String {
        self.country.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool anonymous_user = 2;

    pub fn anonymous_user(&self) -> bool {
        self.anonymous_user.unwrap_or(false)
    }

    pub fn clear_anonymous_user(&mut self) {
        self.anonymous_user = ::std::option::Option::None;
    }

    pub fn has_anonymous_user(&self) -> bool {
        self.anonymous_user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_anonymous_user(&mut self, v: bool) {
        self.anonymous_user = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMarketingMessages_GetActiveMarketingMessages_Request {
    const NAME: &'static str = "CMarketingMessages_GetActiveMarketingMessages_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.country = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.anonymous_user = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.country.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.anonymous_user {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.country.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.anonymous_user {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_GetActiveMarketingMessages_Request {
        CMarketingMessages_GetActiveMarketingMessages_Request::new()
    }

    fn clear(&mut self) {
        self.country = ::std::option::Option::None;
        self.anonymous_user = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_GetActiveMarketingMessages_Request {
        static instance: CMarketingMessages_GetActiveMarketingMessages_Request = CMarketingMessages_GetActiveMarketingMessages_Request {
            country: ::std::option::Option::None,
            anonymous_user: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMarketingMessageProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessageProto {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessageProto.gid)
    pub gid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMarketingMessageProto.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMarketingMessageProto.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<EMarketingMessageType>>,
    // @@protoc_insertion_point(field:CMarketingMessageProto.visibility)
    pub visibility: ::std::option::Option<::protobuf::EnumOrUnknown<EMarketingMessageVisibility>>,
    // @@protoc_insertion_point(field:CMarketingMessageProto.priority)
    pub priority: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMarketingMessageProto.association_type)
    pub association_type: ::std::option::Option<::protobuf::EnumOrUnknown<EMarketingMessageAssociationType>>,
    // @@protoc_insertion_point(field:CMarketingMessageProto.associated_id)
    pub associated_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMarketingMessageProto.associated_name)
    pub associated_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMarketingMessageProto.start_date)
    pub start_date: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMarketingMessageProto.end_date)
    pub end_date: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMarketingMessageProto.country_allow)
    pub country_allow: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMarketingMessageProto.country_deny)
    pub country_deny: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMarketingMessageProto.ownership_restrictions_overridden)
    pub ownership_restrictions_overridden: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMarketingMessageProto.must_own_appid)
    pub must_own_appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMarketingMessageProto.must_not_own_appid)
    pub must_not_own_appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMarketingMessageProto.must_own_packageid)
    pub must_own_packageid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMarketingMessageProto.must_not_own_packageid)
    pub must_not_own_packageid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMarketingMessageProto.must_have_launched_appid)
    pub must_have_launched_appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMarketingMessageProto.additional_restrictions)
    pub additional_restrictions: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMarketingMessageProto.template_type)
    pub template_type: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMarketingMessageProto.template_vars)
    pub template_vars: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMarketingMessageProto.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMarketingMessageProto.creator_name)
    pub creator_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMarketingMessageProto.template_vars_json)
    pub template_vars_json: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMarketingMessageProto.additional_restrictions_json)
    pub additional_restrictions_json: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessageProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessageProto {
    fn default() -> &'a CMarketingMessageProto {
        <CMarketingMessageProto as ::protobuf::Message>::default_instance()
    }
}

impl CMarketingMessageProto {
    pub fn new() -> CMarketingMessageProto {
        ::std::default::Default::default()
    }

    // optional fixed64 gid = 1;

    pub fn gid(&self) -> u64 {
        self.gid.unwrap_or(0)
    }

    pub fn clear_gid(&mut self) {
        self.gid = ::std::option::Option::None;
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: u64) {
        self.gid = ::std::option::Option::Some(v);
    }

    // optional string title = 2;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .EMarketingMessageType type = 3;

    pub fn type_(&self) -> EMarketingMessageType {
        match self.type_ {
            Some(e) => e.enum_value_or(EMarketingMessageType::k_EMarketingMessageInvalid),
            None => EMarketingMessageType::k_EMarketingMessageInvalid,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: EMarketingMessageType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .EMarketingMessageVisibility visibility = 4;

    pub fn visibility(&self) -> EMarketingMessageVisibility {
        match self.visibility {
            Some(e) => e.enum_value_or(EMarketingMessageVisibility::k_EMarketingMessageVisibleBeta),
            None => EMarketingMessageVisibility::k_EMarketingMessageVisibleBeta,
        }
    }

    pub fn clear_visibility(&mut self) {
        self.visibility = ::std::option::Option::None;
    }

    pub fn has_visibility(&self) -> bool {
        self.visibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visibility(&mut self, v: EMarketingMessageVisibility) {
        self.visibility = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 priority = 5;

    pub fn priority(&self) -> u32 {
        self.priority.unwrap_or(0)
    }

    pub fn clear_priority(&mut self) {
        self.priority = ::std::option::Option::None;
    }

    pub fn has_priority(&self) -> bool {
        self.priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_priority(&mut self, v: u32) {
        self.priority = ::std::option::Option::Some(v);
    }

    // optional .EMarketingMessageAssociationType association_type = 6;

    pub fn association_type(&self) -> EMarketingMessageAssociationType {
        match self.association_type {
            Some(e) => e.enum_value_or(EMarketingMessageAssociationType::k_EMarketingMessageNoAssociation),
            None => EMarketingMessageAssociationType::k_EMarketingMessageNoAssociation,
        }
    }

    pub fn clear_association_type(&mut self) {
        self.association_type = ::std::option::Option::None;
    }

    pub fn has_association_type(&self) -> bool {
        self.association_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_association_type(&mut self, v: EMarketingMessageAssociationType) {
        self.association_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 associated_id = 7;

    pub fn associated_id(&self) -> u32 {
        self.associated_id.unwrap_or(0)
    }

    pub fn clear_associated_id(&mut self) {
        self.associated_id = ::std::option::Option::None;
    }

    pub fn has_associated_id(&self) -> bool {
        self.associated_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_associated_id(&mut self, v: u32) {
        self.associated_id = ::std::option::Option::Some(v);
    }

    // optional string associated_name = 8;

    pub fn associated_name(&self) -> &str {
        match self.associated_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_associated_name(&mut self) {
        self.associated_name = ::std::option::Option::None;
    }

    pub fn has_associated_name(&self) -> bool {
        self.associated_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_associated_name(&mut self, v: ::std::string::String) {
        self.associated_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_associated_name(&mut self) -> &mut ::std::string::String {
        if self.associated_name.is_none() {
            self.associated_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.associated_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_associated_name(&mut self) -> ::std::string::String {
        self.associated_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 start_date = 9;

    pub fn start_date(&self) -> u32 {
        self.start_date.unwrap_or(0)
    }

    pub fn clear_start_date(&mut self) {
        self.start_date = ::std::option::Option::None;
    }

    pub fn has_start_date(&self) -> bool {
        self.start_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_date(&mut self, v: u32) {
        self.start_date = ::std::option::Option::Some(v);
    }

    // optional uint32 end_date = 10;

    pub fn end_date(&self) -> u32 {
        self.end_date.unwrap_or(0)
    }

    pub fn clear_end_date(&mut self) {
        self.end_date = ::std::option::Option::None;
    }

    pub fn has_end_date(&self) -> bool {
        self.end_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_date(&mut self, v: u32) {
        self.end_date = ::std::option::Option::Some(v);
    }

    // optional string country_allow = 11;

    pub fn country_allow(&self) -> &str {
        match self.country_allow.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_country_allow(&mut self) {
        self.country_allow = ::std::option::Option::None;
    }

    pub fn has_country_allow(&self) -> bool {
        self.country_allow.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country_allow(&mut self, v: ::std::string::String) {
        self.country_allow = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_allow(&mut self) -> &mut ::std::string::String {
        if self.country_allow.is_none() {
            self.country_allow = ::std::option::Option::Some(::std::string::String::new());
        }
        self.country_allow.as_mut().unwrap()
    }

    // Take field
    pub fn take_country_allow(&mut self) -> ::std::string::String {
        self.country_allow.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string country_deny = 12;

    pub fn country_deny(&self) -> &str {
        match self.country_deny.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_country_deny(&mut self) {
        self.country_deny = ::std::option::Option::None;
    }

    pub fn has_country_deny(&self) -> bool {
        self.country_deny.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country_deny(&mut self, v: ::std::string::String) {
        self.country_deny = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_deny(&mut self) -> &mut ::std::string::String {
        if self.country_deny.is_none() {
            self.country_deny = ::std::option::Option::Some(::std::string::String::new());
        }
        self.country_deny.as_mut().unwrap()
    }

    // Take field
    pub fn take_country_deny(&mut self) -> ::std::string::String {
        self.country_deny.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool ownership_restrictions_overridden = 13;

    pub fn ownership_restrictions_overridden(&self) -> bool {
        self.ownership_restrictions_overridden.unwrap_or(false)
    }

    pub fn clear_ownership_restrictions_overridden(&mut self) {
        self.ownership_restrictions_overridden = ::std::option::Option::None;
    }

    pub fn has_ownership_restrictions_overridden(&self) -> bool {
        self.ownership_restrictions_overridden.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ownership_restrictions_overridden(&mut self, v: bool) {
        self.ownership_restrictions_overridden = ::std::option::Option::Some(v);
    }

    // optional uint32 must_own_appid = 14;

    pub fn must_own_appid(&self) -> u32 {
        self.must_own_appid.unwrap_or(0)
    }

    pub fn clear_must_own_appid(&mut self) {
        self.must_own_appid = ::std::option::Option::None;
    }

    pub fn has_must_own_appid(&self) -> bool {
        self.must_own_appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_must_own_appid(&mut self, v: u32) {
        self.must_own_appid = ::std::option::Option::Some(v);
    }

    // optional uint32 must_not_own_appid = 15;

    pub fn must_not_own_appid(&self) -> u32 {
        self.must_not_own_appid.unwrap_or(0)
    }

    pub fn clear_must_not_own_appid(&mut self) {
        self.must_not_own_appid = ::std::option::Option::None;
    }

    pub fn has_must_not_own_appid(&self) -> bool {
        self.must_not_own_appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_must_not_own_appid(&mut self, v: u32) {
        self.must_not_own_appid = ::std::option::Option::Some(v);
    }

    // optional uint32 must_own_packageid = 16;

    pub fn must_own_packageid(&self) -> u32 {
        self.must_own_packageid.unwrap_or(0)
    }

    pub fn clear_must_own_packageid(&mut self) {
        self.must_own_packageid = ::std::option::Option::None;
    }

    pub fn has_must_own_packageid(&self) -> bool {
        self.must_own_packageid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_must_own_packageid(&mut self, v: u32) {
        self.must_own_packageid = ::std::option::Option::Some(v);
    }

    // optional uint32 must_not_own_packageid = 17;

    pub fn must_not_own_packageid(&self) -> u32 {
        self.must_not_own_packageid.unwrap_or(0)
    }

    pub fn clear_must_not_own_packageid(&mut self) {
        self.must_not_own_packageid = ::std::option::Option::None;
    }

    pub fn has_must_not_own_packageid(&self) -> bool {
        self.must_not_own_packageid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_must_not_own_packageid(&mut self, v: u32) {
        self.must_not_own_packageid = ::std::option::Option::Some(v);
    }

    // optional uint32 must_have_launched_appid = 18;

    pub fn must_have_launched_appid(&self) -> u32 {
        self.must_have_launched_appid.unwrap_or(0)
    }

    pub fn clear_must_have_launched_appid(&mut self) {
        self.must_have_launched_appid = ::std::option::Option::None;
    }

    pub fn has_must_have_launched_appid(&self) -> bool {
        self.must_have_launched_appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_must_have_launched_appid(&mut self, v: u32) {
        self.must_have_launched_appid = ::std::option::Option::Some(v);
    }

    // optional string additional_restrictions = 19;

    pub fn additional_restrictions(&self) -> &str {
        match self.additional_restrictions.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_additional_restrictions(&mut self) {
        self.additional_restrictions = ::std::option::Option::None;
    }

    pub fn has_additional_restrictions(&self) -> bool {
        self.additional_restrictions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_additional_restrictions(&mut self, v: ::std::string::String) {
        self.additional_restrictions = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_additional_restrictions(&mut self) -> &mut ::std::string::String {
        if self.additional_restrictions.is_none() {
            self.additional_restrictions = ::std::option::Option::Some(::std::string::String::new());
        }
        self.additional_restrictions.as_mut().unwrap()
    }

    // Take field
    pub fn take_additional_restrictions(&mut self) -> ::std::string::String {
        self.additional_restrictions.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string template_type = 20;

    pub fn template_type(&self) -> &str {
        match self.template_type.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_template_type(&mut self) {
        self.template_type = ::std::option::Option::None;
    }

    pub fn has_template_type(&self) -> bool {
        self.template_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_template_type(&mut self, v: ::std::string::String) {
        self.template_type = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_template_type(&mut self) -> &mut ::std::string::String {
        if self.template_type.is_none() {
            self.template_type = ::std::option::Option::Some(::std::string::String::new());
        }
        self.template_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_template_type(&mut self) -> ::std::string::String {
        self.template_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string template_vars = 21;

    pub fn template_vars(&self) -> &str {
        match self.template_vars.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_template_vars(&mut self) {
        self.template_vars = ::std::option::Option::None;
    }

    pub fn has_template_vars(&self) -> bool {
        self.template_vars.is_some()
    }

    // Param is passed by value, moved
    pub fn set_template_vars(&mut self, v: ::std::string::String) {
        self.template_vars = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_template_vars(&mut self) -> &mut ::std::string::String {
        if self.template_vars.is_none() {
            self.template_vars = ::std::option::Option::Some(::std::string::String::new());
        }
        self.template_vars.as_mut().unwrap()
    }

    // Take field
    pub fn take_template_vars(&mut self) -> ::std::string::String {
        self.template_vars.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 flags = 22;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional string creator_name = 23;

    pub fn creator_name(&self) -> &str {
        match self.creator_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_creator_name(&mut self) {
        self.creator_name = ::std::option::Option::None;
    }

    pub fn has_creator_name(&self) -> bool {
        self.creator_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creator_name(&mut self, v: ::std::string::String) {
        self.creator_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_creator_name(&mut self) -> &mut ::std::string::String {
        if self.creator_name.is_none() {
            self.creator_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.creator_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_creator_name(&mut self) -> ::std::string::String {
        self.creator_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string template_vars_json = 24;

    pub fn template_vars_json(&self) -> &str {
        match self.template_vars_json.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_template_vars_json(&mut self) {
        self.template_vars_json = ::std::option::Option::None;
    }

    pub fn has_template_vars_json(&self) -> bool {
        self.template_vars_json.is_some()
    }

    // Param is passed by value, moved
    pub fn set_template_vars_json(&mut self, v: ::std::string::String) {
        self.template_vars_json = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_template_vars_json(&mut self) -> &mut ::std::string::String {
        if self.template_vars_json.is_none() {
            self.template_vars_json = ::std::option::Option::Some(::std::string::String::new());
        }
        self.template_vars_json.as_mut().unwrap()
    }

    // Take field
    pub fn take_template_vars_json(&mut self) -> ::std::string::String {
        self.template_vars_json.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string additional_restrictions_json = 25;

    pub fn additional_restrictions_json(&self) -> &str {
        match self.additional_restrictions_json.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_additional_restrictions_json(&mut self) {
        self.additional_restrictions_json = ::std::option::Option::None;
    }

    pub fn has_additional_restrictions_json(&self) -> bool {
        self.additional_restrictions_json.is_some()
    }

    // Param is passed by value, moved
    pub fn set_additional_restrictions_json(&mut self, v: ::std::string::String) {
        self.additional_restrictions_json = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_additional_restrictions_json(&mut self) -> &mut ::std::string::String {
        if self.additional_restrictions_json.is_none() {
            self.additional_restrictions_json = ::std::option::Option::Some(::std::string::String::new());
        }
        self.additional_restrictions_json.as_mut().unwrap()
    }

    // Take field
    pub fn take_additional_restrictions_json(&mut self) -> ::std::string::String {
        self.additional_restrictions_json.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMarketingMessageProto {
    const NAME: &'static str = "CMarketingMessageProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.gid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.visibility = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.priority = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.association_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                56 => {
                    self.associated_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.associated_name = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.start_date = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.end_date = ::std::option::Option::Some(is.read_uint32()?);
                },
                90 => {
                    self.country_allow = ::std::option::Option::Some(is.read_string()?);
                },
                98 => {
                    self.country_deny = ::std::option::Option::Some(is.read_string()?);
                },
                104 => {
                    self.ownership_restrictions_overridden = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.must_own_appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.must_not_own_appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.must_own_packageid = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.must_not_own_packageid = ::std::option::Option::Some(is.read_uint32()?);
                },
                144 => {
                    self.must_have_launched_appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                154 => {
                    self.additional_restrictions = ::std::option::Option::Some(is.read_string()?);
                },
                162 => {
                    self.template_type = ::std::option::Option::Some(is.read_string()?);
                },
                170 => {
                    self.template_vars = ::std::option::Option::Some(is.read_string()?);
                },
                176 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                186 => {
                    self.creator_name = ::std::option::Option::Some(is.read_string()?);
                },
                194 => {
                    self.template_vars_json = ::std::option::Option::Some(is.read_string()?);
                },
                202 => {
                    self.additional_restrictions_json = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.visibility {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.priority {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.association_type {
            my_size += ::protobuf::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.associated_id {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.associated_name.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.start_date {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.end_date {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.country_allow.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.country_deny.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(v) = self.ownership_restrictions_overridden {
            my_size += 1 + 1;
        }
        if let Some(v) = self.must_own_appid {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.must_not_own_appid {
            my_size += ::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.must_own_packageid {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.must_not_own_packageid {
            my_size += ::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.must_have_launched_appid {
            my_size += ::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.additional_restrictions.as_ref() {
            my_size += ::protobuf::rt::string_size(19, &v);
        }
        if let Some(v) = self.template_type.as_ref() {
            my_size += ::protobuf::rt::string_size(20, &v);
        }
        if let Some(v) = self.template_vars.as_ref() {
            my_size += ::protobuf::rt::string_size(21, &v);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::uint32_size(22, v);
        }
        if let Some(v) = self.creator_name.as_ref() {
            my_size += ::protobuf::rt::string_size(23, &v);
        }
        if let Some(v) = self.template_vars_json.as_ref() {
            my_size += ::protobuf::rt::string_size(24, &v);
        }
        if let Some(v) = self.additional_restrictions_json.as_ref() {
            my_size += ::protobuf::rt::string_size(25, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.gid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.visibility {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.priority {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.association_type {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.associated_id {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.associated_name.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.start_date {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.end_date {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.country_allow.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.country_deny.as_ref() {
            os.write_string(12, v)?;
        }
        if let Some(v) = self.ownership_restrictions_overridden {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.must_own_appid {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.must_not_own_appid {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.must_own_packageid {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.must_not_own_packageid {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.must_have_launched_appid {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.additional_restrictions.as_ref() {
            os.write_string(19, v)?;
        }
        if let Some(v) = self.template_type.as_ref() {
            os.write_string(20, v)?;
        }
        if let Some(v) = self.template_vars.as_ref() {
            os.write_string(21, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.creator_name.as_ref() {
            os.write_string(23, v)?;
        }
        if let Some(v) = self.template_vars_json.as_ref() {
            os.write_string(24, v)?;
        }
        if let Some(v) = self.additional_restrictions_json.as_ref() {
            os.write_string(25, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessageProto {
        CMarketingMessageProto::new()
    }

    fn clear(&mut self) {
        self.gid = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.visibility = ::std::option::Option::None;
        self.priority = ::std::option::Option::None;
        self.association_type = ::std::option::Option::None;
        self.associated_id = ::std::option::Option::None;
        self.associated_name = ::std::option::Option::None;
        self.start_date = ::std::option::Option::None;
        self.end_date = ::std::option::Option::None;
        self.country_allow = ::std::option::Option::None;
        self.country_deny = ::std::option::Option::None;
        self.ownership_restrictions_overridden = ::std::option::Option::None;
        self.must_own_appid = ::std::option::Option::None;
        self.must_not_own_appid = ::std::option::Option::None;
        self.must_own_packageid = ::std::option::Option::None;
        self.must_not_own_packageid = ::std::option::Option::None;
        self.must_have_launched_appid = ::std::option::Option::None;
        self.additional_restrictions = ::std::option::Option::None;
        self.template_type = ::std::option::Option::None;
        self.template_vars = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.creator_name = ::std::option::Option::None;
        self.template_vars_json = ::std::option::Option::None;
        self.additional_restrictions_json = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessageProto {
        static instance: CMarketingMessageProto = CMarketingMessageProto {
            gid: ::std::option::Option::None,
            title: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            visibility: ::std::option::Option::None,
            priority: ::std::option::Option::None,
            association_type: ::std::option::Option::None,
            associated_id: ::std::option::Option::None,
            associated_name: ::std::option::Option::None,
            start_date: ::std::option::Option::None,
            end_date: ::std::option::Option::None,
            country_allow: ::std::option::Option::None,
            country_deny: ::std::option::Option::None,
            ownership_restrictions_overridden: ::std::option::Option::None,
            must_own_appid: ::std::option::Option::None,
            must_not_own_appid: ::std::option::Option::None,
            must_own_packageid: ::std::option::Option::None,
            must_not_own_packageid: ::std::option::Option::None,
            must_have_launched_appid: ::std::option::Option::None,
            additional_restrictions: ::std::option::Option::None,
            template_type: ::std::option::Option::None,
            template_vars: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            creator_name: ::std::option::Option::None,
            template_vars_json: ::std::option::Option::None,
            additional_restrictions_json: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMarketingMessages_GetActiveMarketingMessages_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_GetActiveMarketingMessages_Response {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessages_GetActiveMarketingMessages_Response.messages)
    pub messages: ::std::vec::Vec<CMarketingMessageProto>,
    // @@protoc_insertion_point(field:CMarketingMessages_GetActiveMarketingMessages_Response.time_next_message_age)
    pub time_next_message_age: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_GetActiveMarketingMessages_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_GetActiveMarketingMessages_Response {
    fn default() -> &'a CMarketingMessages_GetActiveMarketingMessages_Response {
        <CMarketingMessages_GetActiveMarketingMessages_Response as ::protobuf::Message>::default_instance()
    }
}

impl CMarketingMessages_GetActiveMarketingMessages_Response {
    pub fn new() -> CMarketingMessages_GetActiveMarketingMessages_Response {
        ::std::default::Default::default()
    }

    // optional uint32 time_next_message_age = 2;

    pub fn time_next_message_age(&self) -> u32 {
        self.time_next_message_age.unwrap_or(0)
    }

    pub fn clear_time_next_message_age(&mut self) {
        self.time_next_message_age = ::std::option::Option::None;
    }

    pub fn has_time_next_message_age(&self) -> bool {
        self.time_next_message_age.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_next_message_age(&mut self, v: u32) {
        self.time_next_message_age = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMarketingMessages_GetActiveMarketingMessages_Response {
    const NAME: &'static str = "CMarketingMessages_GetActiveMarketingMessages_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.messages.push(is.read_message()?);
                },
                16 => {
                    self.time_next_message_age = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.time_next_message_age {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.messages {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.time_next_message_age {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_GetActiveMarketingMessages_Response {
        CMarketingMessages_GetActiveMarketingMessages_Response::new()
    }

    fn clear(&mut self) {
        self.messages.clear();
        self.time_next_message_age = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_GetActiveMarketingMessages_Response {
        static instance: CMarketingMessages_GetActiveMarketingMessages_Response = CMarketingMessages_GetActiveMarketingMessages_Response {
            messages: ::std::vec::Vec::new(),
            time_next_message_age: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Get a list of active marketing messages filtered for a specific user."]
// @@protoc_insertion_point(message:CMarketingMessages_GetMarketingMessagesForUser_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_GetMarketingMessagesForUser_Request {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessages_GetMarketingMessagesForUser_Request.include_seen_messages)
    pub include_seen_messages: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMarketingMessages_GetMarketingMessagesForUser_Request.country_code)
    pub country_code: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMarketingMessages_GetMarketingMessagesForUser_Request.elanguage)
    pub elanguage: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMarketingMessages_GetMarketingMessagesForUser_Request.operating_system)
    pub operating_system: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMarketingMessages_GetMarketingMessagesForUser_Request.client_package_version)
    pub client_package_version: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMarketingMessages_GetMarketingMessagesForUser_Request.context)
    pub context: ::protobuf::MessageField<super::steammessages_storebrowse_steamclient::StoreBrowseContext>,
    // @@protoc_insertion_point(field:CMarketingMessages_GetMarketingMessagesForUser_Request.data_request)
    pub data_request: ::protobuf::MessageField<super::steammessages_storebrowse_steamclient::StoreBrowseItemDataRequest>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_GetMarketingMessagesForUser_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_GetMarketingMessagesForUser_Request {
    fn default() -> &'a CMarketingMessages_GetMarketingMessagesForUser_Request {
        <CMarketingMessages_GetMarketingMessagesForUser_Request as ::protobuf::Message>::default_instance()
    }
}

impl CMarketingMessages_GetMarketingMessagesForUser_Request {
    pub fn new() -> CMarketingMessages_GetMarketingMessagesForUser_Request {
        ::std::default::Default::default()
    }

    // optional bool include_seen_messages = 1;

    pub fn include_seen_messages(&self) -> bool {
        self.include_seen_messages.unwrap_or(false)
    }

    pub fn clear_include_seen_messages(&mut self) {
        self.include_seen_messages = ::std::option::Option::None;
    }

    pub fn has_include_seen_messages(&self) -> bool {
        self.include_seen_messages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_seen_messages(&mut self, v: bool) {
        self.include_seen_messages = ::std::option::Option::Some(v);
    }

    // optional string country_code = 2;

    pub fn country_code(&self) -> &str {
        match self.country_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_country_code(&mut self) {
        self.country_code = ::std::option::Option::None;
    }

    pub fn has_country_code(&self) -> bool {
        self.country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country_code(&mut self, v: ::std::string::String) {
        self.country_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_code(&mut self) -> &mut ::std::string::String {
        if self.country_code.is_none() {
            self.country_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_country_code(&mut self) -> ::std::string::String {
        self.country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 elanguage = 3;

    pub fn elanguage(&self) -> i32 {
        self.elanguage.unwrap_or(0)
    }

    pub fn clear_elanguage(&mut self) {
        self.elanguage = ::std::option::Option::None;
    }

    pub fn has_elanguage(&self) -> bool {
        self.elanguage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_elanguage(&mut self, v: i32) {
        self.elanguage = ::std::option::Option::Some(v);
    }

    // optional int32 operating_system = 4;

    pub fn operating_system(&self) -> i32 {
        self.operating_system.unwrap_or(0)
    }

    pub fn clear_operating_system(&mut self) {
        self.operating_system = ::std::option::Option::None;
    }

    pub fn has_operating_system(&self) -> bool {
        self.operating_system.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operating_system(&mut self, v: i32) {
        self.operating_system = ::std::option::Option::Some(v);
    }

    // optional int32 client_package_version = 5;

    pub fn client_package_version(&self) -> i32 {
        self.client_package_version.unwrap_or(0)
    }

    pub fn clear_client_package_version(&mut self) {
        self.client_package_version = ::std::option::Option::None;
    }

    pub fn has_client_package_version(&self) -> bool {
        self.client_package_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_package_version(&mut self, v: i32) {
        self.client_package_version = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMarketingMessages_GetMarketingMessagesForUser_Request {
    const NAME: &'static str = "CMarketingMessages_GetMarketingMessagesForUser_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.include_seen_messages = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    self.country_code = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.elanguage = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.operating_system = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.client_package_version = ::std::option::Option::Some(is.read_int32()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.context)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data_request)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.include_seen_messages {
            my_size += 1 + 1;
        }
        if let Some(v) = self.country_code.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.elanguage {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.operating_system {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.client_package_version {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.data_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.include_seen_messages {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.country_code.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.elanguage {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.operating_system {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.client_package_version {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.context.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.data_request.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_GetMarketingMessagesForUser_Request {
        CMarketingMessages_GetMarketingMessagesForUser_Request::new()
    }

    fn clear(&mut self) {
        self.include_seen_messages = ::std::option::Option::None;
        self.country_code = ::std::option::Option::None;
        self.elanguage = ::std::option::Option::None;
        self.operating_system = ::std::option::Option::None;
        self.client_package_version = ::std::option::Option::None;
        self.context.clear();
        self.data_request.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_GetMarketingMessagesForUser_Request {
        static instance: CMarketingMessages_GetMarketingMessagesForUser_Request = CMarketingMessages_GetMarketingMessagesForUser_Request {
            include_seen_messages: ::std::option::Option::None,
            country_code: ::std::option::Option::None,
            elanguage: ::std::option::Option::None,
            operating_system: ::std::option::Option::None,
            client_package_version: ::std::option::Option::None,
            context: ::protobuf::MessageField::none(),
            data_request: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDisplayMarketingMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDisplayMarketingMessage {
    // message fields
    // @@protoc_insertion_point(field:CDisplayMarketingMessage.gid)
    pub gid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CDisplayMarketingMessage.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDisplayMarketingMessage.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<EMarketingMessageType>>,
    // @@protoc_insertion_point(field:CDisplayMarketingMessage.associated_item_id)
    pub associated_item_id: ::protobuf::MessageField<super::steammessages_storebrowse_steamclient::StoreItemID>,
    // @@protoc_insertion_point(field:CDisplayMarketingMessage.associated_item)
    pub associated_item: ::protobuf::MessageField<super::steammessages_storebrowse_steamclient::StoreItem>,
    // @@protoc_insertion_point(field:CDisplayMarketingMessage.associated_name)
    pub associated_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDisplayMarketingMessage.template_type)
    pub template_type: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDisplayMarketingMessage.template_vars_json)
    pub template_vars_json: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CDisplayMarketingMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDisplayMarketingMessage {
    fn default() -> &'a CDisplayMarketingMessage {
        <CDisplayMarketingMessage as ::protobuf::Message>::default_instance()
    }
}

impl CDisplayMarketingMessage {
    pub fn new() -> CDisplayMarketingMessage {
        ::std::default::Default::default()
    }

    // optional fixed64 gid = 1;

    pub fn gid(&self) -> u64 {
        self.gid.unwrap_or(0)
    }

    pub fn clear_gid(&mut self) {
        self.gid = ::std::option::Option::None;
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: u64) {
        self.gid = ::std::option::Option::Some(v);
    }

    // optional string title = 2;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .EMarketingMessageType type = 3;

    pub fn type_(&self) -> EMarketingMessageType {
        match self.type_ {
            Some(e) => e.enum_value_or(EMarketingMessageType::k_EMarketingMessageInvalid),
            None => EMarketingMessageType::k_EMarketingMessageInvalid,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: EMarketingMessageType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string associated_name = 6;

    pub fn associated_name(&self) -> &str {
        match self.associated_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_associated_name(&mut self) {
        self.associated_name = ::std::option::Option::None;
    }

    pub fn has_associated_name(&self) -> bool {
        self.associated_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_associated_name(&mut self, v: ::std::string::String) {
        self.associated_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_associated_name(&mut self) -> &mut ::std::string::String {
        if self.associated_name.is_none() {
            self.associated_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.associated_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_associated_name(&mut self) -> ::std::string::String {
        self.associated_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string template_type = 10;

    pub fn template_type(&self) -> &str {
        match self.template_type.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_template_type(&mut self) {
        self.template_type = ::std::option::Option::None;
    }

    pub fn has_template_type(&self) -> bool {
        self.template_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_template_type(&mut self, v: ::std::string::String) {
        self.template_type = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_template_type(&mut self) -> &mut ::std::string::String {
        if self.template_type.is_none() {
            self.template_type = ::std::option::Option::Some(::std::string::String::new());
        }
        self.template_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_template_type(&mut self) -> ::std::string::String {
        self.template_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string template_vars_json = 11;

    pub fn template_vars_json(&self) -> &str {
        match self.template_vars_json.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_template_vars_json(&mut self) {
        self.template_vars_json = ::std::option::Option::None;
    }

    pub fn has_template_vars_json(&self) -> bool {
        self.template_vars_json.is_some()
    }

    // Param is passed by value, moved
    pub fn set_template_vars_json(&mut self, v: ::std::string::String) {
        self.template_vars_json = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_template_vars_json(&mut self) -> &mut ::std::string::String {
        if self.template_vars_json.is_none() {
            self.template_vars_json = ::std::option::Option::Some(::std::string::String::new());
        }
        self.template_vars_json.as_mut().unwrap()
    }

    // Take field
    pub fn take_template_vars_json(&mut self) -> ::std::string::String {
        self.template_vars_json.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CDisplayMarketingMessage {
    const NAME: &'static str = "CDisplayMarketingMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.gid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.associated_item_id)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.associated_item)?;
                },
                50 => {
                    self.associated_name = ::std::option::Option::Some(is.read_string()?);
                },
                82 => {
                    self.template_type = ::std::option::Option::Some(is.read_string()?);
                },
                90 => {
                    self.template_vars_json = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.associated_item_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.associated_item.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.associated_name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.template_type.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.template_vars_json.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.gid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.associated_item_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.associated_item.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.associated_name.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.template_type.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.template_vars_json.as_ref() {
            os.write_string(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDisplayMarketingMessage {
        CDisplayMarketingMessage::new()
    }

    fn clear(&mut self) {
        self.gid = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.associated_item_id.clear();
        self.associated_item.clear();
        self.associated_name = ::std::option::Option::None;
        self.template_type = ::std::option::Option::None;
        self.template_vars_json = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDisplayMarketingMessage {
        static instance: CDisplayMarketingMessage = CDisplayMarketingMessage {
            gid: ::std::option::Option::None,
            title: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            associated_item_id: ::protobuf::MessageField::none(),
            associated_item: ::protobuf::MessageField::none(),
            associated_name: ::std::option::Option::None,
            template_type: ::std::option::Option::None,
            template_vars_json: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMarketingMessages_GetMarketingMessagesForUser_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_GetMarketingMessagesForUser_Response {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessages_GetMarketingMessagesForUser_Response.messages)
    pub messages: ::std::vec::Vec<cmarketing_messages_get_marketing_messages_for_user_response::MarketingMessageForUser>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_GetMarketingMessagesForUser_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_GetMarketingMessagesForUser_Response {
    fn default() -> &'a CMarketingMessages_GetMarketingMessagesForUser_Response {
        <CMarketingMessages_GetMarketingMessagesForUser_Response as ::protobuf::Message>::default_instance()
    }
}

impl CMarketingMessages_GetMarketingMessagesForUser_Response {
    pub fn new() -> CMarketingMessages_GetMarketingMessagesForUser_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMarketingMessages_GetMarketingMessagesForUser_Response {
    const NAME: &'static str = "CMarketingMessages_GetMarketingMessagesForUser_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.messages.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.messages {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_GetMarketingMessagesForUser_Response {
        CMarketingMessages_GetMarketingMessagesForUser_Response::new()
    }

    fn clear(&mut self) {
        self.messages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_GetMarketingMessagesForUser_Response {
        static instance: CMarketingMessages_GetMarketingMessagesForUser_Response = CMarketingMessages_GetMarketingMessagesForUser_Response {
            messages: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMarketingMessages_GetMarketingMessagesForUser_Response`
pub mod cmarketing_messages_get_marketing_messages_for_user_response {
    // @@protoc_insertion_point(message:CMarketingMessages_GetMarketingMessagesForUser_Response.MarketingMessageForUser)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct MarketingMessageForUser {
        // message fields
        // @@protoc_insertion_point(field:CMarketingMessages_GetMarketingMessagesForUser_Response.MarketingMessageForUser.already_seen)
        pub already_seen: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMarketingMessages_GetMarketingMessagesForUser_Response.MarketingMessageForUser.message)
        pub message: ::protobuf::MessageField<super::CDisplayMarketingMessage>,
        // special fields
        // @@protoc_insertion_point(special_field:CMarketingMessages_GetMarketingMessagesForUser_Response.MarketingMessageForUser.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MarketingMessageForUser {
        fn default() -> &'a MarketingMessageForUser {
            <MarketingMessageForUser as ::protobuf::Message>::default_instance()
        }
    }

    impl MarketingMessageForUser {
        pub fn new() -> MarketingMessageForUser {
            ::std::default::Default::default()
        }

        // optional bool already_seen = 1;

        pub fn already_seen(&self) -> bool {
            self.already_seen.unwrap_or(false)
        }

        pub fn clear_already_seen(&mut self) {
            self.already_seen = ::std::option::Option::None;
        }

        pub fn has_already_seen(&self) -> bool {
            self.already_seen.is_some()
        }

        // Param is passed by value, moved
        pub fn set_already_seen(&mut self, v: bool) {
            self.already_seen = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for MarketingMessageForUser {
        const NAME: &'static str = "MarketingMessageForUser";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.already_seen = ::std::option::Option::Some(is.read_bool()?);
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.message)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.already_seen {
                my_size += 1 + 1;
            }
            if let Some(v) = self.message.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.already_seen {
                os.write_bool(1, v)?;
            }
            if let Some(v) = self.message.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MarketingMessageForUser {
            MarketingMessageForUser::new()
        }

        fn clear(&mut self) {
            self.already_seen = ::std::option::Option::None;
            self.message.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MarketingMessageForUser {
            static instance: MarketingMessageForUser = MarketingMessageForUser {
                already_seen: ::std::option::Option::None,
                message: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

#[doc = "Returns a boolean if the user has pending marketing messages.  Intended to be fast."]
// @@protoc_insertion_point(message:CMarketingMessages_DoesUserHavePendingMarketingMessages_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_DoesUserHavePendingMarketingMessages_Request {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessages_DoesUserHavePendingMarketingMessages_Request.country_code)
    pub country_code: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMarketingMessages_DoesUserHavePendingMarketingMessages_Request.elanguage)
    pub elanguage: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMarketingMessages_DoesUserHavePendingMarketingMessages_Request.operating_system)
    pub operating_system: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMarketingMessages_DoesUserHavePendingMarketingMessages_Request.client_package_version)
    pub client_package_version: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_DoesUserHavePendingMarketingMessages_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_DoesUserHavePendingMarketingMessages_Request {
    fn default() -> &'a CMarketingMessages_DoesUserHavePendingMarketingMessages_Request {
        <CMarketingMessages_DoesUserHavePendingMarketingMessages_Request as ::protobuf::Message>::default_instance()
    }
}

impl CMarketingMessages_DoesUserHavePendingMarketingMessages_Request {
    pub fn new() -> CMarketingMessages_DoesUserHavePendingMarketingMessages_Request {
        ::std::default::Default::default()
    }

    // optional string country_code = 2;

    pub fn country_code(&self) -> &str {
        match self.country_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_country_code(&mut self) {
        self.country_code = ::std::option::Option::None;
    }

    pub fn has_country_code(&self) -> bool {
        self.country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country_code(&mut self, v: ::std::string::String) {
        self.country_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_code(&mut self) -> &mut ::std::string::String {
        if self.country_code.is_none() {
            self.country_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_country_code(&mut self) -> ::std::string::String {
        self.country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 elanguage = 3;

    pub fn elanguage(&self) -> i32 {
        self.elanguage.unwrap_or(0)
    }

    pub fn clear_elanguage(&mut self) {
        self.elanguage = ::std::option::Option::None;
    }

    pub fn has_elanguage(&self) -> bool {
        self.elanguage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_elanguage(&mut self, v: i32) {
        self.elanguage = ::std::option::Option::Some(v);
    }

    // optional int32 operating_system = 4;

    pub fn operating_system(&self) -> i32 {
        self.operating_system.unwrap_or(0)
    }

    pub fn clear_operating_system(&mut self) {
        self.operating_system = ::std::option::Option::None;
    }

    pub fn has_operating_system(&self) -> bool {
        self.operating_system.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operating_system(&mut self, v: i32) {
        self.operating_system = ::std::option::Option::Some(v);
    }

    // optional int32 client_package_version = 5;

    pub fn client_package_version(&self) -> i32 {
        self.client_package_version.unwrap_or(0)
    }

    pub fn clear_client_package_version(&mut self) {
        self.client_package_version = ::std::option::Option::None;
    }

    pub fn has_client_package_version(&self) -> bool {
        self.client_package_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_package_version(&mut self, v: i32) {
        self.client_package_version = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMarketingMessages_DoesUserHavePendingMarketingMessages_Request {
    const NAME: &'static str = "CMarketingMessages_DoesUserHavePendingMarketingMessages_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.country_code = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.elanguage = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.operating_system = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.client_package_version = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.country_code.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.elanguage {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.operating_system {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.client_package_version {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.country_code.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.elanguage {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.operating_system {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.client_package_version {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_DoesUserHavePendingMarketingMessages_Request {
        CMarketingMessages_DoesUserHavePendingMarketingMessages_Request::new()
    }

    fn clear(&mut self) {
        self.country_code = ::std::option::Option::None;
        self.elanguage = ::std::option::Option::None;
        self.operating_system = ::std::option::Option::None;
        self.client_package_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_DoesUserHavePendingMarketingMessages_Request {
        static instance: CMarketingMessages_DoesUserHavePendingMarketingMessages_Request = CMarketingMessages_DoesUserHavePendingMarketingMessages_Request {
            country_code: ::std::option::Option::None,
            elanguage: ::std::option::Option::None,
            operating_system: ::std::option::Option::None,
            client_package_version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMarketingMessages_DoesUserHavePendingMarketingMessages_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_DoesUserHavePendingMarketingMessages_Response {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessages_DoesUserHavePendingMarketingMessages_Response.has_pending_messages)
    pub has_pending_messages: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMarketingMessages_DoesUserHavePendingMarketingMessages_Response.pending_message_count)
    pub pending_message_count: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_DoesUserHavePendingMarketingMessages_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_DoesUserHavePendingMarketingMessages_Response {
    fn default() -> &'a CMarketingMessages_DoesUserHavePendingMarketingMessages_Response {
        <CMarketingMessages_DoesUserHavePendingMarketingMessages_Response as ::protobuf::Message>::default_instance()
    }
}

impl CMarketingMessages_DoesUserHavePendingMarketingMessages_Response {
    pub fn new() -> CMarketingMessages_DoesUserHavePendingMarketingMessages_Response {
        ::std::default::Default::default()
    }

    // optional bool has_pending_messages = 1;

    pub fn has_pending_messages(&self) -> bool {
        self.has_pending_messages.unwrap_or(false)
    }

    pub fn clear_has_pending_messages(&mut self) {
        self.has_pending_messages = ::std::option::Option::None;
    }

    pub fn has_has_pending_messages(&self) -> bool {
        self.has_pending_messages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_pending_messages(&mut self, v: bool) {
        self.has_pending_messages = ::std::option::Option::Some(v);
    }

    // optional int32 pending_message_count = 2;

    pub fn pending_message_count(&self) -> i32 {
        self.pending_message_count.unwrap_or(0)
    }

    pub fn clear_pending_message_count(&mut self) {
        self.pending_message_count = ::std::option::Option::None;
    }

    pub fn has_pending_message_count(&self) -> bool {
        self.pending_message_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pending_message_count(&mut self, v: i32) {
        self.pending_message_count = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMarketingMessages_DoesUserHavePendingMarketingMessages_Response {
    const NAME: &'static str = "CMarketingMessages_DoesUserHavePendingMarketingMessages_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.has_pending_messages = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.pending_message_count = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.has_pending_messages {
            my_size += 1 + 1;
        }
        if let Some(v) = self.pending_message_count {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.has_pending_messages {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.pending_message_count {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_DoesUserHavePendingMarketingMessages_Response {
        CMarketingMessages_DoesUserHavePendingMarketingMessages_Response::new()
    }

    fn clear(&mut self) {
        self.has_pending_messages = ::std::option::Option::None;
        self.pending_message_count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_DoesUserHavePendingMarketingMessages_Response {
        static instance: CMarketingMessages_DoesUserHavePendingMarketingMessages_Response = CMarketingMessages_DoesUserHavePendingMarketingMessages_Response {
            has_pending_messages: ::std::option::Option::None,
            pending_message_count: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Get a single marketing message for Admin, not cacheable."]
// @@protoc_insertion_point(message:CMarketingMessages_GetDisplayMarketingMessage_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_GetDisplayMarketingMessage_Request {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessages_GetDisplayMarketingMessage_Request.gid)
    pub gid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMarketingMessages_GetDisplayMarketingMessage_Request.context)
    pub context: ::protobuf::MessageField<super::steammessages_storebrowse_steamclient::StoreBrowseContext>,
    // @@protoc_insertion_point(field:CMarketingMessages_GetDisplayMarketingMessage_Request.data_request)
    pub data_request: ::protobuf::MessageField<super::steammessages_storebrowse_steamclient::StoreBrowseItemDataRequest>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_GetDisplayMarketingMessage_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_GetDisplayMarketingMessage_Request {
    fn default() -> &'a CMarketingMessages_GetDisplayMarketingMessage_Request {
        <CMarketingMessages_GetDisplayMarketingMessage_Request as ::protobuf::Message>::default_instance()
    }
}

impl CMarketingMessages_GetDisplayMarketingMessage_Request {
    pub fn new() -> CMarketingMessages_GetDisplayMarketingMessage_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 gid = 1;

    pub fn gid(&self) -> u64 {
        self.gid.unwrap_or(0)
    }

    pub fn clear_gid(&mut self) {
        self.gid = ::std::option::Option::None;
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: u64) {
        self.gid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMarketingMessages_GetDisplayMarketingMessage_Request {
    const NAME: &'static str = "CMarketingMessages_GetDisplayMarketingMessage_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.gid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.context)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data_request)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.data_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.gid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.context.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.data_request.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_GetDisplayMarketingMessage_Request {
        CMarketingMessages_GetDisplayMarketingMessage_Request::new()
    }

    fn clear(&mut self) {
        self.gid = ::std::option::Option::None;
        self.context.clear();
        self.data_request.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_GetDisplayMarketingMessage_Request {
        static instance: CMarketingMessages_GetDisplayMarketingMessage_Request = CMarketingMessages_GetDisplayMarketingMessage_Request {
            gid: ::std::option::Option::None,
            context: ::protobuf::MessageField::none(),
            data_request: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMarketingMessages_GetDisplayMarketingMessage_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_GetDisplayMarketingMessage_Response {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessages_GetDisplayMarketingMessage_Response.message)
    pub message: ::protobuf::MessageField<CDisplayMarketingMessage>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_GetDisplayMarketingMessage_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_GetDisplayMarketingMessage_Response {
    fn default() -> &'a CMarketingMessages_GetDisplayMarketingMessage_Response {
        <CMarketingMessages_GetDisplayMarketingMessage_Response as ::protobuf::Message>::default_instance()
    }
}

impl CMarketingMessages_GetDisplayMarketingMessage_Response {
    pub fn new() -> CMarketingMessages_GetDisplayMarketingMessage_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMarketingMessages_GetDisplayMarketingMessage_Response {
    const NAME: &'static str = "CMarketingMessages_GetDisplayMarketingMessage_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.message)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.message.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_GetDisplayMarketingMessage_Response {
        CMarketingMessages_GetDisplayMarketingMessage_Response::new()
    }

    fn clear(&mut self) {
        self.message.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_GetDisplayMarketingMessage_Response {
        static instance: CMarketingMessages_GetDisplayMarketingMessage_Response = CMarketingMessages_GetDisplayMarketingMessage_Response {
            message: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Mark that a user has viewed a message (so we won't show it again)'."]
// @@protoc_insertion_point(message:CMarketingMessages_MarkMessageSeen_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_MarkMessageSeen_Notification {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessages_MarkMessageSeen_Notification.gid)
    pub gid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMarketingMessages_MarkMessageSeen_Notification.display_index)
    pub display_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMarketingMessages_MarkMessageSeen_Notification.template_type)
    pub template_type: ::std::option::Option<::protobuf::EnumOrUnknown<EMarketingMessageTemplateType>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_MarkMessageSeen_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_MarkMessageSeen_Notification {
    fn default() -> &'a CMarketingMessages_MarkMessageSeen_Notification {
        <CMarketingMessages_MarkMessageSeen_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CMarketingMessages_MarkMessageSeen_Notification {
    pub fn new() -> CMarketingMessages_MarkMessageSeen_Notification {
        ::std::default::Default::default()
    }

    // optional fixed64 gid = 1;

    pub fn gid(&self) -> u64 {
        self.gid.unwrap_or(0)
    }

    pub fn clear_gid(&mut self) {
        self.gid = ::std::option::Option::None;
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: u64) {
        self.gid = ::std::option::Option::Some(v);
    }

    // optional uint32 display_index = 2;

    pub fn display_index(&self) -> u32 {
        self.display_index.unwrap_or(0u32)
    }

    pub fn clear_display_index(&mut self) {
        self.display_index = ::std::option::Option::None;
    }

    pub fn has_display_index(&self) -> bool {
        self.display_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_index(&mut self, v: u32) {
        self.display_index = ::std::option::Option::Some(v);
    }

    // optional .EMarketingMessageTemplateType template_type = 3;

    pub fn template_type(&self) -> EMarketingMessageTemplateType {
        match self.template_type {
            Some(e) => e.enum_value_or(EMarketingMessageTemplateType::k_EMarketingMessageTemplate_Unknown),
            None => EMarketingMessageTemplateType::k_EMarketingMessageTemplate_Unknown,
        }
    }

    pub fn clear_template_type(&mut self) {
        self.template_type = ::std::option::Option::None;
    }

    pub fn has_template_type(&self) -> bool {
        self.template_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_template_type(&mut self, v: EMarketingMessageTemplateType) {
        self.template_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::protobuf::Message for CMarketingMessages_MarkMessageSeen_Notification {
    const NAME: &'static str = "CMarketingMessages_MarkMessageSeen_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.gid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.display_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.template_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.display_index {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.template_type {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.gid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.display_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.template_type {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_MarkMessageSeen_Notification {
        CMarketingMessages_MarkMessageSeen_Notification::new()
    }

    fn clear(&mut self) {
        self.gid = ::std::option::Option::None;
        self.display_index = ::std::option::Option::None;
        self.template_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_MarkMessageSeen_Notification {
        static instance: CMarketingMessages_MarkMessageSeen_Notification = CMarketingMessages_MarkMessageSeen_Notification {
            gid: ::std::option::Option::None,
            display_index: ::std::option::Option::None,
            template_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Get a single marketing message.  Admin account needed for non-active messages"]
// @@protoc_insertion_point(message:CMarketingMessages_GetMarketingMessage_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_GetMarketingMessage_Request {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessages_GetMarketingMessage_Request.gid)
    pub gid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_GetMarketingMessage_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_GetMarketingMessage_Request {
    fn default() -> &'a CMarketingMessages_GetMarketingMessage_Request {
        <CMarketingMessages_GetMarketingMessage_Request as ::protobuf::Message>::default_instance()
    }
}

impl CMarketingMessages_GetMarketingMessage_Request {
    pub fn new() -> CMarketingMessages_GetMarketingMessage_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 gid = 1;

    pub fn gid(&self) -> u64 {
        self.gid.unwrap_or(0)
    }

    pub fn clear_gid(&mut self) {
        self.gid = ::std::option::Option::None;
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: u64) {
        self.gid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMarketingMessages_GetMarketingMessage_Request {
    const NAME: &'static str = "CMarketingMessages_GetMarketingMessage_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.gid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gid {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.gid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_GetMarketingMessage_Request {
        CMarketingMessages_GetMarketingMessage_Request::new()
    }

    fn clear(&mut self) {
        self.gid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_GetMarketingMessage_Request {
        static instance: CMarketingMessages_GetMarketingMessage_Request = CMarketingMessages_GetMarketingMessage_Request {
            gid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMarketingMessages_GetMarketingMessage_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_GetMarketingMessage_Response {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessages_GetMarketingMessage_Response.message)
    pub message: ::protobuf::MessageField<CMarketingMessageProto>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_GetMarketingMessage_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_GetMarketingMessage_Response {
    fn default() -> &'a CMarketingMessages_GetMarketingMessage_Response {
        <CMarketingMessages_GetMarketingMessage_Response as ::protobuf::Message>::default_instance()
    }
}

impl CMarketingMessages_GetMarketingMessage_Response {
    pub fn new() -> CMarketingMessages_GetMarketingMessage_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMarketingMessages_GetMarketingMessage_Response {
    const NAME: &'static str = "CMarketingMessages_GetMarketingMessage_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.message)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.message.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_GetMarketingMessage_Response {
        CMarketingMessages_GetMarketingMessage_Response::new()
    }

    fn clear(&mut self) {
        self.message.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_GetMarketingMessage_Response {
        static instance: CMarketingMessages_GetMarketingMessage_Response = CMarketingMessages_GetMarketingMessage_Response {
            message: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Create a new marketing message."]
// @@protoc_insertion_point(message:CMarketingMessages_CreateMarketingMessage_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_CreateMarketingMessage_Request {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessages_CreateMarketingMessage_Request.message)
    pub message: ::protobuf::MessageField<CMarketingMessageProto>,
    // @@protoc_insertion_point(field:CMarketingMessages_CreateMarketingMessage_Request.from_json)
    pub from_json: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_CreateMarketingMessage_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_CreateMarketingMessage_Request {
    fn default() -> &'a CMarketingMessages_CreateMarketingMessage_Request {
        <CMarketingMessages_CreateMarketingMessage_Request as ::protobuf::Message>::default_instance()
    }
}

impl CMarketingMessages_CreateMarketingMessage_Request {
    pub fn new() -> CMarketingMessages_CreateMarketingMessage_Request {
        ::std::default::Default::default()
    }

    // optional bool from_json = 2;

    pub fn from_json(&self) -> bool {
        self.from_json.unwrap_or(false)
    }

    pub fn clear_from_json(&mut self) {
        self.from_json = ::std::option::Option::None;
    }

    pub fn has_from_json(&self) -> bool {
        self.from_json.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_json(&mut self, v: bool) {
        self.from_json = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMarketingMessages_CreateMarketingMessage_Request {
    const NAME: &'static str = "CMarketingMessages_CreateMarketingMessage_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.message)?;
                },
                16 => {
                    self.from_json = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.from_json {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.message.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.from_json {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_CreateMarketingMessage_Request {
        CMarketingMessages_CreateMarketingMessage_Request::new()
    }

    fn clear(&mut self) {
        self.message.clear();
        self.from_json = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_CreateMarketingMessage_Request {
        static instance: CMarketingMessages_CreateMarketingMessage_Request = CMarketingMessages_CreateMarketingMessage_Request {
            message: ::protobuf::MessageField::none(),
            from_json: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMarketingMessages_CreateMarketingMessage_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_CreateMarketingMessage_Response {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessages_CreateMarketingMessage_Response.gid)
    pub gid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_CreateMarketingMessage_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_CreateMarketingMessage_Response {
    fn default() -> &'a CMarketingMessages_CreateMarketingMessage_Response {
        <CMarketingMessages_CreateMarketingMessage_Response as ::protobuf::Message>::default_instance()
    }
}

impl CMarketingMessages_CreateMarketingMessage_Response {
    pub fn new() -> CMarketingMessages_CreateMarketingMessage_Response {
        ::std::default::Default::default()
    }

    // optional fixed64 gid = 1;

    pub fn gid(&self) -> u64 {
        self.gid.unwrap_or(0)
    }

    pub fn clear_gid(&mut self) {
        self.gid = ::std::option::Option::None;
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: u64) {
        self.gid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMarketingMessages_CreateMarketingMessage_Response {
    const NAME: &'static str = "CMarketingMessages_CreateMarketingMessage_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.gid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gid {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.gid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_CreateMarketingMessage_Response {
        CMarketingMessages_CreateMarketingMessage_Response::new()
    }

    fn clear(&mut self) {
        self.gid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_CreateMarketingMessage_Response {
        static instance: CMarketingMessages_CreateMarketingMessage_Response = CMarketingMessages_CreateMarketingMessage_Response {
            gid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Modify a marketing message."]
// @@protoc_insertion_point(message:CMarketingMessages_UpdateMarketingMessage_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_UpdateMarketingMessage_Request {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessages_UpdateMarketingMessage_Request.gid)
    pub gid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMarketingMessages_UpdateMarketingMessage_Request.message)
    pub message: ::protobuf::MessageField<CMarketingMessageProto>,
    // @@protoc_insertion_point(field:CMarketingMessages_UpdateMarketingMessage_Request.from_json)
    pub from_json: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_UpdateMarketingMessage_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_UpdateMarketingMessage_Request {
    fn default() -> &'a CMarketingMessages_UpdateMarketingMessage_Request {
        <CMarketingMessages_UpdateMarketingMessage_Request as ::protobuf::Message>::default_instance()
    }
}

impl CMarketingMessages_UpdateMarketingMessage_Request {
    pub fn new() -> CMarketingMessages_UpdateMarketingMessage_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 gid = 1;

    pub fn gid(&self) -> u64 {
        self.gid.unwrap_or(0)
    }

    pub fn clear_gid(&mut self) {
        self.gid = ::std::option::Option::None;
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: u64) {
        self.gid = ::std::option::Option::Some(v);
    }

    // optional bool from_json = 3;

    pub fn from_json(&self) -> bool {
        self.from_json.unwrap_or(false)
    }

    pub fn clear_from_json(&mut self) {
        self.from_json = ::std::option::Option::None;
    }

    pub fn has_from_json(&self) -> bool {
        self.from_json.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_json(&mut self, v: bool) {
        self.from_json = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMarketingMessages_UpdateMarketingMessage_Request {
    const NAME: &'static str = "CMarketingMessages_UpdateMarketingMessage_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.gid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.message)?;
                },
                24 => {
                    self.from_json = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.from_json {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.gid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.from_json {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_UpdateMarketingMessage_Request {
        CMarketingMessages_UpdateMarketingMessage_Request::new()
    }

    fn clear(&mut self) {
        self.gid = ::std::option::Option::None;
        self.message.clear();
        self.from_json = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_UpdateMarketingMessage_Request {
        static instance: CMarketingMessages_UpdateMarketingMessage_Request = CMarketingMessages_UpdateMarketingMessage_Request {
            gid: ::std::option::Option::None,
            message: ::protobuf::MessageField::none(),
            from_json: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMarketingMessages_UpdateMarketingMessage_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_UpdateMarketingMessage_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_UpdateMarketingMessage_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_UpdateMarketingMessage_Response {
    fn default() -> &'a CMarketingMessages_UpdateMarketingMessage_Response {
        <CMarketingMessages_UpdateMarketingMessage_Response as ::protobuf::Message>::default_instance()
    }
}

impl CMarketingMessages_UpdateMarketingMessage_Response {
    pub fn new() -> CMarketingMessages_UpdateMarketingMessage_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMarketingMessages_UpdateMarketingMessage_Response {
    const NAME: &'static str = "CMarketingMessages_UpdateMarketingMessage_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_UpdateMarketingMessage_Response {
        CMarketingMessages_UpdateMarketingMessage_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_UpdateMarketingMessage_Response {
        static instance: CMarketingMessages_UpdateMarketingMessage_Response = CMarketingMessages_UpdateMarketingMessage_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Delete a marketing message."]
// @@protoc_insertion_point(message:CMarketingMessages_DeleteMarketingMessage_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_DeleteMarketingMessage_Request {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessages_DeleteMarketingMessage_Request.gid)
    pub gid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_DeleteMarketingMessage_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_DeleteMarketingMessage_Request {
    fn default() -> &'a CMarketingMessages_DeleteMarketingMessage_Request {
        <CMarketingMessages_DeleteMarketingMessage_Request as ::protobuf::Message>::default_instance()
    }
}

impl CMarketingMessages_DeleteMarketingMessage_Request {
    pub fn new() -> CMarketingMessages_DeleteMarketingMessage_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 gid = 1;

    pub fn gid(&self) -> u64 {
        self.gid.unwrap_or(0)
    }

    pub fn clear_gid(&mut self) {
        self.gid = ::std::option::Option::None;
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: u64) {
        self.gid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMarketingMessages_DeleteMarketingMessage_Request {
    const NAME: &'static str = "CMarketingMessages_DeleteMarketingMessage_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.gid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gid {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.gid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_DeleteMarketingMessage_Request {
        CMarketingMessages_DeleteMarketingMessage_Request::new()
    }

    fn clear(&mut self) {
        self.gid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_DeleteMarketingMessage_Request {
        static instance: CMarketingMessages_DeleteMarketingMessage_Request = CMarketingMessages_DeleteMarketingMessage_Request {
            gid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMarketingMessages_DeleteMarketingMessage_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_DeleteMarketingMessage_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_DeleteMarketingMessage_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_DeleteMarketingMessage_Response {
    fn default() -> &'a CMarketingMessages_DeleteMarketingMessage_Response {
        <CMarketingMessages_DeleteMarketingMessage_Response as ::protobuf::Message>::default_instance()
    }
}

impl CMarketingMessages_DeleteMarketingMessage_Response {
    pub fn new() -> CMarketingMessages_DeleteMarketingMessage_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMarketingMessages_DeleteMarketingMessage_Response {
    const NAME: &'static str = "CMarketingMessages_DeleteMarketingMessage_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_DeleteMarketingMessage_Response {
        CMarketingMessages_DeleteMarketingMessage_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_DeleteMarketingMessage_Response {
        static instance: CMarketingMessages_DeleteMarketingMessage_Response = CMarketingMessages_DeleteMarketingMessage_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Search for marketing messages by name, type, etc."]
// @@protoc_insertion_point(message:CMarketingMessages_FindMarketingMessages_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_FindMarketingMessages_Request {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessages_FindMarketingMessages_Request.lookup_type)
    pub lookup_type: ::std::option::Option<::protobuf::EnumOrUnknown<EMarketingMessageLookupType>>,
    // @@protoc_insertion_point(field:CMarketingMessages_FindMarketingMessages_Request.gid)
    pub gid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMarketingMessages_FindMarketingMessages_Request.message_type)
    pub message_type: ::std::option::Option<::protobuf::EnumOrUnknown<EMarketingMessageType>>,
    // @@protoc_insertion_point(field:CMarketingMessages_FindMarketingMessages_Request.gidlist)
    pub gidlist: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CMarketingMessages_FindMarketingMessages_Request.title)
    pub title: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_FindMarketingMessages_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_FindMarketingMessages_Request {
    fn default() -> &'a CMarketingMessages_FindMarketingMessages_Request {
        <CMarketingMessages_FindMarketingMessages_Request as ::protobuf::Message>::default_instance()
    }
}

impl CMarketingMessages_FindMarketingMessages_Request {
    pub fn new() -> CMarketingMessages_FindMarketingMessages_Request {
        ::std::default::Default::default()
    }

    // optional .EMarketingMessageLookupType lookup_type = 1;

    pub fn lookup_type(&self) -> EMarketingMessageLookupType {
        match self.lookup_type {
            Some(e) => e.enum_value_or(EMarketingMessageLookupType::k_EMarketingMessageLookupInvalid),
            None => EMarketingMessageLookupType::k_EMarketingMessageLookupInvalid,
        }
    }

    pub fn clear_lookup_type(&mut self) {
        self.lookup_type = ::std::option::Option::None;
    }

    pub fn has_lookup_type(&self) -> bool {
        self.lookup_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lookup_type(&mut self, v: EMarketingMessageLookupType) {
        self.lookup_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional fixed64 gid = 2;

    pub fn gid(&self) -> u64 {
        self.gid.unwrap_or(0)
    }

    pub fn clear_gid(&mut self) {
        self.gid = ::std::option::Option::None;
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: u64) {
        self.gid = ::std::option::Option::Some(v);
    }

    // optional .EMarketingMessageType message_type = 3;

    pub fn message_type(&self) -> EMarketingMessageType {
        match self.message_type {
            Some(e) => e.enum_value_or(EMarketingMessageType::k_EMarketingMessageInvalid),
            None => EMarketingMessageType::k_EMarketingMessageInvalid,
        }
    }

    pub fn clear_message_type(&mut self) {
        self.message_type = ::std::option::Option::None;
    }

    pub fn has_message_type(&self) -> bool {
        self.message_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_type(&mut self, v: EMarketingMessageType) {
        self.message_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string title = 5;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMarketingMessages_FindMarketingMessages_Request {
    const NAME: &'static str = "CMarketingMessages_FindMarketingMessages_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.lookup_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                17 => {
                    self.gid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.message_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                34 => {
                    is.read_repeated_packed_fixed64_into(&mut self.gidlist)?;
                },
                33 => {
                    self.gidlist.push(is.read_fixed64()?);
                },
                42 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.lookup_type {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.gid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.message_type {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        my_size += 9 * self.gidlist.len() as u64;
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.lookup_type {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.gid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.message_type {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.gidlist {
            os.write_fixed64(4, *v)?;
        };
        if let Some(v) = self.title.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_FindMarketingMessages_Request {
        CMarketingMessages_FindMarketingMessages_Request::new()
    }

    fn clear(&mut self) {
        self.lookup_type = ::std::option::Option::None;
        self.gid = ::std::option::Option::None;
        self.message_type = ::std::option::Option::None;
        self.gidlist.clear();
        self.title = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_FindMarketingMessages_Request {
        static instance: CMarketingMessages_FindMarketingMessages_Request = CMarketingMessages_FindMarketingMessages_Request {
            lookup_type: ::std::option::Option::None,
            gid: ::std::option::Option::None,
            message_type: ::std::option::Option::None,
            gidlist: ::std::vec::Vec::new(),
            title: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMarketingMessages_FindMarketingMessages_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_FindMarketingMessages_Response {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessages_FindMarketingMessages_Response.messages)
    pub messages: ::std::vec::Vec<CMarketingMessageProto>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_FindMarketingMessages_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_FindMarketingMessages_Response {
    fn default() -> &'a CMarketingMessages_FindMarketingMessages_Response {
        <CMarketingMessages_FindMarketingMessages_Response as ::protobuf::Message>::default_instance()
    }
}

impl CMarketingMessages_FindMarketingMessages_Response {
    pub fn new() -> CMarketingMessages_FindMarketingMessages_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMarketingMessages_FindMarketingMessages_Response {
    const NAME: &'static str = "CMarketingMessages_FindMarketingMessages_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.messages.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.messages {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_FindMarketingMessages_Response {
        CMarketingMessages_FindMarketingMessages_Response::new()
    }

    fn clear(&mut self) {
        self.messages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_FindMarketingMessages_Response {
        static instance: CMarketingMessages_FindMarketingMessages_Response = CMarketingMessages_FindMarketingMessages_Response {
            messages: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "For a specific marketing message, then all of the viewership stats for the date range it was intended to be visible to customers"]
// @@protoc_insertion_point(message:CMarketingMessages_GetMarketingMessageViewerStats_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_GetMarketingMessageViewerStats_Request {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessages_GetMarketingMessageViewerStats_Request.gid)
    pub gid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_GetMarketingMessageViewerStats_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_GetMarketingMessageViewerStats_Request {
    fn default() -> &'a CMarketingMessages_GetMarketingMessageViewerStats_Request {
        <CMarketingMessages_GetMarketingMessageViewerStats_Request as ::protobuf::Message>::default_instance()
    }
}

impl CMarketingMessages_GetMarketingMessageViewerStats_Request {
    pub fn new() -> CMarketingMessages_GetMarketingMessageViewerStats_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 gid = 1;

    pub fn gid(&self) -> u64 {
        self.gid.unwrap_or(0)
    }

    pub fn clear_gid(&mut self) {
        self.gid = ::std::option::Option::None;
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: u64) {
        self.gid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMarketingMessages_GetMarketingMessageViewerStats_Request {
    const NAME: &'static str = "CMarketingMessages_GetMarketingMessageViewerStats_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.gid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gid {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.gid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_GetMarketingMessageViewerStats_Request {
        CMarketingMessages_GetMarketingMessageViewerStats_Request::new()
    }

    fn clear(&mut self) {
        self.gid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_GetMarketingMessageViewerStats_Request {
        static instance: CMarketingMessages_GetMarketingMessageViewerStats_Request = CMarketingMessages_GetMarketingMessageViewerStats_Request {
            gid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMarketingMessageHourlyStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessageHourlyStats {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessageHourlyStats.rt_time_hour)
    pub rt_time_hour: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMarketingMessageHourlyStats.seen_count)
    pub seen_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMarketingMessageHourlyStats.template_type)
    pub template_type: ::std::option::Option<::protobuf::EnumOrUnknown<EMarketingMessageTemplateType>>,
    // @@protoc_insertion_point(field:CMarketingMessageHourlyStats.display_index)
    pub display_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessageHourlyStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessageHourlyStats {
    fn default() -> &'a CMarketingMessageHourlyStats {
        <CMarketingMessageHourlyStats as ::protobuf::Message>::default_instance()
    }
}

impl CMarketingMessageHourlyStats {
    pub fn new() -> CMarketingMessageHourlyStats {
        ::std::default::Default::default()
    }

    // optional uint32 rt_time_hour = 1;

    pub fn rt_time_hour(&self) -> u32 {
        self.rt_time_hour.unwrap_or(0)
    }

    pub fn clear_rt_time_hour(&mut self) {
        self.rt_time_hour = ::std::option::Option::None;
    }

    pub fn has_rt_time_hour(&self) -> bool {
        self.rt_time_hour.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rt_time_hour(&mut self, v: u32) {
        self.rt_time_hour = ::std::option::Option::Some(v);
    }

    // optional uint32 seen_count = 2;

    pub fn seen_count(&self) -> u32 {
        self.seen_count.unwrap_or(0)
    }

    pub fn clear_seen_count(&mut self) {
        self.seen_count = ::std::option::Option::None;
    }

    pub fn has_seen_count(&self) -> bool {
        self.seen_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seen_count(&mut self, v: u32) {
        self.seen_count = ::std::option::Option::Some(v);
    }

    // optional .EMarketingMessageTemplateType template_type = 3;

    pub fn template_type(&self) -> EMarketingMessageTemplateType {
        match self.template_type {
            Some(e) => e.enum_value_or(EMarketingMessageTemplateType::k_EMarketingMessageTemplate_Unknown),
            None => EMarketingMessageTemplateType::k_EMarketingMessageTemplate_Unknown,
        }
    }

    pub fn clear_template_type(&mut self) {
        self.template_type = ::std::option::Option::None;
    }

    pub fn has_template_type(&self) -> bool {
        self.template_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_template_type(&mut self, v: EMarketingMessageTemplateType) {
        self.template_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 display_index = 4;

    pub fn display_index(&self) -> u32 {
        self.display_index.unwrap_or(0)
    }

    pub fn clear_display_index(&mut self) {
        self.display_index = ::std::option::Option::None;
    }

    pub fn has_display_index(&self) -> bool {
        self.display_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_index(&mut self, v: u32) {
        self.display_index = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMarketingMessageHourlyStats {
    const NAME: &'static str = "CMarketingMessageHourlyStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.rt_time_hour = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.seen_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.template_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.display_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rt_time_hour {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.seen_count {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.template_type {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.display_index {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.rt_time_hour {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.seen_count {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.template_type {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.display_index {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessageHourlyStats {
        CMarketingMessageHourlyStats::new()
    }

    fn clear(&mut self) {
        self.rt_time_hour = ::std::option::Option::None;
        self.seen_count = ::std::option::Option::None;
        self.template_type = ::std::option::Option::None;
        self.display_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessageHourlyStats {
        static instance: CMarketingMessageHourlyStats = CMarketingMessageHourlyStats {
            rt_time_hour: ::std::option::Option::None,
            seen_count: ::std::option::Option::None,
            template_type: ::std::option::Option::None,
            display_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMarketingMessages_GetMarketingMessageViewerStats_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_GetMarketingMessageViewerStats_Response {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessages_GetMarketingMessageViewerStats_Response.stats)
    pub stats: ::std::vec::Vec<CMarketingMessageHourlyStats>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_GetMarketingMessageViewerStats_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_GetMarketingMessageViewerStats_Response {
    fn default() -> &'a CMarketingMessages_GetMarketingMessageViewerStats_Response {
        <CMarketingMessages_GetMarketingMessageViewerStats_Response as ::protobuf::Message>::default_instance()
    }
}

impl CMarketingMessages_GetMarketingMessageViewerStats_Response {
    pub fn new() -> CMarketingMessages_GetMarketingMessageViewerStats_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMarketingMessages_GetMarketingMessageViewerStats_Response {
    const NAME: &'static str = "CMarketingMessages_GetMarketingMessageViewerStats_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.stats.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.stats {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_GetMarketingMessageViewerStats_Response {
        CMarketingMessages_GetMarketingMessageViewerStats_Response::new()
    }

    fn clear(&mut self) {
        self.stats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_GetMarketingMessageViewerStats_Response {
        static instance: CMarketingMessages_GetMarketingMessageViewerStats_Response = CMarketingMessages_GetMarketingMessageViewerStats_Response {
            stats: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "For a time range, return the seen stats across all of the marketing messages"]
// @@protoc_insertion_point(message:CMarketingMessages_GetMarketingMessagesViewerRangeStats_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_GetMarketingMessagesViewerRangeStats_Request {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessages_GetMarketingMessagesViewerRangeStats_Request.rt_start_time)
    pub rt_start_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMarketingMessages_GetMarketingMessagesViewerRangeStats_Request.rt_end_time)
    pub rt_end_time: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_GetMarketingMessagesViewerRangeStats_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_GetMarketingMessagesViewerRangeStats_Request {
    fn default() -> &'a CMarketingMessages_GetMarketingMessagesViewerRangeStats_Request {
        <CMarketingMessages_GetMarketingMessagesViewerRangeStats_Request as ::protobuf::Message>::default_instance()
    }
}

impl CMarketingMessages_GetMarketingMessagesViewerRangeStats_Request {
    pub fn new() -> CMarketingMessages_GetMarketingMessagesViewerRangeStats_Request {
        ::std::default::Default::default()
    }

    // optional uint32 rt_start_time = 1;

    pub fn rt_start_time(&self) -> u32 {
        self.rt_start_time.unwrap_or(0)
    }

    pub fn clear_rt_start_time(&mut self) {
        self.rt_start_time = ::std::option::Option::None;
    }

    pub fn has_rt_start_time(&self) -> bool {
        self.rt_start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rt_start_time(&mut self, v: u32) {
        self.rt_start_time = ::std::option::Option::Some(v);
    }

    // optional uint32 rt_end_time = 2;

    pub fn rt_end_time(&self) -> u32 {
        self.rt_end_time.unwrap_or(0)
    }

    pub fn clear_rt_end_time(&mut self) {
        self.rt_end_time = ::std::option::Option::None;
    }

    pub fn has_rt_end_time(&self) -> bool {
        self.rt_end_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rt_end_time(&mut self, v: u32) {
        self.rt_end_time = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMarketingMessages_GetMarketingMessagesViewerRangeStats_Request {
    const NAME: &'static str = "CMarketingMessages_GetMarketingMessagesViewerRangeStats_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.rt_start_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.rt_end_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rt_start_time {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.rt_end_time {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.rt_start_time {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.rt_end_time {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_GetMarketingMessagesViewerRangeStats_Request {
        CMarketingMessages_GetMarketingMessagesViewerRangeStats_Request::new()
    }

    fn clear(&mut self) {
        self.rt_start_time = ::std::option::Option::None;
        self.rt_end_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_GetMarketingMessagesViewerRangeStats_Request {
        static instance: CMarketingMessages_GetMarketingMessagesViewerRangeStats_Request = CMarketingMessages_GetMarketingMessagesViewerRangeStats_Request {
            rt_start_time: ::std::option::Option::None,
            rt_end_time: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMarketingMessages_GetMarketingMessagesViewerRangeStats_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_GetMarketingMessagesViewerRangeStats_Response {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessages_GetMarketingMessagesViewerRangeStats_Response.stats)
    pub stats: ::std::vec::Vec<CMarketingMessageHourlyStats>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_GetMarketingMessagesViewerRangeStats_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_GetMarketingMessagesViewerRangeStats_Response {
    fn default() -> &'a CMarketingMessages_GetMarketingMessagesViewerRangeStats_Response {
        <CMarketingMessages_GetMarketingMessagesViewerRangeStats_Response as ::protobuf::Message>::default_instance()
    }
}

impl CMarketingMessages_GetMarketingMessagesViewerRangeStats_Response {
    pub fn new() -> CMarketingMessages_GetMarketingMessagesViewerRangeStats_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMarketingMessages_GetMarketingMessagesViewerRangeStats_Response {
    const NAME: &'static str = "CMarketingMessages_GetMarketingMessagesViewerRangeStats_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.stats.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.stats {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_GetMarketingMessagesViewerRangeStats_Response {
        CMarketingMessages_GetMarketingMessagesViewerRangeStats_Response::new()
    }

    fn clear(&mut self) {
        self.stats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_GetMarketingMessagesViewerRangeStats_Response {
        static instance: CMarketingMessages_GetMarketingMessagesViewerRangeStats_Response = CMarketingMessages_GetMarketingMessagesViewerRangeStats_Response {
            stats: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EMarketingMessageType)
pub enum EMarketingMessageType {
    // @@protoc_insertion_point(enum_value:EMarketingMessageType.k_EMarketingMessageInvalid)
    k_EMarketingMessageInvalid = 0,
    // @@protoc_insertion_point(enum_value:EMarketingMessageType.k_EMarketingMessageNowAvailable)
    k_EMarketingMessageNowAvailable = 1,
    // @@protoc_insertion_point(enum_value:EMarketingMessageType.k_EMarketingMessageWeekendDeal)
    k_EMarketingMessageWeekendDeal = 2,
    // @@protoc_insertion_point(enum_value:EMarketingMessageType.k_EMarketingMessagePrePurchase)
    k_EMarketingMessagePrePurchase = 3,
    // @@protoc_insertion_point(enum_value:EMarketingMessageType.k_EMarketingMessagePlayNow)
    k_EMarketingMessagePlayNow = 4,
    // @@protoc_insertion_point(enum_value:EMarketingMessageType.k_EMarketingMessagePreloadNow)
    k_EMarketingMessagePreloadNow = 5,
    // @@protoc_insertion_point(enum_value:EMarketingMessageType.k_EMarketingMessageGeneral)
    k_EMarketingMessageGeneral = 6,
    // @@protoc_insertion_point(enum_value:EMarketingMessageType.k_EMarketingMessageDemoQuit)
    k_EMarketingMessageDemoQuit = 7,
    // @@protoc_insertion_point(enum_value:EMarketingMessageType.k_EMarketingMessageGifting)
    k_EMarketingMessageGifting = 8,
    // @@protoc_insertion_point(enum_value:EMarketingMessageType.k_EMarketingMessageEJsKorner)
    k_EMarketingMessageEJsKorner = 9,
    // @@protoc_insertion_point(enum_value:EMarketingMessageType.k_EMarketingMessageUpdate)
    k_EMarketingMessageUpdate = 10,
    // @@protoc_insertion_point(enum_value:EMarketingMessageType.k_EMarketingMessageMidweekDeal)
    k_EMarketingMessageMidweekDeal = 11,
    // @@protoc_insertion_point(enum_value:EMarketingMessageType.k_EMarketingMessageDailyDeal)
    k_EMarketingMessageDailyDeal = 12,
}

impl ::protobuf::Enum for EMarketingMessageType {
    const NAME: &'static str = "EMarketingMessageType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EMarketingMessageType> {
        match value {
            0 => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessageInvalid),
            1 => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessageNowAvailable),
            2 => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessageWeekendDeal),
            3 => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessagePrePurchase),
            4 => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessagePlayNow),
            5 => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessagePreloadNow),
            6 => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessageGeneral),
            7 => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessageDemoQuit),
            8 => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessageGifting),
            9 => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessageEJsKorner),
            10 => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessageUpdate),
            11 => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessageMidweekDeal),
            12 => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessageDailyDeal),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EMarketingMessageType> {
        match str {
            "k_EMarketingMessageInvalid" => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessageInvalid),
            "k_EMarketingMessageNowAvailable" => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessageNowAvailable),
            "k_EMarketingMessageWeekendDeal" => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessageWeekendDeal),
            "k_EMarketingMessagePrePurchase" => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessagePrePurchase),
            "k_EMarketingMessagePlayNow" => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessagePlayNow),
            "k_EMarketingMessagePreloadNow" => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessagePreloadNow),
            "k_EMarketingMessageGeneral" => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessageGeneral),
            "k_EMarketingMessageDemoQuit" => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessageDemoQuit),
            "k_EMarketingMessageGifting" => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessageGifting),
            "k_EMarketingMessageEJsKorner" => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessageEJsKorner),
            "k_EMarketingMessageUpdate" => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessageUpdate),
            "k_EMarketingMessageMidweekDeal" => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessageMidweekDeal),
            "k_EMarketingMessageDailyDeal" => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessageDailyDeal),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EMarketingMessageType] = &[
        EMarketingMessageType::k_EMarketingMessageInvalid,
        EMarketingMessageType::k_EMarketingMessageNowAvailable,
        EMarketingMessageType::k_EMarketingMessageWeekendDeal,
        EMarketingMessageType::k_EMarketingMessagePrePurchase,
        EMarketingMessageType::k_EMarketingMessagePlayNow,
        EMarketingMessageType::k_EMarketingMessagePreloadNow,
        EMarketingMessageType::k_EMarketingMessageGeneral,
        EMarketingMessageType::k_EMarketingMessageDemoQuit,
        EMarketingMessageType::k_EMarketingMessageGifting,
        EMarketingMessageType::k_EMarketingMessageEJsKorner,
        EMarketingMessageType::k_EMarketingMessageUpdate,
        EMarketingMessageType::k_EMarketingMessageMidweekDeal,
        EMarketingMessageType::k_EMarketingMessageDailyDeal,
    ];
}

impl ::std::default::Default for EMarketingMessageType {
    fn default() -> Self {
        EMarketingMessageType::k_EMarketingMessageInvalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EMarketingMessageVisibility)
pub enum EMarketingMessageVisibility {
    // @@protoc_insertion_point(enum_value:EMarketingMessageVisibility.k_EMarketingMessageVisibleBeta)
    k_EMarketingMessageVisibleBeta = 1,
    // @@protoc_insertion_point(enum_value:EMarketingMessageVisibility.k_EMarketingMessageVisiblePublic)
    k_EMarketingMessageVisiblePublic = 2,
}

impl ::protobuf::Enum for EMarketingMessageVisibility {
    const NAME: &'static str = "EMarketingMessageVisibility";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EMarketingMessageVisibility> {
        match value {
            1 => ::std::option::Option::Some(EMarketingMessageVisibility::k_EMarketingMessageVisibleBeta),
            2 => ::std::option::Option::Some(EMarketingMessageVisibility::k_EMarketingMessageVisiblePublic),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EMarketingMessageVisibility> {
        match str {
            "k_EMarketingMessageVisibleBeta" => ::std::option::Option::Some(EMarketingMessageVisibility::k_EMarketingMessageVisibleBeta),
            "k_EMarketingMessageVisiblePublic" => ::std::option::Option::Some(EMarketingMessageVisibility::k_EMarketingMessageVisiblePublic),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EMarketingMessageVisibility] = &[
        EMarketingMessageVisibility::k_EMarketingMessageVisibleBeta,
        EMarketingMessageVisibility::k_EMarketingMessageVisiblePublic,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EMarketingMessageVisibility {
    fn default() -> Self {
        EMarketingMessageVisibility::k_EMarketingMessageVisibleBeta
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EMarketingMessageAssociationType)
pub enum EMarketingMessageAssociationType {
    // @@protoc_insertion_point(enum_value:EMarketingMessageAssociationType.k_EMarketingMessageNoAssociation)
    k_EMarketingMessageNoAssociation = 0,
    // @@protoc_insertion_point(enum_value:EMarketingMessageAssociationType.k_EMarketingMessageAppAssociation)
    k_EMarketingMessageAppAssociation = 1,
    // @@protoc_insertion_point(enum_value:EMarketingMessageAssociationType.k_EMarketingMessageSubscriptionAssociation)
    k_EMarketingMessageSubscriptionAssociation = 2,
    // @@protoc_insertion_point(enum_value:EMarketingMessageAssociationType.k_EMarketingMessagePublisherAssociation)
    k_EMarketingMessagePublisherAssociation = 3,
    // @@protoc_insertion_point(enum_value:EMarketingMessageAssociationType.k_EMarketingMessageGenreAssociation)
    k_EMarketingMessageGenreAssociation = 4,
    // @@protoc_insertion_point(enum_value:EMarketingMessageAssociationType.k_EMarketingMessageBundleAssociation)
    k_EMarketingMessageBundleAssociation = 5,
}

impl ::protobuf::Enum for EMarketingMessageAssociationType {
    const NAME: &'static str = "EMarketingMessageAssociationType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EMarketingMessageAssociationType> {
        match value {
            0 => ::std::option::Option::Some(EMarketingMessageAssociationType::k_EMarketingMessageNoAssociation),
            1 => ::std::option::Option::Some(EMarketingMessageAssociationType::k_EMarketingMessageAppAssociation),
            2 => ::std::option::Option::Some(EMarketingMessageAssociationType::k_EMarketingMessageSubscriptionAssociation),
            3 => ::std::option::Option::Some(EMarketingMessageAssociationType::k_EMarketingMessagePublisherAssociation),
            4 => ::std::option::Option::Some(EMarketingMessageAssociationType::k_EMarketingMessageGenreAssociation),
            5 => ::std::option::Option::Some(EMarketingMessageAssociationType::k_EMarketingMessageBundleAssociation),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EMarketingMessageAssociationType> {
        match str {
            "k_EMarketingMessageNoAssociation" => ::std::option::Option::Some(EMarketingMessageAssociationType::k_EMarketingMessageNoAssociation),
            "k_EMarketingMessageAppAssociation" => ::std::option::Option::Some(EMarketingMessageAssociationType::k_EMarketingMessageAppAssociation),
            "k_EMarketingMessageSubscriptionAssociation" => ::std::option::Option::Some(EMarketingMessageAssociationType::k_EMarketingMessageSubscriptionAssociation),
            "k_EMarketingMessagePublisherAssociation" => ::std::option::Option::Some(EMarketingMessageAssociationType::k_EMarketingMessagePublisherAssociation),
            "k_EMarketingMessageGenreAssociation" => ::std::option::Option::Some(EMarketingMessageAssociationType::k_EMarketingMessageGenreAssociation),
            "k_EMarketingMessageBundleAssociation" => ::std::option::Option::Some(EMarketingMessageAssociationType::k_EMarketingMessageBundleAssociation),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EMarketingMessageAssociationType] = &[
        EMarketingMessageAssociationType::k_EMarketingMessageNoAssociation,
        EMarketingMessageAssociationType::k_EMarketingMessageAppAssociation,
        EMarketingMessageAssociationType::k_EMarketingMessageSubscriptionAssociation,
        EMarketingMessageAssociationType::k_EMarketingMessagePublisherAssociation,
        EMarketingMessageAssociationType::k_EMarketingMessageGenreAssociation,
        EMarketingMessageAssociationType::k_EMarketingMessageBundleAssociation,
    ];
}

impl ::std::default::Default for EMarketingMessageAssociationType {
    fn default() -> Self {
        EMarketingMessageAssociationType::k_EMarketingMessageNoAssociation
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EMarketingMessageTemplateType)
pub enum EMarketingMessageTemplateType {
    // @@protoc_insertion_point(enum_value:EMarketingMessageTemplateType.k_EMarketingMessageTemplate_Unknown)
    k_EMarketingMessageTemplate_Unknown = 0,
    // @@protoc_insertion_point(enum_value:EMarketingMessageTemplateType.k_EMarketingMessageTemplate_Image)
    k_EMarketingMessageTemplate_Image = 1,
    // @@protoc_insertion_point(enum_value:EMarketingMessageTemplateType.k_EMarketingMessageTemplate_Animated)
    k_EMarketingMessageTemplate_Animated = 2,
    // @@protoc_insertion_point(enum_value:EMarketingMessageTemplateType.k_EMarketingMessageTemplate_Featured_Video)
    k_EMarketingMessageTemplate_Featured_Video = 3,
    // @@protoc_insertion_point(enum_value:EMarketingMessageTemplateType.k_EMarketingMessageTemplate_DLC_Override)
    k_EMarketingMessageTemplate_DLC_Override = 4,
    // @@protoc_insertion_point(enum_value:EMarketingMessageTemplateType.k_EMarketingMessageTemplate_Replay)
    k_EMarketingMessageTemplate_Replay = 5,
    // @@protoc_insertion_point(enum_value:EMarketingMessageTemplateType.k_EMarketingMessageTemplate_MAX)
    k_EMarketingMessageTemplate_MAX = 6,
}

impl ::protobuf::Enum for EMarketingMessageTemplateType {
    const NAME: &'static str = "EMarketingMessageTemplateType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EMarketingMessageTemplateType> {
        match value {
            0 => ::std::option::Option::Some(EMarketingMessageTemplateType::k_EMarketingMessageTemplate_Unknown),
            1 => ::std::option::Option::Some(EMarketingMessageTemplateType::k_EMarketingMessageTemplate_Image),
            2 => ::std::option::Option::Some(EMarketingMessageTemplateType::k_EMarketingMessageTemplate_Animated),
            3 => ::std::option::Option::Some(EMarketingMessageTemplateType::k_EMarketingMessageTemplate_Featured_Video),
            4 => ::std::option::Option::Some(EMarketingMessageTemplateType::k_EMarketingMessageTemplate_DLC_Override),
            5 => ::std::option::Option::Some(EMarketingMessageTemplateType::k_EMarketingMessageTemplate_Replay),
            6 => ::std::option::Option::Some(EMarketingMessageTemplateType::k_EMarketingMessageTemplate_MAX),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EMarketingMessageTemplateType> {
        match str {
            "k_EMarketingMessageTemplate_Unknown" => ::std::option::Option::Some(EMarketingMessageTemplateType::k_EMarketingMessageTemplate_Unknown),
            "k_EMarketingMessageTemplate_Image" => ::std::option::Option::Some(EMarketingMessageTemplateType::k_EMarketingMessageTemplate_Image),
            "k_EMarketingMessageTemplate_Animated" => ::std::option::Option::Some(EMarketingMessageTemplateType::k_EMarketingMessageTemplate_Animated),
            "k_EMarketingMessageTemplate_Featured_Video" => ::std::option::Option::Some(EMarketingMessageTemplateType::k_EMarketingMessageTemplate_Featured_Video),
            "k_EMarketingMessageTemplate_DLC_Override" => ::std::option::Option::Some(EMarketingMessageTemplateType::k_EMarketingMessageTemplate_DLC_Override),
            "k_EMarketingMessageTemplate_Replay" => ::std::option::Option::Some(EMarketingMessageTemplateType::k_EMarketingMessageTemplate_Replay),
            "k_EMarketingMessageTemplate_MAX" => ::std::option::Option::Some(EMarketingMessageTemplateType::k_EMarketingMessageTemplate_MAX),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EMarketingMessageTemplateType] = &[
        EMarketingMessageTemplateType::k_EMarketingMessageTemplate_Unknown,
        EMarketingMessageTemplateType::k_EMarketingMessageTemplate_Image,
        EMarketingMessageTemplateType::k_EMarketingMessageTemplate_Animated,
        EMarketingMessageTemplateType::k_EMarketingMessageTemplate_Featured_Video,
        EMarketingMessageTemplateType::k_EMarketingMessageTemplate_DLC_Override,
        EMarketingMessageTemplateType::k_EMarketingMessageTemplate_Replay,
        EMarketingMessageTemplateType::k_EMarketingMessageTemplate_MAX,
    ];
}

impl ::std::default::Default for EMarketingMessageTemplateType {
    fn default() -> Self {
        EMarketingMessageTemplateType::k_EMarketingMessageTemplate_Unknown
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EMarketingMessageLookupType)
pub enum EMarketingMessageLookupType {
    // @@protoc_insertion_point(enum_value:EMarketingMessageLookupType.k_EMarketingMessageLookupInvalid)
    k_EMarketingMessageLookupInvalid = 0,
    // @@protoc_insertion_point(enum_value:EMarketingMessageLookupType.k_EMarketingMessageLookupByGID)
    k_EMarketingMessageLookupByGID = 1,
    // @@protoc_insertion_point(enum_value:EMarketingMessageLookupType.k_EMarketingMessageLookupActive)
    k_EMarketingMessageLookupActive = 2,
    // @@protoc_insertion_point(enum_value:EMarketingMessageLookupType.k_EMarketingMessageLookupByTitleWithType)
    k_EMarketingMessageLookupByTitleWithType = 3,
    // @@protoc_insertion_point(enum_value:EMarketingMessageLookupType.k_EMarketingMessageLookupByGIDList)
    k_EMarketingMessageLookupByGIDList = 4,
}

impl ::protobuf::Enum for EMarketingMessageLookupType {
    const NAME: &'static str = "EMarketingMessageLookupType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EMarketingMessageLookupType> {
        match value {
            0 => ::std::option::Option::Some(EMarketingMessageLookupType::k_EMarketingMessageLookupInvalid),
            1 => ::std::option::Option::Some(EMarketingMessageLookupType::k_EMarketingMessageLookupByGID),
            2 => ::std::option::Option::Some(EMarketingMessageLookupType::k_EMarketingMessageLookupActive),
            3 => ::std::option::Option::Some(EMarketingMessageLookupType::k_EMarketingMessageLookupByTitleWithType),
            4 => ::std::option::Option::Some(EMarketingMessageLookupType::k_EMarketingMessageLookupByGIDList),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EMarketingMessageLookupType> {
        match str {
            "k_EMarketingMessageLookupInvalid" => ::std::option::Option::Some(EMarketingMessageLookupType::k_EMarketingMessageLookupInvalid),
            "k_EMarketingMessageLookupByGID" => ::std::option::Option::Some(EMarketingMessageLookupType::k_EMarketingMessageLookupByGID),
            "k_EMarketingMessageLookupActive" => ::std::option::Option::Some(EMarketingMessageLookupType::k_EMarketingMessageLookupActive),
            "k_EMarketingMessageLookupByTitleWithType" => ::std::option::Option::Some(EMarketingMessageLookupType::k_EMarketingMessageLookupByTitleWithType),
            "k_EMarketingMessageLookupByGIDList" => ::std::option::Option::Some(EMarketingMessageLookupType::k_EMarketingMessageLookupByGIDList),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EMarketingMessageLookupType] = &[
        EMarketingMessageLookupType::k_EMarketingMessageLookupInvalid,
        EMarketingMessageLookupType::k_EMarketingMessageLookupByGID,
        EMarketingMessageLookupType::k_EMarketingMessageLookupActive,
        EMarketingMessageLookupType::k_EMarketingMessageLookupByTitleWithType,
        EMarketingMessageLookupType::k_EMarketingMessageLookupByGIDList,
    ];
}

impl ::std::default::Default for EMarketingMessageLookupType {
    fn default() -> Self {
        EMarketingMessageLookupType::k_EMarketingMessageLookupInvalid
    }
}

#[allow(unused_imports)]
use crate::steammessages_base::*;
#[allow(unused_imports)]
use crate::steammessages_unified_base_steamclient::*;
#[allow(unused_imports)]
use crate::steammessages_storebrowse_steamclient::*;
impl crate::RpcMessage for CMarketingMessages_GetActiveMarketingMessages_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMarketingMessageProto {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMarketingMessages_GetActiveMarketingMessages_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMarketingMessages_GetMarketingMessagesForUser_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CDisplayMarketingMessage {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMarketingMessages_GetMarketingMessagesForUser_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage
for CMarketingMessages_DoesUserHavePendingMarketingMessages_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage
for CMarketingMessages_DoesUserHavePendingMarketingMessages_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMarketingMessages_GetDisplayMarketingMessage_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMarketingMessages_GetDisplayMarketingMessage_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMarketingMessages_MarkMessageSeen_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMarketingMessages_GetMarketingMessage_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMarketingMessages_GetMarketingMessage_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMarketingMessages_CreateMarketingMessage_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMarketingMessages_CreateMarketingMessage_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMarketingMessages_UpdateMarketingMessage_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMarketingMessages_UpdateMarketingMessage_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMarketingMessages_DeleteMarketingMessage_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMarketingMessages_DeleteMarketingMessage_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMarketingMessages_FindMarketingMessages_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMarketingMessages_FindMarketingMessages_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMarketingMessages_GetMarketingMessageViewerStats_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMarketingMessageHourlyStats {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMarketingMessages_GetMarketingMessageViewerStats_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage
for CMarketingMessages_GetMarketingMessagesViewerRangeStats_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage
for CMarketingMessages_GetMarketingMessagesViewerRangeStats_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
///Marketing message data ("Steam News" updates at client startup).
struct MarketingMessages {}
impl crate::RpcService for MarketingMessages {
    const SERVICE_NAME: &'static str = "MarketingMessages";
}
impl crate::RpcMethod for CMarketingMessages_CreateMarketingMessage_Request {
    const METHOD_NAME: &'static str = "MarketingMessages.CreateMarketingMessage#1";
    type Response = CMarketingMessages_CreateMarketingMessage_Response;
}
impl crate::RpcMethod for CMarketingMessages_DeleteMarketingMessage_Request {
    const METHOD_NAME: &'static str = "MarketingMessages.DeleteMarketingMessage#1";
    type Response = CMarketingMessages_DeleteMarketingMessage_Response;
}
impl crate::RpcMethod
for CMarketingMessages_DoesUserHavePendingMarketingMessages_Request {
    const METHOD_NAME: &'static str = "MarketingMessages.DoesUserHavePendingMarketingMessages#1";
    type Response = CMarketingMessages_DoesUserHavePendingMarketingMessages_Response;
}
impl crate::RpcMethod for CMarketingMessages_FindMarketingMessages_Request {
    const METHOD_NAME: &'static str = "MarketingMessages.FindMarketingMessages#1";
    type Response = CMarketingMessages_FindMarketingMessages_Response;
}
impl crate::RpcMethod for CMarketingMessages_GetActiveMarketingMessages_Request {
    const METHOD_NAME: &'static str = "MarketingMessages.GetActiveMarketingMessages#1";
    type Response = CMarketingMessages_GetActiveMarketingMessages_Response;
}
impl crate::RpcMethod for CMarketingMessages_GetDisplayMarketingMessage_Request {
    const METHOD_NAME: &'static str = "MarketingMessages.GetDisplayMarketingMessage#1";
    type Response = CMarketingMessages_GetDisplayMarketingMessage_Response;
}
impl crate::RpcMethod for CMarketingMessages_GetMarketingMessageViewerStats_Request {
    const METHOD_NAME: &'static str = "MarketingMessages.GetMarketingMessageViewerStats#1";
    type Response = CMarketingMessages_GetMarketingMessageViewerStats_Response;
}
impl crate::RpcMethod for CMarketingMessages_GetMarketingMessage_Request {
    const METHOD_NAME: &'static str = "MarketingMessages.GetMarketingMessage#1";
    type Response = CMarketingMessages_GetMarketingMessage_Response;
}
impl crate::RpcMethod for CMarketingMessages_GetMarketingMessagesForUser_Request {
    const METHOD_NAME: &'static str = "MarketingMessages.GetMarketingMessagesForUser#1";
    type Response = CMarketingMessages_GetMarketingMessagesForUser_Response;
}
impl crate::RpcMethod
for CMarketingMessages_GetMarketingMessagesViewerRangeStats_Request {
    const METHOD_NAME: &'static str = "MarketingMessages.GetMarketingMessagesViewerRangeStats#1";
    type Response = CMarketingMessages_GetMarketingMessagesViewerRangeStats_Response;
}
impl crate::RpcMethod for CMarketingMessages_MarkMessageSeen_Notification {
    const METHOD_NAME: &'static str = "MarketingMessages.MarkMessageSeen#1";
    type Response = ();
}
impl crate::RpcMethod for CMarketingMessages_UpdateMarketingMessage_Request {
    const METHOD_NAME: &'static str = "MarketingMessages.UpdateMarketingMessage#1";
    type Response = CMarketingMessages_UpdateMarketingMessage_Response;
}
