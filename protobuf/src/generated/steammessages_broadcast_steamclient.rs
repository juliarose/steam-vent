// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_broadcast.steamclient.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

#[doc = "Request from client to directory to begin a broadcast session. No data being sent to relay; just available for broadcast."]
// @@protoc_insertion_point(message:CBroadcast_BeginBroadcastSession_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_BeginBroadcastSession_Request {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_BeginBroadcastSession_Request.permission)
    pub permission: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CBroadcast_BeginBroadcastSession_Request.gameid)
    pub gameid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_BeginBroadcastSession_Request.client_instance_id)
    pub client_instance_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_BeginBroadcastSession_Request.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBroadcast_BeginBroadcastSession_Request.cellid)
    pub cellid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CBroadcast_BeginBroadcastSession_Request.rtmp_token)
    pub rtmp_token: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_BeginBroadcastSession_Request.thumbnail_upload)
    pub thumbnail_upload: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CBroadcast_BeginBroadcastSession_Request.client_beta)
    pub client_beta: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBroadcast_BeginBroadcastSession_Request.sysid)
    pub sysid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CBroadcast_BeginBroadcastSession_Request.allow_webrtc)
    pub allow_webrtc: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_BeginBroadcastSession_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_BeginBroadcastSession_Request {
    fn default() -> &'a CBroadcast_BeginBroadcastSession_Request {
        <CBroadcast_BeginBroadcastSession_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_BeginBroadcastSession_Request {
    pub fn new() -> CBroadcast_BeginBroadcastSession_Request {
        ::std::default::Default::default()
    }

    // optional int32 permission = 1;

    pub fn permission(&self) -> i32 {
        self.permission.unwrap_or(0)
    }

    pub fn clear_permission(&mut self) {
        self.permission = ::std::option::Option::None;
    }

    pub fn has_permission(&self) -> bool {
        self.permission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permission(&mut self, v: i32) {
        self.permission = ::std::option::Option::Some(v);
    }

    // optional uint64 gameid = 2;

    pub fn gameid(&self) -> u64 {
        self.gameid.unwrap_or(0)
    }

    pub fn clear_gameid(&mut self) {
        self.gameid = ::std::option::Option::None;
    }

    pub fn has_gameid(&self) -> bool {
        self.gameid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameid(&mut self, v: u64) {
        self.gameid = ::std::option::Option::Some(v);
    }

    // optional uint64 client_instance_id = 3;

    pub fn client_instance_id(&self) -> u64 {
        self.client_instance_id.unwrap_or(0)
    }

    pub fn clear_client_instance_id(&mut self) {
        self.client_instance_id = ::std::option::Option::None;
    }

    pub fn has_client_instance_id(&self) -> bool {
        self.client_instance_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_instance_id(&mut self, v: u64) {
        self.client_instance_id = ::std::option::Option::Some(v);
    }

    // optional string title = 4;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 cellid = 5;

    pub fn cellid(&self) -> u32 {
        self.cellid.unwrap_or(0)
    }

    pub fn clear_cellid(&mut self) {
        self.cellid = ::std::option::Option::None;
    }

    pub fn has_cellid(&self) -> bool {
        self.cellid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cellid(&mut self, v: u32) {
        self.cellid = ::std::option::Option::Some(v);
    }

    // optional uint64 rtmp_token = 6;

    pub fn rtmp_token(&self) -> u64 {
        self.rtmp_token.unwrap_or(0)
    }

    pub fn clear_rtmp_token(&mut self) {
        self.rtmp_token = ::std::option::Option::None;
    }

    pub fn has_rtmp_token(&self) -> bool {
        self.rtmp_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtmp_token(&mut self, v: u64) {
        self.rtmp_token = ::std::option::Option::Some(v);
    }

    // optional bool thumbnail_upload = 7;

    pub fn thumbnail_upload(&self) -> bool {
        self.thumbnail_upload.unwrap_or(false)
    }

    pub fn clear_thumbnail_upload(&mut self) {
        self.thumbnail_upload = ::std::option::Option::None;
    }

    pub fn has_thumbnail_upload(&self) -> bool {
        self.thumbnail_upload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnail_upload(&mut self, v: bool) {
        self.thumbnail_upload = ::std::option::Option::Some(v);
    }

    // optional string client_beta = 8;

    pub fn client_beta(&self) -> &str {
        match self.client_beta.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_client_beta(&mut self) {
        self.client_beta = ::std::option::Option::None;
    }

    pub fn has_client_beta(&self) -> bool {
        self.client_beta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_beta(&mut self, v: ::std::string::String) {
        self.client_beta = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_beta(&mut self) -> &mut ::std::string::String {
        if self.client_beta.is_none() {
            self.client_beta = ::std::option::Option::Some(::std::string::String::new());
        }
        self.client_beta.as_mut().unwrap()
    }

    // Take field
    pub fn take_client_beta(&mut self) -> ::std::string::String {
        self.client_beta.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 sysid = 9;

    pub fn sysid(&self) -> u32 {
        self.sysid.unwrap_or(0)
    }

    pub fn clear_sysid(&mut self) {
        self.sysid = ::std::option::Option::None;
    }

    pub fn has_sysid(&self) -> bool {
        self.sysid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sysid(&mut self, v: u32) {
        self.sysid = ::std::option::Option::Some(v);
    }

    // optional bool allow_webrtc = 10;

    pub fn allow_webrtc(&self) -> bool {
        self.allow_webrtc.unwrap_or(false)
    }

    pub fn clear_allow_webrtc(&mut self) {
        self.allow_webrtc = ::std::option::Option::None;
    }

    pub fn has_allow_webrtc(&self) -> bool {
        self.allow_webrtc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_webrtc(&mut self, v: bool) {
        self.allow_webrtc = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_BeginBroadcastSession_Request {
    const NAME: &'static str = "CBroadcast_BeginBroadcastSession_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.permission = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.gameid = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.client_instance_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                34 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.cellid = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.rtmp_token = ::std::option::Option::Some(is.read_uint64()?);
                },
                56 => {
                    self.thumbnail_upload = ::std::option::Option::Some(is.read_bool()?);
                },
                66 => {
                    self.client_beta = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.sysid = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.allow_webrtc = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.permission {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.gameid {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.client_instance_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.cellid {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.rtmp_token {
            my_size += ::protobuf::rt::uint64_size(6, v);
        }
        if let Some(v) = self.thumbnail_upload {
            my_size += 1 + 1;
        }
        if let Some(v) = self.client_beta.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.sysid {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.allow_webrtc {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.permission {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.gameid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.client_instance_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.cellid {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.rtmp_token {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.thumbnail_upload {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.client_beta.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.sysid {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.allow_webrtc {
            os.write_bool(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_BeginBroadcastSession_Request {
        CBroadcast_BeginBroadcastSession_Request::new()
    }

    fn clear(&mut self) {
        self.permission = ::std::option::Option::None;
        self.gameid = ::std::option::Option::None;
        self.client_instance_id = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.cellid = ::std::option::Option::None;
        self.rtmp_token = ::std::option::Option::None;
        self.thumbnail_upload = ::std::option::Option::None;
        self.client_beta = ::std::option::Option::None;
        self.sysid = ::std::option::Option::None;
        self.allow_webrtc = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_BeginBroadcastSession_Request {
        static instance: CBroadcast_BeginBroadcastSession_Request = CBroadcast_BeginBroadcastSession_Request {
            permission: ::std::option::Option::None,
            gameid: ::std::option::Option::None,
            client_instance_id: ::std::option::Option::None,
            title: ::std::option::Option::None,
            cellid: ::std::option::Option::None,
            rtmp_token: ::std::option::Option::None,
            thumbnail_upload: ::std::option::Option::None,
            client_beta: ::std::option::Option::None,
            sysid: ::std::option::Option::None,
            allow_webrtc: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CBroadcast_BeginBroadcastSession_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_BeginBroadcastSession_Response {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_BeginBroadcastSession_Response.broadcast_id)
    pub broadcast_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_BeginBroadcastSession_Response.thumbnail_upload_address)
    pub thumbnail_upload_address: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBroadcast_BeginBroadcastSession_Response.thumbnail_upload_token)
    pub thumbnail_upload_token: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBroadcast_BeginBroadcastSession_Response.thumbnail_interval_seconds)
    pub thumbnail_interval_seconds: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CBroadcast_BeginBroadcastSession_Response.heartbeat_interval_seconds)
    pub heartbeat_interval_seconds: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_BeginBroadcastSession_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_BeginBroadcastSession_Response {
    fn default() -> &'a CBroadcast_BeginBroadcastSession_Response {
        <CBroadcast_BeginBroadcastSession_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_BeginBroadcastSession_Response {
    pub fn new() -> CBroadcast_BeginBroadcastSession_Response {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_id = 1;

    pub fn broadcast_id(&self) -> u64 {
        self.broadcast_id.unwrap_or(0)
    }

    pub fn clear_broadcast_id(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_id(&self) -> bool {
        self.broadcast_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_id(&mut self, v: u64) {
        self.broadcast_id = ::std::option::Option::Some(v);
    }

    // optional string thumbnail_upload_address = 2;

    pub fn thumbnail_upload_address(&self) -> &str {
        match self.thumbnail_upload_address.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_thumbnail_upload_address(&mut self) {
        self.thumbnail_upload_address = ::std::option::Option::None;
    }

    pub fn has_thumbnail_upload_address(&self) -> bool {
        self.thumbnail_upload_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnail_upload_address(&mut self, v: ::std::string::String) {
        self.thumbnail_upload_address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnail_upload_address(&mut self) -> &mut ::std::string::String {
        if self.thumbnail_upload_address.is_none() {
            self.thumbnail_upload_address = ::std::option::Option::Some(::std::string::String::new());
        }
        self.thumbnail_upload_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnail_upload_address(&mut self) -> ::std::string::String {
        self.thumbnail_upload_address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string thumbnail_upload_token = 3;

    pub fn thumbnail_upload_token(&self) -> &str {
        match self.thumbnail_upload_token.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_thumbnail_upload_token(&mut self) {
        self.thumbnail_upload_token = ::std::option::Option::None;
    }

    pub fn has_thumbnail_upload_token(&self) -> bool {
        self.thumbnail_upload_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnail_upload_token(&mut self, v: ::std::string::String) {
        self.thumbnail_upload_token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnail_upload_token(&mut self) -> &mut ::std::string::String {
        if self.thumbnail_upload_token.is_none() {
            self.thumbnail_upload_token = ::std::option::Option::Some(::std::string::String::new());
        }
        self.thumbnail_upload_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnail_upload_token(&mut self) -> ::std::string::String {
        self.thumbnail_upload_token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 thumbnail_interval_seconds = 4;

    pub fn thumbnail_interval_seconds(&self) -> u32 {
        self.thumbnail_interval_seconds.unwrap_or(0)
    }

    pub fn clear_thumbnail_interval_seconds(&mut self) {
        self.thumbnail_interval_seconds = ::std::option::Option::None;
    }

    pub fn has_thumbnail_interval_seconds(&self) -> bool {
        self.thumbnail_interval_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnail_interval_seconds(&mut self, v: u32) {
        self.thumbnail_interval_seconds = ::std::option::Option::Some(v);
    }

    // optional uint32 heartbeat_interval_seconds = 5;

    pub fn heartbeat_interval_seconds(&self) -> u32 {
        self.heartbeat_interval_seconds.unwrap_or(0)
    }

    pub fn clear_heartbeat_interval_seconds(&mut self) {
        self.heartbeat_interval_seconds = ::std::option::Option::None;
    }

    pub fn has_heartbeat_interval_seconds(&self) -> bool {
        self.heartbeat_interval_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_heartbeat_interval_seconds(&mut self, v: u32) {
        self.heartbeat_interval_seconds = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_BeginBroadcastSession_Response {
    const NAME: &'static str = "CBroadcast_BeginBroadcastSession_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    self.thumbnail_upload_address = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.thumbnail_upload_token = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.thumbnail_interval_seconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.heartbeat_interval_seconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.thumbnail_upload_address.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.thumbnail_upload_token.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.thumbnail_interval_seconds {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.heartbeat_interval_seconds {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.thumbnail_upload_address.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.thumbnail_upload_token.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.thumbnail_interval_seconds {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.heartbeat_interval_seconds {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_BeginBroadcastSession_Response {
        CBroadcast_BeginBroadcastSession_Response::new()
    }

    fn clear(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
        self.thumbnail_upload_address = ::std::option::Option::None;
        self.thumbnail_upload_token = ::std::option::Option::None;
        self.thumbnail_interval_seconds = ::std::option::Option::None;
        self.heartbeat_interval_seconds = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_BeginBroadcastSession_Response {
        static instance: CBroadcast_BeginBroadcastSession_Response = CBroadcast_BeginBroadcastSession_Response {
            broadcast_id: ::std::option::Option::None,
            thumbnail_upload_address: ::std::option::Option::None,
            thumbnail_upload_token: ::std::option::Option::None,
            thumbnail_interval_seconds: ::std::option::Option::None,
            heartbeat_interval_seconds: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Request from client to stop a broadcast session. Any uploads will terminate."]
// @@protoc_insertion_point(message:CBroadcast_EndBroadcastSession_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_EndBroadcastSession_Request {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_EndBroadcastSession_Request.broadcast_id)
    pub broadcast_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_EndBroadcastSession_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_EndBroadcastSession_Request {
    fn default() -> &'a CBroadcast_EndBroadcastSession_Request {
        <CBroadcast_EndBroadcastSession_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_EndBroadcastSession_Request {
    pub fn new() -> CBroadcast_EndBroadcastSession_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_id = 1;

    pub fn broadcast_id(&self) -> u64 {
        self.broadcast_id.unwrap_or(0)
    }

    pub fn clear_broadcast_id(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_id(&self) -> bool {
        self.broadcast_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_id(&mut self, v: u64) {
        self.broadcast_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_EndBroadcastSession_Request {
    const NAME: &'static str = "CBroadcast_EndBroadcastSession_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_EndBroadcastSession_Request {
        CBroadcast_EndBroadcastSession_Request::new()
    }

    fn clear(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_EndBroadcastSession_Request {
        static instance: CBroadcast_EndBroadcastSession_Request = CBroadcast_EndBroadcastSession_Request {
            broadcast_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CBroadcast_EndBroadcastSession_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_EndBroadcastSession_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_EndBroadcastSession_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_EndBroadcastSession_Response {
    fn default() -> &'a CBroadcast_EndBroadcastSession_Response {
        <CBroadcast_EndBroadcastSession_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_EndBroadcastSession_Response {
    pub fn new() -> CBroadcast_EndBroadcastSession_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CBroadcast_EndBroadcastSession_Response {
    const NAME: &'static str = "CBroadcast_EndBroadcastSession_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_EndBroadcastSession_Response {
        CBroadcast_EndBroadcastSession_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_EndBroadcastSession_Response {
        static instance: CBroadcast_EndBroadcastSession_Response = CBroadcast_EndBroadcastSession_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Request from client to begin sending video for a broadcast."]
// @@protoc_insertion_point(message:CBroadcast_StartBroadcastUpload_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_StartBroadcastUpload_Request {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_StartBroadcastUpload_Request.broadcast_id)
    pub broadcast_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_StartBroadcastUpload_Request.cellid)
    pub cellid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CBroadcast_StartBroadcastUpload_Request.as_rtmp)
    pub as_rtmp: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CBroadcast_StartBroadcastUpload_Request.delay_seconds)
    pub delay_seconds: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CBroadcast_StartBroadcastUpload_Request.rtmp_token)
    pub rtmp_token: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_StartBroadcastUpload_Request.upload_ip_address)
    pub upload_ip_address: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CBroadcast_StartBroadcastUpload_Request.is_replay)
    pub is_replay: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CBroadcast_StartBroadcastUpload_Request.sysid)
    pub sysid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_StartBroadcastUpload_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_StartBroadcastUpload_Request {
    fn default() -> &'a CBroadcast_StartBroadcastUpload_Request {
        <CBroadcast_StartBroadcastUpload_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_StartBroadcastUpload_Request {
    pub fn new() -> CBroadcast_StartBroadcastUpload_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_id = 1;

    pub fn broadcast_id(&self) -> u64 {
        self.broadcast_id.unwrap_or(0)
    }

    pub fn clear_broadcast_id(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_id(&self) -> bool {
        self.broadcast_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_id(&mut self, v: u64) {
        self.broadcast_id = ::std::option::Option::Some(v);
    }

    // optional uint32 cellid = 2;

    pub fn cellid(&self) -> u32 {
        self.cellid.unwrap_or(0)
    }

    pub fn clear_cellid(&mut self) {
        self.cellid = ::std::option::Option::None;
    }

    pub fn has_cellid(&self) -> bool {
        self.cellid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cellid(&mut self, v: u32) {
        self.cellid = ::std::option::Option::Some(v);
    }

    // optional bool as_rtmp = 3;

    pub fn as_rtmp(&self) -> bool {
        self.as_rtmp.unwrap_or(false)
    }

    pub fn clear_as_rtmp(&mut self) {
        self.as_rtmp = ::std::option::Option::None;
    }

    pub fn has_as_rtmp(&self) -> bool {
        self.as_rtmp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_as_rtmp(&mut self, v: bool) {
        self.as_rtmp = ::std::option::Option::Some(v);
    }

    // optional uint32 delay_seconds = 4;

    pub fn delay_seconds(&self) -> u32 {
        self.delay_seconds.unwrap_or(0)
    }

    pub fn clear_delay_seconds(&mut self) {
        self.delay_seconds = ::std::option::Option::None;
    }

    pub fn has_delay_seconds(&self) -> bool {
        self.delay_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delay_seconds(&mut self, v: u32) {
        self.delay_seconds = ::std::option::Option::Some(v);
    }

    // optional uint64 rtmp_token = 5;

    pub fn rtmp_token(&self) -> u64 {
        self.rtmp_token.unwrap_or(0u64)
    }

    pub fn clear_rtmp_token(&mut self) {
        self.rtmp_token = ::std::option::Option::None;
    }

    pub fn has_rtmp_token(&self) -> bool {
        self.rtmp_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtmp_token(&mut self, v: u64) {
        self.rtmp_token = ::std::option::Option::Some(v);
    }

    // optional uint32 upload_ip_address = 6;

    pub fn upload_ip_address(&self) -> u32 {
        self.upload_ip_address.unwrap_or(0)
    }

    pub fn clear_upload_ip_address(&mut self) {
        self.upload_ip_address = ::std::option::Option::None;
    }

    pub fn has_upload_ip_address(&self) -> bool {
        self.upload_ip_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upload_ip_address(&mut self, v: u32) {
        self.upload_ip_address = ::std::option::Option::Some(v);
    }

    // optional bool is_replay = 7;

    pub fn is_replay(&self) -> bool {
        self.is_replay.unwrap_or(false)
    }

    pub fn clear_is_replay(&mut self) {
        self.is_replay = ::std::option::Option::None;
    }

    pub fn has_is_replay(&self) -> bool {
        self.is_replay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_replay(&mut self, v: bool) {
        self.is_replay = ::std::option::Option::Some(v);
    }

    // optional uint32 sysid = 8;

    pub fn sysid(&self) -> u32 {
        self.sysid.unwrap_or(0)
    }

    pub fn clear_sysid(&mut self) {
        self.sysid = ::std::option::Option::None;
    }

    pub fn has_sysid(&self) -> bool {
        self.sysid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sysid(&mut self, v: u32) {
        self.sysid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_StartBroadcastUpload_Request {
    const NAME: &'static str = "CBroadcast_StartBroadcastUpload_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.cellid = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.as_rtmp = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.delay_seconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.rtmp_token = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.upload_ip_address = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.is_replay = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.sysid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.cellid {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.as_rtmp {
            my_size += 1 + 1;
        }
        if let Some(v) = self.delay_seconds {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.rtmp_token {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.upload_ip_address {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.is_replay {
            my_size += 1 + 1;
        }
        if let Some(v) = self.sysid {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.cellid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.as_rtmp {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.delay_seconds {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.rtmp_token {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.upload_ip_address {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.is_replay {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.sysid {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_StartBroadcastUpload_Request {
        CBroadcast_StartBroadcastUpload_Request::new()
    }

    fn clear(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
        self.cellid = ::std::option::Option::None;
        self.as_rtmp = ::std::option::Option::None;
        self.delay_seconds = ::std::option::Option::None;
        self.rtmp_token = ::std::option::Option::None;
        self.upload_ip_address = ::std::option::Option::None;
        self.is_replay = ::std::option::Option::None;
        self.sysid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_StartBroadcastUpload_Request {
        static instance: CBroadcast_StartBroadcastUpload_Request = CBroadcast_StartBroadcastUpload_Request {
            broadcast_id: ::std::option::Option::None,
            cellid: ::std::option::Option::None,
            as_rtmp: ::std::option::Option::None,
            delay_seconds: ::std::option::Option::None,
            rtmp_token: ::std::option::Option::None,
            upload_ip_address: ::std::option::Option::None,
            is_replay: ::std::option::Option::None,
            sysid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CBroadcast_StartBroadcastUpload_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_StartBroadcastUpload_Response {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_StartBroadcastUpload_Response.upload_token)
    pub upload_token: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBroadcast_StartBroadcastUpload_Response.upload_address)
    pub upload_address: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBroadcast_StartBroadcastUpload_Response.broadcast_upload_id)
    pub broadcast_upload_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_StartBroadcastUpload_Response.enable_replay)
    pub enable_replay: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CBroadcast_StartBroadcastUpload_Response.http_address)
    pub http_address: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_StartBroadcastUpload_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_StartBroadcastUpload_Response {
    fn default() -> &'a CBroadcast_StartBroadcastUpload_Response {
        <CBroadcast_StartBroadcastUpload_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_StartBroadcastUpload_Response {
    pub fn new() -> CBroadcast_StartBroadcastUpload_Response {
        ::std::default::Default::default()
    }

    // optional string upload_token = 1;

    pub fn upload_token(&self) -> &str {
        match self.upload_token.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_upload_token(&mut self) {
        self.upload_token = ::std::option::Option::None;
    }

    pub fn has_upload_token(&self) -> bool {
        self.upload_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upload_token(&mut self, v: ::std::string::String) {
        self.upload_token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_upload_token(&mut self) -> &mut ::std::string::String {
        if self.upload_token.is_none() {
            self.upload_token = ::std::option::Option::Some(::std::string::String::new());
        }
        self.upload_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_upload_token(&mut self) -> ::std::string::String {
        self.upload_token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string upload_address = 2;

    pub fn upload_address(&self) -> &str {
        match self.upload_address.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_upload_address(&mut self) {
        self.upload_address = ::std::option::Option::None;
    }

    pub fn has_upload_address(&self) -> bool {
        self.upload_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upload_address(&mut self, v: ::std::string::String) {
        self.upload_address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_upload_address(&mut self) -> &mut ::std::string::String {
        if self.upload_address.is_none() {
            self.upload_address = ::std::option::Option::Some(::std::string::String::new());
        }
        self.upload_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_upload_address(&mut self) -> ::std::string::String {
        self.upload_address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 broadcast_upload_id = 3;

    pub fn broadcast_upload_id(&self) -> u64 {
        self.broadcast_upload_id.unwrap_or(0)
    }

    pub fn clear_broadcast_upload_id(&mut self) {
        self.broadcast_upload_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_upload_id(&self) -> bool {
        self.broadcast_upload_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_upload_id(&mut self, v: u64) {
        self.broadcast_upload_id = ::std::option::Option::Some(v);
    }

    // optional bool enable_replay = 6;

    pub fn enable_replay(&self) -> bool {
        self.enable_replay.unwrap_or(false)
    }

    pub fn clear_enable_replay(&mut self) {
        self.enable_replay = ::std::option::Option::None;
    }

    pub fn has_enable_replay(&self) -> bool {
        self.enable_replay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_replay(&mut self, v: bool) {
        self.enable_replay = ::std::option::Option::Some(v);
    }

    // optional string http_address = 7;

    pub fn http_address(&self) -> &str {
        match self.http_address.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_http_address(&mut self) {
        self.http_address = ::std::option::Option::None;
    }

    pub fn has_http_address(&self) -> bool {
        self.http_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_http_address(&mut self, v: ::std::string::String) {
        self.http_address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_http_address(&mut self) -> &mut ::std::string::String {
        if self.http_address.is_none() {
            self.http_address = ::std::option::Option::Some(::std::string::String::new());
        }
        self.http_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_http_address(&mut self) -> ::std::string::String {
        self.http_address.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CBroadcast_StartBroadcastUpload_Response {
    const NAME: &'static str = "CBroadcast_StartBroadcastUpload_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.upload_token = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.upload_address = ::std::option::Option::Some(is.read_string()?);
                },
                25 => {
                    self.broadcast_upload_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                48 => {
                    self.enable_replay = ::std::option::Option::Some(is.read_bool()?);
                },
                58 => {
                    self.http_address = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.upload_token.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.upload_address.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.broadcast_upload_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.enable_replay {
            my_size += 1 + 1;
        }
        if let Some(v) = self.http_address.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.upload_token.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.upload_address.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.broadcast_upload_id {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.enable_replay {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.http_address.as_ref() {
            os.write_string(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_StartBroadcastUpload_Response {
        CBroadcast_StartBroadcastUpload_Response::new()
    }

    fn clear(&mut self) {
        self.upload_token = ::std::option::Option::None;
        self.upload_address = ::std::option::Option::None;
        self.broadcast_upload_id = ::std::option::Option::None;
        self.enable_replay = ::std::option::Option::None;
        self.http_address = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_StartBroadcastUpload_Response {
        static instance: CBroadcast_StartBroadcastUpload_Response = CBroadcast_StartBroadcastUpload_Response {
            upload_token: ::std::option::Option::None,
            upload_address: ::std::option::Option::None,
            broadcast_upload_id: ::std::option::Option::None,
            enable_replay: ::std::option::Option::None,
            http_address: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Tells directory that client stopped uploading broadcast"]
// @@protoc_insertion_point(message:CBroadcast_NotifyBroadcastUploadStop_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_NotifyBroadcastUploadStop_Notification {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_NotifyBroadcastUploadStop_Notification.broadcast_upload_id)
    pub broadcast_upload_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_NotifyBroadcastUploadStop_Notification.upload_result)
    pub upload_result: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_NotifyBroadcastUploadStop_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_NotifyBroadcastUploadStop_Notification {
    fn default() -> &'a CBroadcast_NotifyBroadcastUploadStop_Notification {
        <CBroadcast_NotifyBroadcastUploadStop_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_NotifyBroadcastUploadStop_Notification {
    pub fn new() -> CBroadcast_NotifyBroadcastUploadStop_Notification {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_upload_id = 1;

    pub fn broadcast_upload_id(&self) -> u64 {
        self.broadcast_upload_id.unwrap_or(0)
    }

    pub fn clear_broadcast_upload_id(&mut self) {
        self.broadcast_upload_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_upload_id(&self) -> bool {
        self.broadcast_upload_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_upload_id(&mut self, v: u64) {
        self.broadcast_upload_id = ::std::option::Option::Some(v);
    }

    // optional uint32 upload_result = 2;

    pub fn upload_result(&self) -> u32 {
        self.upload_result.unwrap_or(0)
    }

    pub fn clear_upload_result(&mut self) {
        self.upload_result = ::std::option::Option::None;
    }

    pub fn has_upload_result(&self) -> bool {
        self.upload_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upload_result(&mut self, v: u32) {
        self.upload_result = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_NotifyBroadcastUploadStop_Notification {
    const NAME: &'static str = "CBroadcast_NotifyBroadcastUploadStop_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_upload_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.upload_result = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_upload_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.upload_result {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast_upload_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.upload_result {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_NotifyBroadcastUploadStop_Notification {
        CBroadcast_NotifyBroadcastUploadStop_Notification::new()
    }

    fn clear(&mut self) {
        self.broadcast_upload_id = ::std::option::Option::None;
        self.upload_result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_NotifyBroadcastUploadStop_Notification {
        static instance: CBroadcast_NotifyBroadcastUploadStop_Notification = CBroadcast_NotifyBroadcastUploadStop_Notification {
            broadcast_upload_id: ::std::option::Option::None,
            upload_result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Request from viewer to watch a broadcast"]
// @@protoc_insertion_point(message:CBroadcast_WatchBroadcast_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_WatchBroadcast_Request {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_WatchBroadcast_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_WatchBroadcast_Request.existing_broadcast_id)
    pub existing_broadcast_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_WatchBroadcast_Request.viewer_token)
    pub viewer_token: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_WatchBroadcast_Request.client_cell)
    pub client_cell: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CBroadcast_WatchBroadcast_Request.watch_location)
    pub watch_location: ::std::option::Option<::protobuf::EnumOrUnknown<EBroadcastWatchLocation>>,
    // @@protoc_insertion_point(field:CBroadcast_WatchBroadcast_Request.is_webrtc)
    pub is_webrtc: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_WatchBroadcast_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_WatchBroadcast_Request {
    fn default() -> &'a CBroadcast_WatchBroadcast_Request {
        <CBroadcast_WatchBroadcast_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_WatchBroadcast_Request {
    pub fn new() -> CBroadcast_WatchBroadcast_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 existing_broadcast_id = 2;

    pub fn existing_broadcast_id(&self) -> u64 {
        self.existing_broadcast_id.unwrap_or(0)
    }

    pub fn clear_existing_broadcast_id(&mut self) {
        self.existing_broadcast_id = ::std::option::Option::None;
    }

    pub fn has_existing_broadcast_id(&self) -> bool {
        self.existing_broadcast_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_existing_broadcast_id(&mut self, v: u64) {
        self.existing_broadcast_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 viewer_token = 3;

    pub fn viewer_token(&self) -> u64 {
        self.viewer_token.unwrap_or(0)
    }

    pub fn clear_viewer_token(&mut self) {
        self.viewer_token = ::std::option::Option::None;
    }

    pub fn has_viewer_token(&self) -> bool {
        self.viewer_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_viewer_token(&mut self, v: u64) {
        self.viewer_token = ::std::option::Option::Some(v);
    }

    // optional uint32 client_cell = 5;

    pub fn client_cell(&self) -> u32 {
        self.client_cell.unwrap_or(0)
    }

    pub fn clear_client_cell(&mut self) {
        self.client_cell = ::std::option::Option::None;
    }

    pub fn has_client_cell(&self) -> bool {
        self.client_cell.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_cell(&mut self, v: u32) {
        self.client_cell = ::std::option::Option::Some(v);
    }

    // optional .EBroadcastWatchLocation watch_location = 6;

    pub fn watch_location(&self) -> EBroadcastWatchLocation {
        match self.watch_location {
            Some(e) => e.enum_value_or(EBroadcastWatchLocation::k_EBroadcastWatchLocation_Invalid),
            None => EBroadcastWatchLocation::k_EBroadcastWatchLocation_Invalid,
        }
    }

    pub fn clear_watch_location(&mut self) {
        self.watch_location = ::std::option::Option::None;
    }

    pub fn has_watch_location(&self) -> bool {
        self.watch_location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watch_location(&mut self, v: EBroadcastWatchLocation) {
        self.watch_location = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool is_webrtc = 7;

    pub fn is_webrtc(&self) -> bool {
        self.is_webrtc.unwrap_or(false)
    }

    pub fn clear_is_webrtc(&mut self) {
        self.is_webrtc = ::std::option::Option::None;
    }

    pub fn has_is_webrtc(&self) -> bool {
        self.is_webrtc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_webrtc(&mut self, v: bool) {
        self.is_webrtc = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_WatchBroadcast_Request {
    const NAME: &'static str = "CBroadcast_WatchBroadcast_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.existing_broadcast_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.viewer_token = ::std::option::Option::Some(is.read_fixed64()?);
                },
                40 => {
                    self.client_cell = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.watch_location = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                56 => {
                    self.is_webrtc = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.existing_broadcast_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.viewer_token {
            my_size += 1 + 8;
        }
        if let Some(v) = self.client_cell {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.watch_location {
            my_size += ::protobuf::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.is_webrtc {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.existing_broadcast_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.viewer_token {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.client_cell {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.watch_location {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.is_webrtc {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_WatchBroadcast_Request {
        CBroadcast_WatchBroadcast_Request::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.existing_broadcast_id = ::std::option::Option::None;
        self.viewer_token = ::std::option::Option::None;
        self.client_cell = ::std::option::Option::None;
        self.watch_location = ::std::option::Option::None;
        self.is_webrtc = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_WatchBroadcast_Request {
        static instance: CBroadcast_WatchBroadcast_Request = CBroadcast_WatchBroadcast_Request {
            steamid: ::std::option::Option::None,
            existing_broadcast_id: ::std::option::Option::None,
            viewer_token: ::std::option::Option::None,
            client_cell: ::std::option::Option::None,
            watch_location: ::std::option::Option::None,
            is_webrtc: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CBroadcast_WatchBroadcast_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_WatchBroadcast_Response {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_WatchBroadcast_Response.response)
    pub response: ::std::option::Option<::protobuf::EnumOrUnknown<cbroadcast_watch_broadcast_response::EWatchResponse>>,
    // @@protoc_insertion_point(field:CBroadcast_WatchBroadcast_Response.mpd_url)
    pub mpd_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBroadcast_WatchBroadcast_Response.broadcast_id)
    pub broadcast_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_WatchBroadcast_Response.gameid)
    pub gameid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_WatchBroadcast_Response.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBroadcast_WatchBroadcast_Response.num_viewers)
    pub num_viewers: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CBroadcast_WatchBroadcast_Response.permission)
    pub permission: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CBroadcast_WatchBroadcast_Response.is_rtmp)
    pub is_rtmp: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CBroadcast_WatchBroadcast_Response.seconds_delay)
    pub seconds_delay: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CBroadcast_WatchBroadcast_Response.viewer_token)
    pub viewer_token: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_WatchBroadcast_Response.hls_m3u8_master_url)
    pub hls_m3u8_master_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBroadcast_WatchBroadcast_Response.heartbeat_interval)
    pub heartbeat_interval: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CBroadcast_WatchBroadcast_Response.thumbnail_url)
    pub thumbnail_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBroadcast_WatchBroadcast_Response.is_webrtc)
    pub is_webrtc: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CBroadcast_WatchBroadcast_Response.webrtc_session_id)
    pub webrtc_session_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_WatchBroadcast_Response.webrtc_offer_sdp)
    pub webrtc_offer_sdp: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBroadcast_WatchBroadcast_Response.webrtc_turn_server)
    pub webrtc_turn_server: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBroadcast_WatchBroadcast_Response.is_replay)
    pub is_replay: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CBroadcast_WatchBroadcast_Response.duration)
    pub duration: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CBroadcast_WatchBroadcast_Response.cdn_auth_url_parameters)
    pub cdn_auth_url_parameters: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_WatchBroadcast_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_WatchBroadcast_Response {
    fn default() -> &'a CBroadcast_WatchBroadcast_Response {
        <CBroadcast_WatchBroadcast_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_WatchBroadcast_Response {
    pub fn new() -> CBroadcast_WatchBroadcast_Response {
        ::std::default::Default::default()
    }

    // optional .CBroadcast_WatchBroadcast_Response.EWatchResponse response = 1;

    pub fn response(&self) -> cbroadcast_watch_broadcast_response::EWatchResponse {
        match self.response {
            Some(e) => e.enum_value_or(cbroadcast_watch_broadcast_response::EWatchResponse::k_EWatchResponseReady),
            None => cbroadcast_watch_broadcast_response::EWatchResponse::k_EWatchResponseReady,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cbroadcast_watch_broadcast_response::EWatchResponse) {
        self.response = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string mpd_url = 2;

    pub fn mpd_url(&self) -> &str {
        match self.mpd_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mpd_url(&mut self) {
        self.mpd_url = ::std::option::Option::None;
    }

    pub fn has_mpd_url(&self) -> bool {
        self.mpd_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mpd_url(&mut self, v: ::std::string::String) {
        self.mpd_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mpd_url(&mut self) -> &mut ::std::string::String {
        if self.mpd_url.is_none() {
            self.mpd_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.mpd_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_mpd_url(&mut self) -> ::std::string::String {
        self.mpd_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 broadcast_id = 3;

    pub fn broadcast_id(&self) -> u64 {
        self.broadcast_id.unwrap_or(0)
    }

    pub fn clear_broadcast_id(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_id(&self) -> bool {
        self.broadcast_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_id(&mut self, v: u64) {
        self.broadcast_id = ::std::option::Option::Some(v);
    }

    // optional uint64 gameid = 4;

    pub fn gameid(&self) -> u64 {
        self.gameid.unwrap_or(0)
    }

    pub fn clear_gameid(&mut self) {
        self.gameid = ::std::option::Option::None;
    }

    pub fn has_gameid(&self) -> bool {
        self.gameid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameid(&mut self, v: u64) {
        self.gameid = ::std::option::Option::Some(v);
    }

    // optional string title = 5;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 num_viewers = 6;

    pub fn num_viewers(&self) -> u32 {
        self.num_viewers.unwrap_or(0)
    }

    pub fn clear_num_viewers(&mut self) {
        self.num_viewers = ::std::option::Option::None;
    }

    pub fn has_num_viewers(&self) -> bool {
        self.num_viewers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_viewers(&mut self, v: u32) {
        self.num_viewers = ::std::option::Option::Some(v);
    }

    // optional int32 permission = 7;

    pub fn permission(&self) -> i32 {
        self.permission.unwrap_or(0)
    }

    pub fn clear_permission(&mut self) {
        self.permission = ::std::option::Option::None;
    }

    pub fn has_permission(&self) -> bool {
        self.permission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permission(&mut self, v: i32) {
        self.permission = ::std::option::Option::Some(v);
    }

    // optional bool is_rtmp = 8;

    pub fn is_rtmp(&self) -> bool {
        self.is_rtmp.unwrap_or(false)
    }

    pub fn clear_is_rtmp(&mut self) {
        self.is_rtmp = ::std::option::Option::None;
    }

    pub fn has_is_rtmp(&self) -> bool {
        self.is_rtmp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_rtmp(&mut self, v: bool) {
        self.is_rtmp = ::std::option::Option::Some(v);
    }

    // optional int32 seconds_delay = 9;

    pub fn seconds_delay(&self) -> i32 {
        self.seconds_delay.unwrap_or(0)
    }

    pub fn clear_seconds_delay(&mut self) {
        self.seconds_delay = ::std::option::Option::None;
    }

    pub fn has_seconds_delay(&self) -> bool {
        self.seconds_delay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_delay(&mut self, v: i32) {
        self.seconds_delay = ::std::option::Option::Some(v);
    }

    // optional fixed64 viewer_token = 10;

    pub fn viewer_token(&self) -> u64 {
        self.viewer_token.unwrap_or(0)
    }

    pub fn clear_viewer_token(&mut self) {
        self.viewer_token = ::std::option::Option::None;
    }

    pub fn has_viewer_token(&self) -> bool {
        self.viewer_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_viewer_token(&mut self, v: u64) {
        self.viewer_token = ::std::option::Option::Some(v);
    }

    // optional string hls_m3u8_master_url = 11;

    pub fn hls_m3u8_master_url(&self) -> &str {
        match self.hls_m3u8_master_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_hls_m3u8_master_url(&mut self) {
        self.hls_m3u8_master_url = ::std::option::Option::None;
    }

    pub fn has_hls_m3u8_master_url(&self) -> bool {
        self.hls_m3u8_master_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hls_m3u8_master_url(&mut self, v: ::std::string::String) {
        self.hls_m3u8_master_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hls_m3u8_master_url(&mut self) -> &mut ::std::string::String {
        if self.hls_m3u8_master_url.is_none() {
            self.hls_m3u8_master_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.hls_m3u8_master_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_hls_m3u8_master_url(&mut self) -> ::std::string::String {
        self.hls_m3u8_master_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 heartbeat_interval = 12;

    pub fn heartbeat_interval(&self) -> i32 {
        self.heartbeat_interval.unwrap_or(0)
    }

    pub fn clear_heartbeat_interval(&mut self) {
        self.heartbeat_interval = ::std::option::Option::None;
    }

    pub fn has_heartbeat_interval(&self) -> bool {
        self.heartbeat_interval.is_some()
    }

    // Param is passed by value, moved
    pub fn set_heartbeat_interval(&mut self, v: i32) {
        self.heartbeat_interval = ::std::option::Option::Some(v);
    }

    // optional string thumbnail_url = 13;

    pub fn thumbnail_url(&self) -> &str {
        match self.thumbnail_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_thumbnail_url(&mut self) {
        self.thumbnail_url = ::std::option::Option::None;
    }

    pub fn has_thumbnail_url(&self) -> bool {
        self.thumbnail_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnail_url(&mut self, v: ::std::string::String) {
        self.thumbnail_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnail_url(&mut self) -> &mut ::std::string::String {
        if self.thumbnail_url.is_none() {
            self.thumbnail_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.thumbnail_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnail_url(&mut self) -> ::std::string::String {
        self.thumbnail_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_webrtc = 14;

    pub fn is_webrtc(&self) -> bool {
        self.is_webrtc.unwrap_or(false)
    }

    pub fn clear_is_webrtc(&mut self) {
        self.is_webrtc = ::std::option::Option::None;
    }

    pub fn has_is_webrtc(&self) -> bool {
        self.is_webrtc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_webrtc(&mut self, v: bool) {
        self.is_webrtc = ::std::option::Option::Some(v);
    }

    // optional fixed64 webrtc_session_id = 15;

    pub fn webrtc_session_id(&self) -> u64 {
        self.webrtc_session_id.unwrap_or(0)
    }

    pub fn clear_webrtc_session_id(&mut self) {
        self.webrtc_session_id = ::std::option::Option::None;
    }

    pub fn has_webrtc_session_id(&self) -> bool {
        self.webrtc_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_webrtc_session_id(&mut self, v: u64) {
        self.webrtc_session_id = ::std::option::Option::Some(v);
    }

    // optional string webrtc_offer_sdp = 16;

    pub fn webrtc_offer_sdp(&self) -> &str {
        match self.webrtc_offer_sdp.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_webrtc_offer_sdp(&mut self) {
        self.webrtc_offer_sdp = ::std::option::Option::None;
    }

    pub fn has_webrtc_offer_sdp(&self) -> bool {
        self.webrtc_offer_sdp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_webrtc_offer_sdp(&mut self, v: ::std::string::String) {
        self.webrtc_offer_sdp = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_webrtc_offer_sdp(&mut self) -> &mut ::std::string::String {
        if self.webrtc_offer_sdp.is_none() {
            self.webrtc_offer_sdp = ::std::option::Option::Some(::std::string::String::new());
        }
        self.webrtc_offer_sdp.as_mut().unwrap()
    }

    // Take field
    pub fn take_webrtc_offer_sdp(&mut self) -> ::std::string::String {
        self.webrtc_offer_sdp.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string webrtc_turn_server = 17;

    pub fn webrtc_turn_server(&self) -> &str {
        match self.webrtc_turn_server.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_webrtc_turn_server(&mut self) {
        self.webrtc_turn_server = ::std::option::Option::None;
    }

    pub fn has_webrtc_turn_server(&self) -> bool {
        self.webrtc_turn_server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_webrtc_turn_server(&mut self, v: ::std::string::String) {
        self.webrtc_turn_server = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_webrtc_turn_server(&mut self) -> &mut ::std::string::String {
        if self.webrtc_turn_server.is_none() {
            self.webrtc_turn_server = ::std::option::Option::Some(::std::string::String::new());
        }
        self.webrtc_turn_server.as_mut().unwrap()
    }

    // Take field
    pub fn take_webrtc_turn_server(&mut self) -> ::std::string::String {
        self.webrtc_turn_server.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_replay = 18;

    pub fn is_replay(&self) -> bool {
        self.is_replay.unwrap_or(false)
    }

    pub fn clear_is_replay(&mut self) {
        self.is_replay = ::std::option::Option::None;
    }

    pub fn has_is_replay(&self) -> bool {
        self.is_replay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_replay(&mut self, v: bool) {
        self.is_replay = ::std::option::Option::Some(v);
    }

    // optional int32 duration = 19;

    pub fn duration(&self) -> i32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: i32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional string cdn_auth_url_parameters = 20;

    pub fn cdn_auth_url_parameters(&self) -> &str {
        match self.cdn_auth_url_parameters.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_cdn_auth_url_parameters(&mut self) {
        self.cdn_auth_url_parameters = ::std::option::Option::None;
    }

    pub fn has_cdn_auth_url_parameters(&self) -> bool {
        self.cdn_auth_url_parameters.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cdn_auth_url_parameters(&mut self, v: ::std::string::String) {
        self.cdn_auth_url_parameters = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cdn_auth_url_parameters(&mut self) -> &mut ::std::string::String {
        if self.cdn_auth_url_parameters.is_none() {
            self.cdn_auth_url_parameters = ::std::option::Option::Some(::std::string::String::new());
        }
        self.cdn_auth_url_parameters.as_mut().unwrap()
    }

    // Take field
    pub fn take_cdn_auth_url_parameters(&mut self) -> ::std::string::String {
        self.cdn_auth_url_parameters.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CBroadcast_WatchBroadcast_Response {
    const NAME: &'static str = "CBroadcast_WatchBroadcast_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.mpd_url = ::std::option::Option::Some(is.read_string()?);
                },
                25 => {
                    self.broadcast_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                32 => {
                    self.gameid = ::std::option::Option::Some(is.read_uint64()?);
                },
                42 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.num_viewers = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.permission = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.is_rtmp = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.seconds_delay = ::std::option::Option::Some(is.read_int32()?);
                },
                81 => {
                    self.viewer_token = ::std::option::Option::Some(is.read_fixed64()?);
                },
                90 => {
                    self.hls_m3u8_master_url = ::std::option::Option::Some(is.read_string()?);
                },
                96 => {
                    self.heartbeat_interval = ::std::option::Option::Some(is.read_int32()?);
                },
                106 => {
                    self.thumbnail_url = ::std::option::Option::Some(is.read_string()?);
                },
                112 => {
                    self.is_webrtc = ::std::option::Option::Some(is.read_bool()?);
                },
                121 => {
                    self.webrtc_session_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                130 => {
                    self.webrtc_offer_sdp = ::std::option::Option::Some(is.read_string()?);
                },
                138 => {
                    self.webrtc_turn_server = ::std::option::Option::Some(is.read_string()?);
                },
                144 => {
                    self.is_replay = ::std::option::Option::Some(is.read_bool()?);
                },
                152 => {
                    self.duration = ::std::option::Option::Some(is.read_int32()?);
                },
                162 => {
                    self.cdn_auth_url_parameters = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.mpd_url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.broadcast_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.gameid {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.num_viewers {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.permission {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.is_rtmp {
            my_size += 1 + 1;
        }
        if let Some(v) = self.seconds_delay {
            my_size += ::protobuf::rt::int32_size(9, v);
        }
        if let Some(v) = self.viewer_token {
            my_size += 1 + 8;
        }
        if let Some(v) = self.hls_m3u8_master_url.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.heartbeat_interval {
            my_size += ::protobuf::rt::int32_size(12, v);
        }
        if let Some(v) = self.thumbnail_url.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.is_webrtc {
            my_size += 1 + 1;
        }
        if let Some(v) = self.webrtc_session_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.webrtc_offer_sdp.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        if let Some(v) = self.webrtc_turn_server.as_ref() {
            my_size += ::protobuf::rt::string_size(17, &v);
        }
        if let Some(v) = self.is_replay {
            my_size += 2 + 1;
        }
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::int32_size(19, v);
        }
        if let Some(v) = self.cdn_auth_url_parameters.as_ref() {
            my_size += ::protobuf::rt::string_size(20, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.mpd_url.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.broadcast_id {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.gameid {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.num_viewers {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.permission {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.is_rtmp {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.seconds_delay {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.viewer_token {
            os.write_fixed64(10, v)?;
        }
        if let Some(v) = self.hls_m3u8_master_url.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.heartbeat_interval {
            os.write_int32(12, v)?;
        }
        if let Some(v) = self.thumbnail_url.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.is_webrtc {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.webrtc_session_id {
            os.write_fixed64(15, v)?;
        }
        if let Some(v) = self.webrtc_offer_sdp.as_ref() {
            os.write_string(16, v)?;
        }
        if let Some(v) = self.webrtc_turn_server.as_ref() {
            os.write_string(17, v)?;
        }
        if let Some(v) = self.is_replay {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.duration {
            os.write_int32(19, v)?;
        }
        if let Some(v) = self.cdn_auth_url_parameters.as_ref() {
            os.write_string(20, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_WatchBroadcast_Response {
        CBroadcast_WatchBroadcast_Response::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.mpd_url = ::std::option::Option::None;
        self.broadcast_id = ::std::option::Option::None;
        self.gameid = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.num_viewers = ::std::option::Option::None;
        self.permission = ::std::option::Option::None;
        self.is_rtmp = ::std::option::Option::None;
        self.seconds_delay = ::std::option::Option::None;
        self.viewer_token = ::std::option::Option::None;
        self.hls_m3u8_master_url = ::std::option::Option::None;
        self.heartbeat_interval = ::std::option::Option::None;
        self.thumbnail_url = ::std::option::Option::None;
        self.is_webrtc = ::std::option::Option::None;
        self.webrtc_session_id = ::std::option::Option::None;
        self.webrtc_offer_sdp = ::std::option::Option::None;
        self.webrtc_turn_server = ::std::option::Option::None;
        self.is_replay = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.cdn_auth_url_parameters = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_WatchBroadcast_Response {
        static instance: CBroadcast_WatchBroadcast_Response = CBroadcast_WatchBroadcast_Response {
            response: ::std::option::Option::None,
            mpd_url: ::std::option::Option::None,
            broadcast_id: ::std::option::Option::None,
            gameid: ::std::option::Option::None,
            title: ::std::option::Option::None,
            num_viewers: ::std::option::Option::None,
            permission: ::std::option::Option::None,
            is_rtmp: ::std::option::Option::None,
            seconds_delay: ::std::option::Option::None,
            viewer_token: ::std::option::Option::None,
            hls_m3u8_master_url: ::std::option::Option::None,
            heartbeat_interval: ::std::option::Option::None,
            thumbnail_url: ::std::option::Option::None,
            is_webrtc: ::std::option::Option::None,
            webrtc_session_id: ::std::option::Option::None,
            webrtc_offer_sdp: ::std::option::Option::None,
            webrtc_turn_server: ::std::option::Option::None,
            is_replay: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            cdn_auth_url_parameters: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CBroadcast_WatchBroadcast_Response`
pub mod cbroadcast_watch_broadcast_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CBroadcast_WatchBroadcast_Response.EWatchResponse)
    pub enum EWatchResponse {
        // @@protoc_insertion_point(enum_value:CBroadcast_WatchBroadcast_Response.EWatchResponse.k_EWatchResponseReady)
        k_EWatchResponseReady = 1,
        // @@protoc_insertion_point(enum_value:CBroadcast_WatchBroadcast_Response.EWatchResponse.k_EWatchResponseNotAvailable)
        k_EWatchResponseNotAvailable = 2,
        // @@protoc_insertion_point(enum_value:CBroadcast_WatchBroadcast_Response.EWatchResponse.k_EWatchResponseWaitingForApproval)
        k_EWatchResponseWaitingForApproval = 3,
        // @@protoc_insertion_point(enum_value:CBroadcast_WatchBroadcast_Response.EWatchResponse.k_EWatchResponseWaitingForStart)
        k_EWatchResponseWaitingForStart = 4,
        // @@protoc_insertion_point(enum_value:CBroadcast_WatchBroadcast_Response.EWatchResponse.k_EWatchResponseInvalidSession)
        k_EWatchResponseInvalidSession = 5,
        // @@protoc_insertion_point(enum_value:CBroadcast_WatchBroadcast_Response.EWatchResponse.k_EWatchResponseTooManyBroadcasts)
        k_EWatchResponseTooManyBroadcasts = 6,
        // @@protoc_insertion_point(enum_value:CBroadcast_WatchBroadcast_Response.EWatchResponse.k_EWatchResponseWaitingForReconnect)
        k_EWatchResponseWaitingForReconnect = 7,
        // @@protoc_insertion_point(enum_value:CBroadcast_WatchBroadcast_Response.EWatchResponse.k_EWatchResponseSystemNotSupported)
        k_EWatchResponseSystemNotSupported = 8,
        // @@protoc_insertion_point(enum_value:CBroadcast_WatchBroadcast_Response.EWatchResponse.k_EWatchResponseUserRestricted)
        k_EWatchResponseUserRestricted = 9,
        // @@protoc_insertion_point(enum_value:CBroadcast_WatchBroadcast_Response.EWatchResponse.k_EWatchResponseClientOutOfDate)
        k_EWatchResponseClientOutOfDate = 10,
        // @@protoc_insertion_point(enum_value:CBroadcast_WatchBroadcast_Response.EWatchResponse.k_EWatchResponsePoorUploadQuality)
        k_EWatchResponsePoorUploadQuality = 11,
        // @@protoc_insertion_point(enum_value:CBroadcast_WatchBroadcast_Response.EWatchResponse.k_EWatchResponseMissingSubscription)
        k_EWatchResponseMissingSubscription = 12,
    }

    impl ::protobuf::Enum for EWatchResponse {
        const NAME: &'static str = "EWatchResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EWatchResponse> {
            match value {
                1 => ::std::option::Option::Some(EWatchResponse::k_EWatchResponseReady),
                2 => ::std::option::Option::Some(EWatchResponse::k_EWatchResponseNotAvailable),
                3 => ::std::option::Option::Some(EWatchResponse::k_EWatchResponseWaitingForApproval),
                4 => ::std::option::Option::Some(EWatchResponse::k_EWatchResponseWaitingForStart),
                5 => ::std::option::Option::Some(EWatchResponse::k_EWatchResponseInvalidSession),
                6 => ::std::option::Option::Some(EWatchResponse::k_EWatchResponseTooManyBroadcasts),
                7 => ::std::option::Option::Some(EWatchResponse::k_EWatchResponseWaitingForReconnect),
                8 => ::std::option::Option::Some(EWatchResponse::k_EWatchResponseSystemNotSupported),
                9 => ::std::option::Option::Some(EWatchResponse::k_EWatchResponseUserRestricted),
                10 => ::std::option::Option::Some(EWatchResponse::k_EWatchResponseClientOutOfDate),
                11 => ::std::option::Option::Some(EWatchResponse::k_EWatchResponsePoorUploadQuality),
                12 => ::std::option::Option::Some(EWatchResponse::k_EWatchResponseMissingSubscription),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EWatchResponse> {
            match str {
                "k_EWatchResponseReady" => ::std::option::Option::Some(EWatchResponse::k_EWatchResponseReady),
                "k_EWatchResponseNotAvailable" => ::std::option::Option::Some(EWatchResponse::k_EWatchResponseNotAvailable),
                "k_EWatchResponseWaitingForApproval" => ::std::option::Option::Some(EWatchResponse::k_EWatchResponseWaitingForApproval),
                "k_EWatchResponseWaitingForStart" => ::std::option::Option::Some(EWatchResponse::k_EWatchResponseWaitingForStart),
                "k_EWatchResponseInvalidSession" => ::std::option::Option::Some(EWatchResponse::k_EWatchResponseInvalidSession),
                "k_EWatchResponseTooManyBroadcasts" => ::std::option::Option::Some(EWatchResponse::k_EWatchResponseTooManyBroadcasts),
                "k_EWatchResponseWaitingForReconnect" => ::std::option::Option::Some(EWatchResponse::k_EWatchResponseWaitingForReconnect),
                "k_EWatchResponseSystemNotSupported" => ::std::option::Option::Some(EWatchResponse::k_EWatchResponseSystemNotSupported),
                "k_EWatchResponseUserRestricted" => ::std::option::Option::Some(EWatchResponse::k_EWatchResponseUserRestricted),
                "k_EWatchResponseClientOutOfDate" => ::std::option::Option::Some(EWatchResponse::k_EWatchResponseClientOutOfDate),
                "k_EWatchResponsePoorUploadQuality" => ::std::option::Option::Some(EWatchResponse::k_EWatchResponsePoorUploadQuality),
                "k_EWatchResponseMissingSubscription" => ::std::option::Option::Some(EWatchResponse::k_EWatchResponseMissingSubscription),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EWatchResponse] = &[
            EWatchResponse::k_EWatchResponseReady,
            EWatchResponse::k_EWatchResponseNotAvailable,
            EWatchResponse::k_EWatchResponseWaitingForApproval,
            EWatchResponse::k_EWatchResponseWaitingForStart,
            EWatchResponse::k_EWatchResponseInvalidSession,
            EWatchResponse::k_EWatchResponseTooManyBroadcasts,
            EWatchResponse::k_EWatchResponseWaitingForReconnect,
            EWatchResponse::k_EWatchResponseSystemNotSupported,
            EWatchResponse::k_EWatchResponseUserRestricted,
            EWatchResponse::k_EWatchResponseClientOutOfDate,
            EWatchResponse::k_EWatchResponsePoorUploadQuality,
            EWatchResponse::k_EWatchResponseMissingSubscription,
        ];
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for EWatchResponse {
        fn default() -> Self {
            EWatchResponse::k_EWatchResponseReady
        }
    }

}

#[doc = "Notify directory that user is still watching."]
// @@protoc_insertion_point(message:CBroadcast_HeartbeatBroadcast_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_HeartbeatBroadcast_Notification {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_HeartbeatBroadcast_Notification.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_HeartbeatBroadcast_Notification.broadcast_id)
    pub broadcast_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_HeartbeatBroadcast_Notification.viewer_token)
    pub viewer_token: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_HeartbeatBroadcast_Notification.representation)
    pub representation: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_HeartbeatBroadcast_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_HeartbeatBroadcast_Notification {
    fn default() -> &'a CBroadcast_HeartbeatBroadcast_Notification {
        <CBroadcast_HeartbeatBroadcast_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_HeartbeatBroadcast_Notification {
    pub fn new() -> CBroadcast_HeartbeatBroadcast_Notification {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 broadcast_id = 2;

    pub fn broadcast_id(&self) -> u64 {
        self.broadcast_id.unwrap_or(0)
    }

    pub fn clear_broadcast_id(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_id(&self) -> bool {
        self.broadcast_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_id(&mut self, v: u64) {
        self.broadcast_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 viewer_token = 3;

    pub fn viewer_token(&self) -> u64 {
        self.viewer_token.unwrap_or(0)
    }

    pub fn clear_viewer_token(&mut self) {
        self.viewer_token = ::std::option::Option::None;
    }

    pub fn has_viewer_token(&self) -> bool {
        self.viewer_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_viewer_token(&mut self, v: u64) {
        self.viewer_token = ::std::option::Option::Some(v);
    }

    // optional uint32 representation = 4;

    pub fn representation(&self) -> u32 {
        self.representation.unwrap_or(0)
    }

    pub fn clear_representation(&mut self) {
        self.representation = ::std::option::Option::None;
    }

    pub fn has_representation(&self) -> bool {
        self.representation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_representation(&mut self, v: u32) {
        self.representation = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_HeartbeatBroadcast_Notification {
    const NAME: &'static str = "CBroadcast_HeartbeatBroadcast_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.broadcast_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.viewer_token = ::std::option::Option::Some(is.read_fixed64()?);
                },
                32 => {
                    self.representation = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.broadcast_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.viewer_token {
            my_size += 1 + 8;
        }
        if let Some(v) = self.representation {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.broadcast_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.viewer_token {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.representation {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_HeartbeatBroadcast_Notification {
        CBroadcast_HeartbeatBroadcast_Notification::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.broadcast_id = ::std::option::Option::None;
        self.viewer_token = ::std::option::Option::None;
        self.representation = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_HeartbeatBroadcast_Notification {
        static instance: CBroadcast_HeartbeatBroadcast_Notification = CBroadcast_HeartbeatBroadcast_Notification {
            steamid: ::std::option::Option::None,
            broadcast_id: ::std::option::Option::None,
            viewer_token: ::std::option::Option::None,
            representation: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Request to immediately stop watching a broadcast. Optional Method, if not called, viewer will time out."]
// @@protoc_insertion_point(message:CBroadcast_StopWatchingBroadcast_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_StopWatchingBroadcast_Notification {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_StopWatchingBroadcast_Notification.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_StopWatchingBroadcast_Notification.broadcast_id)
    pub broadcast_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_StopWatchingBroadcast_Notification.viewer_token)
    pub viewer_token: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_StopWatchingBroadcast_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_StopWatchingBroadcast_Notification {
    fn default() -> &'a CBroadcast_StopWatchingBroadcast_Notification {
        <CBroadcast_StopWatchingBroadcast_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_StopWatchingBroadcast_Notification {
    pub fn new() -> CBroadcast_StopWatchingBroadcast_Notification {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 broadcast_id = 2;

    pub fn broadcast_id(&self) -> u64 {
        self.broadcast_id.unwrap_or(0)
    }

    pub fn clear_broadcast_id(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_id(&self) -> bool {
        self.broadcast_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_id(&mut self, v: u64) {
        self.broadcast_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 viewer_token = 3;

    pub fn viewer_token(&self) -> u64 {
        self.viewer_token.unwrap_or(0)
    }

    pub fn clear_viewer_token(&mut self) {
        self.viewer_token = ::std::option::Option::None;
    }

    pub fn has_viewer_token(&self) -> bool {
        self.viewer_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_viewer_token(&mut self, v: u64) {
        self.viewer_token = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_StopWatchingBroadcast_Notification {
    const NAME: &'static str = "CBroadcast_StopWatchingBroadcast_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.broadcast_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.viewer_token = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.broadcast_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.viewer_token {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.broadcast_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.viewer_token {
            os.write_fixed64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_StopWatchingBroadcast_Notification {
        CBroadcast_StopWatchingBroadcast_Notification::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.broadcast_id = ::std::option::Option::None;
        self.viewer_token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_StopWatchingBroadcast_Notification {
        static instance: CBroadcast_StopWatchingBroadcast_Notification = CBroadcast_StopWatchingBroadcast_Notification {
            steamid: ::std::option::Option::None,
            broadcast_id: ::std::option::Option::None,
            viewer_token: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Request from viewer about broadcast details"]
// @@protoc_insertion_point(message:CBroadcast_GetBroadcastStatus_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_GetBroadcastStatus_Request {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_GetBroadcastStatus_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_GetBroadcastStatus_Request.broadcast_id)
    pub broadcast_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_GetBroadcastStatus_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_GetBroadcastStatus_Request {
    fn default() -> &'a CBroadcast_GetBroadcastStatus_Request {
        <CBroadcast_GetBroadcastStatus_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_GetBroadcastStatus_Request {
    pub fn new() -> CBroadcast_GetBroadcastStatus_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 broadcast_id = 2;

    pub fn broadcast_id(&self) -> u64 {
        self.broadcast_id.unwrap_or(0)
    }

    pub fn clear_broadcast_id(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_id(&self) -> bool {
        self.broadcast_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_id(&mut self, v: u64) {
        self.broadcast_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_GetBroadcastStatus_Request {
    const NAME: &'static str = "CBroadcast_GetBroadcastStatus_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.broadcast_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.broadcast_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.broadcast_id {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_GetBroadcastStatus_Request {
        CBroadcast_GetBroadcastStatus_Request::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.broadcast_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_GetBroadcastStatus_Request {
        static instance: CBroadcast_GetBroadcastStatus_Request = CBroadcast_GetBroadcastStatus_Request {
            steamid: ::std::option::Option::None,
            broadcast_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CBroadcast_GetBroadcastStatus_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_GetBroadcastStatus_Response {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_GetBroadcastStatus_Response.gameid)
    pub gameid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_GetBroadcastStatus_Response.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBroadcast_GetBroadcastStatus_Response.num_viewers)
    pub num_viewers: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CBroadcast_GetBroadcastStatus_Response.permission)
    pub permission: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CBroadcast_GetBroadcastStatus_Response.is_rtmp)
    pub is_rtmp: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CBroadcast_GetBroadcastStatus_Response.seconds_delay)
    pub seconds_delay: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CBroadcast_GetBroadcastStatus_Response.is_publisher)
    pub is_publisher: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CBroadcast_GetBroadcastStatus_Response.thumbnail_url)
    pub thumbnail_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBroadcast_GetBroadcastStatus_Response.update_interval)
    pub update_interval: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CBroadcast_GetBroadcastStatus_Response.is_uploading)
    pub is_uploading: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CBroadcast_GetBroadcastStatus_Response.duration)
    pub duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CBroadcast_GetBroadcastStatus_Response.is_replay)
    pub is_replay: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CBroadcast_GetBroadcastStatus_Response.is_capturing_vod)
    pub is_capturing_vod: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CBroadcast_GetBroadcastStatus_Response.is_store_whitelisted)
    pub is_store_whitelisted: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_GetBroadcastStatus_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_GetBroadcastStatus_Response {
    fn default() -> &'a CBroadcast_GetBroadcastStatus_Response {
        <CBroadcast_GetBroadcastStatus_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_GetBroadcastStatus_Response {
    pub fn new() -> CBroadcast_GetBroadcastStatus_Response {
        ::std::default::Default::default()
    }

    // optional uint64 gameid = 1;

    pub fn gameid(&self) -> u64 {
        self.gameid.unwrap_or(0)
    }

    pub fn clear_gameid(&mut self) {
        self.gameid = ::std::option::Option::None;
    }

    pub fn has_gameid(&self) -> bool {
        self.gameid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameid(&mut self, v: u64) {
        self.gameid = ::std::option::Option::Some(v);
    }

    // optional string title = 2;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 num_viewers = 3;

    pub fn num_viewers(&self) -> u32 {
        self.num_viewers.unwrap_or(0)
    }

    pub fn clear_num_viewers(&mut self) {
        self.num_viewers = ::std::option::Option::None;
    }

    pub fn has_num_viewers(&self) -> bool {
        self.num_viewers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_viewers(&mut self, v: u32) {
        self.num_viewers = ::std::option::Option::Some(v);
    }

    // optional int32 permission = 4;

    pub fn permission(&self) -> i32 {
        self.permission.unwrap_or(0)
    }

    pub fn clear_permission(&mut self) {
        self.permission = ::std::option::Option::None;
    }

    pub fn has_permission(&self) -> bool {
        self.permission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permission(&mut self, v: i32) {
        self.permission = ::std::option::Option::Some(v);
    }

    // optional bool is_rtmp = 5;

    pub fn is_rtmp(&self) -> bool {
        self.is_rtmp.unwrap_or(false)
    }

    pub fn clear_is_rtmp(&mut self) {
        self.is_rtmp = ::std::option::Option::None;
    }

    pub fn has_is_rtmp(&self) -> bool {
        self.is_rtmp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_rtmp(&mut self, v: bool) {
        self.is_rtmp = ::std::option::Option::Some(v);
    }

    // optional int32 seconds_delay = 6;

    pub fn seconds_delay(&self) -> i32 {
        self.seconds_delay.unwrap_or(0)
    }

    pub fn clear_seconds_delay(&mut self) {
        self.seconds_delay = ::std::option::Option::None;
    }

    pub fn has_seconds_delay(&self) -> bool {
        self.seconds_delay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_delay(&mut self, v: i32) {
        self.seconds_delay = ::std::option::Option::Some(v);
    }

    // optional bool is_publisher = 7;

    pub fn is_publisher(&self) -> bool {
        self.is_publisher.unwrap_or(false)
    }

    pub fn clear_is_publisher(&mut self) {
        self.is_publisher = ::std::option::Option::None;
    }

    pub fn has_is_publisher(&self) -> bool {
        self.is_publisher.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_publisher(&mut self, v: bool) {
        self.is_publisher = ::std::option::Option::Some(v);
    }

    // optional string thumbnail_url = 8;

    pub fn thumbnail_url(&self) -> &str {
        match self.thumbnail_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_thumbnail_url(&mut self) {
        self.thumbnail_url = ::std::option::Option::None;
    }

    pub fn has_thumbnail_url(&self) -> bool {
        self.thumbnail_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnail_url(&mut self, v: ::std::string::String) {
        self.thumbnail_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnail_url(&mut self) -> &mut ::std::string::String {
        if self.thumbnail_url.is_none() {
            self.thumbnail_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.thumbnail_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnail_url(&mut self) -> ::std::string::String {
        self.thumbnail_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 update_interval = 9;

    pub fn update_interval(&self) -> i32 {
        self.update_interval.unwrap_or(0)
    }

    pub fn clear_update_interval(&mut self) {
        self.update_interval = ::std::option::Option::None;
    }

    pub fn has_update_interval(&self) -> bool {
        self.update_interval.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_interval(&mut self, v: i32) {
        self.update_interval = ::std::option::Option::Some(v);
    }

    // optional bool is_uploading = 10;

    pub fn is_uploading(&self) -> bool {
        self.is_uploading.unwrap_or(false)
    }

    pub fn clear_is_uploading(&mut self) {
        self.is_uploading = ::std::option::Option::None;
    }

    pub fn has_is_uploading(&self) -> bool {
        self.is_uploading.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_uploading(&mut self, v: bool) {
        self.is_uploading = ::std::option::Option::Some(v);
    }

    // optional uint32 duration = 11;

    pub fn duration(&self) -> u32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: u32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional bool is_replay = 12;

    pub fn is_replay(&self) -> bool {
        self.is_replay.unwrap_or(false)
    }

    pub fn clear_is_replay(&mut self) {
        self.is_replay = ::std::option::Option::None;
    }

    pub fn has_is_replay(&self) -> bool {
        self.is_replay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_replay(&mut self, v: bool) {
        self.is_replay = ::std::option::Option::Some(v);
    }

    // optional bool is_capturing_vod = 13;

    pub fn is_capturing_vod(&self) -> bool {
        self.is_capturing_vod.unwrap_or(false)
    }

    pub fn clear_is_capturing_vod(&mut self) {
        self.is_capturing_vod = ::std::option::Option::None;
    }

    pub fn has_is_capturing_vod(&self) -> bool {
        self.is_capturing_vod.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_capturing_vod(&mut self, v: bool) {
        self.is_capturing_vod = ::std::option::Option::Some(v);
    }

    // optional bool is_store_whitelisted = 14;

    pub fn is_store_whitelisted(&self) -> bool {
        self.is_store_whitelisted.unwrap_or(false)
    }

    pub fn clear_is_store_whitelisted(&mut self) {
        self.is_store_whitelisted = ::std::option::Option::None;
    }

    pub fn has_is_store_whitelisted(&self) -> bool {
        self.is_store_whitelisted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_store_whitelisted(&mut self, v: bool) {
        self.is_store_whitelisted = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_GetBroadcastStatus_Response {
    const NAME: &'static str = "CBroadcast_GetBroadcastStatus_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.gameid = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.num_viewers = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.permission = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.is_rtmp = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.seconds_delay = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.is_publisher = ::std::option::Option::Some(is.read_bool()?);
                },
                66 => {
                    self.thumbnail_url = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.update_interval = ::std::option::Option::Some(is.read_int32()?);
                },
                80 => {
                    self.is_uploading = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.is_replay = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.is_capturing_vod = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.is_store_whitelisted = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gameid {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.num_viewers {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.permission {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.is_rtmp {
            my_size += 1 + 1;
        }
        if let Some(v) = self.seconds_delay {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.is_publisher {
            my_size += 1 + 1;
        }
        if let Some(v) = self.thumbnail_url.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.update_interval {
            my_size += ::protobuf::rt::int32_size(9, v);
        }
        if let Some(v) = self.is_uploading {
            my_size += 1 + 1;
        }
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.is_replay {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_capturing_vod {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_store_whitelisted {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.gameid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.num_viewers {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.permission {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.is_rtmp {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.seconds_delay {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.is_publisher {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.thumbnail_url.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.update_interval {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.is_uploading {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.duration {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.is_replay {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.is_capturing_vod {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.is_store_whitelisted {
            os.write_bool(14, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_GetBroadcastStatus_Response {
        CBroadcast_GetBroadcastStatus_Response::new()
    }

    fn clear(&mut self) {
        self.gameid = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.num_viewers = ::std::option::Option::None;
        self.permission = ::std::option::Option::None;
        self.is_rtmp = ::std::option::Option::None;
        self.seconds_delay = ::std::option::Option::None;
        self.is_publisher = ::std::option::Option::None;
        self.thumbnail_url = ::std::option::Option::None;
        self.update_interval = ::std::option::Option::None;
        self.is_uploading = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.is_replay = ::std::option::Option::None;
        self.is_capturing_vod = ::std::option::Option::None;
        self.is_store_whitelisted = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_GetBroadcastStatus_Response {
        static instance: CBroadcast_GetBroadcastStatus_Response = CBroadcast_GetBroadcastStatus_Response {
            gameid: ::std::option::Option::None,
            title: ::std::option::Option::None,
            num_viewers: ::std::option::Option::None,
            permission: ::std::option::Option::None,
            is_rtmp: ::std::option::Option::None,
            seconds_delay: ::std::option::Option::None,
            is_publisher: ::std::option::Option::None,
            thumbnail_url: ::std::option::Option::None,
            update_interval: ::std::option::Option::None,
            is_uploading: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            is_replay: ::std::option::Option::None,
            is_capturing_vod: ::std::option::Option::None,
            is_store_whitelisted: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Request thumbnail URL for broadcast"]
// @@protoc_insertion_point(message:CBroadcast_GetBroadcastThumbnail_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_GetBroadcastThumbnail_Request {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_GetBroadcastThumbnail_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_GetBroadcastThumbnail_Request.broadcast_id)
    pub broadcast_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_GetBroadcastThumbnail_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_GetBroadcastThumbnail_Request {
    fn default() -> &'a CBroadcast_GetBroadcastThumbnail_Request {
        <CBroadcast_GetBroadcastThumbnail_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_GetBroadcastThumbnail_Request {
    pub fn new() -> CBroadcast_GetBroadcastThumbnail_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 broadcast_id = 2;

    pub fn broadcast_id(&self) -> u64 {
        self.broadcast_id.unwrap_or(0)
    }

    pub fn clear_broadcast_id(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_id(&self) -> bool {
        self.broadcast_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_id(&mut self, v: u64) {
        self.broadcast_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_GetBroadcastThumbnail_Request {
    const NAME: &'static str = "CBroadcast_GetBroadcastThumbnail_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.broadcast_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.broadcast_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.broadcast_id {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_GetBroadcastThumbnail_Request {
        CBroadcast_GetBroadcastThumbnail_Request::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.broadcast_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_GetBroadcastThumbnail_Request {
        static instance: CBroadcast_GetBroadcastThumbnail_Request = CBroadcast_GetBroadcastThumbnail_Request {
            steamid: ::std::option::Option::None,
            broadcast_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CBroadcast_GetBroadcastThumbnail_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_GetBroadcastThumbnail_Response {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_GetBroadcastThumbnail_Response.thumbnail_url)
    pub thumbnail_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBroadcast_GetBroadcastThumbnail_Response.update_interval)
    pub update_interval: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CBroadcast_GetBroadcastThumbnail_Response.num_viewers)
    pub num_viewers: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CBroadcast_GetBroadcastThumbnail_Response.duration)
    pub duration: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_GetBroadcastThumbnail_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_GetBroadcastThumbnail_Response {
    fn default() -> &'a CBroadcast_GetBroadcastThumbnail_Response {
        <CBroadcast_GetBroadcastThumbnail_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_GetBroadcastThumbnail_Response {
    pub fn new() -> CBroadcast_GetBroadcastThumbnail_Response {
        ::std::default::Default::default()
    }

    // optional string thumbnail_url = 1;

    pub fn thumbnail_url(&self) -> &str {
        match self.thumbnail_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_thumbnail_url(&mut self) {
        self.thumbnail_url = ::std::option::Option::None;
    }

    pub fn has_thumbnail_url(&self) -> bool {
        self.thumbnail_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnail_url(&mut self, v: ::std::string::String) {
        self.thumbnail_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnail_url(&mut self) -> &mut ::std::string::String {
        if self.thumbnail_url.is_none() {
            self.thumbnail_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.thumbnail_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnail_url(&mut self) -> ::std::string::String {
        self.thumbnail_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 update_interval = 2;

    pub fn update_interval(&self) -> i32 {
        self.update_interval.unwrap_or(0)
    }

    pub fn clear_update_interval(&mut self) {
        self.update_interval = ::std::option::Option::None;
    }

    pub fn has_update_interval(&self) -> bool {
        self.update_interval.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_interval(&mut self, v: i32) {
        self.update_interval = ::std::option::Option::Some(v);
    }

    // optional int32 num_viewers = 3;

    pub fn num_viewers(&self) -> i32 {
        self.num_viewers.unwrap_or(0)
    }

    pub fn clear_num_viewers(&mut self) {
        self.num_viewers = ::std::option::Option::None;
    }

    pub fn has_num_viewers(&self) -> bool {
        self.num_viewers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_viewers(&mut self, v: i32) {
        self.num_viewers = ::std::option::Option::Some(v);
    }

    // optional int32 duration = 4;

    pub fn duration(&self) -> i32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: i32) {
        self.duration = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_GetBroadcastThumbnail_Response {
    const NAME: &'static str = "CBroadcast_GetBroadcastThumbnail_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.thumbnail_url = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.update_interval = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.num_viewers = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.duration = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.thumbnail_url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.update_interval {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.num_viewers {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.thumbnail_url.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.update_interval {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.num_viewers {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.duration {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_GetBroadcastThumbnail_Response {
        CBroadcast_GetBroadcastThumbnail_Response::new()
    }

    fn clear(&mut self) {
        self.thumbnail_url = ::std::option::Option::None;
        self.update_interval = ::std::option::Option::None;
        self.num_viewers = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_GetBroadcastThumbnail_Response {
        static instance: CBroadcast_GetBroadcastThumbnail_Response = CBroadcast_GetBroadcastThumbnail_Response {
            thumbnail_url: ::std::option::Option::None,
            update_interval: ::std::option::Option::None,
            num_viewers: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Invites another steam user to watch the caller's broadcast"]
// @@protoc_insertion_point(message:CBroadcast_InviteToBroadcast_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_InviteToBroadcast_Request {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_InviteToBroadcast_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_InviteToBroadcast_Request.approval_response)
    pub approval_response: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_InviteToBroadcast_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_InviteToBroadcast_Request {
    fn default() -> &'a CBroadcast_InviteToBroadcast_Request {
        <CBroadcast_InviteToBroadcast_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_InviteToBroadcast_Request {
    pub fn new() -> CBroadcast_InviteToBroadcast_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional bool approval_response = 2;

    pub fn approval_response(&self) -> bool {
        self.approval_response.unwrap_or(false)
    }

    pub fn clear_approval_response(&mut self) {
        self.approval_response = ::std::option::Option::None;
    }

    pub fn has_approval_response(&self) -> bool {
        self.approval_response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_approval_response(&mut self, v: bool) {
        self.approval_response = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_InviteToBroadcast_Request {
    const NAME: &'static str = "CBroadcast_InviteToBroadcast_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.approval_response = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.approval_response {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.approval_response {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_InviteToBroadcast_Request {
        CBroadcast_InviteToBroadcast_Request::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.approval_response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_InviteToBroadcast_Request {
        static instance: CBroadcast_InviteToBroadcast_Request = CBroadcast_InviteToBroadcast_Request {
            steamid: ::std::option::Option::None,
            approval_response: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CBroadcast_InviteToBroadcast_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_InviteToBroadcast_Response {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_InviteToBroadcast_Response.success)
    pub success: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_InviteToBroadcast_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_InviteToBroadcast_Response {
    fn default() -> &'a CBroadcast_InviteToBroadcast_Response {
        <CBroadcast_InviteToBroadcast_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_InviteToBroadcast_Response {
    pub fn new() -> CBroadcast_InviteToBroadcast_Response {
        ::std::default::Default::default()
    }

    // optional bool success = 1;

    pub fn success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_InviteToBroadcast_Response {
    const NAME: &'static str = "CBroadcast_InviteToBroadcast_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_InviteToBroadcast_Response {
        CBroadcast_InviteToBroadcast_Response::new()
    }

    fn clear(&mut self) {
        self.success = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_InviteToBroadcast_Response {
        static instance: CBroadcast_InviteToBroadcast_Response = CBroadcast_InviteToBroadcast_Response {
            success: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Sends users current broadcast state (permissions, game) to the server"]
// @@protoc_insertion_point(message:CBroadcast_SendBroadcastStateToServer_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_SendBroadcastStateToServer_Request {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_SendBroadcastStateToServer_Request.permission)
    pub permission: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CBroadcast_SendBroadcastStateToServer_Request.gameid)
    pub gameid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_SendBroadcastStateToServer_Request.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBroadcast_SendBroadcastStateToServer_Request.game_data_config)
    pub game_data_config: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_SendBroadcastStateToServer_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_SendBroadcastStateToServer_Request {
    fn default() -> &'a CBroadcast_SendBroadcastStateToServer_Request {
        <CBroadcast_SendBroadcastStateToServer_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_SendBroadcastStateToServer_Request {
    pub fn new() -> CBroadcast_SendBroadcastStateToServer_Request {
        ::std::default::Default::default()
    }

    // optional int32 permission = 1;

    pub fn permission(&self) -> i32 {
        self.permission.unwrap_or(0)
    }

    pub fn clear_permission(&mut self) {
        self.permission = ::std::option::Option::None;
    }

    pub fn has_permission(&self) -> bool {
        self.permission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permission(&mut self, v: i32) {
        self.permission = ::std::option::Option::Some(v);
    }

    // optional uint64 gameid = 2;

    pub fn gameid(&self) -> u64 {
        self.gameid.unwrap_or(0)
    }

    pub fn clear_gameid(&mut self) {
        self.gameid = ::std::option::Option::None;
    }

    pub fn has_gameid(&self) -> bool {
        self.gameid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameid(&mut self, v: u64) {
        self.gameid = ::std::option::Option::Some(v);
    }

    // optional string title = 3;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string game_data_config = 4;

    pub fn game_data_config(&self) -> &str {
        match self.game_data_config.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_data_config(&mut self) {
        self.game_data_config = ::std::option::Option::None;
    }

    pub fn has_game_data_config(&self) -> bool {
        self.game_data_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_data_config(&mut self, v: ::std::string::String) {
        self.game_data_config = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_data_config(&mut self) -> &mut ::std::string::String {
        if self.game_data_config.is_none() {
            self.game_data_config = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_data_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_data_config(&mut self) -> ::std::string::String {
        self.game_data_config.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CBroadcast_SendBroadcastStateToServer_Request {
    const NAME: &'static str = "CBroadcast_SendBroadcastStateToServer_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.permission = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.gameid = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.game_data_config = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.permission {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.gameid {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.game_data_config.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.permission {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.gameid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.game_data_config.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_SendBroadcastStateToServer_Request {
        CBroadcast_SendBroadcastStateToServer_Request::new()
    }

    fn clear(&mut self) {
        self.permission = ::std::option::Option::None;
        self.gameid = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.game_data_config = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_SendBroadcastStateToServer_Request {
        static instance: CBroadcast_SendBroadcastStateToServer_Request = CBroadcast_SendBroadcastStateToServer_Request {
            permission: ::std::option::Option::None,
            gameid: ::std::option::Option::None,
            title: ::std::option::Option::None,
            game_data_config: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CBroadcast_SendBroadcastStateToServer_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_SendBroadcastStateToServer_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_SendBroadcastStateToServer_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_SendBroadcastStateToServer_Response {
    fn default() -> &'a CBroadcast_SendBroadcastStateToServer_Response {
        <CBroadcast_SendBroadcastStateToServer_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_SendBroadcastStateToServer_Response {
    pub fn new() -> CBroadcast_SendBroadcastStateToServer_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CBroadcast_SendBroadcastStateToServer_Response {
    const NAME: &'static str = "CBroadcast_SendBroadcastStateToServer_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_SendBroadcastStateToServer_Response {
        CBroadcast_SendBroadcastStateToServer_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_SendBroadcastStateToServer_Response {
        static instance: CBroadcast_SendBroadcastStateToServer_Response = CBroadcast_SendBroadcastStateToServer_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Tells directory broadcast session is still available"]
// @@protoc_insertion_point(message:CBroadcast_NotifyBroadcastSessionHeartbeat_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_NotifyBroadcastSessionHeartbeat_Notification {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_NotifyBroadcastSessionHeartbeat_Notification.broadcast_id)
    pub broadcast_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_NotifyBroadcastSessionHeartbeat_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_NotifyBroadcastSessionHeartbeat_Notification {
    fn default() -> &'a CBroadcast_NotifyBroadcastSessionHeartbeat_Notification {
        <CBroadcast_NotifyBroadcastSessionHeartbeat_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_NotifyBroadcastSessionHeartbeat_Notification {
    pub fn new() -> CBroadcast_NotifyBroadcastSessionHeartbeat_Notification {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_id = 1;

    pub fn broadcast_id(&self) -> u64 {
        self.broadcast_id.unwrap_or(0)
    }

    pub fn clear_broadcast_id(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_id(&self) -> bool {
        self.broadcast_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_id(&mut self, v: u64) {
        self.broadcast_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_NotifyBroadcastSessionHeartbeat_Notification {
    const NAME: &'static str = "CBroadcast_NotifyBroadcastSessionHeartbeat_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_NotifyBroadcastSessionHeartbeat_Notification {
        CBroadcast_NotifyBroadcastSessionHeartbeat_Notification::new()
    }

    fn clear(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_NotifyBroadcastSessionHeartbeat_Notification {
        static instance: CBroadcast_NotifyBroadcastSessionHeartbeat_Notification = CBroadcast_NotifyBroadcastSessionHeartbeat_Notification {
            broadcast_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Gets chat room info for a broadcast"]
// @@protoc_insertion_point(message:CBroadcast_GetBroadcastChatInfo_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_GetBroadcastChatInfo_Request {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_GetBroadcastChatInfo_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_GetBroadcastChatInfo_Request.broadcast_id)
    pub broadcast_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_GetBroadcastChatInfo_Request.client_ip)
    pub client_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CBroadcast_GetBroadcastChatInfo_Request.client_cell)
    pub client_cell: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_GetBroadcastChatInfo_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_GetBroadcastChatInfo_Request {
    fn default() -> &'a CBroadcast_GetBroadcastChatInfo_Request {
        <CBroadcast_GetBroadcastChatInfo_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_GetBroadcastChatInfo_Request {
    pub fn new() -> CBroadcast_GetBroadcastChatInfo_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 broadcast_id = 2;

    pub fn broadcast_id(&self) -> u64 {
        self.broadcast_id.unwrap_or(0)
    }

    pub fn clear_broadcast_id(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_id(&self) -> bool {
        self.broadcast_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_id(&mut self, v: u64) {
        self.broadcast_id = ::std::option::Option::Some(v);
    }

    // optional uint32 client_ip = 3;

    pub fn client_ip(&self) -> u32 {
        self.client_ip.unwrap_or(0)
    }

    pub fn clear_client_ip(&mut self) {
        self.client_ip = ::std::option::Option::None;
    }

    pub fn has_client_ip(&self) -> bool {
        self.client_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_ip(&mut self, v: u32) {
        self.client_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 client_cell = 4;

    pub fn client_cell(&self) -> u32 {
        self.client_cell.unwrap_or(0)
    }

    pub fn clear_client_cell(&mut self) {
        self.client_cell = ::std::option::Option::None;
    }

    pub fn has_client_cell(&self) -> bool {
        self.client_cell.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_cell(&mut self, v: u32) {
        self.client_cell = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_GetBroadcastChatInfo_Request {
    const NAME: &'static str = "CBroadcast_GetBroadcastChatInfo_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.broadcast_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.client_ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.client_cell = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.broadcast_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.client_ip {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.client_cell {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.broadcast_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.client_ip {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.client_cell {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_GetBroadcastChatInfo_Request {
        CBroadcast_GetBroadcastChatInfo_Request::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.broadcast_id = ::std::option::Option::None;
        self.client_ip = ::std::option::Option::None;
        self.client_cell = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_GetBroadcastChatInfo_Request {
        static instance: CBroadcast_GetBroadcastChatInfo_Request = CBroadcast_GetBroadcastChatInfo_Request {
            steamid: ::std::option::Option::None,
            broadcast_id: ::std::option::Option::None,
            client_ip: ::std::option::Option::None,
            client_cell: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CBroadcast_GetBroadcastChatInfo_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_GetBroadcastChatInfo_Response {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_GetBroadcastChatInfo_Response.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_GetBroadcastChatInfo_Response.view_url_template)
    pub view_url_template: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBroadcast_GetBroadcastChatInfo_Response.flair_group_ids)
    pub flair_group_ids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_GetBroadcastChatInfo_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_GetBroadcastChatInfo_Response {
    fn default() -> &'a CBroadcast_GetBroadcastChatInfo_Response {
        <CBroadcast_GetBroadcastChatInfo_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_GetBroadcastChatInfo_Response {
    pub fn new() -> CBroadcast_GetBroadcastChatInfo_Response {
        ::std::default::Default::default()
    }

    // optional fixed64 chat_id = 1;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional string view_url_template = 3;

    pub fn view_url_template(&self) -> &str {
        match self.view_url_template.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_view_url_template(&mut self) {
        self.view_url_template = ::std::option::Option::None;
    }

    pub fn has_view_url_template(&self) -> bool {
        self.view_url_template.is_some()
    }

    // Param is passed by value, moved
    pub fn set_view_url_template(&mut self, v: ::std::string::String) {
        self.view_url_template = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_view_url_template(&mut self) -> &mut ::std::string::String {
        if self.view_url_template.is_none() {
            self.view_url_template = ::std::option::Option::Some(::std::string::String::new());
        }
        self.view_url_template.as_mut().unwrap()
    }

    // Take field
    pub fn take_view_url_template(&mut self) -> ::std::string::String {
        self.view_url_template.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CBroadcast_GetBroadcastChatInfo_Response {
    const NAME: &'static str = "CBroadcast_GetBroadcastChatInfo_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.chat_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    self.view_url_template = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    is.read_repeated_packed_uint32_into(&mut self.flair_group_ids)?;
                },
                32 => {
                    self.flair_group_ids.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.view_url_template.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.flair_group_ids {
            my_size += ::protobuf::rt::uint32_size(4, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.view_url_template.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.flair_group_ids {
            os.write_uint32(4, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_GetBroadcastChatInfo_Response {
        CBroadcast_GetBroadcastChatInfo_Response::new()
    }

    fn clear(&mut self) {
        self.chat_id = ::std::option::Option::None;
        self.view_url_template = ::std::option::Option::None;
        self.flair_group_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_GetBroadcastChatInfo_Response {
        static instance: CBroadcast_GetBroadcastChatInfo_Response = CBroadcast_GetBroadcastChatInfo_Response {
            chat_id: ::std::option::Option::None,
            view_url_template: ::std::option::Option::None,
            flair_group_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Post chat message to specified chat room"]
// @@protoc_insertion_point(message:CBroadcast_PostChatMessage_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_PostChatMessage_Request {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_PostChatMessage_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_PostChatMessage_Request.message)
    pub message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBroadcast_PostChatMessage_Request.instance_id)
    pub instance_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CBroadcast_PostChatMessage_Request.language)
    pub language: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CBroadcast_PostChatMessage_Request.country_code)
    pub country_code: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_PostChatMessage_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_PostChatMessage_Request {
    fn default() -> &'a CBroadcast_PostChatMessage_Request {
        <CBroadcast_PostChatMessage_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_PostChatMessage_Request {
    pub fn new() -> CBroadcast_PostChatMessage_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 chat_id = 1;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional string message = 2;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 instance_id = 3;

    pub fn instance_id(&self) -> u32 {
        self.instance_id.unwrap_or(0)
    }

    pub fn clear_instance_id(&mut self) {
        self.instance_id = ::std::option::Option::None;
    }

    pub fn has_instance_id(&self) -> bool {
        self.instance_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instance_id(&mut self, v: u32) {
        self.instance_id = ::std::option::Option::Some(v);
    }

    // optional uint32 language = 4;

    pub fn language(&self) -> u32 {
        self.language.unwrap_or(0u32)
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: u32) {
        self.language = ::std::option::Option::Some(v);
    }

    // optional string country_code = 5;

    pub fn country_code(&self) -> &str {
        match self.country_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_country_code(&mut self) {
        self.country_code = ::std::option::Option::None;
    }

    pub fn has_country_code(&self) -> bool {
        self.country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country_code(&mut self, v: ::std::string::String) {
        self.country_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_code(&mut self) -> &mut ::std::string::String {
        if self.country_code.is_none() {
            self.country_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_country_code(&mut self) -> ::std::string::String {
        self.country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CBroadcast_PostChatMessage_Request {
    const NAME: &'static str = "CBroadcast_PostChatMessage_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.chat_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.instance_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.language = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.country_code = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.instance_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.country_code.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.instance_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.language {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.country_code.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_PostChatMessage_Request {
        CBroadcast_PostChatMessage_Request::new()
    }

    fn clear(&mut self) {
        self.chat_id = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.instance_id = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.country_code = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_PostChatMessage_Request {
        static instance: CBroadcast_PostChatMessage_Request = CBroadcast_PostChatMessage_Request {
            chat_id: ::std::option::Option::None,
            message: ::std::option::Option::None,
            instance_id: ::std::option::Option::None,
            language: ::std::option::Option::None,
            country_code: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CBroadcast_PostChatMessage_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_PostChatMessage_Response {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_PostChatMessage_Response.persona_name)
    pub persona_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBroadcast_PostChatMessage_Response.in_game)
    pub in_game: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CBroadcast_PostChatMessage_Response.result)
    pub result: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CBroadcast_PostChatMessage_Response.cooldown_time_seconds)
    pub cooldown_time_seconds: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_PostChatMessage_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_PostChatMessage_Response {
    fn default() -> &'a CBroadcast_PostChatMessage_Response {
        <CBroadcast_PostChatMessage_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_PostChatMessage_Response {
    pub fn new() -> CBroadcast_PostChatMessage_Response {
        ::std::default::Default::default()
    }

    // optional string persona_name = 1;

    pub fn persona_name(&self) -> &str {
        match self.persona_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_persona_name(&mut self) {
        self.persona_name = ::std::option::Option::None;
    }

    pub fn has_persona_name(&self) -> bool {
        self.persona_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_name(&mut self, v: ::std::string::String) {
        self.persona_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persona_name(&mut self) -> &mut ::std::string::String {
        if self.persona_name.is_none() {
            self.persona_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.persona_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_persona_name(&mut self) -> ::std::string::String {
        self.persona_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool in_game = 2;

    pub fn in_game(&self) -> bool {
        self.in_game.unwrap_or(false)
    }

    pub fn clear_in_game(&mut self) {
        self.in_game = ::std::option::Option::None;
    }

    pub fn has_in_game(&self) -> bool {
        self.in_game.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_game(&mut self, v: bool) {
        self.in_game = ::std::option::Option::Some(v);
    }

    // optional int32 result = 3;

    pub fn result(&self) -> i32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: i32) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional int32 cooldown_time_seconds = 4;

    pub fn cooldown_time_seconds(&self) -> i32 {
        self.cooldown_time_seconds.unwrap_or(0)
    }

    pub fn clear_cooldown_time_seconds(&mut self) {
        self.cooldown_time_seconds = ::std::option::Option::None;
    }

    pub fn has_cooldown_time_seconds(&self) -> bool {
        self.cooldown_time_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cooldown_time_seconds(&mut self, v: i32) {
        self.cooldown_time_seconds = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_PostChatMessage_Response {
    const NAME: &'static str = "CBroadcast_PostChatMessage_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.persona_name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.in_game = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.result = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.cooldown_time_seconds = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.persona_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.in_game {
            my_size += 1 + 1;
        }
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.cooldown_time_seconds {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.persona_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.in_game {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.result {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.cooldown_time_seconds {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_PostChatMessage_Response {
        CBroadcast_PostChatMessage_Response::new()
    }

    fn clear(&mut self) {
        self.persona_name = ::std::option::Option::None;
        self.in_game = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.cooldown_time_seconds = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_PostChatMessage_Response {
        static instance: CBroadcast_PostChatMessage_Response = CBroadcast_PostChatMessage_Response {
            persona_name: ::std::option::Option::None,
            in_game: ::std::option::Option::None,
            result: ::std::option::Option::None,
            cooldown_time_seconds: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Update chat message flair in the specified chat room"]
// @@protoc_insertion_point(message:CBroadcast_UpdateChatMessageFlair_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_UpdateChatMessageFlair_Request {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_UpdateChatMessageFlair_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_UpdateChatMessageFlair_Request.flair)
    pub flair: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_UpdateChatMessageFlair_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_UpdateChatMessageFlair_Request {
    fn default() -> &'a CBroadcast_UpdateChatMessageFlair_Request {
        <CBroadcast_UpdateChatMessageFlair_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_UpdateChatMessageFlair_Request {
    pub fn new() -> CBroadcast_UpdateChatMessageFlair_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 chat_id = 1;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional string flair = 2;

    pub fn flair(&self) -> &str {
        match self.flair.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_flair(&mut self) {
        self.flair = ::std::option::Option::None;
    }

    pub fn has_flair(&self) -> bool {
        self.flair.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flair(&mut self, v: ::std::string::String) {
        self.flair = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_flair(&mut self) -> &mut ::std::string::String {
        if self.flair.is_none() {
            self.flair = ::std::option::Option::Some(::std::string::String::new());
        }
        self.flair.as_mut().unwrap()
    }

    // Take field
    pub fn take_flair(&mut self) -> ::std::string::String {
        self.flair.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CBroadcast_UpdateChatMessageFlair_Request {
    const NAME: &'static str = "CBroadcast_UpdateChatMessageFlair_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.chat_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    self.flair = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.flair.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.flair.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_UpdateChatMessageFlair_Request {
        CBroadcast_UpdateChatMessageFlair_Request::new()
    }

    fn clear(&mut self) {
        self.chat_id = ::std::option::Option::None;
        self.flair = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_UpdateChatMessageFlair_Request {
        static instance: CBroadcast_UpdateChatMessageFlair_Request = CBroadcast_UpdateChatMessageFlair_Request {
            chat_id: ::std::option::Option::None,
            flair: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CBroadcast_UpdateChatMessageFlair_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_UpdateChatMessageFlair_Response {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_UpdateChatMessageFlair_Response.result)
    pub result: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CBroadcast_UpdateChatMessageFlair_Response.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_UpdateChatMessageFlair_Response.flair)
    pub flair: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_UpdateChatMessageFlair_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_UpdateChatMessageFlair_Response {
    fn default() -> &'a CBroadcast_UpdateChatMessageFlair_Response {
        <CBroadcast_UpdateChatMessageFlair_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_UpdateChatMessageFlair_Response {
    pub fn new() -> CBroadcast_UpdateChatMessageFlair_Response {
        ::std::default::Default::default()
    }

    // optional int32 result = 1;

    pub fn result(&self) -> i32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: i32) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional fixed64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional string flair = 3;

    pub fn flair(&self) -> &str {
        match self.flair.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_flair(&mut self) {
        self.flair = ::std::option::Option::None;
    }

    pub fn has_flair(&self) -> bool {
        self.flair.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flair(&mut self, v: ::std::string::String) {
        self.flair = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_flair(&mut self) -> &mut ::std::string::String {
        if self.flair.is_none() {
            self.flair = ::std::option::Option::Some(::std::string::String::new());
        }
        self.flair.as_mut().unwrap()
    }

    // Take field
    pub fn take_flair(&mut self) -> ::std::string::String {
        self.flair.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CBroadcast_UpdateChatMessageFlair_Response {
    const NAME: &'static str = "CBroadcast_UpdateChatMessageFlair_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_int32()?);
                },
                17 => {
                    self.chat_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    self.flair = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.flair.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.flair.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_UpdateChatMessageFlair_Response {
        CBroadcast_UpdateChatMessageFlair_Response::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.flair = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_UpdateChatMessageFlair_Response {
        static instance: CBroadcast_UpdateChatMessageFlair_Response = CBroadcast_UpdateChatMessageFlair_Response {
            result: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            flair: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Mute a user in your broadcast chat"]
// @@protoc_insertion_point(message:CBroadcast_MuteBroadcastChatUser_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_MuteBroadcastChatUser_Request {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_MuteBroadcastChatUser_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_MuteBroadcastChatUser_Request.user_steamid)
    pub user_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_MuteBroadcastChatUser_Request.muted)
    pub muted: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_MuteBroadcastChatUser_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_MuteBroadcastChatUser_Request {
    fn default() -> &'a CBroadcast_MuteBroadcastChatUser_Request {
        <CBroadcast_MuteBroadcastChatUser_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_MuteBroadcastChatUser_Request {
    pub fn new() -> CBroadcast_MuteBroadcastChatUser_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 chat_id = 1;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 user_steamid = 2;

    pub fn user_steamid(&self) -> u64 {
        self.user_steamid.unwrap_or(0)
    }

    pub fn clear_user_steamid(&mut self) {
        self.user_steamid = ::std::option::Option::None;
    }

    pub fn has_user_steamid(&self) -> bool {
        self.user_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_steamid(&mut self, v: u64) {
        self.user_steamid = ::std::option::Option::Some(v);
    }

    // optional bool muted = 3;

    pub fn muted(&self) -> bool {
        self.muted.unwrap_or(false)
    }

    pub fn clear_muted(&mut self) {
        self.muted = ::std::option::Option::None;
    }

    pub fn has_muted(&self) -> bool {
        self.muted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_muted(&mut self, v: bool) {
        self.muted = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_MuteBroadcastChatUser_Request {
    const NAME: &'static str = "CBroadcast_MuteBroadcastChatUser_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.chat_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.user_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.muted = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.user_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.muted {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.user_steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.muted {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_MuteBroadcastChatUser_Request {
        CBroadcast_MuteBroadcastChatUser_Request::new()
    }

    fn clear(&mut self) {
        self.chat_id = ::std::option::Option::None;
        self.user_steamid = ::std::option::Option::None;
        self.muted = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_MuteBroadcastChatUser_Request {
        static instance: CBroadcast_MuteBroadcastChatUser_Request = CBroadcast_MuteBroadcastChatUser_Request {
            chat_id: ::std::option::Option::None,
            user_steamid: ::std::option::Option::None,
            muted: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CBroadcast_MuteBroadcastChatUser_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_MuteBroadcastChatUser_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_MuteBroadcastChatUser_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_MuteBroadcastChatUser_Response {
    fn default() -> &'a CBroadcast_MuteBroadcastChatUser_Response {
        <CBroadcast_MuteBroadcastChatUser_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_MuteBroadcastChatUser_Response {
    pub fn new() -> CBroadcast_MuteBroadcastChatUser_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CBroadcast_MuteBroadcastChatUser_Response {
    const NAME: &'static str = "CBroadcast_MuteBroadcastChatUser_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_MuteBroadcastChatUser_Response {
        CBroadcast_MuteBroadcastChatUser_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_MuteBroadcastChatUser_Response {
        static instance: CBroadcast_MuteBroadcastChatUser_Response = CBroadcast_MuteBroadcastChatUser_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Tell all viewers to remove user chat text"]
// @@protoc_insertion_point(message:CBroadcast_RemoveUserChatText_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_RemoveUserChatText_Request {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_RemoveUserChatText_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_RemoveUserChatText_Request.user_steamid)
    pub user_steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_RemoveUserChatText_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_RemoveUserChatText_Request {
    fn default() -> &'a CBroadcast_RemoveUserChatText_Request {
        <CBroadcast_RemoveUserChatText_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_RemoveUserChatText_Request {
    pub fn new() -> CBroadcast_RemoveUserChatText_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 chat_id = 1;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 user_steamid = 2;

    pub fn user_steamid(&self) -> u64 {
        self.user_steamid.unwrap_or(0)
    }

    pub fn clear_user_steamid(&mut self) {
        self.user_steamid = ::std::option::Option::None;
    }

    pub fn has_user_steamid(&self) -> bool {
        self.user_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_steamid(&mut self, v: u64) {
        self.user_steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_RemoveUserChatText_Request {
    const NAME: &'static str = "CBroadcast_RemoveUserChatText_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.chat_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.user_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.user_steamid {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.user_steamid {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_RemoveUserChatText_Request {
        CBroadcast_RemoveUserChatText_Request::new()
    }

    fn clear(&mut self) {
        self.chat_id = ::std::option::Option::None;
        self.user_steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_RemoveUserChatText_Request {
        static instance: CBroadcast_RemoveUserChatText_Request = CBroadcast_RemoveUserChatText_Request {
            chat_id: ::std::option::Option::None,
            user_steamid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CBroadcast_RemoveUserChatText_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_RemoveUserChatText_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_RemoveUserChatText_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_RemoveUserChatText_Response {
    fn default() -> &'a CBroadcast_RemoveUserChatText_Response {
        <CBroadcast_RemoveUserChatText_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_RemoveUserChatText_Response {
    pub fn new() -> CBroadcast_RemoveUserChatText_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CBroadcast_RemoveUserChatText_Response {
    const NAME: &'static str = "CBroadcast_RemoveUserChatText_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_RemoveUserChatText_Response {
        CBroadcast_RemoveUserChatText_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_RemoveUserChatText_Response {
        static instance: CBroadcast_RemoveUserChatText_Response = CBroadcast_RemoveUserChatText_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Get names for list of users in chat"]
// @@protoc_insertion_point(message:CBroadcast_GetBroadcastChatUserNames_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_GetBroadcastChatUserNames_Request {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_GetBroadcastChatUserNames_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_GetBroadcastChatUserNames_Request.user_steamid)
    pub user_steamid: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_GetBroadcastChatUserNames_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_GetBroadcastChatUserNames_Request {
    fn default() -> &'a CBroadcast_GetBroadcastChatUserNames_Request {
        <CBroadcast_GetBroadcastChatUserNames_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_GetBroadcastChatUserNames_Request {
    pub fn new() -> CBroadcast_GetBroadcastChatUserNames_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 chat_id = 1;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_GetBroadcastChatUserNames_Request {
    const NAME: &'static str = "CBroadcast_GetBroadcastChatUserNames_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.chat_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    is.read_repeated_packed_fixed64_into(&mut self.user_steamid)?;
                },
                17 => {
                    self.user_steamid.push(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_id {
            my_size += 1 + 8;
        }
        my_size += 9 * self.user_steamid.len() as u64;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_id {
            os.write_fixed64(1, v)?;
        }
        for v in &self.user_steamid {
            os.write_fixed64(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_GetBroadcastChatUserNames_Request {
        CBroadcast_GetBroadcastChatUserNames_Request::new()
    }

    fn clear(&mut self) {
        self.chat_id = ::std::option::Option::None;
        self.user_steamid.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_GetBroadcastChatUserNames_Request {
        static instance: CBroadcast_GetBroadcastChatUserNames_Request = CBroadcast_GetBroadcastChatUserNames_Request {
            chat_id: ::std::option::Option::None,
            user_steamid: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CBroadcast_GetBroadcastChatUserNames_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_GetBroadcastChatUserNames_Response {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_GetBroadcastChatUserNames_Response.persona_names)
    pub persona_names: ::std::vec::Vec<cbroadcast_get_broadcast_chat_user_names_response::PersonaName>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_GetBroadcastChatUserNames_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_GetBroadcastChatUserNames_Response {
    fn default() -> &'a CBroadcast_GetBroadcastChatUserNames_Response {
        <CBroadcast_GetBroadcastChatUserNames_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_GetBroadcastChatUserNames_Response {
    pub fn new() -> CBroadcast_GetBroadcastChatUserNames_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CBroadcast_GetBroadcastChatUserNames_Response {
    const NAME: &'static str = "CBroadcast_GetBroadcastChatUserNames_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.persona_names.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.persona_names {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.persona_names {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_GetBroadcastChatUserNames_Response {
        CBroadcast_GetBroadcastChatUserNames_Response::new()
    }

    fn clear(&mut self) {
        self.persona_names.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_GetBroadcastChatUserNames_Response {
        static instance: CBroadcast_GetBroadcastChatUserNames_Response = CBroadcast_GetBroadcastChatUserNames_Response {
            persona_names: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CBroadcast_GetBroadcastChatUserNames_Response`
pub mod cbroadcast_get_broadcast_chat_user_names_response {
    // @@protoc_insertion_point(message:CBroadcast_GetBroadcastChatUserNames_Response.PersonaName)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PersonaName {
        // message fields
        // @@protoc_insertion_point(field:CBroadcast_GetBroadcastChatUserNames_Response.PersonaName.steam_id)
        pub steam_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CBroadcast_GetBroadcastChatUserNames_Response.PersonaName.persona)
        pub persona: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CBroadcast_GetBroadcastChatUserNames_Response.PersonaName.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PersonaName {
        fn default() -> &'a PersonaName {
            <PersonaName as ::protobuf::Message>::default_instance()
        }
    }

    impl PersonaName {
        pub fn new() -> PersonaName {
            ::std::default::Default::default()
        }

        // optional fixed64 steam_id = 1;

        pub fn steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }

        // optional string persona = 2;

        pub fn persona(&self) -> &str {
            match self.persona.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_persona(&mut self) {
            self.persona = ::std::option::Option::None;
        }

        pub fn has_persona(&self) -> bool {
            self.persona.is_some()
        }

        // Param is passed by value, moved
        pub fn set_persona(&mut self, v: ::std::string::String) {
            self.persona = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_persona(&mut self) -> &mut ::std::string::String {
            if self.persona.is_none() {
                self.persona = ::std::option::Option::Some(::std::string::String::new());
            }
            self.persona.as_mut().unwrap()
        }

        // Take field
        pub fn take_persona(&mut self) -> ::std::string::String {
            self.persona.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::protobuf::Message for PersonaName {
        const NAME: &'static str = "PersonaName";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    18 => {
                        self.persona = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steam_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.persona.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.steam_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.persona.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PersonaName {
            PersonaName::new()
        }

        fn clear(&mut self) {
            self.steam_id = ::std::option::Option::None;
            self.persona = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PersonaName {
            static instance: PersonaName = PersonaName {
                steam_id: ::std::option::Option::None,
                persona: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

#[doc = "Start building a broadcast clip"]
// @@protoc_insertion_point(message:CBroadcast_StartBuildClip_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_StartBuildClip_Request {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_StartBuildClip_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_StartBuildClip_Request.broadcast_session_id)
    pub broadcast_session_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_StartBuildClip_Request.first_segment)
    pub first_segment: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CBroadcast_StartBuildClip_Request.num_segments)
    pub num_segments: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CBroadcast_StartBuildClip_Request.clip_description)
    pub clip_description: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_StartBuildClip_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_StartBuildClip_Request {
    fn default() -> &'a CBroadcast_StartBuildClip_Request {
        <CBroadcast_StartBuildClip_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_StartBuildClip_Request {
    pub fn new() -> CBroadcast_StartBuildClip_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 broadcast_session_id = 2;

    pub fn broadcast_session_id(&self) -> u64 {
        self.broadcast_session_id.unwrap_or(0)
    }

    pub fn clear_broadcast_session_id(&mut self) {
        self.broadcast_session_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_session_id(&self) -> bool {
        self.broadcast_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_session_id(&mut self, v: u64) {
        self.broadcast_session_id = ::std::option::Option::Some(v);
    }

    // optional int32 first_segment = 3;

    pub fn first_segment(&self) -> i32 {
        self.first_segment.unwrap_or(0)
    }

    pub fn clear_first_segment(&mut self) {
        self.first_segment = ::std::option::Option::None;
    }

    pub fn has_first_segment(&self) -> bool {
        self.first_segment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_segment(&mut self, v: i32) {
        self.first_segment = ::std::option::Option::Some(v);
    }

    // optional int32 num_segments = 4;

    pub fn num_segments(&self) -> i32 {
        self.num_segments.unwrap_or(0)
    }

    pub fn clear_num_segments(&mut self) {
        self.num_segments = ::std::option::Option::None;
    }

    pub fn has_num_segments(&self) -> bool {
        self.num_segments.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_segments(&mut self, v: i32) {
        self.num_segments = ::std::option::Option::Some(v);
    }

    // optional string clip_description = 5;

    pub fn clip_description(&self) -> &str {
        match self.clip_description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_clip_description(&mut self) {
        self.clip_description = ::std::option::Option::None;
    }

    pub fn has_clip_description(&self) -> bool {
        self.clip_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clip_description(&mut self, v: ::std::string::String) {
        self.clip_description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clip_description(&mut self) -> &mut ::std::string::String {
        if self.clip_description.is_none() {
            self.clip_description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.clip_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_clip_description(&mut self) -> ::std::string::String {
        self.clip_description.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CBroadcast_StartBuildClip_Request {
    const NAME: &'static str = "CBroadcast_StartBuildClip_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.broadcast_session_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.first_segment = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.num_segments = ::std::option::Option::Some(is.read_int32()?);
                },
                42 => {
                    self.clip_description = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.broadcast_session_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.first_segment {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.num_segments {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.clip_description.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.broadcast_session_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.first_segment {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.num_segments {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.clip_description.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_StartBuildClip_Request {
        CBroadcast_StartBuildClip_Request::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.broadcast_session_id = ::std::option::Option::None;
        self.first_segment = ::std::option::Option::None;
        self.num_segments = ::std::option::Option::None;
        self.clip_description = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_StartBuildClip_Request {
        static instance: CBroadcast_StartBuildClip_Request = CBroadcast_StartBuildClip_Request {
            steamid: ::std::option::Option::None,
            broadcast_session_id: ::std::option::Option::None,
            first_segment: ::std::option::Option::None,
            num_segments: ::std::option::Option::None,
            clip_description: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CBroadcast_StartBuildClip_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_StartBuildClip_Response {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_StartBuildClip_Response.broadcast_clip_id)
    pub broadcast_clip_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_StartBuildClip_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_StartBuildClip_Response {
    fn default() -> &'a CBroadcast_StartBuildClip_Response {
        <CBroadcast_StartBuildClip_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_StartBuildClip_Response {
    pub fn new() -> CBroadcast_StartBuildClip_Response {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_clip_id = 1;

    pub fn broadcast_clip_id(&self) -> u64 {
        self.broadcast_clip_id.unwrap_or(0)
    }

    pub fn clear_broadcast_clip_id(&mut self) {
        self.broadcast_clip_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_clip_id(&self) -> bool {
        self.broadcast_clip_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_clip_id(&mut self, v: u64) {
        self.broadcast_clip_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_StartBuildClip_Response {
    const NAME: &'static str = "CBroadcast_StartBuildClip_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_clip_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_clip_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast_clip_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_StartBuildClip_Response {
        CBroadcast_StartBuildClip_Response::new()
    }

    fn clear(&mut self) {
        self.broadcast_clip_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_StartBuildClip_Response {
        static instance: CBroadcast_StartBuildClip_Response = CBroadcast_StartBuildClip_Response {
            broadcast_clip_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Start building a broadcast clip"]
// @@protoc_insertion_point(message:CBroadcast_GetBuildClipStatus_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_GetBuildClipStatus_Request {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_GetBuildClipStatus_Request.broadcast_clip_id)
    pub broadcast_clip_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_GetBuildClipStatus_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_GetBuildClipStatus_Request {
    fn default() -> &'a CBroadcast_GetBuildClipStatus_Request {
        <CBroadcast_GetBuildClipStatus_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_GetBuildClipStatus_Request {
    pub fn new() -> CBroadcast_GetBuildClipStatus_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_clip_id = 1;

    pub fn broadcast_clip_id(&self) -> u64 {
        self.broadcast_clip_id.unwrap_or(0)
    }

    pub fn clear_broadcast_clip_id(&mut self) {
        self.broadcast_clip_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_clip_id(&self) -> bool {
        self.broadcast_clip_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_clip_id(&mut self, v: u64) {
        self.broadcast_clip_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_GetBuildClipStatus_Request {
    const NAME: &'static str = "CBroadcast_GetBuildClipStatus_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_clip_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_clip_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast_clip_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_GetBuildClipStatus_Request {
        CBroadcast_GetBuildClipStatus_Request::new()
    }

    fn clear(&mut self) {
        self.broadcast_clip_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_GetBuildClipStatus_Request {
        static instance: CBroadcast_GetBuildClipStatus_Request = CBroadcast_GetBuildClipStatus_Request {
            broadcast_clip_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CBroadcast_GetBuildClipStatus_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_GetBuildClipStatus_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_GetBuildClipStatus_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_GetBuildClipStatus_Response {
    fn default() -> &'a CBroadcast_GetBuildClipStatus_Response {
        <CBroadcast_GetBuildClipStatus_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_GetBuildClipStatus_Response {
    pub fn new() -> CBroadcast_GetBuildClipStatus_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CBroadcast_GetBuildClipStatus_Response {
    const NAME: &'static str = "CBroadcast_GetBuildClipStatus_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_GetBuildClipStatus_Response {
        CBroadcast_GetBuildClipStatus_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_GetBuildClipStatus_Response {
        static instance: CBroadcast_GetBuildClipStatus_Response = CBroadcast_GetBuildClipStatus_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Updates a broadcast clip"]
// @@protoc_insertion_point(message:CBroadcast_SetClipDetails_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_SetClipDetails_Request {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_SetClipDetails_Request.broadcast_clip_id)
    pub broadcast_clip_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_SetClipDetails_Request.start_time)
    pub start_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CBroadcast_SetClipDetails_Request.end_time)
    pub end_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CBroadcast_SetClipDetails_Request.video_description)
    pub video_description: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_SetClipDetails_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_SetClipDetails_Request {
    fn default() -> &'a CBroadcast_SetClipDetails_Request {
        <CBroadcast_SetClipDetails_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_SetClipDetails_Request {
    pub fn new() -> CBroadcast_SetClipDetails_Request {
        ::std::default::Default::default()
    }

    // optional uint64 broadcast_clip_id = 1;

    pub fn broadcast_clip_id(&self) -> u64 {
        self.broadcast_clip_id.unwrap_or(0)
    }

    pub fn clear_broadcast_clip_id(&mut self) {
        self.broadcast_clip_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_clip_id(&self) -> bool {
        self.broadcast_clip_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_clip_id(&mut self, v: u64) {
        self.broadcast_clip_id = ::std::option::Option::Some(v);
    }

    // optional uint32 start_time = 2;

    pub fn start_time(&self) -> u32 {
        self.start_time.unwrap_or(0)
    }

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: u32) {
        self.start_time = ::std::option::Option::Some(v);
    }

    // optional uint32 end_time = 3;

    pub fn end_time(&self) -> u32 {
        self.end_time.unwrap_or(0)
    }

    pub fn clear_end_time(&mut self) {
        self.end_time = ::std::option::Option::None;
    }

    pub fn has_end_time(&self) -> bool {
        self.end_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: u32) {
        self.end_time = ::std::option::Option::Some(v);
    }

    // optional string video_description = 4;

    pub fn video_description(&self) -> &str {
        match self.video_description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_video_description(&mut self) {
        self.video_description = ::std::option::Option::None;
    }

    pub fn has_video_description(&self) -> bool {
        self.video_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_video_description(&mut self, v: ::std::string::String) {
        self.video_description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_video_description(&mut self) -> &mut ::std::string::String {
        if self.video_description.is_none() {
            self.video_description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.video_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_video_description(&mut self) -> ::std::string::String {
        self.video_description.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CBroadcast_SetClipDetails_Request {
    const NAME: &'static str = "CBroadcast_SetClipDetails_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.broadcast_clip_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.start_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.end_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.video_description = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_clip_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.start_time {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.end_time {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.video_description.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast_clip_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.start_time {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.end_time {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.video_description.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_SetClipDetails_Request {
        CBroadcast_SetClipDetails_Request::new()
    }

    fn clear(&mut self) {
        self.broadcast_clip_id = ::std::option::Option::None;
        self.start_time = ::std::option::Option::None;
        self.end_time = ::std::option::Option::None;
        self.video_description = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_SetClipDetails_Request {
        static instance: CBroadcast_SetClipDetails_Request = CBroadcast_SetClipDetails_Request {
            broadcast_clip_id: ::std::option::Option::None,
            start_time: ::std::option::Option::None,
            end_time: ::std::option::Option::None,
            video_description: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CBroadcast_SetClipDetails_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_SetClipDetails_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_SetClipDetails_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_SetClipDetails_Response {
    fn default() -> &'a CBroadcast_SetClipDetails_Response {
        <CBroadcast_SetClipDetails_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_SetClipDetails_Response {
    pub fn new() -> CBroadcast_SetClipDetails_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CBroadcast_SetClipDetails_Response {
    const NAME: &'static str = "CBroadcast_SetClipDetails_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_SetClipDetails_Response {
        CBroadcast_SetClipDetails_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_SetClipDetails_Response {
        static instance: CBroadcast_SetClipDetails_Response = CBroadcast_SetClipDetails_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Get details for Broadcast Clips"]
// @@protoc_insertion_point(message:CBroadcast_GetClipDetails_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_GetClipDetails_Request {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_GetClipDetails_Request.broadcast_clip_id)
    pub broadcast_clip_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_GetClipDetails_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_GetClipDetails_Request {
    fn default() -> &'a CBroadcast_GetClipDetails_Request {
        <CBroadcast_GetClipDetails_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_GetClipDetails_Request {
    pub fn new() -> CBroadcast_GetClipDetails_Request {
        ::std::default::Default::default()
    }

    // optional uint64 broadcast_clip_id = 1;

    pub fn broadcast_clip_id(&self) -> u64 {
        self.broadcast_clip_id.unwrap_or(0)
    }

    pub fn clear_broadcast_clip_id(&mut self) {
        self.broadcast_clip_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_clip_id(&self) -> bool {
        self.broadcast_clip_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_clip_id(&mut self, v: u64) {
        self.broadcast_clip_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_GetClipDetails_Request {
    const NAME: &'static str = "CBroadcast_GetClipDetails_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.broadcast_clip_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_clip_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast_clip_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_GetClipDetails_Request {
        CBroadcast_GetClipDetails_Request::new()
    }

    fn clear(&mut self) {
        self.broadcast_clip_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_GetClipDetails_Request {
        static instance: CBroadcast_GetClipDetails_Request = CBroadcast_GetClipDetails_Request {
            broadcast_clip_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CBroadcast_GetClipDetails_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_GetClipDetails_Response {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_GetClipDetails_Response.broadcast_clip_id)
    pub broadcast_clip_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_GetClipDetails_Response.video_id)
    pub video_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_GetClipDetails_Response.channel_id)
    pub channel_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_GetClipDetails_Response.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CBroadcast_GetClipDetails_Response.accountid_broadcaster)
    pub accountid_broadcaster: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CBroadcast_GetClipDetails_Response.accountid_clipmaker)
    pub accountid_clipmaker: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CBroadcast_GetClipDetails_Response.video_description)
    pub video_description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBroadcast_GetClipDetails_Response.start_time)
    pub start_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CBroadcast_GetClipDetails_Response.length_milliseconds)
    pub length_milliseconds: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CBroadcast_GetClipDetails_Response.thumbnail_path)
    pub thumbnail_path: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_GetClipDetails_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_GetClipDetails_Response {
    fn default() -> &'a CBroadcast_GetClipDetails_Response {
        <CBroadcast_GetClipDetails_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_GetClipDetails_Response {
    pub fn new() -> CBroadcast_GetClipDetails_Response {
        ::std::default::Default::default()
    }

    // optional uint64 broadcast_clip_id = 1;

    pub fn broadcast_clip_id(&self) -> u64 {
        self.broadcast_clip_id.unwrap_or(0)
    }

    pub fn clear_broadcast_clip_id(&mut self) {
        self.broadcast_clip_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_clip_id(&self) -> bool {
        self.broadcast_clip_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_clip_id(&mut self, v: u64) {
        self.broadcast_clip_id = ::std::option::Option::Some(v);
    }

    // optional uint64 video_id = 2;

    pub fn video_id(&self) -> u64 {
        self.video_id.unwrap_or(0)
    }

    pub fn clear_video_id(&mut self) {
        self.video_id = ::std::option::Option::None;
    }

    pub fn has_video_id(&self) -> bool {
        self.video_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_video_id(&mut self, v: u64) {
        self.video_id = ::std::option::Option::Some(v);
    }

    // optional uint64 channel_id = 3;

    pub fn channel_id(&self) -> u64 {
        self.channel_id.unwrap_or(0)
    }

    pub fn clear_channel_id(&mut self) {
        self.channel_id = ::std::option::Option::None;
    }

    pub fn has_channel_id(&self) -> bool {
        self.channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: u64) {
        self.channel_id = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 4;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 accountid_broadcaster = 5;

    pub fn accountid_broadcaster(&self) -> u32 {
        self.accountid_broadcaster.unwrap_or(0)
    }

    pub fn clear_accountid_broadcaster(&mut self) {
        self.accountid_broadcaster = ::std::option::Option::None;
    }

    pub fn has_accountid_broadcaster(&self) -> bool {
        self.accountid_broadcaster.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid_broadcaster(&mut self, v: u32) {
        self.accountid_broadcaster = ::std::option::Option::Some(v);
    }

    // optional uint32 accountid_clipmaker = 6;

    pub fn accountid_clipmaker(&self) -> u32 {
        self.accountid_clipmaker.unwrap_or(0)
    }

    pub fn clear_accountid_clipmaker(&mut self) {
        self.accountid_clipmaker = ::std::option::Option::None;
    }

    pub fn has_accountid_clipmaker(&self) -> bool {
        self.accountid_clipmaker.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid_clipmaker(&mut self, v: u32) {
        self.accountid_clipmaker = ::std::option::Option::Some(v);
    }

    // optional string video_description = 7;

    pub fn video_description(&self) -> &str {
        match self.video_description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_video_description(&mut self) {
        self.video_description = ::std::option::Option::None;
    }

    pub fn has_video_description(&self) -> bool {
        self.video_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_video_description(&mut self, v: ::std::string::String) {
        self.video_description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_video_description(&mut self) -> &mut ::std::string::String {
        if self.video_description.is_none() {
            self.video_description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.video_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_video_description(&mut self) -> ::std::string::String {
        self.video_description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 start_time = 8;

    pub fn start_time(&self) -> u32 {
        self.start_time.unwrap_or(0)
    }

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: u32) {
        self.start_time = ::std::option::Option::Some(v);
    }

    // optional uint32 length_milliseconds = 9;

    pub fn length_milliseconds(&self) -> u32 {
        self.length_milliseconds.unwrap_or(0)
    }

    pub fn clear_length_milliseconds(&mut self) {
        self.length_milliseconds = ::std::option::Option::None;
    }

    pub fn has_length_milliseconds(&self) -> bool {
        self.length_milliseconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_length_milliseconds(&mut self, v: u32) {
        self.length_milliseconds = ::std::option::Option::Some(v);
    }

    // optional string thumbnail_path = 10;

    pub fn thumbnail_path(&self) -> &str {
        match self.thumbnail_path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_thumbnail_path(&mut self) {
        self.thumbnail_path = ::std::option::Option::None;
    }

    pub fn has_thumbnail_path(&self) -> bool {
        self.thumbnail_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnail_path(&mut self, v: ::std::string::String) {
        self.thumbnail_path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnail_path(&mut self) -> &mut ::std::string::String {
        if self.thumbnail_path.is_none() {
            self.thumbnail_path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.thumbnail_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnail_path(&mut self) -> ::std::string::String {
        self.thumbnail_path.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CBroadcast_GetClipDetails_Response {
    const NAME: &'static str = "CBroadcast_GetClipDetails_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.broadcast_clip_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.video_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.channel_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.accountid_broadcaster = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.accountid_clipmaker = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.video_description = ::std::option::Option::Some(is.read_string()?);
                },
                64 => {
                    self.start_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.length_milliseconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                82 => {
                    self.thumbnail_path = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_clip_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.video_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.channel_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.accountid_broadcaster {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.accountid_clipmaker {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.video_description.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.start_time {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.length_milliseconds {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.thumbnail_path.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast_clip_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.video_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.channel_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.accountid_broadcaster {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.accountid_clipmaker {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.video_description.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.start_time {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.length_milliseconds {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.thumbnail_path.as_ref() {
            os.write_string(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_GetClipDetails_Response {
        CBroadcast_GetClipDetails_Response::new()
    }

    fn clear(&mut self) {
        self.broadcast_clip_id = ::std::option::Option::None;
        self.video_id = ::std::option::Option::None;
        self.channel_id = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.accountid_broadcaster = ::std::option::Option::None;
        self.accountid_clipmaker = ::std::option::Option::None;
        self.video_description = ::std::option::Option::None;
        self.start_time = ::std::option::Option::None;
        self.length_milliseconds = ::std::option::Option::None;
        self.thumbnail_path = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_GetClipDetails_Response {
        static instance: CBroadcast_GetClipDetails_Response = CBroadcast_GetClipDetails_Response {
            broadcast_clip_id: ::std::option::Option::None,
            video_id: ::std::option::Option::None,
            channel_id: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            accountid_broadcaster: ::std::option::Option::None,
            accountid_clipmaker: ::std::option::Option::None,
            video_description: ::std::option::Option::None,
            start_time: ::std::option::Option::None,
            length_milliseconds: ::std::option::Option::None,
            thumbnail_path: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Sets RTMP broadcast info"]
// @@protoc_insertion_point(message:CBroadcast_SetRTMPInfo_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_SetRTMPInfo_Request {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_SetRTMPInfo_Request.broadcast_permission)
    pub broadcast_permission: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CBroadcast_SetRTMPInfo_Request.update_token)
    pub update_token: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CBroadcast_SetRTMPInfo_Request.broadcast_delay)
    pub broadcast_delay: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CBroadcast_SetRTMPInfo_Request.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CBroadcast_SetRTMPInfo_Request.required_app_id)
    pub required_app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CBroadcast_SetRTMPInfo_Request.broadcast_chat_permission)
    pub broadcast_chat_permission: ::std::option::Option<::protobuf::EnumOrUnknown<EBroadcastChatPermission>>,
    // @@protoc_insertion_point(field:CBroadcast_SetRTMPInfo_Request.broadcast_buffer)
    pub broadcast_buffer: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CBroadcast_SetRTMPInfo_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_SetRTMPInfo_Request.chat_rate_limit)
    pub chat_rate_limit: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CBroadcast_SetRTMPInfo_Request.enable_replay)
    pub enable_replay: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CBroadcast_SetRTMPInfo_Request.is_partner_chat_only)
    pub is_partner_chat_only: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CBroadcast_SetRTMPInfo_Request.wordban_list)
    pub wordban_list: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_SetRTMPInfo_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_SetRTMPInfo_Request {
    fn default() -> &'a CBroadcast_SetRTMPInfo_Request {
        <CBroadcast_SetRTMPInfo_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_SetRTMPInfo_Request {
    pub fn new() -> CBroadcast_SetRTMPInfo_Request {
        ::std::default::Default::default()
    }

    // optional int32 broadcast_permission = 1;

    pub fn broadcast_permission(&self) -> i32 {
        self.broadcast_permission.unwrap_or(0)
    }

    pub fn clear_broadcast_permission(&mut self) {
        self.broadcast_permission = ::std::option::Option::None;
    }

    pub fn has_broadcast_permission(&self) -> bool {
        self.broadcast_permission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_permission(&mut self, v: i32) {
        self.broadcast_permission = ::std::option::Option::Some(v);
    }

    // optional bool update_token = 2;

    pub fn update_token(&self) -> bool {
        self.update_token.unwrap_or(false)
    }

    pub fn clear_update_token(&mut self) {
        self.update_token = ::std::option::Option::None;
    }

    pub fn has_update_token(&self) -> bool {
        self.update_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_token(&mut self, v: bool) {
        self.update_token = ::std::option::Option::Some(v);
    }

    // optional int32 broadcast_delay = 3;

    pub fn broadcast_delay(&self) -> i32 {
        self.broadcast_delay.unwrap_or(0)
    }

    pub fn clear_broadcast_delay(&mut self) {
        self.broadcast_delay = ::std::option::Option::None;
    }

    pub fn has_broadcast_delay(&self) -> bool {
        self.broadcast_delay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_delay(&mut self, v: i32) {
        self.broadcast_delay = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 4;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 required_app_id = 5;

    pub fn required_app_id(&self) -> u32 {
        self.required_app_id.unwrap_or(0)
    }

    pub fn clear_required_app_id(&mut self) {
        self.required_app_id = ::std::option::Option::None;
    }

    pub fn has_required_app_id(&self) -> bool {
        self.required_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_required_app_id(&mut self, v: u32) {
        self.required_app_id = ::std::option::Option::Some(v);
    }

    // optional .EBroadcastChatPermission broadcast_chat_permission = 6;

    pub fn broadcast_chat_permission(&self) -> EBroadcastChatPermission {
        match self.broadcast_chat_permission {
            Some(e) => e.enum_value_or(EBroadcastChatPermission::k_EBroadcastChatPermissionPublic),
            None => EBroadcastChatPermission::k_EBroadcastChatPermissionPublic,
        }
    }

    pub fn clear_broadcast_chat_permission(&mut self) {
        self.broadcast_chat_permission = ::std::option::Option::None;
    }

    pub fn has_broadcast_chat_permission(&self) -> bool {
        self.broadcast_chat_permission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_chat_permission(&mut self, v: EBroadcastChatPermission) {
        self.broadcast_chat_permission = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 broadcast_buffer = 7;

    pub fn broadcast_buffer(&self) -> i32 {
        self.broadcast_buffer.unwrap_or(0)
    }

    pub fn clear_broadcast_buffer(&mut self) {
        self.broadcast_buffer = ::std::option::Option::None;
    }

    pub fn has_broadcast_buffer(&self) -> bool {
        self.broadcast_buffer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_buffer(&mut self, v: i32) {
        self.broadcast_buffer = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 8;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional uint32 chat_rate_limit = 9;

    pub fn chat_rate_limit(&self) -> u32 {
        self.chat_rate_limit.unwrap_or(0)
    }

    pub fn clear_chat_rate_limit(&mut self) {
        self.chat_rate_limit = ::std::option::Option::None;
    }

    pub fn has_chat_rate_limit(&self) -> bool {
        self.chat_rate_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_rate_limit(&mut self, v: u32) {
        self.chat_rate_limit = ::std::option::Option::Some(v);
    }

    // optional bool enable_replay = 10;

    pub fn enable_replay(&self) -> bool {
        self.enable_replay.unwrap_or(false)
    }

    pub fn clear_enable_replay(&mut self) {
        self.enable_replay = ::std::option::Option::None;
    }

    pub fn has_enable_replay(&self) -> bool {
        self.enable_replay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_replay(&mut self, v: bool) {
        self.enable_replay = ::std::option::Option::Some(v);
    }

    // optional bool is_partner_chat_only = 11;

    pub fn is_partner_chat_only(&self) -> bool {
        self.is_partner_chat_only.unwrap_or(false)
    }

    pub fn clear_is_partner_chat_only(&mut self) {
        self.is_partner_chat_only = ::std::option::Option::None;
    }

    pub fn has_is_partner_chat_only(&self) -> bool {
        self.is_partner_chat_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_partner_chat_only(&mut self, v: bool) {
        self.is_partner_chat_only = ::std::option::Option::Some(v);
    }

    // optional string wordban_list = 12;

    pub fn wordban_list(&self) -> &str {
        match self.wordban_list.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_wordban_list(&mut self) {
        self.wordban_list = ::std::option::Option::None;
    }

    pub fn has_wordban_list(&self) -> bool {
        self.wordban_list.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wordban_list(&mut self, v: ::std::string::String) {
        self.wordban_list = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_wordban_list(&mut self) -> &mut ::std::string::String {
        if self.wordban_list.is_none() {
            self.wordban_list = ::std::option::Option::Some(::std::string::String::new());
        }
        self.wordban_list.as_mut().unwrap()
    }

    // Take field
    pub fn take_wordban_list(&mut self) -> ::std::string::String {
        self.wordban_list.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CBroadcast_SetRTMPInfo_Request {
    const NAME: &'static str = "CBroadcast_SetRTMPInfo_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.broadcast_permission = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.update_token = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.broadcast_delay = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.required_app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.broadcast_chat_permission = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                56 => {
                    self.broadcast_buffer = ::std::option::Option::Some(is.read_int32()?);
                },
                65 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                72 => {
                    self.chat_rate_limit = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.enable_replay = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.is_partner_chat_only = ::std::option::Option::Some(is.read_bool()?);
                },
                98 => {
                    self.wordban_list = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_permission {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.update_token {
            my_size += 1 + 1;
        }
        if let Some(v) = self.broadcast_delay {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.required_app_id {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.broadcast_chat_permission {
            my_size += ::protobuf::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.broadcast_buffer {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.chat_rate_limit {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.enable_replay {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_partner_chat_only {
            my_size += 1 + 1;
        }
        if let Some(v) = self.wordban_list.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast_permission {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.update_token {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.broadcast_delay {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.required_app_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.broadcast_chat_permission {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.broadcast_buffer {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(8, v)?;
        }
        if let Some(v) = self.chat_rate_limit {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.enable_replay {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.is_partner_chat_only {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.wordban_list.as_ref() {
            os.write_string(12, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_SetRTMPInfo_Request {
        CBroadcast_SetRTMPInfo_Request::new()
    }

    fn clear(&mut self) {
        self.broadcast_permission = ::std::option::Option::None;
        self.update_token = ::std::option::Option::None;
        self.broadcast_delay = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.required_app_id = ::std::option::Option::None;
        self.broadcast_chat_permission = ::std::option::Option::None;
        self.broadcast_buffer = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.chat_rate_limit = ::std::option::Option::None;
        self.enable_replay = ::std::option::Option::None;
        self.is_partner_chat_only = ::std::option::Option::None;
        self.wordban_list = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_SetRTMPInfo_Request {
        static instance: CBroadcast_SetRTMPInfo_Request = CBroadcast_SetRTMPInfo_Request {
            broadcast_permission: ::std::option::Option::None,
            update_token: ::std::option::Option::None,
            broadcast_delay: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            required_app_id: ::std::option::Option::None,
            broadcast_chat_permission: ::std::option::Option::None,
            broadcast_buffer: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            chat_rate_limit: ::std::option::Option::None,
            enable_replay: ::std::option::Option::None,
            is_partner_chat_only: ::std::option::Option::None,
            wordban_list: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CBroadcast_SetRTMPInfo_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_SetRTMPInfo_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_SetRTMPInfo_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_SetRTMPInfo_Response {
    fn default() -> &'a CBroadcast_SetRTMPInfo_Response {
        <CBroadcast_SetRTMPInfo_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_SetRTMPInfo_Response {
    pub fn new() -> CBroadcast_SetRTMPInfo_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CBroadcast_SetRTMPInfo_Response {
    const NAME: &'static str = "CBroadcast_SetRTMPInfo_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_SetRTMPInfo_Response {
        CBroadcast_SetRTMPInfo_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_SetRTMPInfo_Response {
        static instance: CBroadcast_SetRTMPInfo_Response = CBroadcast_SetRTMPInfo_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Gets RTMP broadcast info"]
// @@protoc_insertion_point(message:CBroadcast_GetRTMPInfo_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_GetRTMPInfo_Request {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_GetRTMPInfo_Request.ip)
    pub ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CBroadcast_GetRTMPInfo_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_GetRTMPInfo_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_GetRTMPInfo_Request {
    fn default() -> &'a CBroadcast_GetRTMPInfo_Request {
        <CBroadcast_GetRTMPInfo_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_GetRTMPInfo_Request {
    pub fn new() -> CBroadcast_GetRTMPInfo_Request {
        ::std::default::Default::default()
    }

    // optional uint32 ip = 1;

    pub fn ip(&self) -> u32 {
        self.ip.unwrap_or(0)
    }

    pub fn clear_ip(&mut self) {
        self.ip = ::std::option::Option::None;
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: u32) {
        self.ip = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 2;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_GetRTMPInfo_Request {
    const NAME: &'static str = "CBroadcast_GetRTMPInfo_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ip {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ip {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_GetRTMPInfo_Request {
        CBroadcast_GetRTMPInfo_Request::new()
    }

    fn clear(&mut self) {
        self.ip = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_GetRTMPInfo_Request {
        static instance: CBroadcast_GetRTMPInfo_Request = CBroadcast_GetRTMPInfo_Request {
            ip: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CBroadcast_GetRTMPInfo_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_GetRTMPInfo_Response {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_GetRTMPInfo_Response.broadcast_permission)
    pub broadcast_permission: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CBroadcast_GetRTMPInfo_Response.rtmp_host)
    pub rtmp_host: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBroadcast_GetRTMPInfo_Response.rtmp_token)
    pub rtmp_token: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBroadcast_GetRTMPInfo_Response.broadcast_delay)
    pub broadcast_delay: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CBroadcast_GetRTMPInfo_Response.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CBroadcast_GetRTMPInfo_Response.required_app_id)
    pub required_app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CBroadcast_GetRTMPInfo_Response.broadcast_chat_permission)
    pub broadcast_chat_permission: ::std::option::Option<::protobuf::EnumOrUnknown<EBroadcastChatPermission>>,
    // @@protoc_insertion_point(field:CBroadcast_GetRTMPInfo_Response.broadcast_buffer)
    pub broadcast_buffer: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CBroadcast_GetRTMPInfo_Response.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_GetRTMPInfo_Response.chat_rate_limit)
    pub chat_rate_limit: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CBroadcast_GetRTMPInfo_Response.enable_replay)
    pub enable_replay: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CBroadcast_GetRTMPInfo_Response.is_partner_chat_only)
    pub is_partner_chat_only: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CBroadcast_GetRTMPInfo_Response.wordban_list)
    pub wordban_list: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_GetRTMPInfo_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_GetRTMPInfo_Response {
    fn default() -> &'a CBroadcast_GetRTMPInfo_Response {
        <CBroadcast_GetRTMPInfo_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_GetRTMPInfo_Response {
    pub fn new() -> CBroadcast_GetRTMPInfo_Response {
        ::std::default::Default::default()
    }

    // optional int32 broadcast_permission = 1;

    pub fn broadcast_permission(&self) -> i32 {
        self.broadcast_permission.unwrap_or(0)
    }

    pub fn clear_broadcast_permission(&mut self) {
        self.broadcast_permission = ::std::option::Option::None;
    }

    pub fn has_broadcast_permission(&self) -> bool {
        self.broadcast_permission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_permission(&mut self, v: i32) {
        self.broadcast_permission = ::std::option::Option::Some(v);
    }

    // optional string rtmp_host = 2;

    pub fn rtmp_host(&self) -> &str {
        match self.rtmp_host.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_rtmp_host(&mut self) {
        self.rtmp_host = ::std::option::Option::None;
    }

    pub fn has_rtmp_host(&self) -> bool {
        self.rtmp_host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtmp_host(&mut self, v: ::std::string::String) {
        self.rtmp_host = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rtmp_host(&mut self) -> &mut ::std::string::String {
        if self.rtmp_host.is_none() {
            self.rtmp_host = ::std::option::Option::Some(::std::string::String::new());
        }
        self.rtmp_host.as_mut().unwrap()
    }

    // Take field
    pub fn take_rtmp_host(&mut self) -> ::std::string::String {
        self.rtmp_host.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string rtmp_token = 3;

    pub fn rtmp_token(&self) -> &str {
        match self.rtmp_token.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_rtmp_token(&mut self) {
        self.rtmp_token = ::std::option::Option::None;
    }

    pub fn has_rtmp_token(&self) -> bool {
        self.rtmp_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtmp_token(&mut self, v: ::std::string::String) {
        self.rtmp_token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rtmp_token(&mut self) -> &mut ::std::string::String {
        if self.rtmp_token.is_none() {
            self.rtmp_token = ::std::option::Option::Some(::std::string::String::new());
        }
        self.rtmp_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_rtmp_token(&mut self) -> ::std::string::String {
        self.rtmp_token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 broadcast_delay = 4;

    pub fn broadcast_delay(&self) -> i32 {
        self.broadcast_delay.unwrap_or(0)
    }

    pub fn clear_broadcast_delay(&mut self) {
        self.broadcast_delay = ::std::option::Option::None;
    }

    pub fn has_broadcast_delay(&self) -> bool {
        self.broadcast_delay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_delay(&mut self, v: i32) {
        self.broadcast_delay = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 5;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 required_app_id = 6;

    pub fn required_app_id(&self) -> u32 {
        self.required_app_id.unwrap_or(0)
    }

    pub fn clear_required_app_id(&mut self) {
        self.required_app_id = ::std::option::Option::None;
    }

    pub fn has_required_app_id(&self) -> bool {
        self.required_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_required_app_id(&mut self, v: u32) {
        self.required_app_id = ::std::option::Option::Some(v);
    }

    // optional .EBroadcastChatPermission broadcast_chat_permission = 7;

    pub fn broadcast_chat_permission(&self) -> EBroadcastChatPermission {
        match self.broadcast_chat_permission {
            Some(e) => e.enum_value_or(EBroadcastChatPermission::k_EBroadcastChatPermissionPublic),
            None => EBroadcastChatPermission::k_EBroadcastChatPermissionPublic,
        }
    }

    pub fn clear_broadcast_chat_permission(&mut self) {
        self.broadcast_chat_permission = ::std::option::Option::None;
    }

    pub fn has_broadcast_chat_permission(&self) -> bool {
        self.broadcast_chat_permission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_chat_permission(&mut self, v: EBroadcastChatPermission) {
        self.broadcast_chat_permission = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 broadcast_buffer = 8;

    pub fn broadcast_buffer(&self) -> i32 {
        self.broadcast_buffer.unwrap_or(0)
    }

    pub fn clear_broadcast_buffer(&mut self) {
        self.broadcast_buffer = ::std::option::Option::None;
    }

    pub fn has_broadcast_buffer(&self) -> bool {
        self.broadcast_buffer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_buffer(&mut self, v: i32) {
        self.broadcast_buffer = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 9;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional uint32 chat_rate_limit = 10;

    pub fn chat_rate_limit(&self) -> u32 {
        self.chat_rate_limit.unwrap_or(0)
    }

    pub fn clear_chat_rate_limit(&mut self) {
        self.chat_rate_limit = ::std::option::Option::None;
    }

    pub fn has_chat_rate_limit(&self) -> bool {
        self.chat_rate_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_rate_limit(&mut self, v: u32) {
        self.chat_rate_limit = ::std::option::Option::Some(v);
    }

    // optional bool enable_replay = 11;

    pub fn enable_replay(&self) -> bool {
        self.enable_replay.unwrap_or(false)
    }

    pub fn clear_enable_replay(&mut self) {
        self.enable_replay = ::std::option::Option::None;
    }

    pub fn has_enable_replay(&self) -> bool {
        self.enable_replay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_replay(&mut self, v: bool) {
        self.enable_replay = ::std::option::Option::Some(v);
    }

    // optional bool is_partner_chat_only = 12;

    pub fn is_partner_chat_only(&self) -> bool {
        self.is_partner_chat_only.unwrap_or(false)
    }

    pub fn clear_is_partner_chat_only(&mut self) {
        self.is_partner_chat_only = ::std::option::Option::None;
    }

    pub fn has_is_partner_chat_only(&self) -> bool {
        self.is_partner_chat_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_partner_chat_only(&mut self, v: bool) {
        self.is_partner_chat_only = ::std::option::Option::Some(v);
    }

    // optional string wordban_list = 13;

    pub fn wordban_list(&self) -> &str {
        match self.wordban_list.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_wordban_list(&mut self) {
        self.wordban_list = ::std::option::Option::None;
    }

    pub fn has_wordban_list(&self) -> bool {
        self.wordban_list.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wordban_list(&mut self, v: ::std::string::String) {
        self.wordban_list = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_wordban_list(&mut self) -> &mut ::std::string::String {
        if self.wordban_list.is_none() {
            self.wordban_list = ::std::option::Option::Some(::std::string::String::new());
        }
        self.wordban_list.as_mut().unwrap()
    }

    // Take field
    pub fn take_wordban_list(&mut self) -> ::std::string::String {
        self.wordban_list.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CBroadcast_GetRTMPInfo_Response {
    const NAME: &'static str = "CBroadcast_GetRTMPInfo_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.broadcast_permission = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.rtmp_host = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.rtmp_token = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.broadcast_delay = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.required_app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.broadcast_chat_permission = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                64 => {
                    self.broadcast_buffer = ::std::option::Option::Some(is.read_int32()?);
                },
                73 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                80 => {
                    self.chat_rate_limit = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.enable_replay = ::std::option::Option::Some(is.read_bool()?);
                },
                96 => {
                    self.is_partner_chat_only = ::std::option::Option::Some(is.read_bool()?);
                },
                106 => {
                    self.wordban_list = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_permission {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.rtmp_host.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.rtmp_token.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.broadcast_delay {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.required_app_id {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.broadcast_chat_permission {
            my_size += ::protobuf::rt::int32_size(7, v.value());
        }
        if let Some(v) = self.broadcast_buffer {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.chat_rate_limit {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.enable_replay {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_partner_chat_only {
            my_size += 1 + 1;
        }
        if let Some(v) = self.wordban_list.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast_permission {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.rtmp_host.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.rtmp_token.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.broadcast_delay {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.required_app_id {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.broadcast_chat_permission {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.broadcast_buffer {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(9, v)?;
        }
        if let Some(v) = self.chat_rate_limit {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.enable_replay {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.is_partner_chat_only {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.wordban_list.as_ref() {
            os.write_string(13, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_GetRTMPInfo_Response {
        CBroadcast_GetRTMPInfo_Response::new()
    }

    fn clear(&mut self) {
        self.broadcast_permission = ::std::option::Option::None;
        self.rtmp_host = ::std::option::Option::None;
        self.rtmp_token = ::std::option::Option::None;
        self.broadcast_delay = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.required_app_id = ::std::option::Option::None;
        self.broadcast_chat_permission = ::std::option::Option::None;
        self.broadcast_buffer = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.chat_rate_limit = ::std::option::Option::None;
        self.enable_replay = ::std::option::Option::None;
        self.is_partner_chat_only = ::std::option::Option::None;
        self.wordban_list = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_GetRTMPInfo_Response {
        static instance: CBroadcast_GetRTMPInfo_Response = CBroadcast_GetRTMPInfo_Response {
            broadcast_permission: ::std::option::Option::None,
            rtmp_host: ::std::option::Option::None,
            rtmp_token: ::std::option::Option::None,
            broadcast_delay: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            required_app_id: ::std::option::Option::None,
            broadcast_chat_permission: ::std::option::Option::None,
            broadcast_buffer: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            chat_rate_limit: ::std::option::Option::None,
            enable_replay: ::std::option::Option::None,
            is_partner_chat_only: ::std::option::Option::None,
            wordban_list: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Notification from client to server with the client's TURN server"]
// @@protoc_insertion_point(message:CBroadcast_WebRTCHaveTURNServer_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_WebRTCHaveTURNServer_Notification {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_WebRTCHaveTURNServer_Notification.broadcast_session_id)
    pub broadcast_session_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_WebRTCHaveTURNServer_Notification.turn_server)
    pub turn_server: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_WebRTCHaveTURNServer_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_WebRTCHaveTURNServer_Notification {
    fn default() -> &'a CBroadcast_WebRTCHaveTURNServer_Notification {
        <CBroadcast_WebRTCHaveTURNServer_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_WebRTCHaveTURNServer_Notification {
    pub fn new() -> CBroadcast_WebRTCHaveTURNServer_Notification {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_session_id = 1;

    pub fn broadcast_session_id(&self) -> u64 {
        self.broadcast_session_id.unwrap_or(0)
    }

    pub fn clear_broadcast_session_id(&mut self) {
        self.broadcast_session_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_session_id(&self) -> bool {
        self.broadcast_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_session_id(&mut self, v: u64) {
        self.broadcast_session_id = ::std::option::Option::Some(v);
    }

    // optional string turn_server = 2;

    pub fn turn_server(&self) -> &str {
        match self.turn_server.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_turn_server(&mut self) {
        self.turn_server = ::std::option::Option::None;
    }

    pub fn has_turn_server(&self) -> bool {
        self.turn_server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_turn_server(&mut self, v: ::std::string::String) {
        self.turn_server = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_turn_server(&mut self) -> &mut ::std::string::String {
        if self.turn_server.is_none() {
            self.turn_server = ::std::option::Option::Some(::std::string::String::new());
        }
        self.turn_server.as_mut().unwrap()
    }

    // Take field
    pub fn take_turn_server(&mut self) -> ::std::string::String {
        self.turn_server.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CBroadcast_WebRTCHaveTURNServer_Notification {
    const NAME: &'static str = "CBroadcast_WebRTCHaveTURNServer_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_session_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    self.turn_server = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_session_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.turn_server.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast_session_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.turn_server.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_WebRTCHaveTURNServer_Notification {
        CBroadcast_WebRTCHaveTURNServer_Notification::new()
    }

    fn clear(&mut self) {
        self.broadcast_session_id = ::std::option::Option::None;
        self.turn_server = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_WebRTCHaveTURNServer_Notification {
        static instance: CBroadcast_WebRTCHaveTURNServer_Notification = CBroadcast_WebRTCHaveTURNServer_Notification {
            broadcast_session_id: ::std::option::Option::None,
            turn_server: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Notify the server that a WebRTC session has been created by the host"]
// @@protoc_insertion_point(message:CBroadcast_WebRTCStartResult_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_WebRTCStartResult_Request {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_WebRTCStartResult_Request.webrtc_session_id)
    pub webrtc_session_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_WebRTCStartResult_Request.started)
    pub started: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CBroadcast_WebRTCStartResult_Request.offer)
    pub offer: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBroadcast_WebRTCStartResult_Request.resolution_x)
    pub resolution_x: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CBroadcast_WebRTCStartResult_Request.resolution_y)
    pub resolution_y: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CBroadcast_WebRTCStartResult_Request.fps)
    pub fps: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_WebRTCStartResult_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_WebRTCStartResult_Request {
    fn default() -> &'a CBroadcast_WebRTCStartResult_Request {
        <CBroadcast_WebRTCStartResult_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_WebRTCStartResult_Request {
    pub fn new() -> CBroadcast_WebRTCStartResult_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 webrtc_session_id = 1;

    pub fn webrtc_session_id(&self) -> u64 {
        self.webrtc_session_id.unwrap_or(0)
    }

    pub fn clear_webrtc_session_id(&mut self) {
        self.webrtc_session_id = ::std::option::Option::None;
    }

    pub fn has_webrtc_session_id(&self) -> bool {
        self.webrtc_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_webrtc_session_id(&mut self, v: u64) {
        self.webrtc_session_id = ::std::option::Option::Some(v);
    }

    // optional bool started = 2;

    pub fn started(&self) -> bool {
        self.started.unwrap_or(false)
    }

    pub fn clear_started(&mut self) {
        self.started = ::std::option::Option::None;
    }

    pub fn has_started(&self) -> bool {
        self.started.is_some()
    }

    // Param is passed by value, moved
    pub fn set_started(&mut self, v: bool) {
        self.started = ::std::option::Option::Some(v);
    }

    // optional string offer = 3;

    pub fn offer(&self) -> &str {
        match self.offer.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_offer(&mut self) {
        self.offer = ::std::option::Option::None;
    }

    pub fn has_offer(&self) -> bool {
        self.offer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offer(&mut self, v: ::std::string::String) {
        self.offer = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_offer(&mut self) -> &mut ::std::string::String {
        if self.offer.is_none() {
            self.offer = ::std::option::Option::Some(::std::string::String::new());
        }
        self.offer.as_mut().unwrap()
    }

    // Take field
    pub fn take_offer(&mut self) -> ::std::string::String {
        self.offer.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 resolution_x = 4;

    pub fn resolution_x(&self) -> u32 {
        self.resolution_x.unwrap_or(0)
    }

    pub fn clear_resolution_x(&mut self) {
        self.resolution_x = ::std::option::Option::None;
    }

    pub fn has_resolution_x(&self) -> bool {
        self.resolution_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resolution_x(&mut self, v: u32) {
        self.resolution_x = ::std::option::Option::Some(v);
    }

    // optional uint32 resolution_y = 5;

    pub fn resolution_y(&self) -> u32 {
        self.resolution_y.unwrap_or(0)
    }

    pub fn clear_resolution_y(&mut self) {
        self.resolution_y = ::std::option::Option::None;
    }

    pub fn has_resolution_y(&self) -> bool {
        self.resolution_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resolution_y(&mut self, v: u32) {
        self.resolution_y = ::std::option::Option::Some(v);
    }

    // optional uint32 fps = 6;

    pub fn fps(&self) -> u32 {
        self.fps.unwrap_or(0)
    }

    pub fn clear_fps(&mut self) {
        self.fps = ::std::option::Option::None;
    }

    pub fn has_fps(&self) -> bool {
        self.fps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fps(&mut self, v: u32) {
        self.fps = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_WebRTCStartResult_Request {
    const NAME: &'static str = "CBroadcast_WebRTCStartResult_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.webrtc_session_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.started = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.offer = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.resolution_x = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.resolution_y = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.fps = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.webrtc_session_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.started {
            my_size += 1 + 1;
        }
        if let Some(v) = self.offer.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.resolution_x {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.resolution_y {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.fps {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.webrtc_session_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.started {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.offer.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.resolution_x {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.resolution_y {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.fps {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_WebRTCStartResult_Request {
        CBroadcast_WebRTCStartResult_Request::new()
    }

    fn clear(&mut self) {
        self.webrtc_session_id = ::std::option::Option::None;
        self.started = ::std::option::Option::None;
        self.offer = ::std::option::Option::None;
        self.resolution_x = ::std::option::Option::None;
        self.resolution_y = ::std::option::Option::None;
        self.fps = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_WebRTCStartResult_Request {
        static instance: CBroadcast_WebRTCStartResult_Request = CBroadcast_WebRTCStartResult_Request {
            webrtc_session_id: ::std::option::Option::None,
            started: ::std::option::Option::None,
            offer: ::std::option::Option::None,
            resolution_x: ::std::option::Option::None,
            resolution_y: ::std::option::Option::None,
            fps: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CBroadcast_WebRTCStartResult_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_WebRTCStartResult_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_WebRTCStartResult_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_WebRTCStartResult_Response {
    fn default() -> &'a CBroadcast_WebRTCStartResult_Response {
        <CBroadcast_WebRTCStartResult_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_WebRTCStartResult_Response {
    pub fn new() -> CBroadcast_WebRTCStartResult_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CBroadcast_WebRTCStartResult_Response {
    const NAME: &'static str = "CBroadcast_WebRTCStartResult_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_WebRTCStartResult_Response {
        CBroadcast_WebRTCStartResult_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_WebRTCStartResult_Response {
        static instance: CBroadcast_WebRTCStartResult_Response = CBroadcast_WebRTCStartResult_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Notify the server that a WebRTC session has been stopped by the host"]
// @@protoc_insertion_point(message:CBroadcast_WebRTCStopped_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_WebRTCStopped_Request {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_WebRTCStopped_Request.webrtc_session_id)
    pub webrtc_session_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_WebRTCStopped_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_WebRTCStopped_Request {
    fn default() -> &'a CBroadcast_WebRTCStopped_Request {
        <CBroadcast_WebRTCStopped_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_WebRTCStopped_Request {
    pub fn new() -> CBroadcast_WebRTCStopped_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 webrtc_session_id = 1;

    pub fn webrtc_session_id(&self) -> u64 {
        self.webrtc_session_id.unwrap_or(0)
    }

    pub fn clear_webrtc_session_id(&mut self) {
        self.webrtc_session_id = ::std::option::Option::None;
    }

    pub fn has_webrtc_session_id(&self) -> bool {
        self.webrtc_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_webrtc_session_id(&mut self, v: u64) {
        self.webrtc_session_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_WebRTCStopped_Request {
    const NAME: &'static str = "CBroadcast_WebRTCStopped_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.webrtc_session_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.webrtc_session_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.webrtc_session_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_WebRTCStopped_Request {
        CBroadcast_WebRTCStopped_Request::new()
    }

    fn clear(&mut self) {
        self.webrtc_session_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_WebRTCStopped_Request {
        static instance: CBroadcast_WebRTCStopped_Request = CBroadcast_WebRTCStopped_Request {
            webrtc_session_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CBroadcast_WebRTCStopped_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_WebRTCStopped_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_WebRTCStopped_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_WebRTCStopped_Response {
    fn default() -> &'a CBroadcast_WebRTCStopped_Response {
        <CBroadcast_WebRTCStopped_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_WebRTCStopped_Response {
    pub fn new() -> CBroadcast_WebRTCStopped_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CBroadcast_WebRTCStopped_Response {
    const NAME: &'static str = "CBroadcast_WebRTCStopped_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_WebRTCStopped_Response {
        CBroadcast_WebRTCStopped_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_WebRTCStopped_Response {
        static instance: CBroadcast_WebRTCStopped_Response = CBroadcast_WebRTCStopped_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Notify the server that a WebRTC session has been created by the viewer"]
// @@protoc_insertion_point(message:CBroadcast_WebRTCSetAnswer_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_WebRTCSetAnswer_Request {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_WebRTCSetAnswer_Request.broadcaster_steamid)
    pub broadcaster_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_WebRTCSetAnswer_Request.webrtc_session_id)
    pub webrtc_session_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_WebRTCSetAnswer_Request.answer)
    pub answer: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_WebRTCSetAnswer_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_WebRTCSetAnswer_Request {
    fn default() -> &'a CBroadcast_WebRTCSetAnswer_Request {
        <CBroadcast_WebRTCSetAnswer_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_WebRTCSetAnswer_Request {
    pub fn new() -> CBroadcast_WebRTCSetAnswer_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcaster_steamid = 1;

    pub fn broadcaster_steamid(&self) -> u64 {
        self.broadcaster_steamid.unwrap_or(0)
    }

    pub fn clear_broadcaster_steamid(&mut self) {
        self.broadcaster_steamid = ::std::option::Option::None;
    }

    pub fn has_broadcaster_steamid(&self) -> bool {
        self.broadcaster_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcaster_steamid(&mut self, v: u64) {
        self.broadcaster_steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 webrtc_session_id = 2;

    pub fn webrtc_session_id(&self) -> u64 {
        self.webrtc_session_id.unwrap_or(0)
    }

    pub fn clear_webrtc_session_id(&mut self) {
        self.webrtc_session_id = ::std::option::Option::None;
    }

    pub fn has_webrtc_session_id(&self) -> bool {
        self.webrtc_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_webrtc_session_id(&mut self, v: u64) {
        self.webrtc_session_id = ::std::option::Option::Some(v);
    }

    // optional string answer = 3;

    pub fn answer(&self) -> &str {
        match self.answer.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_answer(&mut self) {
        self.answer = ::std::option::Option::None;
    }

    pub fn has_answer(&self) -> bool {
        self.answer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_answer(&mut self, v: ::std::string::String) {
        self.answer = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_answer(&mut self) -> &mut ::std::string::String {
        if self.answer.is_none() {
            self.answer = ::std::option::Option::Some(::std::string::String::new());
        }
        self.answer.as_mut().unwrap()
    }

    // Take field
    pub fn take_answer(&mut self) -> ::std::string::String {
        self.answer.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CBroadcast_WebRTCSetAnswer_Request {
    const NAME: &'static str = "CBroadcast_WebRTCSetAnswer_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcaster_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.webrtc_session_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    self.answer = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcaster_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.webrtc_session_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.answer.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcaster_steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.webrtc_session_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.answer.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_WebRTCSetAnswer_Request {
        CBroadcast_WebRTCSetAnswer_Request::new()
    }

    fn clear(&mut self) {
        self.broadcaster_steamid = ::std::option::Option::None;
        self.webrtc_session_id = ::std::option::Option::None;
        self.answer = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_WebRTCSetAnswer_Request {
        static instance: CBroadcast_WebRTCSetAnswer_Request = CBroadcast_WebRTCSetAnswer_Request {
            broadcaster_steamid: ::std::option::Option::None,
            webrtc_session_id: ::std::option::Option::None,
            answer: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CBroadcast_WebRTCSetAnswer_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_WebRTCSetAnswer_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_WebRTCSetAnswer_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_WebRTCSetAnswer_Response {
    fn default() -> &'a CBroadcast_WebRTCSetAnswer_Response {
        <CBroadcast_WebRTCSetAnswer_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_WebRTCSetAnswer_Response {
    pub fn new() -> CBroadcast_WebRTCSetAnswer_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CBroadcast_WebRTCSetAnswer_Response {
    const NAME: &'static str = "CBroadcast_WebRTCSetAnswer_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_WebRTCSetAnswer_Response {
        CBroadcast_WebRTCSetAnswer_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_WebRTCSetAnswer_Response {
        static instance: CBroadcast_WebRTCSetAnswer_Response = CBroadcast_WebRTCSetAnswer_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Lookup the best TURN server for this client"]
// @@protoc_insertion_point(message:CBroadcast_WebRTCLookupTURNServer_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_WebRTCLookupTURNServer_Request {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_WebRTCLookupTURNServer_Request.cellid)
    pub cellid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_WebRTCLookupTURNServer_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_WebRTCLookupTURNServer_Request {
    fn default() -> &'a CBroadcast_WebRTCLookupTURNServer_Request {
        <CBroadcast_WebRTCLookupTURNServer_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_WebRTCLookupTURNServer_Request {
    pub fn new() -> CBroadcast_WebRTCLookupTURNServer_Request {
        ::std::default::Default::default()
    }

    // optional uint32 cellid = 1;

    pub fn cellid(&self) -> u32 {
        self.cellid.unwrap_or(0)
    }

    pub fn clear_cellid(&mut self) {
        self.cellid = ::std::option::Option::None;
    }

    pub fn has_cellid(&self) -> bool {
        self.cellid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cellid(&mut self, v: u32) {
        self.cellid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_WebRTCLookupTURNServer_Request {
    const NAME: &'static str = "CBroadcast_WebRTCLookupTURNServer_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.cellid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cellid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cellid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_WebRTCLookupTURNServer_Request {
        CBroadcast_WebRTCLookupTURNServer_Request::new()
    }

    fn clear(&mut self) {
        self.cellid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_WebRTCLookupTURNServer_Request {
        static instance: CBroadcast_WebRTCLookupTURNServer_Request = CBroadcast_WebRTCLookupTURNServer_Request {
            cellid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CBroadcast_WebRTCLookupTURNServer_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_WebRTCLookupTURNServer_Response {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_WebRTCLookupTURNServer_Response.turn_server)
    pub turn_server: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_WebRTCLookupTURNServer_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_WebRTCLookupTURNServer_Response {
    fn default() -> &'a CBroadcast_WebRTCLookupTURNServer_Response {
        <CBroadcast_WebRTCLookupTURNServer_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_WebRTCLookupTURNServer_Response {
    pub fn new() -> CBroadcast_WebRTCLookupTURNServer_Response {
        ::std::default::Default::default()
    }

    // optional string turn_server = 1;

    pub fn turn_server(&self) -> &str {
        match self.turn_server.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_turn_server(&mut self) {
        self.turn_server = ::std::option::Option::None;
    }

    pub fn has_turn_server(&self) -> bool {
        self.turn_server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_turn_server(&mut self, v: ::std::string::String) {
        self.turn_server = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_turn_server(&mut self) -> &mut ::std::string::String {
        if self.turn_server.is_none() {
            self.turn_server = ::std::option::Option::Some(::std::string::String::new());
        }
        self.turn_server.as_mut().unwrap()
    }

    // Take field
    pub fn take_turn_server(&mut self) -> ::std::string::String {
        self.turn_server.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CBroadcast_WebRTCLookupTURNServer_Response {
    const NAME: &'static str = "CBroadcast_WebRTCLookupTURNServer_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.turn_server = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.turn_server.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.turn_server.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_WebRTCLookupTURNServer_Response {
        CBroadcast_WebRTCLookupTURNServer_Response::new()
    }

    fn clear(&mut self) {
        self.turn_server = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_WebRTCLookupTURNServer_Response {
        static instance: CBroadcast_WebRTCLookupTURNServer_Response = CBroadcast_WebRTCLookupTURNServer_Response {
            turn_server: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CBroadcast_WebRTC_Candidate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_WebRTC_Candidate {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_WebRTC_Candidate.sdp_mid)
    pub sdp_mid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBroadcast_WebRTC_Candidate.sdp_mline_index)
    pub sdp_mline_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CBroadcast_WebRTC_Candidate.candidate)
    pub candidate: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_WebRTC_Candidate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_WebRTC_Candidate {
    fn default() -> &'a CBroadcast_WebRTC_Candidate {
        <CBroadcast_WebRTC_Candidate as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_WebRTC_Candidate {
    pub fn new() -> CBroadcast_WebRTC_Candidate {
        ::std::default::Default::default()
    }

    // optional string sdp_mid = 1;

    pub fn sdp_mid(&self) -> &str {
        match self.sdp_mid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_sdp_mid(&mut self) {
        self.sdp_mid = ::std::option::Option::None;
    }

    pub fn has_sdp_mid(&self) -> bool {
        self.sdp_mid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sdp_mid(&mut self, v: ::std::string::String) {
        self.sdp_mid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sdp_mid(&mut self) -> &mut ::std::string::String {
        if self.sdp_mid.is_none() {
            self.sdp_mid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.sdp_mid.as_mut().unwrap()
    }

    // Take field
    pub fn take_sdp_mid(&mut self) -> ::std::string::String {
        self.sdp_mid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 sdp_mline_index = 2;

    pub fn sdp_mline_index(&self) -> i32 {
        self.sdp_mline_index.unwrap_or(0)
    }

    pub fn clear_sdp_mline_index(&mut self) {
        self.sdp_mline_index = ::std::option::Option::None;
    }

    pub fn has_sdp_mline_index(&self) -> bool {
        self.sdp_mline_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sdp_mline_index(&mut self, v: i32) {
        self.sdp_mline_index = ::std::option::Option::Some(v);
    }

    // optional string candidate = 3;

    pub fn candidate(&self) -> &str {
        match self.candidate.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_candidate(&mut self) {
        self.candidate = ::std::option::Option::None;
    }

    pub fn has_candidate(&self) -> bool {
        self.candidate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_candidate(&mut self, v: ::std::string::String) {
        self.candidate = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_candidate(&mut self) -> &mut ::std::string::String {
        if self.candidate.is_none() {
            self.candidate = ::std::option::Option::Some(::std::string::String::new());
        }
        self.candidate.as_mut().unwrap()
    }

    // Take field
    pub fn take_candidate(&mut self) -> ::std::string::String {
        self.candidate.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CBroadcast_WebRTC_Candidate {
    const NAME: &'static str = "CBroadcast_WebRTC_Candidate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.sdp_mid = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.sdp_mline_index = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.candidate = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.sdp_mid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.sdp_mline_index {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.candidate.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.sdp_mid.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.sdp_mline_index {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.candidate.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_WebRTC_Candidate {
        CBroadcast_WebRTC_Candidate::new()
    }

    fn clear(&mut self) {
        self.sdp_mid = ::std::option::Option::None;
        self.sdp_mline_index = ::std::option::Option::None;
        self.candidate = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_WebRTC_Candidate {
        static instance: CBroadcast_WebRTC_Candidate = CBroadcast_WebRTC_Candidate {
            sdp_mid: ::std::option::Option::None,
            sdp_mline_index: ::std::option::Option::None,
            candidate: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Add an ICE candidate for the host side of a WebRTC session"]
// @@protoc_insertion_point(message:CBroadcast_WebRTCAddHostCandidate_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_WebRTCAddHostCandidate_Request {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_WebRTCAddHostCandidate_Request.webrtc_session_id)
    pub webrtc_session_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_WebRTCAddHostCandidate_Request.candidate)
    pub candidate: ::protobuf::MessageField<CBroadcast_WebRTC_Candidate>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_WebRTCAddHostCandidate_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_WebRTCAddHostCandidate_Request {
    fn default() -> &'a CBroadcast_WebRTCAddHostCandidate_Request {
        <CBroadcast_WebRTCAddHostCandidate_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_WebRTCAddHostCandidate_Request {
    pub fn new() -> CBroadcast_WebRTCAddHostCandidate_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 webrtc_session_id = 1;

    pub fn webrtc_session_id(&self) -> u64 {
        self.webrtc_session_id.unwrap_or(0)
    }

    pub fn clear_webrtc_session_id(&mut self) {
        self.webrtc_session_id = ::std::option::Option::None;
    }

    pub fn has_webrtc_session_id(&self) -> bool {
        self.webrtc_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_webrtc_session_id(&mut self, v: u64) {
        self.webrtc_session_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_WebRTCAddHostCandidate_Request {
    const NAME: &'static str = "CBroadcast_WebRTCAddHostCandidate_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.webrtc_session_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.candidate)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.webrtc_session_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.candidate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.webrtc_session_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.candidate.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_WebRTCAddHostCandidate_Request {
        CBroadcast_WebRTCAddHostCandidate_Request::new()
    }

    fn clear(&mut self) {
        self.webrtc_session_id = ::std::option::Option::None;
        self.candidate.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_WebRTCAddHostCandidate_Request {
        static instance: CBroadcast_WebRTCAddHostCandidate_Request = CBroadcast_WebRTCAddHostCandidate_Request {
            webrtc_session_id: ::std::option::Option::None,
            candidate: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CBroadcast_WebRTCAddHostCandidate_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_WebRTCAddHostCandidate_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_WebRTCAddHostCandidate_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_WebRTCAddHostCandidate_Response {
    fn default() -> &'a CBroadcast_WebRTCAddHostCandidate_Response {
        <CBroadcast_WebRTCAddHostCandidate_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_WebRTCAddHostCandidate_Response {
    pub fn new() -> CBroadcast_WebRTCAddHostCandidate_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CBroadcast_WebRTCAddHostCandidate_Response {
    const NAME: &'static str = "CBroadcast_WebRTCAddHostCandidate_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_WebRTCAddHostCandidate_Response {
        CBroadcast_WebRTCAddHostCandidate_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_WebRTCAddHostCandidate_Response {
        static instance: CBroadcast_WebRTCAddHostCandidate_Response = CBroadcast_WebRTCAddHostCandidate_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Add an ICE candidate for the viewer side of a WebRTC session"]
// @@protoc_insertion_point(message:CBroadcast_WebRTCAddViewerCandidate_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_WebRTCAddViewerCandidate_Request {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_WebRTCAddViewerCandidate_Request.broadcaster_steamid)
    pub broadcaster_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_WebRTCAddViewerCandidate_Request.webrtc_session_id)
    pub webrtc_session_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_WebRTCAddViewerCandidate_Request.candidate)
    pub candidate: ::protobuf::MessageField<CBroadcast_WebRTC_Candidate>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_WebRTCAddViewerCandidate_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_WebRTCAddViewerCandidate_Request {
    fn default() -> &'a CBroadcast_WebRTCAddViewerCandidate_Request {
        <CBroadcast_WebRTCAddViewerCandidate_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_WebRTCAddViewerCandidate_Request {
    pub fn new() -> CBroadcast_WebRTCAddViewerCandidate_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcaster_steamid = 1;

    pub fn broadcaster_steamid(&self) -> u64 {
        self.broadcaster_steamid.unwrap_or(0)
    }

    pub fn clear_broadcaster_steamid(&mut self) {
        self.broadcaster_steamid = ::std::option::Option::None;
    }

    pub fn has_broadcaster_steamid(&self) -> bool {
        self.broadcaster_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcaster_steamid(&mut self, v: u64) {
        self.broadcaster_steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 webrtc_session_id = 2;

    pub fn webrtc_session_id(&self) -> u64 {
        self.webrtc_session_id.unwrap_or(0)
    }

    pub fn clear_webrtc_session_id(&mut self) {
        self.webrtc_session_id = ::std::option::Option::None;
    }

    pub fn has_webrtc_session_id(&self) -> bool {
        self.webrtc_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_webrtc_session_id(&mut self, v: u64) {
        self.webrtc_session_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_WebRTCAddViewerCandidate_Request {
    const NAME: &'static str = "CBroadcast_WebRTCAddViewerCandidate_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcaster_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.webrtc_session_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.candidate)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcaster_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.webrtc_session_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.candidate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcaster_steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.webrtc_session_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.candidate.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_WebRTCAddViewerCandidate_Request {
        CBroadcast_WebRTCAddViewerCandidate_Request::new()
    }

    fn clear(&mut self) {
        self.broadcaster_steamid = ::std::option::Option::None;
        self.webrtc_session_id = ::std::option::Option::None;
        self.candidate.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_WebRTCAddViewerCandidate_Request {
        static instance: CBroadcast_WebRTCAddViewerCandidate_Request = CBroadcast_WebRTCAddViewerCandidate_Request {
            broadcaster_steamid: ::std::option::Option::None,
            webrtc_session_id: ::std::option::Option::None,
            candidate: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CBroadcast_WebRTCAddViewerCandidate_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_WebRTCAddViewerCandidate_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_WebRTCAddViewerCandidate_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_WebRTCAddViewerCandidate_Response {
    fn default() -> &'a CBroadcast_WebRTCAddViewerCandidate_Response {
        <CBroadcast_WebRTCAddViewerCandidate_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_WebRTCAddViewerCandidate_Response {
    pub fn new() -> CBroadcast_WebRTCAddViewerCandidate_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CBroadcast_WebRTCAddViewerCandidate_Response {
    const NAME: &'static str = "CBroadcast_WebRTCAddViewerCandidate_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_WebRTCAddViewerCandidate_Response {
        CBroadcast_WebRTCAddViewerCandidate_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_WebRTCAddViewerCandidate_Response {
        static instance: CBroadcast_WebRTCAddViewerCandidate_Response = CBroadcast_WebRTCAddViewerCandidate_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Get the ICE candidates for the host side of a WebRTC session"]
// @@protoc_insertion_point(message:CBroadcast_WebRTCGetHostCandidates_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_WebRTCGetHostCandidates_Request {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_WebRTCGetHostCandidates_Request.broadcaster_steamid)
    pub broadcaster_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_WebRTCGetHostCandidates_Request.webrtc_session_id)
    pub webrtc_session_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_WebRTCGetHostCandidates_Request.candidate_generation)
    pub candidate_generation: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_WebRTCGetHostCandidates_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_WebRTCGetHostCandidates_Request {
    fn default() -> &'a CBroadcast_WebRTCGetHostCandidates_Request {
        <CBroadcast_WebRTCGetHostCandidates_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_WebRTCGetHostCandidates_Request {
    pub fn new() -> CBroadcast_WebRTCGetHostCandidates_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcaster_steamid = 1;

    pub fn broadcaster_steamid(&self) -> u64 {
        self.broadcaster_steamid.unwrap_or(0)
    }

    pub fn clear_broadcaster_steamid(&mut self) {
        self.broadcaster_steamid = ::std::option::Option::None;
    }

    pub fn has_broadcaster_steamid(&self) -> bool {
        self.broadcaster_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcaster_steamid(&mut self, v: u64) {
        self.broadcaster_steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 webrtc_session_id = 2;

    pub fn webrtc_session_id(&self) -> u64 {
        self.webrtc_session_id.unwrap_or(0)
    }

    pub fn clear_webrtc_session_id(&mut self) {
        self.webrtc_session_id = ::std::option::Option::None;
    }

    pub fn has_webrtc_session_id(&self) -> bool {
        self.webrtc_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_webrtc_session_id(&mut self, v: u64) {
        self.webrtc_session_id = ::std::option::Option::Some(v);
    }

    // optional uint32 candidate_generation = 3;

    pub fn candidate_generation(&self) -> u32 {
        self.candidate_generation.unwrap_or(0)
    }

    pub fn clear_candidate_generation(&mut self) {
        self.candidate_generation = ::std::option::Option::None;
    }

    pub fn has_candidate_generation(&self) -> bool {
        self.candidate_generation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_candidate_generation(&mut self, v: u32) {
        self.candidate_generation = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_WebRTCGetHostCandidates_Request {
    const NAME: &'static str = "CBroadcast_WebRTCGetHostCandidates_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcaster_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.webrtc_session_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.candidate_generation = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcaster_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.webrtc_session_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.candidate_generation {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcaster_steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.webrtc_session_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.candidate_generation {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_WebRTCGetHostCandidates_Request {
        CBroadcast_WebRTCGetHostCandidates_Request::new()
    }

    fn clear(&mut self) {
        self.broadcaster_steamid = ::std::option::Option::None;
        self.webrtc_session_id = ::std::option::Option::None;
        self.candidate_generation = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_WebRTCGetHostCandidates_Request {
        static instance: CBroadcast_WebRTCGetHostCandidates_Request = CBroadcast_WebRTCGetHostCandidates_Request {
            broadcaster_steamid: ::std::option::Option::None,
            webrtc_session_id: ::std::option::Option::None,
            candidate_generation: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CBroadcast_WebRTCGetHostCandidates_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_WebRTCGetHostCandidates_Response {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_WebRTCGetHostCandidates_Response.candidate_generation)
    pub candidate_generation: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CBroadcast_WebRTCGetHostCandidates_Response.candidates)
    pub candidates: ::std::vec::Vec<CBroadcast_WebRTC_Candidate>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_WebRTCGetHostCandidates_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_WebRTCGetHostCandidates_Response {
    fn default() -> &'a CBroadcast_WebRTCGetHostCandidates_Response {
        <CBroadcast_WebRTCGetHostCandidates_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_WebRTCGetHostCandidates_Response {
    pub fn new() -> CBroadcast_WebRTCGetHostCandidates_Response {
        ::std::default::Default::default()
    }

    // optional uint32 candidate_generation = 1;

    pub fn candidate_generation(&self) -> u32 {
        self.candidate_generation.unwrap_or(0)
    }

    pub fn clear_candidate_generation(&mut self) {
        self.candidate_generation = ::std::option::Option::None;
    }

    pub fn has_candidate_generation(&self) -> bool {
        self.candidate_generation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_candidate_generation(&mut self, v: u32) {
        self.candidate_generation = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_WebRTCGetHostCandidates_Response {
    const NAME: &'static str = "CBroadcast_WebRTCGetHostCandidates_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.candidate_generation = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.candidates.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.candidate_generation {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.candidates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.candidate_generation {
            os.write_uint32(1, v)?;
        }
        for v in &self.candidates {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_WebRTCGetHostCandidates_Response {
        CBroadcast_WebRTCGetHostCandidates_Response::new()
    }

    fn clear(&mut self) {
        self.candidate_generation = ::std::option::Option::None;
        self.candidates.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_WebRTCGetHostCandidates_Response {
        static instance: CBroadcast_WebRTCGetHostCandidates_Response = CBroadcast_WebRTCGetHostCandidates_Response {
            candidate_generation: ::std::option::Option::None,
            candidates: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Gets broadcast upload stats for user"]
// @@protoc_insertion_point(message:CBroadcast_GetBroadcastUploadStats_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_GetBroadcastUploadStats_Request {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_GetBroadcastUploadStats_Request.row_limit)
    pub row_limit: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CBroadcast_GetBroadcastUploadStats_Request.start_time)
    pub start_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CBroadcast_GetBroadcastUploadStats_Request.upload_id)
    pub upload_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_GetBroadcastUploadStats_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_GetBroadcastUploadStats_Request.session_id)
    pub session_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_GetBroadcastUploadStats_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_GetBroadcastUploadStats_Request {
    fn default() -> &'a CBroadcast_GetBroadcastUploadStats_Request {
        <CBroadcast_GetBroadcastUploadStats_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_GetBroadcastUploadStats_Request {
    pub fn new() -> CBroadcast_GetBroadcastUploadStats_Request {
        ::std::default::Default::default()
    }

    // optional uint32 row_limit = 1;

    pub fn row_limit(&self) -> u32 {
        self.row_limit.unwrap_or(100u32)
    }

    pub fn clear_row_limit(&mut self) {
        self.row_limit = ::std::option::Option::None;
    }

    pub fn has_row_limit(&self) -> bool {
        self.row_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_row_limit(&mut self, v: u32) {
        self.row_limit = ::std::option::Option::Some(v);
    }

    // optional uint32 start_time = 2;

    pub fn start_time(&self) -> u32 {
        self.start_time.unwrap_or(0u32)
    }

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: u32) {
        self.start_time = ::std::option::Option::Some(v);
    }

    // optional uint64 upload_id = 3;

    pub fn upload_id(&self) -> u64 {
        self.upload_id.unwrap_or(0)
    }

    pub fn clear_upload_id(&mut self) {
        self.upload_id = ::std::option::Option::None;
    }

    pub fn has_upload_id(&self) -> bool {
        self.upload_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upload_id(&mut self, v: u64) {
        self.upload_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 4;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional uint64 session_id = 5;

    pub fn session_id(&self) -> u64 {
        self.session_id.unwrap_or(0)
    }

    pub fn clear_session_id(&mut self) {
        self.session_id = ::std::option::Option::None;
    }

    pub fn has_session_id(&self) -> bool {
        self.session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_id(&mut self, v: u64) {
        self.session_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_GetBroadcastUploadStats_Request {
    const NAME: &'static str = "CBroadcast_GetBroadcastUploadStats_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.row_limit = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.start_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.upload_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                33 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                40 => {
                    self.session_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.row_limit {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.start_time {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.upload_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.session_id {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.row_limit {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.start_time {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.upload_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.session_id {
            os.write_uint64(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_GetBroadcastUploadStats_Request {
        CBroadcast_GetBroadcastUploadStats_Request::new()
    }

    fn clear(&mut self) {
        self.row_limit = ::std::option::Option::None;
        self.start_time = ::std::option::Option::None;
        self.upload_id = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.session_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_GetBroadcastUploadStats_Request {
        static instance: CBroadcast_GetBroadcastUploadStats_Request = CBroadcast_GetBroadcastUploadStats_Request {
            row_limit: ::std::option::Option::None,
            start_time: ::std::option::Option::None,
            upload_id: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            session_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CBroadcast_GetBroadcastUploadStats_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_GetBroadcastUploadStats_Response {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_GetBroadcastUploadStats_Response.upload_stats)
    pub upload_stats: ::std::vec::Vec<cbroadcast_get_broadcast_upload_stats_response::UploadStats>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_GetBroadcastUploadStats_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_GetBroadcastUploadStats_Response {
    fn default() -> &'a CBroadcast_GetBroadcastUploadStats_Response {
        <CBroadcast_GetBroadcastUploadStats_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_GetBroadcastUploadStats_Response {
    pub fn new() -> CBroadcast_GetBroadcastUploadStats_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CBroadcast_GetBroadcastUploadStats_Response {
    const NAME: &'static str = "CBroadcast_GetBroadcastUploadStats_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.upload_stats.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.upload_stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.upload_stats {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_GetBroadcastUploadStats_Response {
        CBroadcast_GetBroadcastUploadStats_Response::new()
    }

    fn clear(&mut self) {
        self.upload_stats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_GetBroadcastUploadStats_Response {
        static instance: CBroadcast_GetBroadcastUploadStats_Response = CBroadcast_GetBroadcastUploadStats_Response {
            upload_stats: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CBroadcast_GetBroadcastUploadStats_Response`
pub mod cbroadcast_get_broadcast_upload_stats_response {
    // @@protoc_insertion_point(message:CBroadcast_GetBroadcastUploadStats_Response.UploadStats)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct UploadStats {
        // message fields
        // @@protoc_insertion_point(field:CBroadcast_GetBroadcastUploadStats_Response.UploadStats.upload_result)
        pub upload_result: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CBroadcast_GetBroadcastUploadStats_Response.UploadStats.time_stopped)
        pub time_stopped: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CBroadcast_GetBroadcastUploadStats_Response.UploadStats.seconds_uploaded)
        pub seconds_uploaded: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CBroadcast_GetBroadcastUploadStats_Response.UploadStats.max_viewers)
        pub max_viewers: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CBroadcast_GetBroadcastUploadStats_Response.UploadStats.resolution_x)
        pub resolution_x: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CBroadcast_GetBroadcastUploadStats_Response.UploadStats.resolution_y)
        pub resolution_y: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CBroadcast_GetBroadcastUploadStats_Response.UploadStats.avg_bandwidth)
        pub avg_bandwidth: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CBroadcast_GetBroadcastUploadStats_Response.UploadStats.total_bytes)
        pub total_bytes: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CBroadcast_GetBroadcastUploadStats_Response.UploadStats.app_id)
        pub app_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CBroadcast_GetBroadcastUploadStats_Response.UploadStats.total_unique_viewers)
        pub total_unique_viewers: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CBroadcast_GetBroadcastUploadStats_Response.UploadStats.total_seconds_watched)
        pub total_seconds_watched: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CBroadcast_GetBroadcastUploadStats_Response.UploadStats.time_started)
        pub time_started: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CBroadcast_GetBroadcastUploadStats_Response.UploadStats.upload_id)
        pub upload_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CBroadcast_GetBroadcastUploadStats_Response.UploadStats.local_address)
        pub local_address: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CBroadcast_GetBroadcastUploadStats_Response.UploadStats.remote_address)
        pub remote_address: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CBroadcast_GetBroadcastUploadStats_Response.UploadStats.frames_per_second)
        pub frames_per_second: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CBroadcast_GetBroadcastUploadStats_Response.UploadStats.num_representations)
        pub num_representations: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CBroadcast_GetBroadcastUploadStats_Response.UploadStats.app_name)
        pub app_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CBroadcast_GetBroadcastUploadStats_Response.UploadStats.is_replay)
        pub is_replay: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CBroadcast_GetBroadcastUploadStats_Response.UploadStats.session_id)
        pub session_id: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CBroadcast_GetBroadcastUploadStats_Response.UploadStats.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a UploadStats {
        fn default() -> &'a UploadStats {
            <UploadStats as ::protobuf::Message>::default_instance()
        }
    }

    impl UploadStats {
        pub fn new() -> UploadStats {
            ::std::default::Default::default()
        }

        // optional uint32 upload_result = 1;

        pub fn upload_result(&self) -> u32 {
            self.upload_result.unwrap_or(0)
        }

        pub fn clear_upload_result(&mut self) {
            self.upload_result = ::std::option::Option::None;
        }

        pub fn has_upload_result(&self) -> bool {
            self.upload_result.is_some()
        }

        // Param is passed by value, moved
        pub fn set_upload_result(&mut self, v: u32) {
            self.upload_result = ::std::option::Option::Some(v);
        }

        // optional uint32 time_stopped = 2;

        pub fn time_stopped(&self) -> u32 {
            self.time_stopped.unwrap_or(0)
        }

        pub fn clear_time_stopped(&mut self) {
            self.time_stopped = ::std::option::Option::None;
        }

        pub fn has_time_stopped(&self) -> bool {
            self.time_stopped.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_stopped(&mut self, v: u32) {
            self.time_stopped = ::std::option::Option::Some(v);
        }

        // optional uint32 seconds_uploaded = 3;

        pub fn seconds_uploaded(&self) -> u32 {
            self.seconds_uploaded.unwrap_or(0)
        }

        pub fn clear_seconds_uploaded(&mut self) {
            self.seconds_uploaded = ::std::option::Option::None;
        }

        pub fn has_seconds_uploaded(&self) -> bool {
            self.seconds_uploaded.is_some()
        }

        // Param is passed by value, moved
        pub fn set_seconds_uploaded(&mut self, v: u32) {
            self.seconds_uploaded = ::std::option::Option::Some(v);
        }

        // optional uint32 max_viewers = 4;

        pub fn max_viewers(&self) -> u32 {
            self.max_viewers.unwrap_or(0)
        }

        pub fn clear_max_viewers(&mut self) {
            self.max_viewers = ::std::option::Option::None;
        }

        pub fn has_max_viewers(&self) -> bool {
            self.max_viewers.is_some()
        }

        // Param is passed by value, moved
        pub fn set_max_viewers(&mut self, v: u32) {
            self.max_viewers = ::std::option::Option::Some(v);
        }

        // optional uint32 resolution_x = 5;

        pub fn resolution_x(&self) -> u32 {
            self.resolution_x.unwrap_or(0)
        }

        pub fn clear_resolution_x(&mut self) {
            self.resolution_x = ::std::option::Option::None;
        }

        pub fn has_resolution_x(&self) -> bool {
            self.resolution_x.is_some()
        }

        // Param is passed by value, moved
        pub fn set_resolution_x(&mut self, v: u32) {
            self.resolution_x = ::std::option::Option::Some(v);
        }

        // optional uint32 resolution_y = 6;

        pub fn resolution_y(&self) -> u32 {
            self.resolution_y.unwrap_or(0)
        }

        pub fn clear_resolution_y(&mut self) {
            self.resolution_y = ::std::option::Option::None;
        }

        pub fn has_resolution_y(&self) -> bool {
            self.resolution_y.is_some()
        }

        // Param is passed by value, moved
        pub fn set_resolution_y(&mut self, v: u32) {
            self.resolution_y = ::std::option::Option::Some(v);
        }

        // optional uint32 avg_bandwidth = 7;

        pub fn avg_bandwidth(&self) -> u32 {
            self.avg_bandwidth.unwrap_or(0)
        }

        pub fn clear_avg_bandwidth(&mut self) {
            self.avg_bandwidth = ::std::option::Option::None;
        }

        pub fn has_avg_bandwidth(&self) -> bool {
            self.avg_bandwidth.is_some()
        }

        // Param is passed by value, moved
        pub fn set_avg_bandwidth(&mut self, v: u32) {
            self.avg_bandwidth = ::std::option::Option::Some(v);
        }

        // optional uint64 total_bytes = 8;

        pub fn total_bytes(&self) -> u64 {
            self.total_bytes.unwrap_or(0)
        }

        pub fn clear_total_bytes(&mut self) {
            self.total_bytes = ::std::option::Option::None;
        }

        pub fn has_total_bytes(&self) -> bool {
            self.total_bytes.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_bytes(&mut self, v: u64) {
            self.total_bytes = ::std::option::Option::Some(v);
        }

        // optional uint32 app_id = 9;

        pub fn app_id(&self) -> u32 {
            self.app_id.unwrap_or(0)
        }

        pub fn clear_app_id(&mut self) {
            self.app_id = ::std::option::Option::None;
        }

        pub fn has_app_id(&self) -> bool {
            self.app_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_app_id(&mut self, v: u32) {
            self.app_id = ::std::option::Option::Some(v);
        }

        // optional uint32 total_unique_viewers = 10;

        pub fn total_unique_viewers(&self) -> u32 {
            self.total_unique_viewers.unwrap_or(0)
        }

        pub fn clear_total_unique_viewers(&mut self) {
            self.total_unique_viewers = ::std::option::Option::None;
        }

        pub fn has_total_unique_viewers(&self) -> bool {
            self.total_unique_viewers.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_unique_viewers(&mut self, v: u32) {
            self.total_unique_viewers = ::std::option::Option::Some(v);
        }

        // optional uint64 total_seconds_watched = 11;

        pub fn total_seconds_watched(&self) -> u64 {
            self.total_seconds_watched.unwrap_or(0)
        }

        pub fn clear_total_seconds_watched(&mut self) {
            self.total_seconds_watched = ::std::option::Option::None;
        }

        pub fn has_total_seconds_watched(&self) -> bool {
            self.total_seconds_watched.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_seconds_watched(&mut self, v: u64) {
            self.total_seconds_watched = ::std::option::Option::Some(v);
        }

        // optional uint32 time_started = 12;

        pub fn time_started(&self) -> u32 {
            self.time_started.unwrap_or(0)
        }

        pub fn clear_time_started(&mut self) {
            self.time_started = ::std::option::Option::None;
        }

        pub fn has_time_started(&self) -> bool {
            self.time_started.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_started(&mut self, v: u32) {
            self.time_started = ::std::option::Option::Some(v);
        }

        // optional uint64 upload_id = 13;

        pub fn upload_id(&self) -> u64 {
            self.upload_id.unwrap_or(0)
        }

        pub fn clear_upload_id(&mut self) {
            self.upload_id = ::std::option::Option::None;
        }

        pub fn has_upload_id(&self) -> bool {
            self.upload_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_upload_id(&mut self, v: u64) {
            self.upload_id = ::std::option::Option::Some(v);
        }

        // optional string local_address = 14;

        pub fn local_address(&self) -> &str {
            match self.local_address.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_local_address(&mut self) {
            self.local_address = ::std::option::Option::None;
        }

        pub fn has_local_address(&self) -> bool {
            self.local_address.is_some()
        }

        // Param is passed by value, moved
        pub fn set_local_address(&mut self, v: ::std::string::String) {
            self.local_address = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_local_address(&mut self) -> &mut ::std::string::String {
            if self.local_address.is_none() {
                self.local_address = ::std::option::Option::Some(::std::string::String::new());
            }
            self.local_address.as_mut().unwrap()
        }

        // Take field
        pub fn take_local_address(&mut self) -> ::std::string::String {
            self.local_address.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string remote_address = 15;

        pub fn remote_address(&self) -> &str {
            match self.remote_address.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_remote_address(&mut self) {
            self.remote_address = ::std::option::Option::None;
        }

        pub fn has_remote_address(&self) -> bool {
            self.remote_address.is_some()
        }

        // Param is passed by value, moved
        pub fn set_remote_address(&mut self, v: ::std::string::String) {
            self.remote_address = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_remote_address(&mut self) -> &mut ::std::string::String {
            if self.remote_address.is_none() {
                self.remote_address = ::std::option::Option::Some(::std::string::String::new());
            }
            self.remote_address.as_mut().unwrap()
        }

        // Take field
        pub fn take_remote_address(&mut self) -> ::std::string::String {
            self.remote_address.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 frames_per_second = 16;

        pub fn frames_per_second(&self) -> u32 {
            self.frames_per_second.unwrap_or(0)
        }

        pub fn clear_frames_per_second(&mut self) {
            self.frames_per_second = ::std::option::Option::None;
        }

        pub fn has_frames_per_second(&self) -> bool {
            self.frames_per_second.is_some()
        }

        // Param is passed by value, moved
        pub fn set_frames_per_second(&mut self, v: u32) {
            self.frames_per_second = ::std::option::Option::Some(v);
        }

        // optional uint32 num_representations = 17;

        pub fn num_representations(&self) -> u32 {
            self.num_representations.unwrap_or(0)
        }

        pub fn clear_num_representations(&mut self) {
            self.num_representations = ::std::option::Option::None;
        }

        pub fn has_num_representations(&self) -> bool {
            self.num_representations.is_some()
        }

        // Param is passed by value, moved
        pub fn set_num_representations(&mut self, v: u32) {
            self.num_representations = ::std::option::Option::Some(v);
        }

        // optional string app_name = 18;

        pub fn app_name(&self) -> &str {
            match self.app_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_app_name(&mut self) {
            self.app_name = ::std::option::Option::None;
        }

        pub fn has_app_name(&self) -> bool {
            self.app_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_app_name(&mut self, v: ::std::string::String) {
            self.app_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_app_name(&mut self) -> &mut ::std::string::String {
            if self.app_name.is_none() {
                self.app_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.app_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_app_name(&mut self) -> ::std::string::String {
            self.app_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool is_replay = 19;

        pub fn is_replay(&self) -> bool {
            self.is_replay.unwrap_or(false)
        }

        pub fn clear_is_replay(&mut self) {
            self.is_replay = ::std::option::Option::None;
        }

        pub fn has_is_replay(&self) -> bool {
            self.is_replay.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_replay(&mut self, v: bool) {
            self.is_replay = ::std::option::Option::Some(v);
        }

        // optional uint64 session_id = 20;

        pub fn session_id(&self) -> u64 {
            self.session_id.unwrap_or(0)
        }

        pub fn clear_session_id(&mut self) {
            self.session_id = ::std::option::Option::None;
        }

        pub fn has_session_id(&self) -> bool {
            self.session_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_session_id(&mut self, v: u64) {
            self.session_id = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for UploadStats {
        const NAME: &'static str = "UploadStats";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.upload_result = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.time_stopped = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.seconds_uploaded = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.max_viewers = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.resolution_x = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.resolution_y = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.avg_bandwidth = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.total_bytes = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    72 => {
                        self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    80 => {
                        self.total_unique_viewers = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    88 => {
                        self.total_seconds_watched = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    96 => {
                        self.time_started = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    104 => {
                        self.upload_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    114 => {
                        self.local_address = ::std::option::Option::Some(is.read_string()?);
                    },
                    122 => {
                        self.remote_address = ::std::option::Option::Some(is.read_string()?);
                    },
                    128 => {
                        self.frames_per_second = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    136 => {
                        self.num_representations = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    146 => {
                        self.app_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    152 => {
                        self.is_replay = ::std::option::Option::Some(is.read_bool()?);
                    },
                    160 => {
                        self.session_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.upload_result {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.time_stopped {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.seconds_uploaded {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.max_viewers {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.resolution_x {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.resolution_y {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.avg_bandwidth {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.total_bytes {
                my_size += ::protobuf::rt::uint64_size(8, v);
            }
            if let Some(v) = self.app_id {
                my_size += ::protobuf::rt::uint32_size(9, v);
            }
            if let Some(v) = self.total_unique_viewers {
                my_size += ::protobuf::rt::uint32_size(10, v);
            }
            if let Some(v) = self.total_seconds_watched {
                my_size += ::protobuf::rt::uint64_size(11, v);
            }
            if let Some(v) = self.time_started {
                my_size += ::protobuf::rt::uint32_size(12, v);
            }
            if let Some(v) = self.upload_id {
                my_size += ::protobuf::rt::uint64_size(13, v);
            }
            if let Some(v) = self.local_address.as_ref() {
                my_size += ::protobuf::rt::string_size(14, &v);
            }
            if let Some(v) = self.remote_address.as_ref() {
                my_size += ::protobuf::rt::string_size(15, &v);
            }
            if let Some(v) = self.frames_per_second {
                my_size += ::protobuf::rt::uint32_size(16, v);
            }
            if let Some(v) = self.num_representations {
                my_size += ::protobuf::rt::uint32_size(17, v);
            }
            if let Some(v) = self.app_name.as_ref() {
                my_size += ::protobuf::rt::string_size(18, &v);
            }
            if let Some(v) = self.is_replay {
                my_size += 2 + 1;
            }
            if let Some(v) = self.session_id {
                my_size += ::protobuf::rt::uint64_size(20, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.upload_result {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.time_stopped {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.seconds_uploaded {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.max_viewers {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.resolution_x {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.resolution_y {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.avg_bandwidth {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.total_bytes {
                os.write_uint64(8, v)?;
            }
            if let Some(v) = self.app_id {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.total_unique_viewers {
                os.write_uint32(10, v)?;
            }
            if let Some(v) = self.total_seconds_watched {
                os.write_uint64(11, v)?;
            }
            if let Some(v) = self.time_started {
                os.write_uint32(12, v)?;
            }
            if let Some(v) = self.upload_id {
                os.write_uint64(13, v)?;
            }
            if let Some(v) = self.local_address.as_ref() {
                os.write_string(14, v)?;
            }
            if let Some(v) = self.remote_address.as_ref() {
                os.write_string(15, v)?;
            }
            if let Some(v) = self.frames_per_second {
                os.write_uint32(16, v)?;
            }
            if let Some(v) = self.num_representations {
                os.write_uint32(17, v)?;
            }
            if let Some(v) = self.app_name.as_ref() {
                os.write_string(18, v)?;
            }
            if let Some(v) = self.is_replay {
                os.write_bool(19, v)?;
            }
            if let Some(v) = self.session_id {
                os.write_uint64(20, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> UploadStats {
            UploadStats::new()
        }

        fn clear(&mut self) {
            self.upload_result = ::std::option::Option::None;
            self.time_stopped = ::std::option::Option::None;
            self.seconds_uploaded = ::std::option::Option::None;
            self.max_viewers = ::std::option::Option::None;
            self.resolution_x = ::std::option::Option::None;
            self.resolution_y = ::std::option::Option::None;
            self.avg_bandwidth = ::std::option::Option::None;
            self.total_bytes = ::std::option::Option::None;
            self.app_id = ::std::option::Option::None;
            self.total_unique_viewers = ::std::option::Option::None;
            self.total_seconds_watched = ::std::option::Option::None;
            self.time_started = ::std::option::Option::None;
            self.upload_id = ::std::option::Option::None;
            self.local_address = ::std::option::Option::None;
            self.remote_address = ::std::option::Option::None;
            self.frames_per_second = ::std::option::Option::None;
            self.num_representations = ::std::option::Option::None;
            self.app_name = ::std::option::Option::None;
            self.is_replay = ::std::option::Option::None;
            self.session_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static UploadStats {
            static instance: UploadStats = UploadStats {
                upload_result: ::std::option::Option::None,
                time_stopped: ::std::option::Option::None,
                seconds_uploaded: ::std::option::Option::None,
                max_viewers: ::std::option::Option::None,
                resolution_x: ::std::option::Option::None,
                resolution_y: ::std::option::Option::None,
                avg_bandwidth: ::std::option::Option::None,
                total_bytes: ::std::option::Option::None,
                app_id: ::std::option::Option::None,
                total_unique_viewers: ::std::option::Option::None,
                total_seconds_watched: ::std::option::Option::None,
                time_started: ::std::option::Option::None,
                upload_id: ::std::option::Option::None,
                local_address: ::std::option::Option::None,
                remote_address: ::std::option::Option::None,
                frames_per_second: ::std::option::Option::None,
                num_representations: ::std::option::Option::None,
                app_name: ::std::option::Option::None,
                is_replay: ::std::option::Option::None,
                session_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

#[doc = "Gets viewer stats for given broadcast"]
// @@protoc_insertion_point(message:CBroadcast_GetBroadcastViewerStats_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_GetBroadcastViewerStats_Request {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_GetBroadcastViewerStats_Request.upload_id)
    pub upload_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_GetBroadcastViewerStats_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_GetBroadcastViewerStats_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_GetBroadcastViewerStats_Request {
    fn default() -> &'a CBroadcast_GetBroadcastViewerStats_Request {
        <CBroadcast_GetBroadcastViewerStats_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_GetBroadcastViewerStats_Request {
    pub fn new() -> CBroadcast_GetBroadcastViewerStats_Request {
        ::std::default::Default::default()
    }

    // optional uint64 upload_id = 1;

    pub fn upload_id(&self) -> u64 {
        self.upload_id.unwrap_or(0)
    }

    pub fn clear_upload_id(&mut self) {
        self.upload_id = ::std::option::Option::None;
    }

    pub fn has_upload_id(&self) -> bool {
        self.upload_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upload_id(&mut self, v: u64) {
        self.upload_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 2;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_GetBroadcastViewerStats_Request {
    const NAME: &'static str = "CBroadcast_GetBroadcastViewerStats_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.upload_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                17 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.upload_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.upload_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_GetBroadcastViewerStats_Request {
        CBroadcast_GetBroadcastViewerStats_Request::new()
    }

    fn clear(&mut self) {
        self.upload_id = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_GetBroadcastViewerStats_Request {
        static instance: CBroadcast_GetBroadcastViewerStats_Request = CBroadcast_GetBroadcastViewerStats_Request {
            upload_id: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CBroadcast_GetBroadcastViewerStats_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_GetBroadcastViewerStats_Response {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_GetBroadcastViewerStats_Response.viewer_stats)
    pub viewer_stats: ::std::vec::Vec<cbroadcast_get_broadcast_viewer_stats_response::ViewerStats>,
    // @@protoc_insertion_point(field:CBroadcast_GetBroadcastViewerStats_Response.country_stats)
    pub country_stats: ::std::vec::Vec<cbroadcast_get_broadcast_viewer_stats_response::CountryStats>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_GetBroadcastViewerStats_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_GetBroadcastViewerStats_Response {
    fn default() -> &'a CBroadcast_GetBroadcastViewerStats_Response {
        <CBroadcast_GetBroadcastViewerStats_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_GetBroadcastViewerStats_Response {
    pub fn new() -> CBroadcast_GetBroadcastViewerStats_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CBroadcast_GetBroadcastViewerStats_Response {
    const NAME: &'static str = "CBroadcast_GetBroadcastViewerStats_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.viewer_stats.push(is.read_message()?);
                },
                18 => {
                    self.country_stats.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.viewer_stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.country_stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.viewer_stats {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.country_stats {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_GetBroadcastViewerStats_Response {
        CBroadcast_GetBroadcastViewerStats_Response::new()
    }

    fn clear(&mut self) {
        self.viewer_stats.clear();
        self.country_stats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_GetBroadcastViewerStats_Response {
        static instance: CBroadcast_GetBroadcastViewerStats_Response = CBroadcast_GetBroadcastViewerStats_Response {
            viewer_stats: ::std::vec::Vec::new(),
            country_stats: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CBroadcast_GetBroadcastViewerStats_Response`
pub mod cbroadcast_get_broadcast_viewer_stats_response {
    // @@protoc_insertion_point(message:CBroadcast_GetBroadcastViewerStats_Response.ViewerStats)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ViewerStats {
        // message fields
        // @@protoc_insertion_point(field:CBroadcast_GetBroadcastViewerStats_Response.ViewerStats.time)
        pub time: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CBroadcast_GetBroadcastViewerStats_Response.ViewerStats.num_viewers)
        pub num_viewers: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CBroadcast_GetBroadcastViewerStats_Response.ViewerStats.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ViewerStats {
        fn default() -> &'a ViewerStats {
            <ViewerStats as ::protobuf::Message>::default_instance()
        }
    }

    impl ViewerStats {
        pub fn new() -> ViewerStats {
            ::std::default::Default::default()
        }

        // optional uint32 time = 1;

        pub fn time(&self) -> u32 {
            self.time.unwrap_or(0)
        }

        pub fn clear_time(&mut self) {
            self.time = ::std::option::Option::None;
        }

        pub fn has_time(&self) -> bool {
            self.time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time(&mut self, v: u32) {
            self.time = ::std::option::Option::Some(v);
        }

        // optional uint32 num_viewers = 2;

        pub fn num_viewers(&self) -> u32 {
            self.num_viewers.unwrap_or(0)
        }

        pub fn clear_num_viewers(&mut self) {
            self.num_viewers = ::std::option::Option::None;
        }

        pub fn has_num_viewers(&self) -> bool {
            self.num_viewers.is_some()
        }

        // Param is passed by value, moved
        pub fn set_num_viewers(&mut self, v: u32) {
            self.num_viewers = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for ViewerStats {
        const NAME: &'static str = "ViewerStats";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.num_viewers = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.time {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.num_viewers {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.time {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.num_viewers {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ViewerStats {
            ViewerStats::new()
        }

        fn clear(&mut self) {
            self.time = ::std::option::Option::None;
            self.num_viewers = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ViewerStats {
            static instance: ViewerStats = ViewerStats {
                time: ::std::option::Option::None,
                num_viewers: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CBroadcast_GetBroadcastViewerStats_Response.CountryStats)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CountryStats {
        // message fields
        // @@protoc_insertion_point(field:CBroadcast_GetBroadcastViewerStats_Response.CountryStats.country_code)
        pub country_code: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CBroadcast_GetBroadcastViewerStats_Response.CountryStats.num_viewers)
        pub num_viewers: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CBroadcast_GetBroadcastViewerStats_Response.CountryStats.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CountryStats {
        fn default() -> &'a CountryStats {
            <CountryStats as ::protobuf::Message>::default_instance()
        }
    }

    impl CountryStats {
        pub fn new() -> CountryStats {
            ::std::default::Default::default()
        }

        // optional string country_code = 1;

        pub fn country_code(&self) -> &str {
            match self.country_code.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_country_code(&mut self) {
            self.country_code = ::std::option::Option::None;
        }

        pub fn has_country_code(&self) -> bool {
            self.country_code.is_some()
        }

        // Param is passed by value, moved
        pub fn set_country_code(&mut self, v: ::std::string::String) {
            self.country_code = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_country_code(&mut self) -> &mut ::std::string::String {
            if self.country_code.is_none() {
                self.country_code = ::std::option::Option::Some(::std::string::String::new());
            }
            self.country_code.as_mut().unwrap()
        }

        // Take field
        pub fn take_country_code(&mut self) -> ::std::string::String {
            self.country_code.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 num_viewers = 2;

        pub fn num_viewers(&self) -> u32 {
            self.num_viewers.unwrap_or(0)
        }

        pub fn clear_num_viewers(&mut self) {
            self.num_viewers = ::std::option::Option::None;
        }

        pub fn has_num_viewers(&self) -> bool {
            self.num_viewers.is_some()
        }

        // Param is passed by value, moved
        pub fn set_num_viewers(&mut self, v: u32) {
            self.num_viewers = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for CountryStats {
        const NAME: &'static str = "CountryStats";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.country_code = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.num_viewers = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.country_code.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.num_viewers {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.country_code.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.num_viewers {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CountryStats {
            CountryStats::new()
        }

        fn clear(&mut self) {
            self.country_code = ::std::option::Option::None;
            self.num_viewers = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CountryStats {
            static instance: CountryStats = CountryStats {
                country_code: ::std::option::Option::None,
                num_viewers: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

#[doc = "Notification from server to client that a viewers state has changed"]
// @@protoc_insertion_point(message:CBroadcast_BroadcastViewerState_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_BroadcastViewerState_Notification {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_BroadcastViewerState_Notification.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_BroadcastViewerState_Notification.state)
    pub state: ::std::option::Option<::protobuf::EnumOrUnknown<cbroadcast_broadcast_viewer_state_notification::EViewerState>>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_BroadcastViewerState_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_BroadcastViewerState_Notification {
    fn default() -> &'a CBroadcast_BroadcastViewerState_Notification {
        <CBroadcast_BroadcastViewerState_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_BroadcastViewerState_Notification {
    pub fn new() -> CBroadcast_BroadcastViewerState_Notification {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional .CBroadcast_BroadcastViewerState_Notification.EViewerState state = 2;

    pub fn state(&self) -> cbroadcast_broadcast_viewer_state_notification::EViewerState {
        match self.state {
            Some(e) => e.enum_value_or(cbroadcast_broadcast_viewer_state_notification::EViewerState::k_EViewerNeedsApproval),
            None => cbroadcast_broadcast_viewer_state_notification::EViewerState::k_EViewerNeedsApproval,
        }
    }

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: cbroadcast_broadcast_viewer_state_notification::EViewerState) {
        self.state = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::protobuf::Message for CBroadcast_BroadcastViewerState_Notification {
    const NAME: &'static str = "CBroadcast_BroadcastViewerState_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.state {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.state {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_BroadcastViewerState_Notification {
        CBroadcast_BroadcastViewerState_Notification::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.state = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_BroadcastViewerState_Notification {
        static instance: CBroadcast_BroadcastViewerState_Notification = CBroadcast_BroadcastViewerState_Notification {
            steamid: ::std::option::Option::None,
            state: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CBroadcast_BroadcastViewerState_Notification`
pub mod cbroadcast_broadcast_viewer_state_notification {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CBroadcast_BroadcastViewerState_Notification.EViewerState)
    pub enum EViewerState {
        // @@protoc_insertion_point(enum_value:CBroadcast_BroadcastViewerState_Notification.EViewerState.k_EViewerNeedsApproval)
        k_EViewerNeedsApproval = 1,
        // @@protoc_insertion_point(enum_value:CBroadcast_BroadcastViewerState_Notification.EViewerState.k_EViewerWatching)
        k_EViewerWatching = 2,
        // @@protoc_insertion_point(enum_value:CBroadcast_BroadcastViewerState_Notification.EViewerState.k_EViewerLeft)
        k_EViewerLeft = 3,
    }

    impl ::protobuf::Enum for EViewerState {
        const NAME: &'static str = "EViewerState";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EViewerState> {
            match value {
                1 => ::std::option::Option::Some(EViewerState::k_EViewerNeedsApproval),
                2 => ::std::option::Option::Some(EViewerState::k_EViewerWatching),
                3 => ::std::option::Option::Some(EViewerState::k_EViewerLeft),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EViewerState> {
            match str {
                "k_EViewerNeedsApproval" => ::std::option::Option::Some(EViewerState::k_EViewerNeedsApproval),
                "k_EViewerWatching" => ::std::option::Option::Some(EViewerState::k_EViewerWatching),
                "k_EViewerLeft" => ::std::option::Option::Some(EViewerState::k_EViewerLeft),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EViewerState] = &[
            EViewerState::k_EViewerNeedsApproval,
            EViewerState::k_EViewerWatching,
            EViewerState::k_EViewerLeft,
        ];
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for EViewerState {
        fn default() -> Self {
            EViewerState::k_EViewerNeedsApproval
        }
    }

}

#[doc = "Notification from server to client one or more users is waiting for user to start broadcast"]
// @@protoc_insertion_point(message:CBroadcast_WaitingBroadcastViewer_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_WaitingBroadcastViewer_Notification {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_WaitingBroadcastViewer_Notification.broadcast_id)
    pub broadcast_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_WaitingBroadcastViewer_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_WaitingBroadcastViewer_Notification {
    fn default() -> &'a CBroadcast_WaitingBroadcastViewer_Notification {
        <CBroadcast_WaitingBroadcastViewer_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_WaitingBroadcastViewer_Notification {
    pub fn new() -> CBroadcast_WaitingBroadcastViewer_Notification {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_id = 1;

    pub fn broadcast_id(&self) -> u64 {
        self.broadcast_id.unwrap_or(0)
    }

    pub fn clear_broadcast_id(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_id(&self) -> bool {
        self.broadcast_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_id(&mut self, v: u64) {
        self.broadcast_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_WaitingBroadcastViewer_Notification {
    const NAME: &'static str = "CBroadcast_WaitingBroadcastViewer_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_WaitingBroadcastViewer_Notification {
        CBroadcast_WaitingBroadcastViewer_Notification::new()
    }

    fn clear(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_WaitingBroadcastViewer_Notification {
        static instance: CBroadcast_WaitingBroadcastViewer_Notification = CBroadcast_WaitingBroadcastViewer_Notification {
            broadcast_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Notification from server to client with information about a broadcast"]
// @@protoc_insertion_point(message:CBroadcast_BroadcastUploadStarted_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_BroadcastUploadStarted_Notification {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_BroadcastUploadStarted_Notification.broadcast_id)
    pub broadcast_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_BroadcastUploadStarted_Notification.upload_token)
    pub upload_token: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBroadcast_BroadcastUploadStarted_Notification.upload_address)
    pub upload_address: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBroadcast_BroadcastUploadStarted_Notification.http_address)
    pub http_address: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBroadcast_BroadcastUploadStarted_Notification.broadcast_upload_id)
    pub broadcast_upload_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_BroadcastUploadStarted_Notification.heartbeat_interval_seconds)
    pub heartbeat_interval_seconds: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CBroadcast_BroadcastUploadStarted_Notification.is_rtmp)
    pub is_rtmp: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_BroadcastUploadStarted_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_BroadcastUploadStarted_Notification {
    fn default() -> &'a CBroadcast_BroadcastUploadStarted_Notification {
        <CBroadcast_BroadcastUploadStarted_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_BroadcastUploadStarted_Notification {
    pub fn new() -> CBroadcast_BroadcastUploadStarted_Notification {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_id = 1;

    pub fn broadcast_id(&self) -> u64 {
        self.broadcast_id.unwrap_or(0)
    }

    pub fn clear_broadcast_id(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_id(&self) -> bool {
        self.broadcast_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_id(&mut self, v: u64) {
        self.broadcast_id = ::std::option::Option::Some(v);
    }

    // optional string upload_token = 2;

    pub fn upload_token(&self) -> &str {
        match self.upload_token.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_upload_token(&mut self) {
        self.upload_token = ::std::option::Option::None;
    }

    pub fn has_upload_token(&self) -> bool {
        self.upload_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upload_token(&mut self, v: ::std::string::String) {
        self.upload_token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_upload_token(&mut self) -> &mut ::std::string::String {
        if self.upload_token.is_none() {
            self.upload_token = ::std::option::Option::Some(::std::string::String::new());
        }
        self.upload_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_upload_token(&mut self) -> ::std::string::String {
        self.upload_token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string upload_address = 3;

    pub fn upload_address(&self) -> &str {
        match self.upload_address.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_upload_address(&mut self) {
        self.upload_address = ::std::option::Option::None;
    }

    pub fn has_upload_address(&self) -> bool {
        self.upload_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upload_address(&mut self, v: ::std::string::String) {
        self.upload_address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_upload_address(&mut self) -> &mut ::std::string::String {
        if self.upload_address.is_none() {
            self.upload_address = ::std::option::Option::Some(::std::string::String::new());
        }
        self.upload_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_upload_address(&mut self) -> ::std::string::String {
        self.upload_address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string http_address = 4;

    pub fn http_address(&self) -> &str {
        match self.http_address.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_http_address(&mut self) {
        self.http_address = ::std::option::Option::None;
    }

    pub fn has_http_address(&self) -> bool {
        self.http_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_http_address(&mut self, v: ::std::string::String) {
        self.http_address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_http_address(&mut self) -> &mut ::std::string::String {
        if self.http_address.is_none() {
            self.http_address = ::std::option::Option::Some(::std::string::String::new());
        }
        self.http_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_http_address(&mut self) -> ::std::string::String {
        self.http_address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 broadcast_upload_id = 5;

    pub fn broadcast_upload_id(&self) -> u64 {
        self.broadcast_upload_id.unwrap_or(0)
    }

    pub fn clear_broadcast_upload_id(&mut self) {
        self.broadcast_upload_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_upload_id(&self) -> bool {
        self.broadcast_upload_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_upload_id(&mut self, v: u64) {
        self.broadcast_upload_id = ::std::option::Option::Some(v);
    }

    // optional uint32 heartbeat_interval_seconds = 6;

    pub fn heartbeat_interval_seconds(&self) -> u32 {
        self.heartbeat_interval_seconds.unwrap_or(0)
    }

    pub fn clear_heartbeat_interval_seconds(&mut self) {
        self.heartbeat_interval_seconds = ::std::option::Option::None;
    }

    pub fn has_heartbeat_interval_seconds(&self) -> bool {
        self.heartbeat_interval_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_heartbeat_interval_seconds(&mut self, v: u32) {
        self.heartbeat_interval_seconds = ::std::option::Option::Some(v);
    }

    // optional bool is_rtmp = 7;

    pub fn is_rtmp(&self) -> bool {
        self.is_rtmp.unwrap_or(false)
    }

    pub fn clear_is_rtmp(&mut self) {
        self.is_rtmp = ::std::option::Option::None;
    }

    pub fn has_is_rtmp(&self) -> bool {
        self.is_rtmp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_rtmp(&mut self, v: bool) {
        self.is_rtmp = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_BroadcastUploadStarted_Notification {
    const NAME: &'static str = "CBroadcast_BroadcastUploadStarted_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    self.upload_token = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.upload_address = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.http_address = ::std::option::Option::Some(is.read_string()?);
                },
                41 => {
                    self.broadcast_upload_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                48 => {
                    self.heartbeat_interval_seconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.is_rtmp = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.upload_token.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.upload_address.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.http_address.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.broadcast_upload_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.heartbeat_interval_seconds {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.is_rtmp {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.upload_token.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.upload_address.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.http_address.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.broadcast_upload_id {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.heartbeat_interval_seconds {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.is_rtmp {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_BroadcastUploadStarted_Notification {
        CBroadcast_BroadcastUploadStarted_Notification::new()
    }

    fn clear(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
        self.upload_token = ::std::option::Option::None;
        self.upload_address = ::std::option::Option::None;
        self.http_address = ::std::option::Option::None;
        self.broadcast_upload_id = ::std::option::Option::None;
        self.heartbeat_interval_seconds = ::std::option::Option::None;
        self.is_rtmp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_BroadcastUploadStarted_Notification {
        static instance: CBroadcast_BroadcastUploadStarted_Notification = CBroadcast_BroadcastUploadStarted_Notification {
            broadcast_id: ::std::option::Option::None,
            upload_token: ::std::option::Option::None,
            upload_address: ::std::option::Option::None,
            http_address: ::std::option::Option::None,
            broadcast_upload_id: ::std::option::Option::None,
            heartbeat_interval_seconds: ::std::option::Option::None,
            is_rtmp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Notification from server to client telling it to stop uploading when the last viewer has disconnected from their broadcast"]
// @@protoc_insertion_point(message:CBroadcast_StopBroadcastUpload_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_StopBroadcastUpload_Notification {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_StopBroadcastUpload_Notification.broadcast_id)
    pub broadcast_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_StopBroadcastUpload_Notification.broadcast_relay_id)
    pub broadcast_relay_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_StopBroadcastUpload_Notification.upload_result)
    pub upload_result: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CBroadcast_StopBroadcastUpload_Notification.too_many_poor_uploads)
    pub too_many_poor_uploads: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_StopBroadcastUpload_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_StopBroadcastUpload_Notification {
    fn default() -> &'a CBroadcast_StopBroadcastUpload_Notification {
        <CBroadcast_StopBroadcastUpload_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_StopBroadcastUpload_Notification {
    pub fn new() -> CBroadcast_StopBroadcastUpload_Notification {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_id = 1;

    pub fn broadcast_id(&self) -> u64 {
        self.broadcast_id.unwrap_or(0)
    }

    pub fn clear_broadcast_id(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_id(&self) -> bool {
        self.broadcast_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_id(&mut self, v: u64) {
        self.broadcast_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 broadcast_relay_id = 2;

    pub fn broadcast_relay_id(&self) -> u64 {
        self.broadcast_relay_id.unwrap_or(0)
    }

    pub fn clear_broadcast_relay_id(&mut self) {
        self.broadcast_relay_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_relay_id(&self) -> bool {
        self.broadcast_relay_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_relay_id(&mut self, v: u64) {
        self.broadcast_relay_id = ::std::option::Option::Some(v);
    }

    // optional uint32 upload_result = 3;

    pub fn upload_result(&self) -> u32 {
        self.upload_result.unwrap_or(0)
    }

    pub fn clear_upload_result(&mut self) {
        self.upload_result = ::std::option::Option::None;
    }

    pub fn has_upload_result(&self) -> bool {
        self.upload_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upload_result(&mut self, v: u32) {
        self.upload_result = ::std::option::Option::Some(v);
    }

    // optional bool too_many_poor_uploads = 4;

    pub fn too_many_poor_uploads(&self) -> bool {
        self.too_many_poor_uploads.unwrap_or(false)
    }

    pub fn clear_too_many_poor_uploads(&mut self) {
        self.too_many_poor_uploads = ::std::option::Option::None;
    }

    pub fn has_too_many_poor_uploads(&self) -> bool {
        self.too_many_poor_uploads.is_some()
    }

    // Param is passed by value, moved
    pub fn set_too_many_poor_uploads(&mut self, v: bool) {
        self.too_many_poor_uploads = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_StopBroadcastUpload_Notification {
    const NAME: &'static str = "CBroadcast_StopBroadcastUpload_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.broadcast_relay_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.upload_result = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.too_many_poor_uploads = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.broadcast_relay_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.upload_result {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.too_many_poor_uploads {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.broadcast_relay_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.upload_result {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.too_many_poor_uploads {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_StopBroadcastUpload_Notification {
        CBroadcast_StopBroadcastUpload_Notification::new()
    }

    fn clear(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
        self.broadcast_relay_id = ::std::option::Option::None;
        self.upload_result = ::std::option::Option::None;
        self.too_many_poor_uploads = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_StopBroadcastUpload_Notification {
        static instance: CBroadcast_StopBroadcastUpload_Notification = CBroadcast_StopBroadcastUpload_Notification {
            broadcast_id: ::std::option::Option::None,
            broadcast_relay_id: ::std::option::Option::None,
            upload_result: ::std::option::Option::None,
            too_many_poor_uploads: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Notification from server to client telling it a session has been closed unexpectedly by the directory"]
// @@protoc_insertion_point(message:CBroadcast_SessionClosed_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_SessionClosed_Notification {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_SessionClosed_Notification.broadcast_id)
    pub broadcast_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_SessionClosed_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_SessionClosed_Notification {
    fn default() -> &'a CBroadcast_SessionClosed_Notification {
        <CBroadcast_SessionClosed_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_SessionClosed_Notification {
    pub fn new() -> CBroadcast_SessionClosed_Notification {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_id = 1;

    pub fn broadcast_id(&self) -> u64 {
        self.broadcast_id.unwrap_or(0)
    }

    pub fn clear_broadcast_id(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_id(&self) -> bool {
        self.broadcast_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_id(&mut self, v: u64) {
        self.broadcast_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_SessionClosed_Notification {
    const NAME: &'static str = "CBroadcast_SessionClosed_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_SessionClosed_Notification {
        CBroadcast_SessionClosed_Notification::new()
    }

    fn clear(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_SessionClosed_Notification {
        static instance: CBroadcast_SessionClosed_Notification = CBroadcast_SessionClosed_Notification {
            broadcast_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Notification from server to client that a broadcaster is inviting a viewer to watch their broadcast"]
// @@protoc_insertion_point(message:CBroadcast_ViewerBroadcastInvite_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_ViewerBroadcastInvite_Notification {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_ViewerBroadcastInvite_Notification.broadcaster_steamid)
    pub broadcaster_steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_ViewerBroadcastInvite_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_ViewerBroadcastInvite_Notification {
    fn default() -> &'a CBroadcast_ViewerBroadcastInvite_Notification {
        <CBroadcast_ViewerBroadcastInvite_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_ViewerBroadcastInvite_Notification {
    pub fn new() -> CBroadcast_ViewerBroadcastInvite_Notification {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcaster_steamid = 1;

    pub fn broadcaster_steamid(&self) -> u64 {
        self.broadcaster_steamid.unwrap_or(0)
    }

    pub fn clear_broadcaster_steamid(&mut self) {
        self.broadcaster_steamid = ::std::option::Option::None;
    }

    pub fn has_broadcaster_steamid(&self) -> bool {
        self.broadcaster_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcaster_steamid(&mut self, v: u64) {
        self.broadcaster_steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_ViewerBroadcastInvite_Notification {
    const NAME: &'static str = "CBroadcast_ViewerBroadcastInvite_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcaster_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcaster_steamid {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcaster_steamid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_ViewerBroadcastInvite_Notification {
        CBroadcast_ViewerBroadcastInvite_Notification::new()
    }

    fn clear(&mut self) {
        self.broadcaster_steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_ViewerBroadcastInvite_Notification {
        static instance: CBroadcast_ViewerBroadcastInvite_Notification = CBroadcast_ViewerBroadcastInvite_Notification {
            broadcaster_steamid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Notification from server to client about current broadcast status"]
// @@protoc_insertion_point(message:CBroadcast_BroadcastStatus_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_BroadcastStatus_Notification {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_BroadcastStatus_Notification.broadcast_id)
    pub broadcast_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_BroadcastStatus_Notification.num_viewers)
    pub num_viewers: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_BroadcastStatus_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_BroadcastStatus_Notification {
    fn default() -> &'a CBroadcast_BroadcastStatus_Notification {
        <CBroadcast_BroadcastStatus_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_BroadcastStatus_Notification {
    pub fn new() -> CBroadcast_BroadcastStatus_Notification {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_id = 1;

    pub fn broadcast_id(&self) -> u64 {
        self.broadcast_id.unwrap_or(0)
    }

    pub fn clear_broadcast_id(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_id(&self) -> bool {
        self.broadcast_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_id(&mut self, v: u64) {
        self.broadcast_id = ::std::option::Option::Some(v);
    }

    // optional int32 num_viewers = 2;

    pub fn num_viewers(&self) -> i32 {
        self.num_viewers.unwrap_or(0)
    }

    pub fn clear_num_viewers(&mut self) {
        self.num_viewers = ::std::option::Option::None;
    }

    pub fn has_num_viewers(&self) -> bool {
        self.num_viewers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_viewers(&mut self, v: i32) {
        self.num_viewers = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_BroadcastStatus_Notification {
    const NAME: &'static str = "CBroadcast_BroadcastStatus_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.num_viewers = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.num_viewers {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.num_viewers {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_BroadcastStatus_Notification {
        CBroadcast_BroadcastStatus_Notification::new()
    }

    fn clear(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
        self.num_viewers = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_BroadcastStatus_Notification {
        static instance: CBroadcast_BroadcastStatus_Notification = CBroadcast_BroadcastStatus_Notification {
            broadcast_id: ::std::option::Option::None,
            num_viewers: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Notification from server to client about current broadcast status"]
// @@protoc_insertion_point(message:CBroadcast_BroadcastChannelLive_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_BroadcastChannelLive_Notification {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_BroadcastChannelLive_Notification.broadcast_channel_id)
    pub broadcast_channel_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_BroadcastChannelLive_Notification.broadcast_channel_name)
    pub broadcast_channel_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBroadcast_BroadcastChannelLive_Notification.broadcast_channel_avatar)
    pub broadcast_channel_avatar: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_BroadcastChannelLive_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_BroadcastChannelLive_Notification {
    fn default() -> &'a CBroadcast_BroadcastChannelLive_Notification {
        <CBroadcast_BroadcastChannelLive_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_BroadcastChannelLive_Notification {
    pub fn new() -> CBroadcast_BroadcastChannelLive_Notification {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_channel_id = 1;

    pub fn broadcast_channel_id(&self) -> u64 {
        self.broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_broadcast_channel_id(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_id(&self) -> bool {
        self.broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_id(&mut self, v: u64) {
        self.broadcast_channel_id = ::std::option::Option::Some(v);
    }

    // optional string broadcast_channel_name = 2;

    pub fn broadcast_channel_name(&self) -> &str {
        match self.broadcast_channel_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_broadcast_channel_name(&mut self) {
        self.broadcast_channel_name = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_name(&self) -> bool {
        self.broadcast_channel_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_name(&mut self, v: ::std::string::String) {
        self.broadcast_channel_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_broadcast_channel_name(&mut self) -> &mut ::std::string::String {
        if self.broadcast_channel_name.is_none() {
            self.broadcast_channel_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.broadcast_channel_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_broadcast_channel_name(&mut self) -> ::std::string::String {
        self.broadcast_channel_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string broadcast_channel_avatar = 3;

    pub fn broadcast_channel_avatar(&self) -> &str {
        match self.broadcast_channel_avatar.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_broadcast_channel_avatar(&mut self) {
        self.broadcast_channel_avatar = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_avatar(&self) -> bool {
        self.broadcast_channel_avatar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_avatar(&mut self, v: ::std::string::String) {
        self.broadcast_channel_avatar = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_broadcast_channel_avatar(&mut self) -> &mut ::std::string::String {
        if self.broadcast_channel_avatar.is_none() {
            self.broadcast_channel_avatar = ::std::option::Option::Some(::std::string::String::new());
        }
        self.broadcast_channel_avatar.as_mut().unwrap()
    }

    // Take field
    pub fn take_broadcast_channel_avatar(&mut self) -> ::std::string::String {
        self.broadcast_channel_avatar.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CBroadcast_BroadcastChannelLive_Notification {
    const NAME: &'static str = "CBroadcast_BroadcastChannelLive_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_channel_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    self.broadcast_channel_name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.broadcast_channel_avatar = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_channel_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.broadcast_channel_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.broadcast_channel_avatar.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast_channel_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.broadcast_channel_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.broadcast_channel_avatar.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_BroadcastChannelLive_Notification {
        CBroadcast_BroadcastChannelLive_Notification::new()
    }

    fn clear(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
        self.broadcast_channel_name = ::std::option::Option::None;
        self.broadcast_channel_avatar = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_BroadcastChannelLive_Notification {
        static instance: CBroadcast_BroadcastChannelLive_Notification = CBroadcast_BroadcastChannelLive_Notification {
            broadcast_channel_id: ::std::option::Option::None,
            broadcast_channel_name: ::std::option::Option::None,
            broadcast_channel_avatar: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Send thumbnails to relay"]
// @@protoc_insertion_point(message:CBroadcast_SendThumbnailToRelay_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_SendThumbnailToRelay_Notification {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_SendThumbnailToRelay_Notification.thumbnail_upload_token)
    pub thumbnail_upload_token: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBroadcast_SendThumbnailToRelay_Notification.thumbnail_broadcast_session_id)
    pub thumbnail_broadcast_session_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_SendThumbnailToRelay_Notification.thumbnail_data)
    pub thumbnail_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CBroadcast_SendThumbnailToRelay_Notification.thumbnail_width)
    pub thumbnail_width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CBroadcast_SendThumbnailToRelay_Notification.thumbnail_height)
    pub thumbnail_height: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_SendThumbnailToRelay_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_SendThumbnailToRelay_Notification {
    fn default() -> &'a CBroadcast_SendThumbnailToRelay_Notification {
        <CBroadcast_SendThumbnailToRelay_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_SendThumbnailToRelay_Notification {
    pub fn new() -> CBroadcast_SendThumbnailToRelay_Notification {
        ::std::default::Default::default()
    }

    // optional string thumbnail_upload_token = 1;

    pub fn thumbnail_upload_token(&self) -> &str {
        match self.thumbnail_upload_token.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_thumbnail_upload_token(&mut self) {
        self.thumbnail_upload_token = ::std::option::Option::None;
    }

    pub fn has_thumbnail_upload_token(&self) -> bool {
        self.thumbnail_upload_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnail_upload_token(&mut self, v: ::std::string::String) {
        self.thumbnail_upload_token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnail_upload_token(&mut self) -> &mut ::std::string::String {
        if self.thumbnail_upload_token.is_none() {
            self.thumbnail_upload_token = ::std::option::Option::Some(::std::string::String::new());
        }
        self.thumbnail_upload_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnail_upload_token(&mut self) -> ::std::string::String {
        self.thumbnail_upload_token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 thumbnail_broadcast_session_id = 2;

    pub fn thumbnail_broadcast_session_id(&self) -> u64 {
        self.thumbnail_broadcast_session_id.unwrap_or(0)
    }

    pub fn clear_thumbnail_broadcast_session_id(&mut self) {
        self.thumbnail_broadcast_session_id = ::std::option::Option::None;
    }

    pub fn has_thumbnail_broadcast_session_id(&self) -> bool {
        self.thumbnail_broadcast_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnail_broadcast_session_id(&mut self, v: u64) {
        self.thumbnail_broadcast_session_id = ::std::option::Option::Some(v);
    }

    // optional bytes thumbnail_data = 3;

    pub fn thumbnail_data(&self) -> &[u8] {
        match self.thumbnail_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_thumbnail_data(&mut self) {
        self.thumbnail_data = ::std::option::Option::None;
    }

    pub fn has_thumbnail_data(&self) -> bool {
        self.thumbnail_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnail_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.thumbnail_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnail_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.thumbnail_data.is_none() {
            self.thumbnail_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.thumbnail_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnail_data(&mut self) -> ::std::vec::Vec<u8> {
        self.thumbnail_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 thumbnail_width = 4;

    pub fn thumbnail_width(&self) -> u32 {
        self.thumbnail_width.unwrap_or(0)
    }

    pub fn clear_thumbnail_width(&mut self) {
        self.thumbnail_width = ::std::option::Option::None;
    }

    pub fn has_thumbnail_width(&self) -> bool {
        self.thumbnail_width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnail_width(&mut self, v: u32) {
        self.thumbnail_width = ::std::option::Option::Some(v);
    }

    // optional uint32 thumbnail_height = 5;

    pub fn thumbnail_height(&self) -> u32 {
        self.thumbnail_height.unwrap_or(0)
    }

    pub fn clear_thumbnail_height(&mut self) {
        self.thumbnail_height = ::std::option::Option::None;
    }

    pub fn has_thumbnail_height(&self) -> bool {
        self.thumbnail_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnail_height(&mut self, v: u32) {
        self.thumbnail_height = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_SendThumbnailToRelay_Notification {
    const NAME: &'static str = "CBroadcast_SendThumbnailToRelay_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.thumbnail_upload_token = ::std::option::Option::Some(is.read_string()?);
                },
                17 => {
                    self.thumbnail_broadcast_session_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    self.thumbnail_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                32 => {
                    self.thumbnail_width = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.thumbnail_height = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.thumbnail_upload_token.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.thumbnail_broadcast_session_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.thumbnail_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.thumbnail_width {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.thumbnail_height {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.thumbnail_upload_token.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.thumbnail_broadcast_session_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.thumbnail_data.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.thumbnail_width {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.thumbnail_height {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_SendThumbnailToRelay_Notification {
        CBroadcast_SendThumbnailToRelay_Notification::new()
    }

    fn clear(&mut self) {
        self.thumbnail_upload_token = ::std::option::Option::None;
        self.thumbnail_broadcast_session_id = ::std::option::Option::None;
        self.thumbnail_data = ::std::option::Option::None;
        self.thumbnail_width = ::std::option::Option::None;
        self.thumbnail_height = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_SendThumbnailToRelay_Notification {
        static instance: CBroadcast_SendThumbnailToRelay_Notification = CBroadcast_SendThumbnailToRelay_Notification {
            thumbnail_upload_token: ::std::option::Option::None,
            thumbnail_broadcast_session_id: ::std::option::Option::None,
            thumbnail_data: ::std::option::Option::None,
            thumbnail_width: ::std::option::Option::None,
            thumbnail_height: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Notification from server to client that it needs the client's TURN server"]
// @@protoc_insertion_point(message:CBroadcast_WebRTCNeedTURNServer_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_WebRTCNeedTURNServer_Notification {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_WebRTCNeedTURNServer_Notification.broadcast_session_id)
    pub broadcast_session_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_WebRTCNeedTURNServer_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_WebRTCNeedTURNServer_Notification {
    fn default() -> &'a CBroadcast_WebRTCNeedTURNServer_Notification {
        <CBroadcast_WebRTCNeedTURNServer_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_WebRTCNeedTURNServer_Notification {
    pub fn new() -> CBroadcast_WebRTCNeedTURNServer_Notification {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_session_id = 1;

    pub fn broadcast_session_id(&self) -> u64 {
        self.broadcast_session_id.unwrap_or(0)
    }

    pub fn clear_broadcast_session_id(&mut self) {
        self.broadcast_session_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_session_id(&self) -> bool {
        self.broadcast_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_session_id(&mut self, v: u64) {
        self.broadcast_session_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_WebRTCNeedTURNServer_Notification {
    const NAME: &'static str = "CBroadcast_WebRTCNeedTURNServer_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_session_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_session_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast_session_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_WebRTCNeedTURNServer_Notification {
        CBroadcast_WebRTCNeedTURNServer_Notification::new()
    }

    fn clear(&mut self) {
        self.broadcast_session_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_WebRTCNeedTURNServer_Notification {
        static instance: CBroadcast_WebRTCNeedTURNServer_Notification = CBroadcast_WebRTCNeedTURNServer_Notification {
            broadcast_session_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Notification from server to client that it should start a WebRTC session"]
// @@protoc_insertion_point(message:CBroadcast_WebRTCStart_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_WebRTCStart_Notification {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_WebRTCStart_Notification.broadcast_session_id)
    pub broadcast_session_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_WebRTCStart_Notification.webrtc_session_id)
    pub webrtc_session_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_WebRTCStart_Notification.viewer_steamid)
    pub viewer_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_WebRTCStart_Notification.viewer_token)
    pub viewer_token: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_WebRTCStart_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_WebRTCStart_Notification {
    fn default() -> &'a CBroadcast_WebRTCStart_Notification {
        <CBroadcast_WebRTCStart_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_WebRTCStart_Notification {
    pub fn new() -> CBroadcast_WebRTCStart_Notification {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_session_id = 1;

    pub fn broadcast_session_id(&self) -> u64 {
        self.broadcast_session_id.unwrap_or(0)
    }

    pub fn clear_broadcast_session_id(&mut self) {
        self.broadcast_session_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_session_id(&self) -> bool {
        self.broadcast_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_session_id(&mut self, v: u64) {
        self.broadcast_session_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 webrtc_session_id = 2;

    pub fn webrtc_session_id(&self) -> u64 {
        self.webrtc_session_id.unwrap_or(0)
    }

    pub fn clear_webrtc_session_id(&mut self) {
        self.webrtc_session_id = ::std::option::Option::None;
    }

    pub fn has_webrtc_session_id(&self) -> bool {
        self.webrtc_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_webrtc_session_id(&mut self, v: u64) {
        self.webrtc_session_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 viewer_steamid = 3;

    pub fn viewer_steamid(&self) -> u64 {
        self.viewer_steamid.unwrap_or(0)
    }

    pub fn clear_viewer_steamid(&mut self) {
        self.viewer_steamid = ::std::option::Option::None;
    }

    pub fn has_viewer_steamid(&self) -> bool {
        self.viewer_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_viewer_steamid(&mut self, v: u64) {
        self.viewer_steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 viewer_token = 4;

    pub fn viewer_token(&self) -> u64 {
        self.viewer_token.unwrap_or(0)
    }

    pub fn clear_viewer_token(&mut self) {
        self.viewer_token = ::std::option::Option::None;
    }

    pub fn has_viewer_token(&self) -> bool {
        self.viewer_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_viewer_token(&mut self, v: u64) {
        self.viewer_token = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_WebRTCStart_Notification {
    const NAME: &'static str = "CBroadcast_WebRTCStart_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_session_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.webrtc_session_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.viewer_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                33 => {
                    self.viewer_token = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_session_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.webrtc_session_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.viewer_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.viewer_token {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast_session_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.webrtc_session_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.viewer_steamid {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.viewer_token {
            os.write_fixed64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_WebRTCStart_Notification {
        CBroadcast_WebRTCStart_Notification::new()
    }

    fn clear(&mut self) {
        self.broadcast_session_id = ::std::option::Option::None;
        self.webrtc_session_id = ::std::option::Option::None;
        self.viewer_steamid = ::std::option::Option::None;
        self.viewer_token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_WebRTCStart_Notification {
        static instance: CBroadcast_WebRTCStart_Notification = CBroadcast_WebRTCStart_Notification {
            broadcast_session_id: ::std::option::Option::None,
            webrtc_session_id: ::std::option::Option::None,
            viewer_steamid: ::std::option::Option::None,
            viewer_token: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Notification from server to client about the broadcast viewer WebRTC answer"]
// @@protoc_insertion_point(message:CBroadcast_WebRTCSetAnswer_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_WebRTCSetAnswer_Notification {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_WebRTCSetAnswer_Notification.broadcast_session_id)
    pub broadcast_session_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_WebRTCSetAnswer_Notification.webrtc_session_id)
    pub webrtc_session_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_WebRTCSetAnswer_Notification.answer)
    pub answer: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_WebRTCSetAnswer_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_WebRTCSetAnswer_Notification {
    fn default() -> &'a CBroadcast_WebRTCSetAnswer_Notification {
        <CBroadcast_WebRTCSetAnswer_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_WebRTCSetAnswer_Notification {
    pub fn new() -> CBroadcast_WebRTCSetAnswer_Notification {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_session_id = 1;

    pub fn broadcast_session_id(&self) -> u64 {
        self.broadcast_session_id.unwrap_or(0)
    }

    pub fn clear_broadcast_session_id(&mut self) {
        self.broadcast_session_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_session_id(&self) -> bool {
        self.broadcast_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_session_id(&mut self, v: u64) {
        self.broadcast_session_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 webrtc_session_id = 2;

    pub fn webrtc_session_id(&self) -> u64 {
        self.webrtc_session_id.unwrap_or(0)
    }

    pub fn clear_webrtc_session_id(&mut self) {
        self.webrtc_session_id = ::std::option::Option::None;
    }

    pub fn has_webrtc_session_id(&self) -> bool {
        self.webrtc_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_webrtc_session_id(&mut self, v: u64) {
        self.webrtc_session_id = ::std::option::Option::Some(v);
    }

    // optional string answer = 3;

    pub fn answer(&self) -> &str {
        match self.answer.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_answer(&mut self) {
        self.answer = ::std::option::Option::None;
    }

    pub fn has_answer(&self) -> bool {
        self.answer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_answer(&mut self, v: ::std::string::String) {
        self.answer = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_answer(&mut self) -> &mut ::std::string::String {
        if self.answer.is_none() {
            self.answer = ::std::option::Option::Some(::std::string::String::new());
        }
        self.answer.as_mut().unwrap()
    }

    // Take field
    pub fn take_answer(&mut self) -> ::std::string::String {
        self.answer.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CBroadcast_WebRTCSetAnswer_Notification {
    const NAME: &'static str = "CBroadcast_WebRTCSetAnswer_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_session_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.webrtc_session_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    self.answer = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_session_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.webrtc_session_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.answer.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast_session_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.webrtc_session_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.answer.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_WebRTCSetAnswer_Notification {
        CBroadcast_WebRTCSetAnswer_Notification::new()
    }

    fn clear(&mut self) {
        self.broadcast_session_id = ::std::option::Option::None;
        self.webrtc_session_id = ::std::option::Option::None;
        self.answer = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_WebRTCSetAnswer_Notification {
        static instance: CBroadcast_WebRTCSetAnswer_Notification = CBroadcast_WebRTCSetAnswer_Notification {
            broadcast_session_id: ::std::option::Option::None,
            webrtc_session_id: ::std::option::Option::None,
            answer: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[doc = "Notification from server to client about a broadcast viewer WebRTC ICE candidate"]
// @@protoc_insertion_point(message:CBroadcast_WebRTCAddViewerCandidate_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_WebRTCAddViewerCandidate_Notification {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_WebRTCAddViewerCandidate_Notification.broadcast_session_id)
    pub broadcast_session_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_WebRTCAddViewerCandidate_Notification.webrtc_session_id)
    pub webrtc_session_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_WebRTCAddViewerCandidate_Notification.candidate)
    pub candidate: ::protobuf::MessageField<CBroadcast_WebRTC_Candidate>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_WebRTCAddViewerCandidate_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_WebRTCAddViewerCandidate_Notification {
    fn default() -> &'a CBroadcast_WebRTCAddViewerCandidate_Notification {
        <CBroadcast_WebRTCAddViewerCandidate_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_WebRTCAddViewerCandidate_Notification {
    pub fn new() -> CBroadcast_WebRTCAddViewerCandidate_Notification {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_session_id = 1;

    pub fn broadcast_session_id(&self) -> u64 {
        self.broadcast_session_id.unwrap_or(0)
    }

    pub fn clear_broadcast_session_id(&mut self) {
        self.broadcast_session_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_session_id(&self) -> bool {
        self.broadcast_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_session_id(&mut self, v: u64) {
        self.broadcast_session_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 webrtc_session_id = 2;

    pub fn webrtc_session_id(&self) -> u64 {
        self.webrtc_session_id.unwrap_or(0)
    }

    pub fn clear_webrtc_session_id(&mut self) {
        self.webrtc_session_id = ::std::option::Option::None;
    }

    pub fn has_webrtc_session_id(&self) -> bool {
        self.webrtc_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_webrtc_session_id(&mut self, v: u64) {
        self.webrtc_session_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_WebRTCAddViewerCandidate_Notification {
    const NAME: &'static str = "CBroadcast_WebRTCAddViewerCandidate_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_session_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.webrtc_session_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.candidate)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_session_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.webrtc_session_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.candidate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast_session_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.webrtc_session_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.candidate.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_WebRTCAddViewerCandidate_Notification {
        CBroadcast_WebRTCAddViewerCandidate_Notification::new()
    }

    fn clear(&mut self) {
        self.broadcast_session_id = ::std::option::Option::None;
        self.webrtc_session_id = ::std::option::Option::None;
        self.candidate.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_WebRTCAddViewerCandidate_Notification {
        static instance: CBroadcast_WebRTCAddViewerCandidate_Notification = CBroadcast_WebRTCAddViewerCandidate_Notification {
            broadcast_session_id: ::std::option::Option::None,
            webrtc_session_id: ::std::option::Option::None,
            candidate: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EBroadcastWatchLocation)
pub enum EBroadcastWatchLocation {
    // @@protoc_insertion_point(enum_value:EBroadcastWatchLocation.k_EBroadcastWatchLocation_Invalid)
    k_EBroadcastWatchLocation_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EBroadcastWatchLocation.k_EBroadcastWatchLocation_SteamTV_Tab)
    k_EBroadcastWatchLocation_SteamTV_Tab = 1,
    // @@protoc_insertion_point(enum_value:EBroadcastWatchLocation.k_EBroadcastWatchLocation_SteamTV_WatchParty)
    k_EBroadcastWatchLocation_SteamTV_WatchParty = 2,
    // @@protoc_insertion_point(enum_value:EBroadcastWatchLocation.k_EBroadcastWatchLocation_Chat_Tab)
    k_EBroadcastWatchLocation_Chat_Tab = 3,
    // @@protoc_insertion_point(enum_value:EBroadcastWatchLocation.k_EBroadcastWatchLocation_Chat_WatchParty)
    k_EBroadcastWatchLocation_Chat_WatchParty = 4,
    // @@protoc_insertion_point(enum_value:EBroadcastWatchLocation.k_EBroadcastWatchLocation_CommunityPage)
    k_EBroadcastWatchLocation_CommunityPage = 5,
    // @@protoc_insertion_point(enum_value:EBroadcastWatchLocation.k_EBroadcastWatchLocation_StoreAppPage)
    k_EBroadcastWatchLocation_StoreAppPage = 6,
    // @@protoc_insertion_point(enum_value:EBroadcastWatchLocation.k_EBroadcastWatchLocation_InGame)
    k_EBroadcastWatchLocation_InGame = 7,
    // @@protoc_insertion_point(enum_value:EBroadcastWatchLocation.k_EBroadcastWatchLocation_BigPicture)
    k_EBroadcastWatchLocation_BigPicture = 8,
    // @@protoc_insertion_point(enum_value:EBroadcastWatchLocation.k_EBroadcastWatchLocation_SalesPage)
    k_EBroadcastWatchLocation_SalesPage = 9,
    // @@protoc_insertion_point(enum_value:EBroadcastWatchLocation.k_EBroadcastWatchLocation_CuratorPage)
    k_EBroadcastWatchLocation_CuratorPage = 10,
    // @@protoc_insertion_point(enum_value:EBroadcastWatchLocation.k_EBroadcastWatchLocation_DeveloperPage)
    k_EBroadcastWatchLocation_DeveloperPage = 11,
    // @@protoc_insertion_point(enum_value:EBroadcastWatchLocation.k_EBroadcastWatchLocation_Chat_Friends)
    k_EBroadcastWatchLocation_Chat_Friends = 12,
    // @@protoc_insertion_point(enum_value:EBroadcastWatchLocation.k_EBroadcastWatchLocation_SteamTV_Web)
    k_EBroadcastWatchLocation_SteamTV_Web = 13,
    // @@protoc_insertion_point(enum_value:EBroadcastWatchLocation.k_EBroadcastWatchLocation_DesktopUI_Overlay)
    k_EBroadcastWatchLocation_DesktopUI_Overlay = 14,
}

impl ::protobuf::Enum for EBroadcastWatchLocation {
    const NAME: &'static str = "EBroadcastWatchLocation";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EBroadcastWatchLocation> {
        match value {
            0 => ::std::option::Option::Some(EBroadcastWatchLocation::k_EBroadcastWatchLocation_Invalid),
            1 => ::std::option::Option::Some(EBroadcastWatchLocation::k_EBroadcastWatchLocation_SteamTV_Tab),
            2 => ::std::option::Option::Some(EBroadcastWatchLocation::k_EBroadcastWatchLocation_SteamTV_WatchParty),
            3 => ::std::option::Option::Some(EBroadcastWatchLocation::k_EBroadcastWatchLocation_Chat_Tab),
            4 => ::std::option::Option::Some(EBroadcastWatchLocation::k_EBroadcastWatchLocation_Chat_WatchParty),
            5 => ::std::option::Option::Some(EBroadcastWatchLocation::k_EBroadcastWatchLocation_CommunityPage),
            6 => ::std::option::Option::Some(EBroadcastWatchLocation::k_EBroadcastWatchLocation_StoreAppPage),
            7 => ::std::option::Option::Some(EBroadcastWatchLocation::k_EBroadcastWatchLocation_InGame),
            8 => ::std::option::Option::Some(EBroadcastWatchLocation::k_EBroadcastWatchLocation_BigPicture),
            9 => ::std::option::Option::Some(EBroadcastWatchLocation::k_EBroadcastWatchLocation_SalesPage),
            10 => ::std::option::Option::Some(EBroadcastWatchLocation::k_EBroadcastWatchLocation_CuratorPage),
            11 => ::std::option::Option::Some(EBroadcastWatchLocation::k_EBroadcastWatchLocation_DeveloperPage),
            12 => ::std::option::Option::Some(EBroadcastWatchLocation::k_EBroadcastWatchLocation_Chat_Friends),
            13 => ::std::option::Option::Some(EBroadcastWatchLocation::k_EBroadcastWatchLocation_SteamTV_Web),
            14 => ::std::option::Option::Some(EBroadcastWatchLocation::k_EBroadcastWatchLocation_DesktopUI_Overlay),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EBroadcastWatchLocation> {
        match str {
            "k_EBroadcastWatchLocation_Invalid" => ::std::option::Option::Some(EBroadcastWatchLocation::k_EBroadcastWatchLocation_Invalid),
            "k_EBroadcastWatchLocation_SteamTV_Tab" => ::std::option::Option::Some(EBroadcastWatchLocation::k_EBroadcastWatchLocation_SteamTV_Tab),
            "k_EBroadcastWatchLocation_SteamTV_WatchParty" => ::std::option::Option::Some(EBroadcastWatchLocation::k_EBroadcastWatchLocation_SteamTV_WatchParty),
            "k_EBroadcastWatchLocation_Chat_Tab" => ::std::option::Option::Some(EBroadcastWatchLocation::k_EBroadcastWatchLocation_Chat_Tab),
            "k_EBroadcastWatchLocation_Chat_WatchParty" => ::std::option::Option::Some(EBroadcastWatchLocation::k_EBroadcastWatchLocation_Chat_WatchParty),
            "k_EBroadcastWatchLocation_CommunityPage" => ::std::option::Option::Some(EBroadcastWatchLocation::k_EBroadcastWatchLocation_CommunityPage),
            "k_EBroadcastWatchLocation_StoreAppPage" => ::std::option::Option::Some(EBroadcastWatchLocation::k_EBroadcastWatchLocation_StoreAppPage),
            "k_EBroadcastWatchLocation_InGame" => ::std::option::Option::Some(EBroadcastWatchLocation::k_EBroadcastWatchLocation_InGame),
            "k_EBroadcastWatchLocation_BigPicture" => ::std::option::Option::Some(EBroadcastWatchLocation::k_EBroadcastWatchLocation_BigPicture),
            "k_EBroadcastWatchLocation_SalesPage" => ::std::option::Option::Some(EBroadcastWatchLocation::k_EBroadcastWatchLocation_SalesPage),
            "k_EBroadcastWatchLocation_CuratorPage" => ::std::option::Option::Some(EBroadcastWatchLocation::k_EBroadcastWatchLocation_CuratorPage),
            "k_EBroadcastWatchLocation_DeveloperPage" => ::std::option::Option::Some(EBroadcastWatchLocation::k_EBroadcastWatchLocation_DeveloperPage),
            "k_EBroadcastWatchLocation_Chat_Friends" => ::std::option::Option::Some(EBroadcastWatchLocation::k_EBroadcastWatchLocation_Chat_Friends),
            "k_EBroadcastWatchLocation_SteamTV_Web" => ::std::option::Option::Some(EBroadcastWatchLocation::k_EBroadcastWatchLocation_SteamTV_Web),
            "k_EBroadcastWatchLocation_DesktopUI_Overlay" => ::std::option::Option::Some(EBroadcastWatchLocation::k_EBroadcastWatchLocation_DesktopUI_Overlay),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EBroadcastWatchLocation] = &[
        EBroadcastWatchLocation::k_EBroadcastWatchLocation_Invalid,
        EBroadcastWatchLocation::k_EBroadcastWatchLocation_SteamTV_Tab,
        EBroadcastWatchLocation::k_EBroadcastWatchLocation_SteamTV_WatchParty,
        EBroadcastWatchLocation::k_EBroadcastWatchLocation_Chat_Tab,
        EBroadcastWatchLocation::k_EBroadcastWatchLocation_Chat_WatchParty,
        EBroadcastWatchLocation::k_EBroadcastWatchLocation_CommunityPage,
        EBroadcastWatchLocation::k_EBroadcastWatchLocation_StoreAppPage,
        EBroadcastWatchLocation::k_EBroadcastWatchLocation_InGame,
        EBroadcastWatchLocation::k_EBroadcastWatchLocation_BigPicture,
        EBroadcastWatchLocation::k_EBroadcastWatchLocation_SalesPage,
        EBroadcastWatchLocation::k_EBroadcastWatchLocation_CuratorPage,
        EBroadcastWatchLocation::k_EBroadcastWatchLocation_DeveloperPage,
        EBroadcastWatchLocation::k_EBroadcastWatchLocation_Chat_Friends,
        EBroadcastWatchLocation::k_EBroadcastWatchLocation_SteamTV_Web,
        EBroadcastWatchLocation::k_EBroadcastWatchLocation_DesktopUI_Overlay,
    ];
}

impl ::std::default::Default for EBroadcastWatchLocation {
    fn default() -> Self {
        EBroadcastWatchLocation::k_EBroadcastWatchLocation_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EBroadcastChatPermission)
pub enum EBroadcastChatPermission {
    // @@protoc_insertion_point(enum_value:EBroadcastChatPermission.k_EBroadcastChatPermissionPublic)
    k_EBroadcastChatPermissionPublic = 0,
    // @@protoc_insertion_point(enum_value:EBroadcastChatPermission.k_EBroadcastChatPermissionOwnsApp)
    k_EBroadcastChatPermissionOwnsApp = 1,
}

impl ::protobuf::Enum for EBroadcastChatPermission {
    const NAME: &'static str = "EBroadcastChatPermission";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EBroadcastChatPermission> {
        match value {
            0 => ::std::option::Option::Some(EBroadcastChatPermission::k_EBroadcastChatPermissionPublic),
            1 => ::std::option::Option::Some(EBroadcastChatPermission::k_EBroadcastChatPermissionOwnsApp),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EBroadcastChatPermission> {
        match str {
            "k_EBroadcastChatPermissionPublic" => ::std::option::Option::Some(EBroadcastChatPermission::k_EBroadcastChatPermissionPublic),
            "k_EBroadcastChatPermissionOwnsApp" => ::std::option::Option::Some(EBroadcastChatPermission::k_EBroadcastChatPermissionOwnsApp),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EBroadcastChatPermission] = &[
        EBroadcastChatPermission::k_EBroadcastChatPermissionPublic,
        EBroadcastChatPermission::k_EBroadcastChatPermissionOwnsApp,
    ];
}

impl ::std::default::Default for EBroadcastChatPermission {
    fn default() -> Self {
        EBroadcastChatPermission::k_EBroadcastChatPermissionPublic
    }
}

#[allow(unused_imports)]
use crate::steammessages_base::*;
#[allow(unused_imports)]
use crate::steammessages_unified_base_steamclient::*;
impl crate::RpcMessage for CBroadcast_BeginBroadcastSession_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_BeginBroadcastSession_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_EndBroadcastSession_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_EndBroadcastSession_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_StartBroadcastUpload_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_StartBroadcastUpload_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_NotifyBroadcastUploadStop_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_WatchBroadcast_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_WatchBroadcast_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_HeartbeatBroadcast_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_StopWatchingBroadcast_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_GetBroadcastStatus_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_GetBroadcastStatus_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_GetBroadcastThumbnail_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_GetBroadcastThumbnail_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_InviteToBroadcast_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_InviteToBroadcast_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_SendBroadcastStateToServer_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_SendBroadcastStateToServer_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_NotifyBroadcastSessionHeartbeat_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_GetBroadcastChatInfo_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_GetBroadcastChatInfo_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_PostChatMessage_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_PostChatMessage_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_UpdateChatMessageFlair_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_UpdateChatMessageFlair_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_MuteBroadcastChatUser_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_MuteBroadcastChatUser_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_RemoveUserChatText_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_RemoveUserChatText_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_GetBroadcastChatUserNames_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_GetBroadcastChatUserNames_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_StartBuildClip_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_StartBuildClip_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_GetBuildClipStatus_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_GetBuildClipStatus_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_SetClipDetails_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_SetClipDetails_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_GetClipDetails_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_GetClipDetails_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_SetRTMPInfo_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_SetRTMPInfo_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_GetRTMPInfo_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_GetRTMPInfo_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_WebRTCHaveTURNServer_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_WebRTCStartResult_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_WebRTCStartResult_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_WebRTCStopped_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_WebRTCStopped_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_WebRTCSetAnswer_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_WebRTCSetAnswer_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_WebRTCLookupTURNServer_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_WebRTCLookupTURNServer_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_WebRTC_Candidate {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_WebRTCAddHostCandidate_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_WebRTCAddHostCandidate_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_WebRTCAddViewerCandidate_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_WebRTCAddViewerCandidate_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_WebRTCGetHostCandidates_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_WebRTCGetHostCandidates_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_GetBroadcastUploadStats_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_GetBroadcastUploadStats_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_GetBroadcastViewerStats_Request {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_GetBroadcastViewerStats_Response {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_BroadcastViewerState_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_WaitingBroadcastViewer_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_BroadcastUploadStarted_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_StopBroadcastUpload_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_SessionClosed_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_ViewerBroadcastInvite_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_BroadcastStatus_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_BroadcastChannelLive_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_SendThumbnailToRelay_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_WebRTCNeedTURNServer_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_WebRTCStart_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_WebRTCSetAnswer_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBroadcast_WebRTCAddViewerCandidate_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
///Methods for Steam broadcast operations
struct Broadcast {}
impl crate::RpcService for Broadcast {
    const SERVICE_NAME: &'static str = "Broadcast";
}
///
struct BroadcastClient {}
impl crate::RpcService for BroadcastClient {
    const SERVICE_NAME: &'static str = "BroadcastClient";
}
impl crate::RpcMethod for CBroadcast_BeginBroadcastSession_Request {
    const METHOD_NAME: &'static str = "Broadcast.BeginBroadcastSession#1";
    type Response = CBroadcast_BeginBroadcastSession_Response;
}
impl crate::RpcMethod for CBroadcast_BroadcastChannelLive_Notification {
    const METHOD_NAME: &'static str = "BroadcastClient.NotifyBroadcastChannelLive#1";
    type Response = ();
}
impl crate::RpcMethod for CBroadcast_BroadcastStatus_Notification {
    const METHOD_NAME: &'static str = "BroadcastClient.NotifyBroadcastStatus#1";
    type Response = ();
}
impl crate::RpcMethod for CBroadcast_BroadcastUploadStarted_Notification {
    const METHOD_NAME: &'static str = "BroadcastClient.NotifyBroadcastUploadStarted#1";
    type Response = ();
}
impl crate::RpcMethod for CBroadcast_BroadcastViewerState_Notification {
    const METHOD_NAME: &'static str = "BroadcastClient.NotifyBroadcastViewerState#1";
    type Response = ();
}
impl crate::RpcMethod for CBroadcast_EndBroadcastSession_Request {
    const METHOD_NAME: &'static str = "Broadcast.EndBroadcastSession#1";
    type Response = CBroadcast_EndBroadcastSession_Response;
}
impl crate::RpcMethod for CBroadcast_GetBroadcastChatInfo_Request {
    const METHOD_NAME: &'static str = "Broadcast.GetBroadcastChatInfo#1";
    type Response = CBroadcast_GetBroadcastChatInfo_Response;
}
impl crate::RpcMethod for CBroadcast_GetBroadcastChatUserNames_Request {
    const METHOD_NAME: &'static str = "Broadcast.GetBroadcastChatUserNames#1";
    type Response = CBroadcast_GetBroadcastChatUserNames_Response;
}
impl crate::RpcMethod for CBroadcast_GetBroadcastStatus_Request {
    const METHOD_NAME: &'static str = "Broadcast.GetBroadcastStatus#1";
    type Response = CBroadcast_GetBroadcastStatus_Response;
}
impl crate::RpcMethod for CBroadcast_GetBroadcastThumbnail_Request {
    const METHOD_NAME: &'static str = "Broadcast.GetBroadcastThumbnail#1";
    type Response = CBroadcast_GetBroadcastThumbnail_Response;
}
impl crate::RpcMethod for CBroadcast_GetBroadcastUploadStats_Request {
    const METHOD_NAME: &'static str = "Broadcast.GetBroadcastUploadStats#1";
    type Response = CBroadcast_GetBroadcastUploadStats_Response;
}
impl crate::RpcMethod for CBroadcast_GetBroadcastViewerStats_Request {
    const METHOD_NAME: &'static str = "Broadcast.GetBroadcastViewerStats#1";
    type Response = CBroadcast_GetBroadcastViewerStats_Response;
}
impl crate::RpcMethod for CBroadcast_GetBuildClipStatus_Request {
    const METHOD_NAME: &'static str = "Broadcast.GetBuildClipStatus#1";
    type Response = CBroadcast_GetBuildClipStatus_Response;
}
impl crate::RpcMethod for CBroadcast_GetClipDetails_Request {
    const METHOD_NAME: &'static str = "Broadcast.GetClipDetails#1";
    type Response = CBroadcast_GetClipDetails_Response;
}
impl crate::RpcMethod for CBroadcast_GetRTMPInfo_Request {
    const METHOD_NAME: &'static str = "Broadcast.GetRTMPInfo#1";
    type Response = CBroadcast_GetRTMPInfo_Response;
}
impl crate::RpcMethod for CBroadcast_HeartbeatBroadcast_Notification {
    const METHOD_NAME: &'static str = "Broadcast.HeartbeatBroadcast#1";
    type Response = ();
}
impl crate::RpcMethod for CBroadcast_InviteToBroadcast_Request {
    const METHOD_NAME: &'static str = "Broadcast.InviteToBroadcast#1";
    type Response = CBroadcast_InviteToBroadcast_Response;
}
impl crate::RpcMethod for CBroadcast_MuteBroadcastChatUser_Request {
    const METHOD_NAME: &'static str = "Broadcast.MuteBroadcastChatUser#1";
    type Response = CBroadcast_MuteBroadcastChatUser_Response;
}
impl crate::RpcMethod for CBroadcast_NotifyBroadcastSessionHeartbeat_Notification {
    const METHOD_NAME: &'static str = "Broadcast.NotifyBroadcastSessionHeartbeat#1";
    type Response = ();
}
impl crate::RpcMethod for CBroadcast_NotifyBroadcastUploadStop_Notification {
    const METHOD_NAME: &'static str = "Broadcast.NotifyBroadcastUploadStop#1";
    type Response = ();
}
impl crate::RpcMethod for CBroadcast_PostChatMessage_Request {
    const METHOD_NAME: &'static str = "Broadcast.PostChatMessage#1";
    type Response = CBroadcast_PostChatMessage_Response;
}
impl crate::RpcMethod for CBroadcast_RemoveUserChatText_Request {
    const METHOD_NAME: &'static str = "Broadcast.RemoveUserChatText#1";
    type Response = CBroadcast_RemoveUserChatText_Response;
}
impl crate::RpcMethod for CBroadcast_SendBroadcastStateToServer_Request {
    const METHOD_NAME: &'static str = "Broadcast.SendBroadcastStateToServer#1";
    type Response = CBroadcast_SendBroadcastStateToServer_Response;
}
impl crate::RpcMethod for CBroadcast_SendThumbnailToRelay_Notification {
    const METHOD_NAME: &'static str = "BroadcastClient.SendThumbnailToRelay#1";
    type Response = ();
}
impl crate::RpcMethod for CBroadcast_SessionClosed_Notification {
    const METHOD_NAME: &'static str = "BroadcastClient.NotifySessionClosed#1";
    type Response = ();
}
impl crate::RpcMethod for CBroadcast_SetClipDetails_Request {
    const METHOD_NAME: &'static str = "Broadcast.SetClipDetails#1";
    type Response = CBroadcast_SetClipDetails_Response;
}
impl crate::RpcMethod for CBroadcast_SetRTMPInfo_Request {
    const METHOD_NAME: &'static str = "Broadcast.SetRTMPInfo#1";
    type Response = CBroadcast_SetRTMPInfo_Response;
}
impl crate::RpcMethod for CBroadcast_StartBroadcastUpload_Request {
    const METHOD_NAME: &'static str = "Broadcast.StartBroadcastUpload#1";
    type Response = CBroadcast_StartBroadcastUpload_Response;
}
impl crate::RpcMethod for CBroadcast_StartBuildClip_Request {
    const METHOD_NAME: &'static str = "Broadcast.StartBuildClip#1";
    type Response = CBroadcast_StartBuildClip_Response;
}
impl crate::RpcMethod for CBroadcast_StopBroadcastUpload_Notification {
    const METHOD_NAME: &'static str = "BroadcastClient.NotifyStopBroadcastUpload#1";
    type Response = ();
}
impl crate::RpcMethod for CBroadcast_StopWatchingBroadcast_Notification {
    const METHOD_NAME: &'static str = "Broadcast.StopWatchingBroadcast#1";
    type Response = ();
}
impl crate::RpcMethod for CBroadcast_UpdateChatMessageFlair_Request {
    const METHOD_NAME: &'static str = "Broadcast.UpdateChatMessageFlair#1";
    type Response = CBroadcast_UpdateChatMessageFlair_Response;
}
impl crate::RpcMethod for CBroadcast_ViewerBroadcastInvite_Notification {
    const METHOD_NAME: &'static str = "BroadcastClient.NotifyViewerBroadcastInvite#1";
    type Response = ();
}
impl crate::RpcMethod for CBroadcast_WaitingBroadcastViewer_Notification {
    const METHOD_NAME: &'static str = "BroadcastClient.NotifyWaitingBroadcastViewer#1";
    type Response = ();
}
impl crate::RpcMethod for CBroadcast_WatchBroadcast_Request {
    const METHOD_NAME: &'static str = "Broadcast.WatchBroadcast#1";
    type Response = CBroadcast_WatchBroadcast_Response;
}
impl crate::RpcMethod for CBroadcast_WebRTCAddHostCandidate_Request {
    const METHOD_NAME: &'static str = "Broadcast.WebRTCAddHostCandidate#1";
    type Response = CBroadcast_WebRTCAddHostCandidate_Response;
}
impl crate::RpcMethod for CBroadcast_WebRTCAddViewerCandidate_Notification {
    const METHOD_NAME: &'static str = "BroadcastClient.NotifyWebRTCAddViewerCandidate#1";
    type Response = ();
}
impl crate::RpcMethod for CBroadcast_WebRTCAddViewerCandidate_Request {
    const METHOD_NAME: &'static str = "Broadcast.WebRTCAddViewerCandidate#1";
    type Response = CBroadcast_WebRTCAddViewerCandidate_Response;
}
impl crate::RpcMethod for CBroadcast_WebRTCGetHostCandidates_Request {
    const METHOD_NAME: &'static str = "Broadcast.WebRTCGetHostCandidates#1";
    type Response = CBroadcast_WebRTCGetHostCandidates_Response;
}
impl crate::RpcMethod for CBroadcast_WebRTCHaveTURNServer_Notification {
    const METHOD_NAME: &'static str = "Broadcast.NotifyWebRTCHaveTURNServer#1";
    type Response = ();
}
impl crate::RpcMethod for CBroadcast_WebRTCLookupTURNServer_Request {
    const METHOD_NAME: &'static str = "Broadcast.WebRTCLookupTURNServer#1";
    type Response = CBroadcast_WebRTCLookupTURNServer_Response;
}
impl crate::RpcMethod for CBroadcast_WebRTCNeedTURNServer_Notification {
    const METHOD_NAME: &'static str = "BroadcastClient.NotifyWebRTCNeedTURNServer#1";
    type Response = ();
}
impl crate::RpcMethod for CBroadcast_WebRTCSetAnswer_Notification {
    const METHOD_NAME: &'static str = "BroadcastClient.NotifyWebRTCSetAnswer#1";
    type Response = ();
}
impl crate::RpcMethod for CBroadcast_WebRTCSetAnswer_Request {
    const METHOD_NAME: &'static str = "Broadcast.WebRTCSetAnswer#1";
    type Response = CBroadcast_WebRTCSetAnswer_Response;
}
impl crate::RpcMethod for CBroadcast_WebRTCStartResult_Request {
    const METHOD_NAME: &'static str = "Broadcast.WebRTCStartResult#1";
    type Response = CBroadcast_WebRTCStartResult_Response;
}
impl crate::RpcMethod for CBroadcast_WebRTCStart_Notification {
    const METHOD_NAME: &'static str = "BroadcastClient.NotifyWebRTCStart#1";
    type Response = ();
}
impl crate::RpcMethod for CBroadcast_WebRTCStopped_Request {
    const METHOD_NAME: &'static str = "Broadcast.WebRTCStopped#1";
    type Response = CBroadcast_WebRTCStopped_Response;
}
