// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_hiddevices.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:CHIDDeviceInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CHIDDeviceInfo {
    // message fields
    // @@protoc_insertion_point(field:CHIDDeviceInfo.location)
    pub location: ::std::option::Option<::protobuf::EnumOrUnknown<EHIDDeviceLocation>>,
    // @@protoc_insertion_point(field:CHIDDeviceInfo.path)
    pub path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CHIDDeviceInfo.vendor_id)
    pub vendor_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CHIDDeviceInfo.product_id)
    pub product_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CHIDDeviceInfo.serial_number)
    pub serial_number: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CHIDDeviceInfo.release_number)
    pub release_number: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CHIDDeviceInfo.manufacturer_string)
    pub manufacturer_string: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CHIDDeviceInfo.product_string)
    pub product_string: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CHIDDeviceInfo.usage_page)
    pub usage_page: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CHIDDeviceInfo.usage)
    pub usage: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CHIDDeviceInfo.interface_number)
    pub interface_number: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CHIDDeviceInfo.ostype)
    pub ostype: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CHIDDeviceInfo.is_generic_gamepad)
    pub is_generic_gamepad: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CHIDDeviceInfo.is_generic_joystick)
    pub is_generic_joystick: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CHIDDeviceInfo.caps_bits)
    pub caps_bits: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CHIDDeviceInfo.session_id)
    pub session_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CHIDDeviceInfo.eControllerType_OBSOLETE)
    pub eControllerType_OBSOLETE: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CHIDDeviceInfo.is_xinput_device_OBSOLETE)
    pub is_xinput_device_OBSOLETE: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CHIDDeviceInfo.session_remote_play_together_appid)
    pub session_remote_play_together_appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CHIDDeviceInfo.is_steamvr_device)
    pub is_steamvr_device: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CHIDDeviceInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CHIDDeviceInfo {
    fn default() -> &'a CHIDDeviceInfo {
        <CHIDDeviceInfo as ::protobuf::Message>::default_instance()
    }
}

impl CHIDDeviceInfo {
    pub fn new() -> CHIDDeviceInfo {
        ::std::default::Default::default()
    }

    // optional .EHIDDeviceLocation location = 1;

    pub fn location(&self) -> EHIDDeviceLocation {
        match self.location {
            Some(e) => e.enum_value_or(EHIDDeviceLocation::k_EDeviceLocationLocal),
            None => EHIDDeviceLocation::k_EDeviceLocationLocal,
        }
    }

    pub fn clear_location(&mut self) {
        self.location = ::std::option::Option::None;
    }

    pub fn has_location(&self) -> bool {
        self.location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: EHIDDeviceLocation) {
        self.location = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string path = 2;

    pub fn path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_path(&mut self) {
        self.path = ::std::option::Option::None;
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 vendor_id = 3;

    pub fn vendor_id(&self) -> u32 {
        self.vendor_id.unwrap_or(0)
    }

    pub fn clear_vendor_id(&mut self) {
        self.vendor_id = ::std::option::Option::None;
    }

    pub fn has_vendor_id(&self) -> bool {
        self.vendor_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vendor_id(&mut self, v: u32) {
        self.vendor_id = ::std::option::Option::Some(v);
    }

    // optional uint32 product_id = 4;

    pub fn product_id(&self) -> u32 {
        self.product_id.unwrap_or(0)
    }

    pub fn clear_product_id(&mut self) {
        self.product_id = ::std::option::Option::None;
    }

    pub fn has_product_id(&self) -> bool {
        self.product_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_product_id(&mut self, v: u32) {
        self.product_id = ::std::option::Option::Some(v);
    }

    // optional string serial_number = 5;

    pub fn serial_number(&self) -> &str {
        match self.serial_number.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_serial_number(&mut self) {
        self.serial_number = ::std::option::Option::None;
    }

    pub fn has_serial_number(&self) -> bool {
        self.serial_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serial_number(&mut self, v: ::std::string::String) {
        self.serial_number = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serial_number(&mut self) -> &mut ::std::string::String {
        if self.serial_number.is_none() {
            self.serial_number = ::std::option::Option::Some(::std::string::String::new());
        }
        self.serial_number.as_mut().unwrap()
    }

    // Take field
    pub fn take_serial_number(&mut self) -> ::std::string::String {
        self.serial_number.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 release_number = 6;

    pub fn release_number(&self) -> u32 {
        self.release_number.unwrap_or(0)
    }

    pub fn clear_release_number(&mut self) {
        self.release_number = ::std::option::Option::None;
    }

    pub fn has_release_number(&self) -> bool {
        self.release_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_release_number(&mut self, v: u32) {
        self.release_number = ::std::option::Option::Some(v);
    }

    // optional string manufacturer_string = 7;

    pub fn manufacturer_string(&self) -> &str {
        match self.manufacturer_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_manufacturer_string(&mut self) {
        self.manufacturer_string = ::std::option::Option::None;
    }

    pub fn has_manufacturer_string(&self) -> bool {
        self.manufacturer_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_manufacturer_string(&mut self, v: ::std::string::String) {
        self.manufacturer_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_manufacturer_string(&mut self) -> &mut ::std::string::String {
        if self.manufacturer_string.is_none() {
            self.manufacturer_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.manufacturer_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_manufacturer_string(&mut self) -> ::std::string::String {
        self.manufacturer_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string product_string = 8;

    pub fn product_string(&self) -> &str {
        match self.product_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_product_string(&mut self) {
        self.product_string = ::std::option::Option::None;
    }

    pub fn has_product_string(&self) -> bool {
        self.product_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_product_string(&mut self, v: ::std::string::String) {
        self.product_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_product_string(&mut self) -> &mut ::std::string::String {
        if self.product_string.is_none() {
            self.product_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.product_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_product_string(&mut self) -> ::std::string::String {
        self.product_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 usage_page = 9;

    pub fn usage_page(&self) -> u32 {
        self.usage_page.unwrap_or(0)
    }

    pub fn clear_usage_page(&mut self) {
        self.usage_page = ::std::option::Option::None;
    }

    pub fn has_usage_page(&self) -> bool {
        self.usage_page.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usage_page(&mut self, v: u32) {
        self.usage_page = ::std::option::Option::Some(v);
    }

    // optional uint32 usage = 10;

    pub fn usage(&self) -> u32 {
        self.usage.unwrap_or(0)
    }

    pub fn clear_usage(&mut self) {
        self.usage = ::std::option::Option::None;
    }

    pub fn has_usage(&self) -> bool {
        self.usage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usage(&mut self, v: u32) {
        self.usage = ::std::option::Option::Some(v);
    }

    // optional int32 interface_number = 11;

    pub fn interface_number(&self) -> i32 {
        self.interface_number.unwrap_or(-1i32)
    }

    pub fn clear_interface_number(&mut self) {
        self.interface_number = ::std::option::Option::None;
    }

    pub fn has_interface_number(&self) -> bool {
        self.interface_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_interface_number(&mut self, v: i32) {
        self.interface_number = ::std::option::Option::Some(v);
    }

    // optional int32 ostype = 12;

    pub fn ostype(&self) -> i32 {
        self.ostype.unwrap_or(-1i32)
    }

    pub fn clear_ostype(&mut self) {
        self.ostype = ::std::option::Option::None;
    }

    pub fn has_ostype(&self) -> bool {
        self.ostype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ostype(&mut self, v: i32) {
        self.ostype = ::std::option::Option::Some(v);
    }

    // optional bool is_generic_gamepad = 13;

    pub fn is_generic_gamepad(&self) -> bool {
        self.is_generic_gamepad.unwrap_or(false)
    }

    pub fn clear_is_generic_gamepad(&mut self) {
        self.is_generic_gamepad = ::std::option::Option::None;
    }

    pub fn has_is_generic_gamepad(&self) -> bool {
        self.is_generic_gamepad.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_generic_gamepad(&mut self, v: bool) {
        self.is_generic_gamepad = ::std::option::Option::Some(v);
    }

    // optional bool is_generic_joystick = 14;

    pub fn is_generic_joystick(&self) -> bool {
        self.is_generic_joystick.unwrap_or(false)
    }

    pub fn clear_is_generic_joystick(&mut self) {
        self.is_generic_joystick = ::std::option::Option::None;
    }

    pub fn has_is_generic_joystick(&self) -> bool {
        self.is_generic_joystick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_generic_joystick(&mut self, v: bool) {
        self.is_generic_joystick = ::std::option::Option::Some(v);
    }

    // optional uint32 caps_bits = 15;

    pub fn caps_bits(&self) -> u32 {
        self.caps_bits.unwrap_or(0)
    }

    pub fn clear_caps_bits(&mut self) {
        self.caps_bits = ::std::option::Option::None;
    }

    pub fn has_caps_bits(&self) -> bool {
        self.caps_bits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caps_bits(&mut self, v: u32) {
        self.caps_bits = ::std::option::Option::Some(v);
    }

    // optional uint32 session_id = 16;

    pub fn session_id(&self) -> u32 {
        self.session_id.unwrap_or(0)
    }

    pub fn clear_session_id(&mut self) {
        self.session_id = ::std::option::Option::None;
    }

    pub fn has_session_id(&self) -> bool {
        self.session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_id(&mut self, v: u32) {
        self.session_id = ::std::option::Option::Some(v);
    }

    // optional uint32 eControllerType_OBSOLETE = 17;

    pub fn eControllerType_OBSOLETE(&self) -> u32 {
        self.eControllerType_OBSOLETE.unwrap_or(0u32)
    }

    pub fn clear_eControllerType_OBSOLETE(&mut self) {
        self.eControllerType_OBSOLETE = ::std::option::Option::None;
    }

    pub fn has_eControllerType_OBSOLETE(&self) -> bool {
        self.eControllerType_OBSOLETE.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eControllerType_OBSOLETE(&mut self, v: u32) {
        self.eControllerType_OBSOLETE = ::std::option::Option::Some(v);
    }

    // optional bool is_xinput_device_OBSOLETE = 18;

    pub fn is_xinput_device_OBSOLETE(&self) -> bool {
        self.is_xinput_device_OBSOLETE.unwrap_or(false)
    }

    pub fn clear_is_xinput_device_OBSOLETE(&mut self) {
        self.is_xinput_device_OBSOLETE = ::std::option::Option::None;
    }

    pub fn has_is_xinput_device_OBSOLETE(&self) -> bool {
        self.is_xinput_device_OBSOLETE.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_xinput_device_OBSOLETE(&mut self, v: bool) {
        self.is_xinput_device_OBSOLETE = ::std::option::Option::Some(v);
    }

    // optional uint32 session_remote_play_together_appid = 19;

    pub fn session_remote_play_together_appid(&self) -> u32 {
        self.session_remote_play_together_appid.unwrap_or(0)
    }

    pub fn clear_session_remote_play_together_appid(&mut self) {
        self.session_remote_play_together_appid = ::std::option::Option::None;
    }

    pub fn has_session_remote_play_together_appid(&self) -> bool {
        self.session_remote_play_together_appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_remote_play_together_appid(&mut self, v: u32) {
        self.session_remote_play_together_appid = ::std::option::Option::Some(v);
    }

    // optional bool is_steamvr_device = 20;

    pub fn is_steamvr_device(&self) -> bool {
        self.is_steamvr_device.unwrap_or(false)
    }

    pub fn clear_is_steamvr_device(&mut self) {
        self.is_steamvr_device = ::std::option::Option::None;
    }

    pub fn has_is_steamvr_device(&self) -> bool {
        self.is_steamvr_device.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_steamvr_device(&mut self, v: bool) {
        self.is_steamvr_device = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CHIDDeviceInfo {
    const NAME: &'static str = "CHIDDeviceInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.location = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.path = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.vendor_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.product_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.serial_number = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.release_number = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.manufacturer_string = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.product_string = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.usage_page = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.usage = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.interface_number = ::std::option::Option::Some(is.read_int32()?);
                },
                96 => {
                    self.ostype = ::std::option::Option::Some(is.read_int32()?);
                },
                104 => {
                    self.is_generic_gamepad = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.is_generic_joystick = ::std::option::Option::Some(is.read_bool()?);
                },
                120 => {
                    self.caps_bits = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.session_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.eControllerType_OBSOLETE = ::std::option::Option::Some(is.read_uint32()?);
                },
                144 => {
                    self.is_xinput_device_OBSOLETE = ::std::option::Option::Some(is.read_bool()?);
                },
                152 => {
                    self.session_remote_play_together_appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.is_steamvr_device = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.location {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.vendor_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.product_id {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.serial_number.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.release_number {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.manufacturer_string.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.product_string.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.usage_page {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.usage {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.interface_number {
            my_size += ::protobuf::rt::int32_size(11, v);
        }
        if let Some(v) = self.ostype {
            my_size += ::protobuf::rt::int32_size(12, v);
        }
        if let Some(v) = self.is_generic_gamepad {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_generic_joystick {
            my_size += 1 + 1;
        }
        if let Some(v) = self.caps_bits {
            my_size += ::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.session_id {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.eControllerType_OBSOLETE {
            my_size += ::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.is_xinput_device_OBSOLETE {
            my_size += 2 + 1;
        }
        if let Some(v) = self.session_remote_play_together_appid {
            my_size += ::protobuf::rt::uint32_size(19, v);
        }
        if let Some(v) = self.is_steamvr_device {
            my_size += 2 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.location {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.path.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.vendor_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.product_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.serial_number.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.release_number {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.manufacturer_string.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.product_string.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.usage_page {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.usage {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.interface_number {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.ostype {
            os.write_int32(12, v)?;
        }
        if let Some(v) = self.is_generic_gamepad {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.is_generic_joystick {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.caps_bits {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.session_id {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.eControllerType_OBSOLETE {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.is_xinput_device_OBSOLETE {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.session_remote_play_together_appid {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.is_steamvr_device {
            os.write_bool(20, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CHIDDeviceInfo {
        CHIDDeviceInfo::new()
    }

    fn clear(&mut self) {
        self.location = ::std::option::Option::None;
        self.path = ::std::option::Option::None;
        self.vendor_id = ::std::option::Option::None;
        self.product_id = ::std::option::Option::None;
        self.serial_number = ::std::option::Option::None;
        self.release_number = ::std::option::Option::None;
        self.manufacturer_string = ::std::option::Option::None;
        self.product_string = ::std::option::Option::None;
        self.usage_page = ::std::option::Option::None;
        self.usage = ::std::option::Option::None;
        self.interface_number = ::std::option::Option::None;
        self.ostype = ::std::option::Option::None;
        self.is_generic_gamepad = ::std::option::Option::None;
        self.is_generic_joystick = ::std::option::Option::None;
        self.caps_bits = ::std::option::Option::None;
        self.session_id = ::std::option::Option::None;
        self.eControllerType_OBSOLETE = ::std::option::Option::None;
        self.is_xinput_device_OBSOLETE = ::std::option::Option::None;
        self.session_remote_play_together_appid = ::std::option::Option::None;
        self.is_steamvr_device = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CHIDDeviceInfo {
        static instance: CHIDDeviceInfo = CHIDDeviceInfo {
            location: ::std::option::Option::None,
            path: ::std::option::Option::None,
            vendor_id: ::std::option::Option::None,
            product_id: ::std::option::Option::None,
            serial_number: ::std::option::Option::None,
            release_number: ::std::option::Option::None,
            manufacturer_string: ::std::option::Option::None,
            product_string: ::std::option::Option::None,
            usage_page: ::std::option::Option::None,
            usage: ::std::option::Option::None,
            interface_number: ::std::option::Option::None,
            ostype: ::std::option::Option::None,
            is_generic_gamepad: ::std::option::Option::None,
            is_generic_joystick: ::std::option::Option::None,
            caps_bits: ::std::option::Option::None,
            session_id: ::std::option::Option::None,
            eControllerType_OBSOLETE: ::std::option::Option::None,
            is_xinput_device_OBSOLETE: ::std::option::Option::None,
            session_remote_play_together_appid: ::std::option::Option::None,
            is_steamvr_device: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CHIDDeviceInputReport)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CHIDDeviceInputReport {
    // message fields
    // @@protoc_insertion_point(field:CHIDDeviceInputReport.full_report)
    pub full_report: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CHIDDeviceInputReport.delta_report)
    pub delta_report: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CHIDDeviceInputReport.delta_report_size)
    pub delta_report_size: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CHIDDeviceInputReport.delta_report_crc)
    pub delta_report_crc: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CHIDDeviceInputReport.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CHIDDeviceInputReport {
    fn default() -> &'a CHIDDeviceInputReport {
        <CHIDDeviceInputReport as ::protobuf::Message>::default_instance()
    }
}

impl CHIDDeviceInputReport {
    pub fn new() -> CHIDDeviceInputReport {
        ::std::default::Default::default()
    }

    // optional bytes full_report = 1;

    pub fn full_report(&self) -> &[u8] {
        match self.full_report.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_full_report(&mut self) {
        self.full_report = ::std::option::Option::None;
    }

    pub fn has_full_report(&self) -> bool {
        self.full_report.is_some()
    }

    // Param is passed by value, moved
    pub fn set_full_report(&mut self, v: ::std::vec::Vec<u8>) {
        self.full_report = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_full_report(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.full_report.is_none() {
            self.full_report = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.full_report.as_mut().unwrap()
    }

    // Take field
    pub fn take_full_report(&mut self) -> ::std::vec::Vec<u8> {
        self.full_report.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes delta_report = 2;

    pub fn delta_report(&self) -> &[u8] {
        match self.delta_report.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_delta_report(&mut self) {
        self.delta_report = ::std::option::Option::None;
    }

    pub fn has_delta_report(&self) -> bool {
        self.delta_report.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delta_report(&mut self, v: ::std::vec::Vec<u8>) {
        self.delta_report = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_delta_report(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.delta_report.is_none() {
            self.delta_report = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.delta_report.as_mut().unwrap()
    }

    // Take field
    pub fn take_delta_report(&mut self) -> ::std::vec::Vec<u8> {
        self.delta_report.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 delta_report_size = 3;

    pub fn delta_report_size(&self) -> u32 {
        self.delta_report_size.unwrap_or(0)
    }

    pub fn clear_delta_report_size(&mut self) {
        self.delta_report_size = ::std::option::Option::None;
    }

    pub fn has_delta_report_size(&self) -> bool {
        self.delta_report_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delta_report_size(&mut self, v: u32) {
        self.delta_report_size = ::std::option::Option::Some(v);
    }

    // optional uint32 delta_report_crc = 4;

    pub fn delta_report_crc(&self) -> u32 {
        self.delta_report_crc.unwrap_or(0)
    }

    pub fn clear_delta_report_crc(&mut self) {
        self.delta_report_crc = ::std::option::Option::None;
    }

    pub fn has_delta_report_crc(&self) -> bool {
        self.delta_report_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delta_report_crc(&mut self, v: u32) {
        self.delta_report_crc = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CHIDDeviceInputReport {
    const NAME: &'static str = "CHIDDeviceInputReport";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.full_report = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.delta_report = ::std::option::Option::Some(is.read_bytes()?);
                },
                24 => {
                    self.delta_report_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.delta_report_crc = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.full_report.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.delta_report.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.delta_report_size {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.delta_report_crc {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.full_report.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.delta_report.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.delta_report_size {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.delta_report_crc {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CHIDDeviceInputReport {
        CHIDDeviceInputReport::new()
    }

    fn clear(&mut self) {
        self.full_report = ::std::option::Option::None;
        self.delta_report = ::std::option::Option::None;
        self.delta_report_size = ::std::option::Option::None;
        self.delta_report_crc = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CHIDDeviceInputReport {
        static instance: CHIDDeviceInputReport = CHIDDeviceInputReport {
            full_report: ::std::option::Option::None,
            delta_report: ::std::option::Option::None,
            delta_report_size: ::std::option::Option::None,
            delta_report_crc: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CHIDMessageToRemote)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CHIDMessageToRemote {
    // message fields
    // @@protoc_insertion_point(field:CHIDMessageToRemote.request_id)
    pub request_id: ::std::option::Option<u32>,
    // message oneof groups
    pub command: ::std::option::Option<chidmessage_to_remote::Command>,
    // special fields
    // @@protoc_insertion_point(special_field:CHIDMessageToRemote.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CHIDMessageToRemote {
    fn default() -> &'a CHIDMessageToRemote {
        <CHIDMessageToRemote as ::protobuf::Message>::default_instance()
    }
}

impl CHIDMessageToRemote {
    pub fn new() -> CHIDMessageToRemote {
        ::std::default::Default::default()
    }

    // optional uint32 request_id = 1;

    pub fn request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional .CHIDMessageToRemote.DeviceOpen device_open = 2;

    pub fn device_open(&self) -> &chidmessage_to_remote::DeviceOpen {
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceOpen(ref v)) => v,
            _ => <chidmessage_to_remote::DeviceOpen as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_device_open(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_device_open(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceOpen(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_device_open(&mut self, v: chidmessage_to_remote::DeviceOpen) {
        self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceOpen(v))
    }

    // Mutable pointer to the field.
    pub fn mut_device_open(&mut self) -> &mut chidmessage_to_remote::DeviceOpen {
        if let ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceOpen(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceOpen(chidmessage_to_remote::DeviceOpen::new()));
        }
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceOpen(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_device_open(&mut self) -> chidmessage_to_remote::DeviceOpen {
        if self.has_device_open() {
            match self.command.take() {
                ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceOpen(v)) => v,
                _ => panic!(),
            }
        } else {
            chidmessage_to_remote::DeviceOpen::new()
        }
    }

    // optional .CHIDMessageToRemote.DeviceClose device_close = 3;

    pub fn device_close(&self) -> &chidmessage_to_remote::DeviceClose {
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceClose(ref v)) => v,
            _ => <chidmessage_to_remote::DeviceClose as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_device_close(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_device_close(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceClose(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_device_close(&mut self, v: chidmessage_to_remote::DeviceClose) {
        self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceClose(v))
    }

    // Mutable pointer to the field.
    pub fn mut_device_close(&mut self) -> &mut chidmessage_to_remote::DeviceClose {
        if let ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceClose(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceClose(chidmessage_to_remote::DeviceClose::new()));
        }
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceClose(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_device_close(&mut self) -> chidmessage_to_remote::DeviceClose {
        if self.has_device_close() {
            match self.command.take() {
                ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceClose(v)) => v,
                _ => panic!(),
            }
        } else {
            chidmessage_to_remote::DeviceClose::new()
        }
    }

    // optional .CHIDMessageToRemote.DeviceWrite device_write = 4;

    pub fn device_write(&self) -> &chidmessage_to_remote::DeviceWrite {
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceWrite(ref v)) => v,
            _ => <chidmessage_to_remote::DeviceWrite as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_device_write(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_device_write(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceWrite(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_device_write(&mut self, v: chidmessage_to_remote::DeviceWrite) {
        self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceWrite(v))
    }

    // Mutable pointer to the field.
    pub fn mut_device_write(&mut self) -> &mut chidmessage_to_remote::DeviceWrite {
        if let ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceWrite(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceWrite(chidmessage_to_remote::DeviceWrite::new()));
        }
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceWrite(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_device_write(&mut self) -> chidmessage_to_remote::DeviceWrite {
        if self.has_device_write() {
            match self.command.take() {
                ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceWrite(v)) => v,
                _ => panic!(),
            }
        } else {
            chidmessage_to_remote::DeviceWrite::new()
        }
    }

    // optional .CHIDMessageToRemote.DeviceRead device_read = 5;

    pub fn device_read(&self) -> &chidmessage_to_remote::DeviceRead {
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceRead(ref v)) => v,
            _ => <chidmessage_to_remote::DeviceRead as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_device_read(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_device_read(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceRead(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_device_read(&mut self, v: chidmessage_to_remote::DeviceRead) {
        self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceRead(v))
    }

    // Mutable pointer to the field.
    pub fn mut_device_read(&mut self) -> &mut chidmessage_to_remote::DeviceRead {
        if let ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceRead(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceRead(chidmessage_to_remote::DeviceRead::new()));
        }
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceRead(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_device_read(&mut self) -> chidmessage_to_remote::DeviceRead {
        if self.has_device_read() {
            match self.command.take() {
                ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceRead(v)) => v,
                _ => panic!(),
            }
        } else {
            chidmessage_to_remote::DeviceRead::new()
        }
    }

    // optional .CHIDMessageToRemote.DeviceSendFeatureReport device_send_feature_report = 6;

    pub fn device_send_feature_report(&self) -> &chidmessage_to_remote::DeviceSendFeatureReport {
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceSendFeatureReport(ref v)) => v,
            _ => <chidmessage_to_remote::DeviceSendFeatureReport as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_device_send_feature_report(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_device_send_feature_report(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceSendFeatureReport(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_device_send_feature_report(&mut self, v: chidmessage_to_remote::DeviceSendFeatureReport) {
        self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceSendFeatureReport(v))
    }

    // Mutable pointer to the field.
    pub fn mut_device_send_feature_report(&mut self) -> &mut chidmessage_to_remote::DeviceSendFeatureReport {
        if let ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceSendFeatureReport(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceSendFeatureReport(chidmessage_to_remote::DeviceSendFeatureReport::new()));
        }
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceSendFeatureReport(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_device_send_feature_report(&mut self) -> chidmessage_to_remote::DeviceSendFeatureReport {
        if self.has_device_send_feature_report() {
            match self.command.take() {
                ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceSendFeatureReport(v)) => v,
                _ => panic!(),
            }
        } else {
            chidmessage_to_remote::DeviceSendFeatureReport::new()
        }
    }

    // optional .CHIDMessageToRemote.DeviceGetFeatureReport device_get_feature_report = 7;

    pub fn device_get_feature_report(&self) -> &chidmessage_to_remote::DeviceGetFeatureReport {
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetFeatureReport(ref v)) => v,
            _ => <chidmessage_to_remote::DeviceGetFeatureReport as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_device_get_feature_report(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_device_get_feature_report(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetFeatureReport(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_device_get_feature_report(&mut self, v: chidmessage_to_remote::DeviceGetFeatureReport) {
        self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetFeatureReport(v))
    }

    // Mutable pointer to the field.
    pub fn mut_device_get_feature_report(&mut self) -> &mut chidmessage_to_remote::DeviceGetFeatureReport {
        if let ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetFeatureReport(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetFeatureReport(chidmessage_to_remote::DeviceGetFeatureReport::new()));
        }
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetFeatureReport(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_device_get_feature_report(&mut self) -> chidmessage_to_remote::DeviceGetFeatureReport {
        if self.has_device_get_feature_report() {
            match self.command.take() {
                ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetFeatureReport(v)) => v,
                _ => panic!(),
            }
        } else {
            chidmessage_to_remote::DeviceGetFeatureReport::new()
        }
    }

    // optional .CHIDMessageToRemote.DeviceGetVendorString device_get_vendor_string = 8;

    pub fn device_get_vendor_string(&self) -> &chidmessage_to_remote::DeviceGetVendorString {
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetVendorString(ref v)) => v,
            _ => <chidmessage_to_remote::DeviceGetVendorString as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_device_get_vendor_string(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_device_get_vendor_string(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetVendorString(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_device_get_vendor_string(&mut self, v: chidmessage_to_remote::DeviceGetVendorString) {
        self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetVendorString(v))
    }

    // Mutable pointer to the field.
    pub fn mut_device_get_vendor_string(&mut self) -> &mut chidmessage_to_remote::DeviceGetVendorString {
        if let ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetVendorString(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetVendorString(chidmessage_to_remote::DeviceGetVendorString::new()));
        }
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetVendorString(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_device_get_vendor_string(&mut self) -> chidmessage_to_remote::DeviceGetVendorString {
        if self.has_device_get_vendor_string() {
            match self.command.take() {
                ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetVendorString(v)) => v,
                _ => panic!(),
            }
        } else {
            chidmessage_to_remote::DeviceGetVendorString::new()
        }
    }

    // optional .CHIDMessageToRemote.DeviceGetProductString device_get_product_string = 9;

    pub fn device_get_product_string(&self) -> &chidmessage_to_remote::DeviceGetProductString {
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetProductString(ref v)) => v,
            _ => <chidmessage_to_remote::DeviceGetProductString as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_device_get_product_string(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_device_get_product_string(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetProductString(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_device_get_product_string(&mut self, v: chidmessage_to_remote::DeviceGetProductString) {
        self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetProductString(v))
    }

    // Mutable pointer to the field.
    pub fn mut_device_get_product_string(&mut self) -> &mut chidmessage_to_remote::DeviceGetProductString {
        if let ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetProductString(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetProductString(chidmessage_to_remote::DeviceGetProductString::new()));
        }
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetProductString(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_device_get_product_string(&mut self) -> chidmessage_to_remote::DeviceGetProductString {
        if self.has_device_get_product_string() {
            match self.command.take() {
                ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetProductString(v)) => v,
                _ => panic!(),
            }
        } else {
            chidmessage_to_remote::DeviceGetProductString::new()
        }
    }

    // optional .CHIDMessageToRemote.DeviceGetSerialNumberString device_get_serial_number_string = 10;

    pub fn device_get_serial_number_string(&self) -> &chidmessage_to_remote::DeviceGetSerialNumberString {
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetSerialNumberString(ref v)) => v,
            _ => <chidmessage_to_remote::DeviceGetSerialNumberString as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_device_get_serial_number_string(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_device_get_serial_number_string(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetSerialNumberString(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_device_get_serial_number_string(&mut self, v: chidmessage_to_remote::DeviceGetSerialNumberString) {
        self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetSerialNumberString(v))
    }

    // Mutable pointer to the field.
    pub fn mut_device_get_serial_number_string(&mut self) -> &mut chidmessage_to_remote::DeviceGetSerialNumberString {
        if let ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetSerialNumberString(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetSerialNumberString(chidmessage_to_remote::DeviceGetSerialNumberString::new()));
        }
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetSerialNumberString(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_device_get_serial_number_string(&mut self) -> chidmessage_to_remote::DeviceGetSerialNumberString {
        if self.has_device_get_serial_number_string() {
            match self.command.take() {
                ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetSerialNumberString(v)) => v,
                _ => panic!(),
            }
        } else {
            chidmessage_to_remote::DeviceGetSerialNumberString::new()
        }
    }

    // optional .CHIDMessageToRemote.DeviceStartInputReports device_start_input_reports = 11;

    pub fn device_start_input_reports(&self) -> &chidmessage_to_remote::DeviceStartInputReports {
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceStartInputReports(ref v)) => v,
            _ => <chidmessage_to_remote::DeviceStartInputReports as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_device_start_input_reports(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_device_start_input_reports(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceStartInputReports(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_device_start_input_reports(&mut self, v: chidmessage_to_remote::DeviceStartInputReports) {
        self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceStartInputReports(v))
    }

    // Mutable pointer to the field.
    pub fn mut_device_start_input_reports(&mut self) -> &mut chidmessage_to_remote::DeviceStartInputReports {
        if let ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceStartInputReports(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceStartInputReports(chidmessage_to_remote::DeviceStartInputReports::new()));
        }
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceStartInputReports(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_device_start_input_reports(&mut self) -> chidmessage_to_remote::DeviceStartInputReports {
        if self.has_device_start_input_reports() {
            match self.command.take() {
                ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceStartInputReports(v)) => v,
                _ => panic!(),
            }
        } else {
            chidmessage_to_remote::DeviceStartInputReports::new()
        }
    }

    // optional .CHIDMessageToRemote.DeviceRequestFullReport device_request_full_report = 12;

    pub fn device_request_full_report(&self) -> &chidmessage_to_remote::DeviceRequestFullReport {
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceRequestFullReport(ref v)) => v,
            _ => <chidmessage_to_remote::DeviceRequestFullReport as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_device_request_full_report(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_device_request_full_report(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceRequestFullReport(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_device_request_full_report(&mut self, v: chidmessage_to_remote::DeviceRequestFullReport) {
        self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceRequestFullReport(v))
    }

    // Mutable pointer to the field.
    pub fn mut_device_request_full_report(&mut self) -> &mut chidmessage_to_remote::DeviceRequestFullReport {
        if let ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceRequestFullReport(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceRequestFullReport(chidmessage_to_remote::DeviceRequestFullReport::new()));
        }
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceRequestFullReport(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_device_request_full_report(&mut self) -> chidmessage_to_remote::DeviceRequestFullReport {
        if self.has_device_request_full_report() {
            match self.command.take() {
                ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceRequestFullReport(v)) => v,
                _ => panic!(),
            }
        } else {
            chidmessage_to_remote::DeviceRequestFullReport::new()
        }
    }

    // optional .CHIDMessageToRemote.DeviceDisconnect device_disconnect = 13;

    pub fn device_disconnect(&self) -> &chidmessage_to_remote::DeviceDisconnect {
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceDisconnect(ref v)) => v,
            _ => <chidmessage_to_remote::DeviceDisconnect as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_device_disconnect(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_device_disconnect(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceDisconnect(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_device_disconnect(&mut self, v: chidmessage_to_remote::DeviceDisconnect) {
        self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceDisconnect(v))
    }

    // Mutable pointer to the field.
    pub fn mut_device_disconnect(&mut self) -> &mut chidmessage_to_remote::DeviceDisconnect {
        if let ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceDisconnect(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceDisconnect(chidmessage_to_remote::DeviceDisconnect::new()));
        }
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceDisconnect(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_device_disconnect(&mut self) -> chidmessage_to_remote::DeviceDisconnect {
        if self.has_device_disconnect() {
            match self.command.take() {
                ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceDisconnect(v)) => v,
                _ => panic!(),
            }
        } else {
            chidmessage_to_remote::DeviceDisconnect::new()
        }
    }
}

impl ::protobuf::Message for CHIDMessageToRemote {
    const NAME: &'static str = "CHIDMessageToRemote";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.request_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceOpen(is.read_message()?));
                },
                26 => {
                    self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceClose(is.read_message()?));
                },
                34 => {
                    self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceWrite(is.read_message()?));
                },
                42 => {
                    self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceRead(is.read_message()?));
                },
                50 => {
                    self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceSendFeatureReport(is.read_message()?));
                },
                58 => {
                    self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetFeatureReport(is.read_message()?));
                },
                66 => {
                    self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetVendorString(is.read_message()?));
                },
                74 => {
                    self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetProductString(is.read_message()?));
                },
                82 => {
                    self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetSerialNumberString(is.read_message()?));
                },
                90 => {
                    self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceStartInputReports(is.read_message()?));
                },
                98 => {
                    self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceRequestFullReport(is.read_message()?));
                },
                106 => {
                    self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceDisconnect(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let ::std::option::Option::Some(ref v) = self.command {
            match v {
                &chidmessage_to_remote::Command::DeviceOpen(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &chidmessage_to_remote::Command::DeviceClose(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &chidmessage_to_remote::Command::DeviceWrite(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &chidmessage_to_remote::Command::DeviceRead(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &chidmessage_to_remote::Command::DeviceSendFeatureReport(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &chidmessage_to_remote::Command::DeviceGetFeatureReport(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &chidmessage_to_remote::Command::DeviceGetVendorString(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &chidmessage_to_remote::Command::DeviceGetProductString(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &chidmessage_to_remote::Command::DeviceGetSerialNumberString(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &chidmessage_to_remote::Command::DeviceStartInputReports(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &chidmessage_to_remote::Command::DeviceRequestFullReport(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &chidmessage_to_remote::Command::DeviceDisconnect(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.request_id {
            os.write_uint32(1, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.command {
            match v {
                &chidmessage_to_remote::Command::DeviceOpen(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &chidmessage_to_remote::Command::DeviceClose(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &chidmessage_to_remote::Command::DeviceWrite(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &chidmessage_to_remote::Command::DeviceRead(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &chidmessage_to_remote::Command::DeviceSendFeatureReport(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &chidmessage_to_remote::Command::DeviceGetFeatureReport(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &chidmessage_to_remote::Command::DeviceGetVendorString(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &chidmessage_to_remote::Command::DeviceGetProductString(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
                },
                &chidmessage_to_remote::Command::DeviceGetSerialNumberString(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
                },
                &chidmessage_to_remote::Command::DeviceStartInputReports(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
                },
                &chidmessage_to_remote::Command::DeviceRequestFullReport(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
                },
                &chidmessage_to_remote::Command::DeviceDisconnect(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CHIDMessageToRemote {
        CHIDMessageToRemote::new()
    }

    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CHIDMessageToRemote {
        static instance: CHIDMessageToRemote = CHIDMessageToRemote {
            request_id: ::std::option::Option::None,
            command: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CHIDMessageToRemote`
pub mod chidmessage_to_remote {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:CHIDMessageToRemote.command)
    pub enum Command {
        // @@protoc_insertion_point(oneof_field:CHIDMessageToRemote.device_open)
        DeviceOpen(DeviceOpen),
        // @@protoc_insertion_point(oneof_field:CHIDMessageToRemote.device_close)
        DeviceClose(DeviceClose),
        // @@protoc_insertion_point(oneof_field:CHIDMessageToRemote.device_write)
        DeviceWrite(DeviceWrite),
        // @@protoc_insertion_point(oneof_field:CHIDMessageToRemote.device_read)
        DeviceRead(DeviceRead),
        // @@protoc_insertion_point(oneof_field:CHIDMessageToRemote.device_send_feature_report)
        DeviceSendFeatureReport(DeviceSendFeatureReport),
        // @@protoc_insertion_point(oneof_field:CHIDMessageToRemote.device_get_feature_report)
        DeviceGetFeatureReport(DeviceGetFeatureReport),
        // @@protoc_insertion_point(oneof_field:CHIDMessageToRemote.device_get_vendor_string)
        DeviceGetVendorString(DeviceGetVendorString),
        // @@protoc_insertion_point(oneof_field:CHIDMessageToRemote.device_get_product_string)
        DeviceGetProductString(DeviceGetProductString),
        // @@protoc_insertion_point(oneof_field:CHIDMessageToRemote.device_get_serial_number_string)
        DeviceGetSerialNumberString(DeviceGetSerialNumberString),
        // @@protoc_insertion_point(oneof_field:CHIDMessageToRemote.device_start_input_reports)
        DeviceStartInputReports(DeviceStartInputReports),
        // @@protoc_insertion_point(oneof_field:CHIDMessageToRemote.device_request_full_report)
        DeviceRequestFullReport(DeviceRequestFullReport),
        // @@protoc_insertion_point(oneof_field:CHIDMessageToRemote.device_disconnect)
        DeviceDisconnect(DeviceDisconnect),
    }

    impl ::protobuf::Oneof for Command {
    }

    impl Command {
    }
    // @@protoc_insertion_point(message:CHIDMessageToRemote.DeviceOpen)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DeviceOpen {
        // message fields
        // @@protoc_insertion_point(field:CHIDMessageToRemote.DeviceOpen.info)
        pub info: ::protobuf::MessageField<super::CHIDDeviceInfo>,
        // special fields
        // @@protoc_insertion_point(special_field:CHIDMessageToRemote.DeviceOpen.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DeviceOpen {
        fn default() -> &'a DeviceOpen {
            <DeviceOpen as ::protobuf::Message>::default_instance()
        }
    }

    impl DeviceOpen {
        pub fn new() -> DeviceOpen {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for DeviceOpen {
        const NAME: &'static str = "DeviceOpen";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.info)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.info.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.info.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DeviceOpen {
            DeviceOpen::new()
        }

        fn clear(&mut self) {
            self.info.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DeviceOpen {
            static instance: DeviceOpen = DeviceOpen {
                info: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CHIDMessageToRemote.DeviceClose)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DeviceClose {
        // message fields
        // @@protoc_insertion_point(field:CHIDMessageToRemote.DeviceClose.device)
        pub device: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CHIDMessageToRemote.DeviceClose.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DeviceClose {
        fn default() -> &'a DeviceClose {
            <DeviceClose as ::protobuf::Message>::default_instance()
        }
    }

    impl DeviceClose {
        pub fn new() -> DeviceClose {
            ::std::default::Default::default()
        }

        // optional uint32 device = 1;

        pub fn device(&self) -> u32 {
            self.device.unwrap_or(0)
        }

        pub fn clear_device(&mut self) {
            self.device = ::std::option::Option::None;
        }

        pub fn has_device(&self) -> bool {
            self.device.is_some()
        }

        // Param is passed by value, moved
        pub fn set_device(&mut self, v: u32) {
            self.device = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for DeviceClose {
        const NAME: &'static str = "DeviceClose";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.device = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.device {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.device {
                os.write_uint32(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DeviceClose {
            DeviceClose::new()
        }

        fn clear(&mut self) {
            self.device = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DeviceClose {
            static instance: DeviceClose = DeviceClose {
                device: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CHIDMessageToRemote.DeviceWrite)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DeviceWrite {
        // message fields
        // @@protoc_insertion_point(field:CHIDMessageToRemote.DeviceWrite.device)
        pub device: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CHIDMessageToRemote.DeviceWrite.data)
        pub data: ::std::option::Option<::std::vec::Vec<u8>>,
        // special fields
        // @@protoc_insertion_point(special_field:CHIDMessageToRemote.DeviceWrite.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DeviceWrite {
        fn default() -> &'a DeviceWrite {
            <DeviceWrite as ::protobuf::Message>::default_instance()
        }
    }

    impl DeviceWrite {
        pub fn new() -> DeviceWrite {
            ::std::default::Default::default()
        }

        // optional uint32 device = 1;

        pub fn device(&self) -> u32 {
            self.device.unwrap_or(0)
        }

        pub fn clear_device(&mut self) {
            self.device = ::std::option::Option::None;
        }

        pub fn has_device(&self) -> bool {
            self.device.is_some()
        }

        // Param is passed by value, moved
        pub fn set_device(&mut self, v: u32) {
            self.device = ::std::option::Option::Some(v);
        }

        // optional bytes data = 2;

        pub fn data(&self) -> &[u8] {
            match self.data.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_data(&mut self) {
            self.data = ::std::option::Option::None;
        }

        pub fn has_data(&self) -> bool {
            self.data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
            self.data = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.data.is_none() {
                self.data = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.data.as_mut().unwrap()
        }

        // Take field
        pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
            self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }
    }

    impl ::protobuf::Message for DeviceWrite {
        const NAME: &'static str = "DeviceWrite";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.device = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.data = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.device {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.data.as_ref() {
                my_size += ::protobuf::rt::bytes_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.device {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.data.as_ref() {
                os.write_bytes(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DeviceWrite {
            DeviceWrite::new()
        }

        fn clear(&mut self) {
            self.device = ::std::option::Option::None;
            self.data = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DeviceWrite {
            static instance: DeviceWrite = DeviceWrite {
                device: ::std::option::Option::None,
                data: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CHIDMessageToRemote.DeviceRead)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DeviceRead {
        // message fields
        // @@protoc_insertion_point(field:CHIDMessageToRemote.DeviceRead.device)
        pub device: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CHIDMessageToRemote.DeviceRead.length)
        pub length: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CHIDMessageToRemote.DeviceRead.timeout_ms)
        pub timeout_ms: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CHIDMessageToRemote.DeviceRead.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DeviceRead {
        fn default() -> &'a DeviceRead {
            <DeviceRead as ::protobuf::Message>::default_instance()
        }
    }

    impl DeviceRead {
        pub fn new() -> DeviceRead {
            ::std::default::Default::default()
        }

        // optional uint32 device = 1;

        pub fn device(&self) -> u32 {
            self.device.unwrap_or(0)
        }

        pub fn clear_device(&mut self) {
            self.device = ::std::option::Option::None;
        }

        pub fn has_device(&self) -> bool {
            self.device.is_some()
        }

        // Param is passed by value, moved
        pub fn set_device(&mut self, v: u32) {
            self.device = ::std::option::Option::Some(v);
        }

        // optional uint32 length = 2;

        pub fn length(&self) -> u32 {
            self.length.unwrap_or(0)
        }

        pub fn clear_length(&mut self) {
            self.length = ::std::option::Option::None;
        }

        pub fn has_length(&self) -> bool {
            self.length.is_some()
        }

        // Param is passed by value, moved
        pub fn set_length(&mut self, v: u32) {
            self.length = ::std::option::Option::Some(v);
        }

        // optional int32 timeout_ms = 3;

        pub fn timeout_ms(&self) -> i32 {
            self.timeout_ms.unwrap_or(0)
        }

        pub fn clear_timeout_ms(&mut self) {
            self.timeout_ms = ::std::option::Option::None;
        }

        pub fn has_timeout_ms(&self) -> bool {
            self.timeout_ms.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timeout_ms(&mut self, v: i32) {
            self.timeout_ms = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for DeviceRead {
        const NAME: &'static str = "DeviceRead";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.device = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.length = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.timeout_ms = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.device {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.length {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.timeout_ms {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.device {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.length {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.timeout_ms {
                os.write_int32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DeviceRead {
            DeviceRead::new()
        }

        fn clear(&mut self) {
            self.device = ::std::option::Option::None;
            self.length = ::std::option::Option::None;
            self.timeout_ms = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DeviceRead {
            static instance: DeviceRead = DeviceRead {
                device: ::std::option::Option::None,
                length: ::std::option::Option::None,
                timeout_ms: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CHIDMessageToRemote.DeviceSendFeatureReport)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DeviceSendFeatureReport {
        // message fields
        // @@protoc_insertion_point(field:CHIDMessageToRemote.DeviceSendFeatureReport.device)
        pub device: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CHIDMessageToRemote.DeviceSendFeatureReport.data)
        pub data: ::std::option::Option<::std::vec::Vec<u8>>,
        // special fields
        // @@protoc_insertion_point(special_field:CHIDMessageToRemote.DeviceSendFeatureReport.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DeviceSendFeatureReport {
        fn default() -> &'a DeviceSendFeatureReport {
            <DeviceSendFeatureReport as ::protobuf::Message>::default_instance()
        }
    }

    impl DeviceSendFeatureReport {
        pub fn new() -> DeviceSendFeatureReport {
            ::std::default::Default::default()
        }

        // optional uint32 device = 1;

        pub fn device(&self) -> u32 {
            self.device.unwrap_or(0)
        }

        pub fn clear_device(&mut self) {
            self.device = ::std::option::Option::None;
        }

        pub fn has_device(&self) -> bool {
            self.device.is_some()
        }

        // Param is passed by value, moved
        pub fn set_device(&mut self, v: u32) {
            self.device = ::std::option::Option::Some(v);
        }

        // optional bytes data = 2;

        pub fn data(&self) -> &[u8] {
            match self.data.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_data(&mut self) {
            self.data = ::std::option::Option::None;
        }

        pub fn has_data(&self) -> bool {
            self.data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
            self.data = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.data.is_none() {
                self.data = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.data.as_mut().unwrap()
        }

        // Take field
        pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
            self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }
    }

    impl ::protobuf::Message for DeviceSendFeatureReport {
        const NAME: &'static str = "DeviceSendFeatureReport";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.device = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.data = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.device {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.data.as_ref() {
                my_size += ::protobuf::rt::bytes_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.device {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.data.as_ref() {
                os.write_bytes(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DeviceSendFeatureReport {
            DeviceSendFeatureReport::new()
        }

        fn clear(&mut self) {
            self.device = ::std::option::Option::None;
            self.data = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DeviceSendFeatureReport {
            static instance: DeviceSendFeatureReport = DeviceSendFeatureReport {
                device: ::std::option::Option::None,
                data: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CHIDMessageToRemote.DeviceGetFeatureReport)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DeviceGetFeatureReport {
        // message fields
        // @@protoc_insertion_point(field:CHIDMessageToRemote.DeviceGetFeatureReport.device)
        pub device: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CHIDMessageToRemote.DeviceGetFeatureReport.report_number)
        pub report_number: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:CHIDMessageToRemote.DeviceGetFeatureReport.length)
        pub length: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CHIDMessageToRemote.DeviceGetFeatureReport.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DeviceGetFeatureReport {
        fn default() -> &'a DeviceGetFeatureReport {
            <DeviceGetFeatureReport as ::protobuf::Message>::default_instance()
        }
    }

    impl DeviceGetFeatureReport {
        pub fn new() -> DeviceGetFeatureReport {
            ::std::default::Default::default()
        }

        // optional uint32 device = 1;

        pub fn device(&self) -> u32 {
            self.device.unwrap_or(0)
        }

        pub fn clear_device(&mut self) {
            self.device = ::std::option::Option::None;
        }

        pub fn has_device(&self) -> bool {
            self.device.is_some()
        }

        // Param is passed by value, moved
        pub fn set_device(&mut self, v: u32) {
            self.device = ::std::option::Option::Some(v);
        }

        // optional bytes report_number = 2;

        pub fn report_number(&self) -> &[u8] {
            match self.report_number.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_report_number(&mut self) {
            self.report_number = ::std::option::Option::None;
        }

        pub fn has_report_number(&self) -> bool {
            self.report_number.is_some()
        }

        // Param is passed by value, moved
        pub fn set_report_number(&mut self, v: ::std::vec::Vec<u8>) {
            self.report_number = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_report_number(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.report_number.is_none() {
                self.report_number = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.report_number.as_mut().unwrap()
        }

        // Take field
        pub fn take_report_number(&mut self) -> ::std::vec::Vec<u8> {
            self.report_number.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional uint32 length = 3;

        pub fn length(&self) -> u32 {
            self.length.unwrap_or(0)
        }

        pub fn clear_length(&mut self) {
            self.length = ::std::option::Option::None;
        }

        pub fn has_length(&self) -> bool {
            self.length.is_some()
        }

        // Param is passed by value, moved
        pub fn set_length(&mut self, v: u32) {
            self.length = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for DeviceGetFeatureReport {
        const NAME: &'static str = "DeviceGetFeatureReport";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.device = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.report_number = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    24 => {
                        self.length = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.device {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.report_number.as_ref() {
                my_size += ::protobuf::rt::bytes_size(2, &v);
            }
            if let Some(v) = self.length {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.device {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.report_number.as_ref() {
                os.write_bytes(2, v)?;
            }
            if let Some(v) = self.length {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DeviceGetFeatureReport {
            DeviceGetFeatureReport::new()
        }

        fn clear(&mut self) {
            self.device = ::std::option::Option::None;
            self.report_number = ::std::option::Option::None;
            self.length = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DeviceGetFeatureReport {
            static instance: DeviceGetFeatureReport = DeviceGetFeatureReport {
                device: ::std::option::Option::None,
                report_number: ::std::option::Option::None,
                length: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CHIDMessageToRemote.DeviceGetVendorString)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DeviceGetVendorString {
        // message fields
        // @@protoc_insertion_point(field:CHIDMessageToRemote.DeviceGetVendorString.device)
        pub device: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CHIDMessageToRemote.DeviceGetVendorString.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DeviceGetVendorString {
        fn default() -> &'a DeviceGetVendorString {
            <DeviceGetVendorString as ::protobuf::Message>::default_instance()
        }
    }

    impl DeviceGetVendorString {
        pub fn new() -> DeviceGetVendorString {
            ::std::default::Default::default()
        }

        // optional uint32 device = 1;

        pub fn device(&self) -> u32 {
            self.device.unwrap_or(0)
        }

        pub fn clear_device(&mut self) {
            self.device = ::std::option::Option::None;
        }

        pub fn has_device(&self) -> bool {
            self.device.is_some()
        }

        // Param is passed by value, moved
        pub fn set_device(&mut self, v: u32) {
            self.device = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for DeviceGetVendorString {
        const NAME: &'static str = "DeviceGetVendorString";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.device = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.device {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.device {
                os.write_uint32(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DeviceGetVendorString {
            DeviceGetVendorString::new()
        }

        fn clear(&mut self) {
            self.device = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DeviceGetVendorString {
            static instance: DeviceGetVendorString = DeviceGetVendorString {
                device: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CHIDMessageToRemote.DeviceGetProductString)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DeviceGetProductString {
        // message fields
        // @@protoc_insertion_point(field:CHIDMessageToRemote.DeviceGetProductString.device)
        pub device: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CHIDMessageToRemote.DeviceGetProductString.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DeviceGetProductString {
        fn default() -> &'a DeviceGetProductString {
            <DeviceGetProductString as ::protobuf::Message>::default_instance()
        }
    }

    impl DeviceGetProductString {
        pub fn new() -> DeviceGetProductString {
            ::std::default::Default::default()
        }

        // optional uint32 device = 1;

        pub fn device(&self) -> u32 {
            self.device.unwrap_or(0)
        }

        pub fn clear_device(&mut self) {
            self.device = ::std::option::Option::None;
        }

        pub fn has_device(&self) -> bool {
            self.device.is_some()
        }

        // Param is passed by value, moved
        pub fn set_device(&mut self, v: u32) {
            self.device = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for DeviceGetProductString {
        const NAME: &'static str = "DeviceGetProductString";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.device = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.device {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.device {
                os.write_uint32(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DeviceGetProductString {
            DeviceGetProductString::new()
        }

        fn clear(&mut self) {
            self.device = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DeviceGetProductString {
            static instance: DeviceGetProductString = DeviceGetProductString {
                device: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CHIDMessageToRemote.DeviceGetSerialNumberString)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DeviceGetSerialNumberString {
        // message fields
        // @@protoc_insertion_point(field:CHIDMessageToRemote.DeviceGetSerialNumberString.device)
        pub device: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CHIDMessageToRemote.DeviceGetSerialNumberString.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DeviceGetSerialNumberString {
        fn default() -> &'a DeviceGetSerialNumberString {
            <DeviceGetSerialNumberString as ::protobuf::Message>::default_instance()
        }
    }

    impl DeviceGetSerialNumberString {
        pub fn new() -> DeviceGetSerialNumberString {
            ::std::default::Default::default()
        }

        // optional uint32 device = 1;

        pub fn device(&self) -> u32 {
            self.device.unwrap_or(0)
        }

        pub fn clear_device(&mut self) {
            self.device = ::std::option::Option::None;
        }

        pub fn has_device(&self) -> bool {
            self.device.is_some()
        }

        // Param is passed by value, moved
        pub fn set_device(&mut self, v: u32) {
            self.device = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for DeviceGetSerialNumberString {
        const NAME: &'static str = "DeviceGetSerialNumberString";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.device = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.device {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.device {
                os.write_uint32(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DeviceGetSerialNumberString {
            DeviceGetSerialNumberString::new()
        }

        fn clear(&mut self) {
            self.device = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DeviceGetSerialNumberString {
            static instance: DeviceGetSerialNumberString = DeviceGetSerialNumberString {
                device: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CHIDMessageToRemote.DeviceStartInputReports)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DeviceStartInputReports {
        // message fields
        // @@protoc_insertion_point(field:CHIDMessageToRemote.DeviceStartInputReports.device)
        pub device: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CHIDMessageToRemote.DeviceStartInputReports.length)
        pub length: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CHIDMessageToRemote.DeviceStartInputReports.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DeviceStartInputReports {
        fn default() -> &'a DeviceStartInputReports {
            <DeviceStartInputReports as ::protobuf::Message>::default_instance()
        }
    }

    impl DeviceStartInputReports {
        pub fn new() -> DeviceStartInputReports {
            ::std::default::Default::default()
        }

        // optional uint32 device = 1;

        pub fn device(&self) -> u32 {
            self.device.unwrap_or(0)
        }

        pub fn clear_device(&mut self) {
            self.device = ::std::option::Option::None;
        }

        pub fn has_device(&self) -> bool {
            self.device.is_some()
        }

        // Param is passed by value, moved
        pub fn set_device(&mut self, v: u32) {
            self.device = ::std::option::Option::Some(v);
        }

        // optional uint32 length = 2;

        pub fn length(&self) -> u32 {
            self.length.unwrap_or(0)
        }

        pub fn clear_length(&mut self) {
            self.length = ::std::option::Option::None;
        }

        pub fn has_length(&self) -> bool {
            self.length.is_some()
        }

        // Param is passed by value, moved
        pub fn set_length(&mut self, v: u32) {
            self.length = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for DeviceStartInputReports {
        const NAME: &'static str = "DeviceStartInputReports";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.device = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.length = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.device {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.length {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.device {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.length {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DeviceStartInputReports {
            DeviceStartInputReports::new()
        }

        fn clear(&mut self) {
            self.device = ::std::option::Option::None;
            self.length = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DeviceStartInputReports {
            static instance: DeviceStartInputReports = DeviceStartInputReports {
                device: ::std::option::Option::None,
                length: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CHIDMessageToRemote.DeviceRequestFullReport)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DeviceRequestFullReport {
        // message fields
        // @@protoc_insertion_point(field:CHIDMessageToRemote.DeviceRequestFullReport.device)
        pub device: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CHIDMessageToRemote.DeviceRequestFullReport.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DeviceRequestFullReport {
        fn default() -> &'a DeviceRequestFullReport {
            <DeviceRequestFullReport as ::protobuf::Message>::default_instance()
        }
    }

    impl DeviceRequestFullReport {
        pub fn new() -> DeviceRequestFullReport {
            ::std::default::Default::default()
        }

        // optional uint32 device = 1;

        pub fn device(&self) -> u32 {
            self.device.unwrap_or(0)
        }

        pub fn clear_device(&mut self) {
            self.device = ::std::option::Option::None;
        }

        pub fn has_device(&self) -> bool {
            self.device.is_some()
        }

        // Param is passed by value, moved
        pub fn set_device(&mut self, v: u32) {
            self.device = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for DeviceRequestFullReport {
        const NAME: &'static str = "DeviceRequestFullReport";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.device = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.device {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.device {
                os.write_uint32(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DeviceRequestFullReport {
            DeviceRequestFullReport::new()
        }

        fn clear(&mut self) {
            self.device = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DeviceRequestFullReport {
            static instance: DeviceRequestFullReport = DeviceRequestFullReport {
                device: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CHIDMessageToRemote.DeviceDisconnect)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DeviceDisconnect {
        // message fields
        // @@protoc_insertion_point(field:CHIDMessageToRemote.DeviceDisconnect.device)
        pub device: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CHIDMessageToRemote.DeviceDisconnect.disconnectMethod)
        pub disconnectMethod: ::std::option::Option<::protobuf::EnumOrUnknown<super::EHIDDeviceDisconnectMethod>>,
        // @@protoc_insertion_point(field:CHIDMessageToRemote.DeviceDisconnect.data)
        pub data: ::std::option::Option<::std::vec::Vec<u8>>,
        // special fields
        // @@protoc_insertion_point(special_field:CHIDMessageToRemote.DeviceDisconnect.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DeviceDisconnect {
        fn default() -> &'a DeviceDisconnect {
            <DeviceDisconnect as ::protobuf::Message>::default_instance()
        }
    }

    impl DeviceDisconnect {
        pub fn new() -> DeviceDisconnect {
            ::std::default::Default::default()
        }

        // optional uint32 device = 1;

        pub fn device(&self) -> u32 {
            self.device.unwrap_or(0)
        }

        pub fn clear_device(&mut self) {
            self.device = ::std::option::Option::None;
        }

        pub fn has_device(&self) -> bool {
            self.device.is_some()
        }

        // Param is passed by value, moved
        pub fn set_device(&mut self, v: u32) {
            self.device = ::std::option::Option::Some(v);
        }

        // optional .EHIDDeviceDisconnectMethod disconnectMethod = 2;

        pub fn disconnectMethod(&self) -> super::EHIDDeviceDisconnectMethod {
            match self.disconnectMethod {
                Some(e) => e.enum_value_or(super::EHIDDeviceDisconnectMethod::k_EDeviceDisconnectMethodUnknown),
                None => super::EHIDDeviceDisconnectMethod::k_EDeviceDisconnectMethodUnknown,
            }
        }

        pub fn clear_disconnectMethod(&mut self) {
            self.disconnectMethod = ::std::option::Option::None;
        }

        pub fn has_disconnectMethod(&self) -> bool {
            self.disconnectMethod.is_some()
        }

        // Param is passed by value, moved
        pub fn set_disconnectMethod(&mut self, v: super::EHIDDeviceDisconnectMethod) {
            self.disconnectMethod = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional bytes data = 3;

        pub fn data(&self) -> &[u8] {
            match self.data.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_data(&mut self) {
            self.data = ::std::option::Option::None;
        }

        pub fn has_data(&self) -> bool {
            self.data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
            self.data = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.data.is_none() {
                self.data = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.data.as_mut().unwrap()
        }

        // Take field
        pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
            self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }
    }

    impl ::protobuf::Message for DeviceDisconnect {
        const NAME: &'static str = "DeviceDisconnect";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.device = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.disconnectMethod = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    26 => {
                        self.data = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.device {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.disconnectMethod {
                my_size += ::protobuf::rt::int32_size(2, v.value());
            }
            if let Some(v) = self.data.as_ref() {
                my_size += ::protobuf::rt::bytes_size(3, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.device {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.disconnectMethod {
                os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.data.as_ref() {
                os.write_bytes(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DeviceDisconnect {
            DeviceDisconnect::new()
        }

        fn clear(&mut self) {
            self.device = ::std::option::Option::None;
            self.disconnectMethod = ::std::option::Option::None;
            self.data = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DeviceDisconnect {
            static instance: DeviceDisconnect = DeviceDisconnect {
                device: ::std::option::Option::None,
                disconnectMethod: ::std::option::Option::None,
                data: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CHIDMessageFromRemote)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CHIDMessageFromRemote {
    // message oneof groups
    pub command: ::std::option::Option<chidmessage_from_remote::Command>,
    // special fields
    // @@protoc_insertion_point(special_field:CHIDMessageFromRemote.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CHIDMessageFromRemote {
    fn default() -> &'a CHIDMessageFromRemote {
        <CHIDMessageFromRemote as ::protobuf::Message>::default_instance()
    }
}

impl CHIDMessageFromRemote {
    pub fn new() -> CHIDMessageFromRemote {
        ::std::default::Default::default()
    }

    // optional .CHIDMessageFromRemote.UpdateDeviceList update_device_list = 1;

    pub fn update_device_list(&self) -> &chidmessage_from_remote::UpdateDeviceList {
        match self.command {
            ::std::option::Option::Some(chidmessage_from_remote::Command::UpdateDeviceList(ref v)) => v,
            _ => <chidmessage_from_remote::UpdateDeviceList as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_update_device_list(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_update_device_list(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(chidmessage_from_remote::Command::UpdateDeviceList(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_update_device_list(&mut self, v: chidmessage_from_remote::UpdateDeviceList) {
        self.command = ::std::option::Option::Some(chidmessage_from_remote::Command::UpdateDeviceList(v))
    }

    // Mutable pointer to the field.
    pub fn mut_update_device_list(&mut self) -> &mut chidmessage_from_remote::UpdateDeviceList {
        if let ::std::option::Option::Some(chidmessage_from_remote::Command::UpdateDeviceList(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(chidmessage_from_remote::Command::UpdateDeviceList(chidmessage_from_remote::UpdateDeviceList::new()));
        }
        match self.command {
            ::std::option::Option::Some(chidmessage_from_remote::Command::UpdateDeviceList(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_update_device_list(&mut self) -> chidmessage_from_remote::UpdateDeviceList {
        if self.has_update_device_list() {
            match self.command.take() {
                ::std::option::Option::Some(chidmessage_from_remote::Command::UpdateDeviceList(v)) => v,
                _ => panic!(),
            }
        } else {
            chidmessage_from_remote::UpdateDeviceList::new()
        }
    }

    // optional .CHIDMessageFromRemote.RequestResponse response = 2;

    pub fn response(&self) -> &chidmessage_from_remote::RequestResponse {
        match self.command {
            ::std::option::Option::Some(chidmessage_from_remote::Command::Response(ref v)) => v,
            _ => <chidmessage_from_remote::RequestResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_response(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(chidmessage_from_remote::Command::Response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: chidmessage_from_remote::RequestResponse) {
        self.command = ::std::option::Option::Some(chidmessage_from_remote::Command::Response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_response(&mut self) -> &mut chidmessage_from_remote::RequestResponse {
        if let ::std::option::Option::Some(chidmessage_from_remote::Command::Response(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(chidmessage_from_remote::Command::Response(chidmessage_from_remote::RequestResponse::new()));
        }
        match self.command {
            ::std::option::Option::Some(chidmessage_from_remote::Command::Response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_response(&mut self) -> chidmessage_from_remote::RequestResponse {
        if self.has_response() {
            match self.command.take() {
                ::std::option::Option::Some(chidmessage_from_remote::Command::Response(v)) => v,
                _ => panic!(),
            }
        } else {
            chidmessage_from_remote::RequestResponse::new()
        }
    }

    // optional .CHIDMessageFromRemote.DeviceInputReports reports = 3;

    pub fn reports(&self) -> &chidmessage_from_remote::DeviceInputReports {
        match self.command {
            ::std::option::Option::Some(chidmessage_from_remote::Command::Reports(ref v)) => v,
            _ => <chidmessage_from_remote::DeviceInputReports as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_reports(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_reports(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(chidmessage_from_remote::Command::Reports(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_reports(&mut self, v: chidmessage_from_remote::DeviceInputReports) {
        self.command = ::std::option::Option::Some(chidmessage_from_remote::Command::Reports(v))
    }

    // Mutable pointer to the field.
    pub fn mut_reports(&mut self) -> &mut chidmessage_from_remote::DeviceInputReports {
        if let ::std::option::Option::Some(chidmessage_from_remote::Command::Reports(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(chidmessage_from_remote::Command::Reports(chidmessage_from_remote::DeviceInputReports::new()));
        }
        match self.command {
            ::std::option::Option::Some(chidmessage_from_remote::Command::Reports(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_reports(&mut self) -> chidmessage_from_remote::DeviceInputReports {
        if self.has_reports() {
            match self.command.take() {
                ::std::option::Option::Some(chidmessage_from_remote::Command::Reports(v)) => v,
                _ => panic!(),
            }
        } else {
            chidmessage_from_remote::DeviceInputReports::new()
        }
    }

    // optional .CHIDMessageFromRemote.CloseDevice close_device = 4;

    pub fn close_device(&self) -> &chidmessage_from_remote::CloseDevice {
        match self.command {
            ::std::option::Option::Some(chidmessage_from_remote::Command::CloseDevice(ref v)) => v,
            _ => <chidmessage_from_remote::CloseDevice as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_close_device(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_close_device(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(chidmessage_from_remote::Command::CloseDevice(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_close_device(&mut self, v: chidmessage_from_remote::CloseDevice) {
        self.command = ::std::option::Option::Some(chidmessage_from_remote::Command::CloseDevice(v))
    }

    // Mutable pointer to the field.
    pub fn mut_close_device(&mut self) -> &mut chidmessage_from_remote::CloseDevice {
        if let ::std::option::Option::Some(chidmessage_from_remote::Command::CloseDevice(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(chidmessage_from_remote::Command::CloseDevice(chidmessage_from_remote::CloseDevice::new()));
        }
        match self.command {
            ::std::option::Option::Some(chidmessage_from_remote::Command::CloseDevice(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_close_device(&mut self) -> chidmessage_from_remote::CloseDevice {
        if self.has_close_device() {
            match self.command.take() {
                ::std::option::Option::Some(chidmessage_from_remote::Command::CloseDevice(v)) => v,
                _ => panic!(),
            }
        } else {
            chidmessage_from_remote::CloseDevice::new()
        }
    }

    // optional .CHIDMessageFromRemote.CloseAllDevices close_all_devices = 5;

    pub fn close_all_devices(&self) -> &chidmessage_from_remote::CloseAllDevices {
        match self.command {
            ::std::option::Option::Some(chidmessage_from_remote::Command::CloseAllDevices(ref v)) => v,
            _ => <chidmessage_from_remote::CloseAllDevices as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_close_all_devices(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_close_all_devices(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(chidmessage_from_remote::Command::CloseAllDevices(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_close_all_devices(&mut self, v: chidmessage_from_remote::CloseAllDevices) {
        self.command = ::std::option::Option::Some(chidmessage_from_remote::Command::CloseAllDevices(v))
    }

    // Mutable pointer to the field.
    pub fn mut_close_all_devices(&mut self) -> &mut chidmessage_from_remote::CloseAllDevices {
        if let ::std::option::Option::Some(chidmessage_from_remote::Command::CloseAllDevices(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(chidmessage_from_remote::Command::CloseAllDevices(chidmessage_from_remote::CloseAllDevices::new()));
        }
        match self.command {
            ::std::option::Option::Some(chidmessage_from_remote::Command::CloseAllDevices(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_close_all_devices(&mut self) -> chidmessage_from_remote::CloseAllDevices {
        if self.has_close_all_devices() {
            match self.command.take() {
                ::std::option::Option::Some(chidmessage_from_remote::Command::CloseAllDevices(v)) => v,
                _ => panic!(),
            }
        } else {
            chidmessage_from_remote::CloseAllDevices::new()
        }
    }
}

impl ::protobuf::Message for CHIDMessageFromRemote {
    const NAME: &'static str = "CHIDMessageFromRemote";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.command = ::std::option::Option::Some(chidmessage_from_remote::Command::UpdateDeviceList(is.read_message()?));
                },
                18 => {
                    self.command = ::std::option::Option::Some(chidmessage_from_remote::Command::Response(is.read_message()?));
                },
                26 => {
                    self.command = ::std::option::Option::Some(chidmessage_from_remote::Command::Reports(is.read_message()?));
                },
                34 => {
                    self.command = ::std::option::Option::Some(chidmessage_from_remote::Command::CloseDevice(is.read_message()?));
                },
                42 => {
                    self.command = ::std::option::Option::Some(chidmessage_from_remote::Command::CloseAllDevices(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.command {
            match v {
                &chidmessage_from_remote::Command::UpdateDeviceList(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &chidmessage_from_remote::Command::Response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &chidmessage_from_remote::Command::Reports(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &chidmessage_from_remote::Command::CloseDevice(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &chidmessage_from_remote::Command::CloseAllDevices(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.command {
            match v {
                &chidmessage_from_remote::Command::UpdateDeviceList(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &chidmessage_from_remote::Command::Response(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &chidmessage_from_remote::Command::Reports(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &chidmessage_from_remote::Command::CloseDevice(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &chidmessage_from_remote::Command::CloseAllDevices(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CHIDMessageFromRemote {
        CHIDMessageFromRemote::new()
    }

    fn clear(&mut self) {
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CHIDMessageFromRemote {
        static instance: CHIDMessageFromRemote = CHIDMessageFromRemote {
            command: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CHIDMessageFromRemote`
pub mod chidmessage_from_remote {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:CHIDMessageFromRemote.command)
    pub enum Command {
        // @@protoc_insertion_point(oneof_field:CHIDMessageFromRemote.update_device_list)
        UpdateDeviceList(UpdateDeviceList),
        // @@protoc_insertion_point(oneof_field:CHIDMessageFromRemote.response)
        Response(RequestResponse),
        // @@protoc_insertion_point(oneof_field:CHIDMessageFromRemote.reports)
        Reports(DeviceInputReports),
        // @@protoc_insertion_point(oneof_field:CHIDMessageFromRemote.close_device)
        CloseDevice(CloseDevice),
        // @@protoc_insertion_point(oneof_field:CHIDMessageFromRemote.close_all_devices)
        CloseAllDevices(CloseAllDevices),
    }

    impl ::protobuf::Oneof for Command {
    }

    impl Command {
    }
    // @@protoc_insertion_point(message:CHIDMessageFromRemote.UpdateDeviceList)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct UpdateDeviceList {
        // message fields
        // @@protoc_insertion_point(field:CHIDMessageFromRemote.UpdateDeviceList.devices)
        pub devices: ::std::vec::Vec<super::CHIDDeviceInfo>,
        // special fields
        // @@protoc_insertion_point(special_field:CHIDMessageFromRemote.UpdateDeviceList.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a UpdateDeviceList {
        fn default() -> &'a UpdateDeviceList {
            <UpdateDeviceList as ::protobuf::Message>::default_instance()
        }
    }

    impl UpdateDeviceList {
        pub fn new() -> UpdateDeviceList {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for UpdateDeviceList {
        const NAME: &'static str = "UpdateDeviceList";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.devices.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.devices {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.devices {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> UpdateDeviceList {
            UpdateDeviceList::new()
        }

        fn clear(&mut self) {
            self.devices.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static UpdateDeviceList {
            static instance: UpdateDeviceList = UpdateDeviceList {
                devices: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CHIDMessageFromRemote.RequestResponse)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RequestResponse {
        // message fields
        // @@protoc_insertion_point(field:CHIDMessageFromRemote.RequestResponse.request_id)
        pub request_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CHIDMessageFromRemote.RequestResponse.result)
        pub result: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CHIDMessageFromRemote.RequestResponse.data)
        pub data: ::std::option::Option<::std::vec::Vec<u8>>,
        // special fields
        // @@protoc_insertion_point(special_field:CHIDMessageFromRemote.RequestResponse.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RequestResponse {
        fn default() -> &'a RequestResponse {
            <RequestResponse as ::protobuf::Message>::default_instance()
        }
    }

    impl RequestResponse {
        pub fn new() -> RequestResponse {
            ::std::default::Default::default()
        }

        // optional uint32 request_id = 1;

        pub fn request_id(&self) -> u32 {
            self.request_id.unwrap_or(0)
        }

        pub fn clear_request_id(&mut self) {
            self.request_id = ::std::option::Option::None;
        }

        pub fn has_request_id(&self) -> bool {
            self.request_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_request_id(&mut self, v: u32) {
            self.request_id = ::std::option::Option::Some(v);
        }

        // optional int32 result = 2;

        pub fn result(&self) -> i32 {
            self.result.unwrap_or(0)
        }

        pub fn clear_result(&mut self) {
            self.result = ::std::option::Option::None;
        }

        pub fn has_result(&self) -> bool {
            self.result.is_some()
        }

        // Param is passed by value, moved
        pub fn set_result(&mut self, v: i32) {
            self.result = ::std::option::Option::Some(v);
        }

        // optional bytes data = 3;

        pub fn data(&self) -> &[u8] {
            match self.data.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_data(&mut self) {
            self.data = ::std::option::Option::None;
        }

        pub fn has_data(&self) -> bool {
            self.data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
            self.data = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.data.is_none() {
                self.data = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.data.as_mut().unwrap()
        }

        // Take field
        pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
            self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }
    }

    impl ::protobuf::Message for RequestResponse {
        const NAME: &'static str = "RequestResponse";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.request_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.result = ::std::option::Option::Some(is.read_int32()?);
                    },
                    26 => {
                        self.data = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.request_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.result {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.data.as_ref() {
                my_size += ::protobuf::rt::bytes_size(3, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.request_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.result {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.data.as_ref() {
                os.write_bytes(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RequestResponse {
            RequestResponse::new()
        }

        fn clear(&mut self) {
            self.request_id = ::std::option::Option::None;
            self.result = ::std::option::Option::None;
            self.data = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RequestResponse {
            static instance: RequestResponse = RequestResponse {
                request_id: ::std::option::Option::None,
                result: ::std::option::Option::None,
                data: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CHIDMessageFromRemote.DeviceInputReports)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DeviceInputReports {
        // message fields
        // @@protoc_insertion_point(field:CHIDMessageFromRemote.DeviceInputReports.device_reports)
        pub device_reports: ::std::vec::Vec<device_input_reports::DeviceInputReport>,
        // special fields
        // @@protoc_insertion_point(special_field:CHIDMessageFromRemote.DeviceInputReports.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DeviceInputReports {
        fn default() -> &'a DeviceInputReports {
            <DeviceInputReports as ::protobuf::Message>::default_instance()
        }
    }

    impl DeviceInputReports {
        pub fn new() -> DeviceInputReports {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for DeviceInputReports {
        const NAME: &'static str = "DeviceInputReports";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.device_reports.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.device_reports {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.device_reports {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DeviceInputReports {
            DeviceInputReports::new()
        }

        fn clear(&mut self) {
            self.device_reports.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DeviceInputReports {
            static instance: DeviceInputReports = DeviceInputReports {
                device_reports: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `DeviceInputReports`
    pub mod device_input_reports {
        // @@protoc_insertion_point(message:CHIDMessageFromRemote.DeviceInputReports.DeviceInputReport)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct DeviceInputReport {
            // message fields
            // @@protoc_insertion_point(field:CHIDMessageFromRemote.DeviceInputReports.DeviceInputReport.device)
            pub device: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CHIDMessageFromRemote.DeviceInputReports.DeviceInputReport.reports)
            pub reports: ::std::vec::Vec<super::super::CHIDDeviceInputReport>,
            // special fields
            // @@protoc_insertion_point(special_field:CHIDMessageFromRemote.DeviceInputReports.DeviceInputReport.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a DeviceInputReport {
            fn default() -> &'a DeviceInputReport {
                <DeviceInputReport as ::protobuf::Message>::default_instance()
            }
        }

        impl DeviceInputReport {
            pub fn new() -> DeviceInputReport {
                ::std::default::Default::default()
            }

            // optional uint32 device = 1;

            pub fn device(&self) -> u32 {
                self.device.unwrap_or(0)
            }

            pub fn clear_device(&mut self) {
                self.device = ::std::option::Option::None;
            }

            pub fn has_device(&self) -> bool {
                self.device.is_some()
            }

            // Param is passed by value, moved
            pub fn set_device(&mut self, v: u32) {
                self.device = ::std::option::Option::Some(v);
            }
        }

        impl ::protobuf::Message for DeviceInputReport {
            const NAME: &'static str = "DeviceInputReport";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.device = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        18 => {
                            self.reports.push(is.read_message()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.device {
                    my_size += ::protobuf::rt::uint32_size(1, v);
                }
                for value in &self.reports {
                    let len = value.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.device {
                    os.write_uint32(1, v)?;
                }
                for v in &self.reports {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> DeviceInputReport {
                DeviceInputReport::new()
            }

            fn clear(&mut self) {
                self.device = ::std::option::Option::None;
                self.reports.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static DeviceInputReport {
                static instance: DeviceInputReport = DeviceInputReport {
                    device: ::std::option::Option::None,
                    reports: ::std::vec::Vec::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }
    }

    // @@protoc_insertion_point(message:CHIDMessageFromRemote.CloseDevice)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CloseDevice {
        // message fields
        // @@protoc_insertion_point(field:CHIDMessageFromRemote.CloseDevice.device)
        pub device: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CHIDMessageFromRemote.CloseDevice.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CloseDevice {
        fn default() -> &'a CloseDevice {
            <CloseDevice as ::protobuf::Message>::default_instance()
        }
    }

    impl CloseDevice {
        pub fn new() -> CloseDevice {
            ::std::default::Default::default()
        }

        // optional uint32 device = 1;

        pub fn device(&self) -> u32 {
            self.device.unwrap_or(0)
        }

        pub fn clear_device(&mut self) {
            self.device = ::std::option::Option::None;
        }

        pub fn has_device(&self) -> bool {
            self.device.is_some()
        }

        // Param is passed by value, moved
        pub fn set_device(&mut self, v: u32) {
            self.device = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for CloseDevice {
        const NAME: &'static str = "CloseDevice";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.device = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.device {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.device {
                os.write_uint32(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CloseDevice {
            CloseDevice::new()
        }

        fn clear(&mut self) {
            self.device = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CloseDevice {
            static instance: CloseDevice = CloseDevice {
                device: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CHIDMessageFromRemote.CloseAllDevices)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CloseAllDevices {
        // special fields
        // @@protoc_insertion_point(special_field:CHIDMessageFromRemote.CloseAllDevices.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CloseAllDevices {
        fn default() -> &'a CloseAllDevices {
            <CloseAllDevices as ::protobuf::Message>::default_instance()
        }
    }

    impl CloseAllDevices {
        pub fn new() -> CloseAllDevices {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for CloseAllDevices {
        const NAME: &'static str = "CloseAllDevices";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CloseAllDevices {
            CloseAllDevices::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CloseAllDevices {
            static instance: CloseAllDevices = CloseAllDevices {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EHIDDeviceLocation)
pub enum EHIDDeviceLocation {
    // @@protoc_insertion_point(enum_value:EHIDDeviceLocation.k_EDeviceLocationLocal)
    k_EDeviceLocationLocal = 0,
    // @@protoc_insertion_point(enum_value:EHIDDeviceLocation.k_EDeviceLocationRemote)
    k_EDeviceLocationRemote = 2,
    // @@protoc_insertion_point(enum_value:EHIDDeviceLocation.k_EDeviceLocationAny)
    k_EDeviceLocationAny = 3,
}

impl ::protobuf::Enum for EHIDDeviceLocation {
    const NAME: &'static str = "EHIDDeviceLocation";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EHIDDeviceLocation> {
        match value {
            0 => ::std::option::Option::Some(EHIDDeviceLocation::k_EDeviceLocationLocal),
            2 => ::std::option::Option::Some(EHIDDeviceLocation::k_EDeviceLocationRemote),
            3 => ::std::option::Option::Some(EHIDDeviceLocation::k_EDeviceLocationAny),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EHIDDeviceLocation> {
        match str {
            "k_EDeviceLocationLocal" => ::std::option::Option::Some(EHIDDeviceLocation::k_EDeviceLocationLocal),
            "k_EDeviceLocationRemote" => ::std::option::Option::Some(EHIDDeviceLocation::k_EDeviceLocationRemote),
            "k_EDeviceLocationAny" => ::std::option::Option::Some(EHIDDeviceLocation::k_EDeviceLocationAny),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EHIDDeviceLocation] = &[
        EHIDDeviceLocation::k_EDeviceLocationLocal,
        EHIDDeviceLocation::k_EDeviceLocationRemote,
        EHIDDeviceLocation::k_EDeviceLocationAny,
    ];
}

impl ::std::default::Default for EHIDDeviceLocation {
    fn default() -> Self {
        EHIDDeviceLocation::k_EDeviceLocationLocal
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EHIDDeviceDisconnectMethod)
pub enum EHIDDeviceDisconnectMethod {
    // @@protoc_insertion_point(enum_value:EHIDDeviceDisconnectMethod.k_EDeviceDisconnectMethodUnknown)
    k_EDeviceDisconnectMethodUnknown = 0,
    // @@protoc_insertion_point(enum_value:EHIDDeviceDisconnectMethod.k_EDeviceDisconnectMethodBluetooth)
    k_EDeviceDisconnectMethodBluetooth = 1,
    // @@protoc_insertion_point(enum_value:EHIDDeviceDisconnectMethod.k_EDeviceDisconnectMethodFeatureReport)
    k_EDeviceDisconnectMethodFeatureReport = 2,
    // @@protoc_insertion_point(enum_value:EHIDDeviceDisconnectMethod.k_EDeviceDisconnectMethodOutputReport)
    k_EDeviceDisconnectMethodOutputReport = 3,
}

impl ::protobuf::Enum for EHIDDeviceDisconnectMethod {
    const NAME: &'static str = "EHIDDeviceDisconnectMethod";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EHIDDeviceDisconnectMethod> {
        match value {
            0 => ::std::option::Option::Some(EHIDDeviceDisconnectMethod::k_EDeviceDisconnectMethodUnknown),
            1 => ::std::option::Option::Some(EHIDDeviceDisconnectMethod::k_EDeviceDisconnectMethodBluetooth),
            2 => ::std::option::Option::Some(EHIDDeviceDisconnectMethod::k_EDeviceDisconnectMethodFeatureReport),
            3 => ::std::option::Option::Some(EHIDDeviceDisconnectMethod::k_EDeviceDisconnectMethodOutputReport),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EHIDDeviceDisconnectMethod> {
        match str {
            "k_EDeviceDisconnectMethodUnknown" => ::std::option::Option::Some(EHIDDeviceDisconnectMethod::k_EDeviceDisconnectMethodUnknown),
            "k_EDeviceDisconnectMethodBluetooth" => ::std::option::Option::Some(EHIDDeviceDisconnectMethod::k_EDeviceDisconnectMethodBluetooth),
            "k_EDeviceDisconnectMethodFeatureReport" => ::std::option::Option::Some(EHIDDeviceDisconnectMethod::k_EDeviceDisconnectMethodFeatureReport),
            "k_EDeviceDisconnectMethodOutputReport" => ::std::option::Option::Some(EHIDDeviceDisconnectMethod::k_EDeviceDisconnectMethodOutputReport),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EHIDDeviceDisconnectMethod] = &[
        EHIDDeviceDisconnectMethod::k_EDeviceDisconnectMethodUnknown,
        EHIDDeviceDisconnectMethod::k_EDeviceDisconnectMethodBluetooth,
        EHIDDeviceDisconnectMethod::k_EDeviceDisconnectMethodFeatureReport,
        EHIDDeviceDisconnectMethod::k_EDeviceDisconnectMethodOutputReport,
    ];
}

impl ::std::default::Default for EHIDDeviceDisconnectMethod {
    fn default() -> Self {
        EHIDDeviceDisconnectMethod::k_EDeviceDisconnectMethodUnknown
    }
}

impl crate::RpcMessage for CHIDDeviceInfo {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CHIDDeviceInputReport {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CHIDMessageToRemote {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CHIDMessageFromRemote {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
