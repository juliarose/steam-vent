// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_client_objects.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:SteamMessagesClientIClientForcedEnumDependencies)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SteamMessagesClientIClientForcedEnumDependencies {
    // message fields
    // @@protoc_insertion_point(field:SteamMessagesClientIClientForcedEnumDependencies.a)
    pub a: ::std::option::Option<::protobuf::EnumOrUnknown<super::enums::EBluetoothDeviceType>>,
    // @@protoc_insertion_point(field:SteamMessagesClientIClientForcedEnumDependencies.b)
    pub b: ::std::option::Option<::protobuf::EnumOrUnknown<super::enums::EStorageBlockContentType>>,
    // @@protoc_insertion_point(field:SteamMessagesClientIClientForcedEnumDependencies.c)
    pub c: ::std::option::Option<::protobuf::EnumOrUnknown<super::enums::EStorageBlockFileSystemType>>,
    // @@protoc_insertion_point(field:SteamMessagesClientIClientForcedEnumDependencies.d)
    pub d: ::std::option::Option<::protobuf::EnumOrUnknown<super::enums::ESDCardFormatStage>>,
    // special fields
    // @@protoc_insertion_point(special_field:SteamMessagesClientIClientForcedEnumDependencies.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SteamMessagesClientIClientForcedEnumDependencies {
    fn default() -> &'a SteamMessagesClientIClientForcedEnumDependencies {
        <SteamMessagesClientIClientForcedEnumDependencies as ::protobuf::Message>::default_instance()
    }
}

impl SteamMessagesClientIClientForcedEnumDependencies {
    pub fn new() -> SteamMessagesClientIClientForcedEnumDependencies {
        ::std::default::Default::default()
    }

    // optional .EBluetoothDeviceType a = 1;

    pub fn a(&self) -> super::enums::EBluetoothDeviceType {
        match self.a {
            Some(e) => e.enum_value_or(super::enums::EBluetoothDeviceType::k_BluetoothDeviceType_Invalid),
            None => super::enums::EBluetoothDeviceType::k_BluetoothDeviceType_Invalid,
        }
    }

    pub fn clear_a(&mut self) {
        self.a = ::std::option::Option::None;
    }

    pub fn has_a(&self) -> bool {
        self.a.is_some()
    }

    // Param is passed by value, moved
    pub fn set_a(&mut self, v: super::enums::EBluetoothDeviceType) {
        self.a = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .EStorageBlockContentType b = 2;

    pub fn b(&self) -> super::enums::EStorageBlockContentType {
        match self.b {
            Some(e) => e.enum_value_or(super::enums::EStorageBlockContentType::k_EStorageBlockContentType_Invalid),
            None => super::enums::EStorageBlockContentType::k_EStorageBlockContentType_Invalid,
        }
    }

    pub fn clear_b(&mut self) {
        self.b = ::std::option::Option::None;
    }

    pub fn has_b(&self) -> bool {
        self.b.is_some()
    }

    // Param is passed by value, moved
    pub fn set_b(&mut self, v: super::enums::EStorageBlockContentType) {
        self.b = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .EStorageBlockFileSystemType c = 3;

    pub fn c(&self) -> super::enums::EStorageBlockFileSystemType {
        match self.c {
            Some(e) => e.enum_value_or(super::enums::EStorageBlockFileSystemType::k_EStorageBlockFileSystemType_Invalid),
            None => super::enums::EStorageBlockFileSystemType::k_EStorageBlockFileSystemType_Invalid,
        }
    }

    pub fn clear_c(&mut self) {
        self.c = ::std::option::Option::None;
    }

    pub fn has_c(&self) -> bool {
        self.c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_c(&mut self, v: super::enums::EStorageBlockFileSystemType) {
        self.c = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .ESDCardFormatStage d = 4;

    pub fn d(&self) -> super::enums::ESDCardFormatStage {
        match self.d {
            Some(e) => e.enum_value_or(super::enums::ESDCardFormatStage::k_ESDCardFormatStage_Invalid),
            None => super::enums::ESDCardFormatStage::k_ESDCardFormatStage_Invalid,
        }
    }

    pub fn clear_d(&mut self) {
        self.d = ::std::option::Option::None;
    }

    pub fn has_d(&self) -> bool {
        self.d.is_some()
    }

    // Param is passed by value, moved
    pub fn set_d(&mut self, v: super::enums::ESDCardFormatStage) {
        self.d = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::protobuf::Message for SteamMessagesClientIClientForcedEnumDependencies {
    const NAME: &'static str = "SteamMessagesClientIClientForcedEnumDependencies";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.a = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.b = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.c = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.d = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.a {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.b {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.c {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.d {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.a {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.b {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.c {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.d {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SteamMessagesClientIClientForcedEnumDependencies {
        SteamMessagesClientIClientForcedEnumDependencies::new()
    }

    fn clear(&mut self) {
        self.a = ::std::option::Option::None;
        self.b = ::std::option::Option::None;
        self.c = ::std::option::Option::None;
        self.d = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SteamMessagesClientIClientForcedEnumDependencies {
        static instance: SteamMessagesClientIClientForcedEnumDependencies = SteamMessagesClientIClientForcedEnumDependencies {
            a: ::std::option::Option::None,
            b: ::std::option::Option::None,
            c: ::std::option::Option::None,
            d: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgNetworkDeviceIP4Address)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgNetworkDeviceIP4Address {
    // message fields
    // @@protoc_insertion_point(field:CMsgNetworkDeviceIP4Address.ip)
    pub ip: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgNetworkDeviceIP4Address.netmask)
    pub netmask: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgNetworkDeviceIP4Address.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgNetworkDeviceIP4Address {
    fn default() -> &'a CMsgNetworkDeviceIP4Address {
        <CMsgNetworkDeviceIP4Address as ::protobuf::Message>::default_instance()
    }
}

impl CMsgNetworkDeviceIP4Address {
    pub fn new() -> CMsgNetworkDeviceIP4Address {
        ::std::default::Default::default()
    }

    // optional int32 ip = 1;

    pub fn ip(&self) -> i32 {
        self.ip.unwrap_or(0i32)
    }

    pub fn clear_ip(&mut self) {
        self.ip = ::std::option::Option::None;
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: i32) {
        self.ip = ::std::option::Option::Some(v);
    }

    // optional int32 netmask = 2;

    pub fn netmask(&self) -> i32 {
        self.netmask.unwrap_or(0)
    }

    pub fn clear_netmask(&mut self) {
        self.netmask = ::std::option::Option::None;
    }

    pub fn has_netmask(&self) -> bool {
        self.netmask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_netmask(&mut self, v: i32) {
        self.netmask = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgNetworkDeviceIP4Address {
    const NAME: &'static str = "CMsgNetworkDeviceIP4Address";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ip = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.netmask = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ip {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.netmask {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ip {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.netmask {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgNetworkDeviceIP4Address {
        CMsgNetworkDeviceIP4Address::new()
    }

    fn clear(&mut self) {
        self.ip = ::std::option::Option::None;
        self.netmask = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgNetworkDeviceIP4Address {
        static instance: CMsgNetworkDeviceIP4Address = CMsgNetworkDeviceIP4Address {
            ip: ::std::option::Option::None,
            netmask: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgNetworkDeviceIP4Config)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgNetworkDeviceIP4Config {
    // message fields
    // @@protoc_insertion_point(field:CMsgNetworkDeviceIP4Config.addresses)
    pub addresses: ::std::vec::Vec<CMsgNetworkDeviceIP4Address>,
    // @@protoc_insertion_point(field:CMsgNetworkDeviceIP4Config.dns_ip)
    pub dns_ip: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgNetworkDeviceIP4Config.gateway_ip)
    pub gateway_ip: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgNetworkDeviceIP4Config.is_dhcp_enabled)
    pub is_dhcp_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgNetworkDeviceIP4Config.is_default_route)
    pub is_default_route: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgNetworkDeviceIP4Config.is_enabled)
    pub is_enabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgNetworkDeviceIP4Config.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgNetworkDeviceIP4Config {
    fn default() -> &'a CMsgNetworkDeviceIP4Config {
        <CMsgNetworkDeviceIP4Config as ::protobuf::Message>::default_instance()
    }
}

impl CMsgNetworkDeviceIP4Config {
    pub fn new() -> CMsgNetworkDeviceIP4Config {
        ::std::default::Default::default()
    }

    // optional int32 gateway_ip = 3;

    pub fn gateway_ip(&self) -> i32 {
        self.gateway_ip.unwrap_or(0)
    }

    pub fn clear_gateway_ip(&mut self) {
        self.gateway_ip = ::std::option::Option::None;
    }

    pub fn has_gateway_ip(&self) -> bool {
        self.gateway_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gateway_ip(&mut self, v: i32) {
        self.gateway_ip = ::std::option::Option::Some(v);
    }

    // optional bool is_dhcp_enabled = 4;

    pub fn is_dhcp_enabled(&self) -> bool {
        self.is_dhcp_enabled.unwrap_or(false)
    }

    pub fn clear_is_dhcp_enabled(&mut self) {
        self.is_dhcp_enabled = ::std::option::Option::None;
    }

    pub fn has_is_dhcp_enabled(&self) -> bool {
        self.is_dhcp_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_dhcp_enabled(&mut self, v: bool) {
        self.is_dhcp_enabled = ::std::option::Option::Some(v);
    }

    // optional bool is_default_route = 5;

    pub fn is_default_route(&self) -> bool {
        self.is_default_route.unwrap_or(false)
    }

    pub fn clear_is_default_route(&mut self) {
        self.is_default_route = ::std::option::Option::None;
    }

    pub fn has_is_default_route(&self) -> bool {
        self.is_default_route.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_default_route(&mut self, v: bool) {
        self.is_default_route = ::std::option::Option::Some(v);
    }

    // optional bool is_enabled = 6;

    pub fn is_enabled(&self) -> bool {
        self.is_enabled.unwrap_or(false)
    }

    pub fn clear_is_enabled(&mut self) {
        self.is_enabled = ::std::option::Option::None;
    }

    pub fn has_is_enabled(&self) -> bool {
        self.is_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_enabled(&mut self, v: bool) {
        self.is_enabled = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgNetworkDeviceIP4Config {
    const NAME: &'static str = "CMsgNetworkDeviceIP4Config";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.addresses.push(is.read_message()?);
                },
                18 => {
                    is.read_repeated_packed_int32_into(&mut self.dns_ip)?;
                },
                16 => {
                    self.dns_ip.push(is.read_int32()?);
                },
                24 => {
                    self.gateway_ip = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.is_dhcp_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.is_default_route = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.is_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.addresses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.dns_ip {
            my_size += ::protobuf::rt::int32_size(2, *value);
        };
        if let Some(v) = self.gateway_ip {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.is_dhcp_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_default_route {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_enabled {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.addresses {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.dns_ip {
            os.write_int32(2, *v)?;
        };
        if let Some(v) = self.gateway_ip {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.is_dhcp_enabled {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.is_default_route {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.is_enabled {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgNetworkDeviceIP4Config {
        CMsgNetworkDeviceIP4Config::new()
    }

    fn clear(&mut self) {
        self.addresses.clear();
        self.dns_ip.clear();
        self.gateway_ip = ::std::option::Option::None;
        self.is_dhcp_enabled = ::std::option::Option::None;
        self.is_default_route = ::std::option::Option::None;
        self.is_enabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgNetworkDeviceIP4Config {
        static instance: CMsgNetworkDeviceIP4Config = CMsgNetworkDeviceIP4Config {
            addresses: ::std::vec::Vec::new(),
            dns_ip: ::std::vec::Vec::new(),
            gateway_ip: ::std::option::Option::None,
            is_dhcp_enabled: ::std::option::Option::None,
            is_default_route: ::std::option::Option::None,
            is_enabled: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgNetworkDeviceIP6Address)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgNetworkDeviceIP6Address {
    // message fields
    // @@protoc_insertion_point(field:CMsgNetworkDeviceIP6Address.ip)
    pub ip: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgNetworkDeviceIP6Address.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgNetworkDeviceIP6Address {
    fn default() -> &'a CMsgNetworkDeviceIP6Address {
        <CMsgNetworkDeviceIP6Address as ::protobuf::Message>::default_instance()
    }
}

impl CMsgNetworkDeviceIP6Address {
    pub fn new() -> CMsgNetworkDeviceIP6Address {
        ::std::default::Default::default()
    }

    // optional string ip = 1;

    pub fn ip(&self) -> &str {
        match self.ip.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_ip(&mut self) {
        self.ip = ::std::option::Option::None;
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: ::std::string::String) {
        self.ip = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip(&mut self) -> &mut ::std::string::String {
        if self.ip.is_none() {
            self.ip = ::std::option::Option::Some(::std::string::String::new());
        }
        self.ip.as_mut().unwrap()
    }

    // Take field
    pub fn take_ip(&mut self) -> ::std::string::String {
        self.ip.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgNetworkDeviceIP6Address {
    const NAME: &'static str = "CMsgNetworkDeviceIP6Address";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.ip = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ip.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ip.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgNetworkDeviceIP6Address {
        CMsgNetworkDeviceIP6Address::new()
    }

    fn clear(&mut self) {
        self.ip = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgNetworkDeviceIP6Address {
        static instance: CMsgNetworkDeviceIP6Address = CMsgNetworkDeviceIP6Address {
            ip: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgNetworkDeviceIP6Config)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgNetworkDeviceIP6Config {
    // message fields
    // @@protoc_insertion_point(field:CMsgNetworkDeviceIP6Config.addresses)
    pub addresses: ::std::vec::Vec<CMsgNetworkDeviceIP6Address>,
    // @@protoc_insertion_point(field:CMsgNetworkDeviceIP6Config.dns_ip)
    pub dns_ip: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgNetworkDeviceIP6Config.gateway_ip)
    pub gateway_ip: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgNetworkDeviceIP6Config.is_dhcp_enabled)
    pub is_dhcp_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgNetworkDeviceIP6Config.is_default_route)
    pub is_default_route: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgNetworkDeviceIP6Config.is_enabled)
    pub is_enabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgNetworkDeviceIP6Config.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgNetworkDeviceIP6Config {
    fn default() -> &'a CMsgNetworkDeviceIP6Config {
        <CMsgNetworkDeviceIP6Config as ::protobuf::Message>::default_instance()
    }
}

impl CMsgNetworkDeviceIP6Config {
    pub fn new() -> CMsgNetworkDeviceIP6Config {
        ::std::default::Default::default()
    }

    // optional string gateway_ip = 3;

    pub fn gateway_ip(&self) -> &str {
        match self.gateway_ip.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_gateway_ip(&mut self) {
        self.gateway_ip = ::std::option::Option::None;
    }

    pub fn has_gateway_ip(&self) -> bool {
        self.gateway_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gateway_ip(&mut self, v: ::std::string::String) {
        self.gateway_ip = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gateway_ip(&mut self) -> &mut ::std::string::String {
        if self.gateway_ip.is_none() {
            self.gateway_ip = ::std::option::Option::Some(::std::string::String::new());
        }
        self.gateway_ip.as_mut().unwrap()
    }

    // Take field
    pub fn take_gateway_ip(&mut self) -> ::std::string::String {
        self.gateway_ip.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_dhcp_enabled = 4;

    pub fn is_dhcp_enabled(&self) -> bool {
        self.is_dhcp_enabled.unwrap_or(false)
    }

    pub fn clear_is_dhcp_enabled(&mut self) {
        self.is_dhcp_enabled = ::std::option::Option::None;
    }

    pub fn has_is_dhcp_enabled(&self) -> bool {
        self.is_dhcp_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_dhcp_enabled(&mut self, v: bool) {
        self.is_dhcp_enabled = ::std::option::Option::Some(v);
    }

    // optional bool is_default_route = 5;

    pub fn is_default_route(&self) -> bool {
        self.is_default_route.unwrap_or(false)
    }

    pub fn clear_is_default_route(&mut self) {
        self.is_default_route = ::std::option::Option::None;
    }

    pub fn has_is_default_route(&self) -> bool {
        self.is_default_route.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_default_route(&mut self, v: bool) {
        self.is_default_route = ::std::option::Option::Some(v);
    }

    // optional bool is_enabled = 6;

    pub fn is_enabled(&self) -> bool {
        self.is_enabled.unwrap_or(false)
    }

    pub fn clear_is_enabled(&mut self) {
        self.is_enabled = ::std::option::Option::None;
    }

    pub fn has_is_enabled(&self) -> bool {
        self.is_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_enabled(&mut self, v: bool) {
        self.is_enabled = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgNetworkDeviceIP6Config {
    const NAME: &'static str = "CMsgNetworkDeviceIP6Config";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.addresses.push(is.read_message()?);
                },
                18 => {
                    self.dns_ip.push(is.read_string()?);
                },
                26 => {
                    self.gateway_ip = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.is_dhcp_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.is_default_route = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.is_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.addresses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.dns_ip {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if let Some(v) = self.gateway_ip.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.is_dhcp_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_default_route {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_enabled {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.addresses {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.dns_ip {
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.gateway_ip.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.is_dhcp_enabled {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.is_default_route {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.is_enabled {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgNetworkDeviceIP6Config {
        CMsgNetworkDeviceIP6Config::new()
    }

    fn clear(&mut self) {
        self.addresses.clear();
        self.dns_ip.clear();
        self.gateway_ip = ::std::option::Option::None;
        self.is_dhcp_enabled = ::std::option::Option::None;
        self.is_default_route = ::std::option::Option::None;
        self.is_enabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgNetworkDeviceIP6Config {
        static instance: CMsgNetworkDeviceIP6Config = CMsgNetworkDeviceIP6Config {
            addresses: ::std::vec::Vec::new(),
            dns_ip: ::std::vec::Vec::new(),
            gateway_ip: ::std::option::Option::None,
            is_dhcp_enabled: ::std::option::Option::None,
            is_default_route: ::std::option::Option::None,
            is_enabled: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgNetworkDevicesData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgNetworkDevicesData {
    // message fields
    // @@protoc_insertion_point(field:CMsgNetworkDevicesData.devices)
    pub devices: ::std::vec::Vec<cmsg_network_devices_data::Device>,
    // @@protoc_insertion_point(field:CMsgNetworkDevicesData.is_wifi_enabled)
    pub is_wifi_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgNetworkDevicesData.is_wifi_scanning_enabled)
    pub is_wifi_scanning_enabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgNetworkDevicesData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgNetworkDevicesData {
    fn default() -> &'a CMsgNetworkDevicesData {
        <CMsgNetworkDevicesData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgNetworkDevicesData {
    pub fn new() -> CMsgNetworkDevicesData {
        ::std::default::Default::default()
    }

    // optional bool is_wifi_enabled = 2;

    pub fn is_wifi_enabled(&self) -> bool {
        self.is_wifi_enabled.unwrap_or(false)
    }

    pub fn clear_is_wifi_enabled(&mut self) {
        self.is_wifi_enabled = ::std::option::Option::None;
    }

    pub fn has_is_wifi_enabled(&self) -> bool {
        self.is_wifi_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_wifi_enabled(&mut self, v: bool) {
        self.is_wifi_enabled = ::std::option::Option::Some(v);
    }

    // optional bool is_wifi_scanning_enabled = 3;

    pub fn is_wifi_scanning_enabled(&self) -> bool {
        self.is_wifi_scanning_enabled.unwrap_or(false)
    }

    pub fn clear_is_wifi_scanning_enabled(&mut self) {
        self.is_wifi_scanning_enabled = ::std::option::Option::None;
    }

    pub fn has_is_wifi_scanning_enabled(&self) -> bool {
        self.is_wifi_scanning_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_wifi_scanning_enabled(&mut self, v: bool) {
        self.is_wifi_scanning_enabled = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgNetworkDevicesData {
    const NAME: &'static str = "CMsgNetworkDevicesData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.devices.push(is.read_message()?);
                },
                16 => {
                    self.is_wifi_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.is_wifi_scanning_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.devices {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.is_wifi_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_wifi_scanning_enabled {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.devices {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.is_wifi_enabled {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.is_wifi_scanning_enabled {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgNetworkDevicesData {
        CMsgNetworkDevicesData::new()
    }

    fn clear(&mut self) {
        self.devices.clear();
        self.is_wifi_enabled = ::std::option::Option::None;
        self.is_wifi_scanning_enabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgNetworkDevicesData {
        static instance: CMsgNetworkDevicesData = CMsgNetworkDevicesData {
            devices: ::std::vec::Vec::new(),
            is_wifi_enabled: ::std::option::Option::None,
            is_wifi_scanning_enabled: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgNetworkDevicesData`
pub mod cmsg_network_devices_data {
    // @@protoc_insertion_point(message:CMsgNetworkDevicesData.Device)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Device {
        // message fields
        // @@protoc_insertion_point(field:CMsgNetworkDevicesData.Device.id)
        pub id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgNetworkDevicesData.Device.etype)
        pub etype: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgNetworkDevicesData.Device.estate)
        pub estate: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgNetworkDevicesData.Device.mac)
        pub mac: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgNetworkDevicesData.Device.vendor)
        pub vendor: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgNetworkDevicesData.Device.product)
        pub product: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgNetworkDevicesData.Device.ip4)
        pub ip4: ::protobuf::MessageField<super::CMsgNetworkDeviceIP4Config>,
        // @@protoc_insertion_point(field:CMsgNetworkDevicesData.Device.ip6)
        pub ip6: ::protobuf::MessageField<super::CMsgNetworkDeviceIP6Config>,
        // @@protoc_insertion_point(field:CMsgNetworkDevicesData.Device.wired)
        pub wired: ::protobuf::MessageField<device::Wired>,
        // @@protoc_insertion_point(field:CMsgNetworkDevicesData.Device.wireless)
        pub wireless: ::protobuf::MessageField<device::Wireless>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgNetworkDevicesData.Device.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Device {
        fn default() -> &'a Device {
            <Device as ::protobuf::Message>::default_instance()
        }
    }

    impl Device {
        pub fn new() -> Device {
            ::std::default::Default::default()
        }

        // optional uint32 id = 1;

        pub fn id(&self) -> u32 {
            self.id.unwrap_or(0u32)
        }

        pub fn clear_id(&mut self) {
            self.id = ::std::option::Option::None;
        }

        pub fn has_id(&self) -> bool {
            self.id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_id(&mut self, v: u32) {
            self.id = ::std::option::Option::Some(v);
        }

        // optional int32 etype = 2;

        pub fn etype(&self) -> i32 {
            self.etype.unwrap_or(0)
        }

        pub fn clear_etype(&mut self) {
            self.etype = ::std::option::Option::None;
        }

        pub fn has_etype(&self) -> bool {
            self.etype.is_some()
        }

        // Param is passed by value, moved
        pub fn set_etype(&mut self, v: i32) {
            self.etype = ::std::option::Option::Some(v);
        }

        // optional int32 estate = 3;

        pub fn estate(&self) -> i32 {
            self.estate.unwrap_or(0)
        }

        pub fn clear_estate(&mut self) {
            self.estate = ::std::option::Option::None;
        }

        pub fn has_estate(&self) -> bool {
            self.estate.is_some()
        }

        // Param is passed by value, moved
        pub fn set_estate(&mut self, v: i32) {
            self.estate = ::std::option::Option::Some(v);
        }

        // optional string mac = 4;

        pub fn mac(&self) -> &str {
            match self.mac.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_mac(&mut self) {
            self.mac = ::std::option::Option::None;
        }

        pub fn has_mac(&self) -> bool {
            self.mac.is_some()
        }

        // Param is passed by value, moved
        pub fn set_mac(&mut self, v: ::std::string::String) {
            self.mac = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_mac(&mut self) -> &mut ::std::string::String {
            if self.mac.is_none() {
                self.mac = ::std::option::Option::Some(::std::string::String::new());
            }
            self.mac.as_mut().unwrap()
        }

        // Take field
        pub fn take_mac(&mut self) -> ::std::string::String {
            self.mac.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string vendor = 5;

        pub fn vendor(&self) -> &str {
            match self.vendor.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_vendor(&mut self) {
            self.vendor = ::std::option::Option::None;
        }

        pub fn has_vendor(&self) -> bool {
            self.vendor.is_some()
        }

        // Param is passed by value, moved
        pub fn set_vendor(&mut self, v: ::std::string::String) {
            self.vendor = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_vendor(&mut self) -> &mut ::std::string::String {
            if self.vendor.is_none() {
                self.vendor = ::std::option::Option::Some(::std::string::String::new());
            }
            self.vendor.as_mut().unwrap()
        }

        // Take field
        pub fn take_vendor(&mut self) -> ::std::string::String {
            self.vendor.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string product = 6;

        pub fn product(&self) -> &str {
            match self.product.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_product(&mut self) {
            self.product = ::std::option::Option::None;
        }

        pub fn has_product(&self) -> bool {
            self.product.is_some()
        }

        // Param is passed by value, moved
        pub fn set_product(&mut self, v: ::std::string::String) {
            self.product = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_product(&mut self) -> &mut ::std::string::String {
            if self.product.is_none() {
                self.product = ::std::option::Option::Some(::std::string::String::new());
            }
            self.product.as_mut().unwrap()
        }

        // Take field
        pub fn take_product(&mut self) -> ::std::string::String {
            self.product.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::protobuf::Message for Device {
        const NAME: &'static str = "Device";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.etype = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.estate = ::std::option::Option::Some(is.read_int32()?);
                    },
                    34 => {
                        self.mac = ::std::option::Option::Some(is.read_string()?);
                    },
                    42 => {
                        self.vendor = ::std::option::Option::Some(is.read_string()?);
                    },
                    50 => {
                        self.product = ::std::option::Option::Some(is.read_string()?);
                    },
                    58 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.ip4)?;
                    },
                    66 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.ip6)?;
                    },
                    74 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.wired)?;
                    },
                    82 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.wireless)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.etype {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.estate {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.mac.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            if let Some(v) = self.vendor.as_ref() {
                my_size += ::protobuf::rt::string_size(5, &v);
            }
            if let Some(v) = self.product.as_ref() {
                my_size += ::protobuf::rt::string_size(6, &v);
            }
            if let Some(v) = self.ip4.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.ip6.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.wired.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.wireless.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.etype {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.estate {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.mac.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.vendor.as_ref() {
                os.write_string(5, v)?;
            }
            if let Some(v) = self.product.as_ref() {
                os.write_string(6, v)?;
            }
            if let Some(v) = self.ip4.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
            }
            if let Some(v) = self.ip6.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
            }
            if let Some(v) = self.wired.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
            }
            if let Some(v) = self.wireless.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Device {
            Device::new()
        }

        fn clear(&mut self) {
            self.id = ::std::option::Option::None;
            self.etype = ::std::option::Option::None;
            self.estate = ::std::option::Option::None;
            self.mac = ::std::option::Option::None;
            self.vendor = ::std::option::Option::None;
            self.product = ::std::option::Option::None;
            self.ip4.clear();
            self.ip6.clear();
            self.wired.clear();
            self.wireless.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Device {
            static instance: Device = Device {
                id: ::std::option::Option::None,
                etype: ::std::option::Option::None,
                estate: ::std::option::Option::None,
                mac: ::std::option::Option::None,
                vendor: ::std::option::Option::None,
                product: ::std::option::Option::None,
                ip4: ::protobuf::MessageField::none(),
                ip6: ::protobuf::MessageField::none(),
                wired: ::protobuf::MessageField::none(),
                wireless: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `Device`
    pub mod device {
        // @@protoc_insertion_point(message:CMsgNetworkDevicesData.Device.Wired)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Wired {
            // message fields
            // @@protoc_insertion_point(field:CMsgNetworkDevicesData.Device.Wired.is_cable_present)
            pub is_cable_present: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:CMsgNetworkDevicesData.Device.Wired.speed_mbit)
            pub speed_mbit: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgNetworkDevicesData.Device.Wired.friendly_name)
            pub friendly_name: ::std::option::Option<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:CMsgNetworkDevicesData.Device.Wired.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Wired {
            fn default() -> &'a Wired {
                <Wired as ::protobuf::Message>::default_instance()
            }
        }

        impl Wired {
            pub fn new() -> Wired {
                ::std::default::Default::default()
            }

            // optional bool is_cable_present = 1;

            pub fn is_cable_present(&self) -> bool {
                self.is_cable_present.unwrap_or(false)
            }

            pub fn clear_is_cable_present(&mut self) {
                self.is_cable_present = ::std::option::Option::None;
            }

            pub fn has_is_cable_present(&self) -> bool {
                self.is_cable_present.is_some()
            }

            // Param is passed by value, moved
            pub fn set_is_cable_present(&mut self, v: bool) {
                self.is_cable_present = ::std::option::Option::Some(v);
            }

            // optional uint32 speed_mbit = 2;

            pub fn speed_mbit(&self) -> u32 {
                self.speed_mbit.unwrap_or(0)
            }

            pub fn clear_speed_mbit(&mut self) {
                self.speed_mbit = ::std::option::Option::None;
            }

            pub fn has_speed_mbit(&self) -> bool {
                self.speed_mbit.is_some()
            }

            // Param is passed by value, moved
            pub fn set_speed_mbit(&mut self, v: u32) {
                self.speed_mbit = ::std::option::Option::Some(v);
            }

            // optional string friendly_name = 3;

            pub fn friendly_name(&self) -> &str {
                match self.friendly_name.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_friendly_name(&mut self) {
                self.friendly_name = ::std::option::Option::None;
            }

            pub fn has_friendly_name(&self) -> bool {
                self.friendly_name.is_some()
            }

            // Param is passed by value, moved
            pub fn set_friendly_name(&mut self, v: ::std::string::String) {
                self.friendly_name = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_friendly_name(&mut self) -> &mut ::std::string::String {
                if self.friendly_name.is_none() {
                    self.friendly_name = ::std::option::Option::Some(::std::string::String::new());
                }
                self.friendly_name.as_mut().unwrap()
            }

            // Take field
            pub fn take_friendly_name(&mut self) -> ::std::string::String {
                self.friendly_name.take().unwrap_or_else(|| ::std::string::String::new())
            }
        }

        impl ::protobuf::Message for Wired {
            const NAME: &'static str = "Wired";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.is_cable_present = ::std::option::Option::Some(is.read_bool()?);
                        },
                        16 => {
                            self.speed_mbit = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        26 => {
                            self.friendly_name = ::std::option::Option::Some(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.is_cable_present {
                    my_size += 1 + 1;
                }
                if let Some(v) = self.speed_mbit {
                    my_size += ::protobuf::rt::uint32_size(2, v);
                }
                if let Some(v) = self.friendly_name.as_ref() {
                    my_size += ::protobuf::rt::string_size(3, &v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.is_cable_present {
                    os.write_bool(1, v)?;
                }
                if let Some(v) = self.speed_mbit {
                    os.write_uint32(2, v)?;
                }
                if let Some(v) = self.friendly_name.as_ref() {
                    os.write_string(3, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Wired {
                Wired::new()
            }

            fn clear(&mut self) {
                self.is_cable_present = ::std::option::Option::None;
                self.speed_mbit = ::std::option::Option::None;
                self.friendly_name = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Wired {
                static instance: Wired = Wired {
                    is_cable_present: ::std::option::Option::None,
                    speed_mbit: ::std::option::Option::None,
                    friendly_name: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        // @@protoc_insertion_point(message:CMsgNetworkDevicesData.Device.Wireless)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Wireless {
            // message fields
            // @@protoc_insertion_point(field:CMsgNetworkDevicesData.Device.Wireless.aps)
            pub aps: ::std::vec::Vec<wireless::AP>,
            // @@protoc_insertion_point(field:CMsgNetworkDevicesData.Device.Wireless.esecurity_supported)
            pub esecurity_supported: ::std::option::Option<i32>,
            // special fields
            // @@protoc_insertion_point(special_field:CMsgNetworkDevicesData.Device.Wireless.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Wireless {
            fn default() -> &'a Wireless {
                <Wireless as ::protobuf::Message>::default_instance()
            }
        }

        impl Wireless {
            pub fn new() -> Wireless {
                ::std::default::Default::default()
            }

            // optional int32 esecurity_supported = 2;

            pub fn esecurity_supported(&self) -> i32 {
                self.esecurity_supported.unwrap_or(0)
            }

            pub fn clear_esecurity_supported(&mut self) {
                self.esecurity_supported = ::std::option::Option::None;
            }

            pub fn has_esecurity_supported(&self) -> bool {
                self.esecurity_supported.is_some()
            }

            // Param is passed by value, moved
            pub fn set_esecurity_supported(&mut self, v: i32) {
                self.esecurity_supported = ::std::option::Option::Some(v);
            }
        }

        impl ::protobuf::Message for Wireless {
            const NAME: &'static str = "Wireless";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.aps.push(is.read_message()?);
                        },
                        16 => {
                            self.esecurity_supported = ::std::option::Option::Some(is.read_int32()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.aps {
                    let len = value.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                if let Some(v) = self.esecurity_supported {
                    my_size += ::protobuf::rt::int32_size(2, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.aps {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                };
                if let Some(v) = self.esecurity_supported {
                    os.write_int32(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Wireless {
                Wireless::new()
            }

            fn clear(&mut self) {
                self.aps.clear();
                self.esecurity_supported = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Wireless {
                static instance: Wireless = Wireless {
                    aps: ::std::vec::Vec::new(),
                    esecurity_supported: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        /// Nested message and enums of message `Wireless`
        pub mod wireless {
            // @@protoc_insertion_point(message:CMsgNetworkDevicesData.Device.Wireless.AP)
            #[derive(PartialEq,Clone,Default,Debug)]
            pub struct AP {
                // message fields
                // @@protoc_insertion_point(field:CMsgNetworkDevicesData.Device.Wireless.AP.id)
                pub id: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:CMsgNetworkDevicesData.Device.Wireless.AP.estrength)
                pub estrength: ::std::option::Option<i32>,
                // @@protoc_insertion_point(field:CMsgNetworkDevicesData.Device.Wireless.AP.ssid)
                pub ssid: ::std::option::Option<::std::string::String>,
                // @@protoc_insertion_point(field:CMsgNetworkDevicesData.Device.Wireless.AP.is_active)
                pub is_active: ::std::option::Option<bool>,
                // @@protoc_insertion_point(field:CMsgNetworkDevicesData.Device.Wireless.AP.is_autoconnect)
                pub is_autoconnect: ::std::option::Option<bool>,
                // @@protoc_insertion_point(field:CMsgNetworkDevicesData.Device.Wireless.AP.esecurity)
                pub esecurity: ::std::option::Option<i32>,
                // @@protoc_insertion_point(field:CMsgNetworkDevicesData.Device.Wireless.AP.user_name)
                pub user_name: ::std::option::Option<::std::string::String>,
                // @@protoc_insertion_point(field:CMsgNetworkDevicesData.Device.Wireless.AP.password)
                pub password: ::std::option::Option<::std::string::String>,
                // @@protoc_insertion_point(field:CMsgNetworkDevicesData.Device.Wireless.AP.strength_raw)
                pub strength_raw: ::std::option::Option<i32>,
                // special fields
                // @@protoc_insertion_point(special_field:CMsgNetworkDevicesData.Device.Wireless.AP.special_fields)
                pub special_fields: ::protobuf::SpecialFields,
            }

            impl<'a> ::std::default::Default for &'a AP {
                fn default() -> &'a AP {
                    <AP as ::protobuf::Message>::default_instance()
                }
            }

            impl AP {
                pub fn new() -> AP {
                    ::std::default::Default::default()
                }

                // optional uint32 id = 1;

                pub fn id(&self) -> u32 {
                    self.id.unwrap_or(0u32)
                }

                pub fn clear_id(&mut self) {
                    self.id = ::std::option::Option::None;
                }

                pub fn has_id(&self) -> bool {
                    self.id.is_some()
                }

                // Param is passed by value, moved
                pub fn set_id(&mut self, v: u32) {
                    self.id = ::std::option::Option::Some(v);
                }

                // optional int32 estrength = 2;

                pub fn estrength(&self) -> i32 {
                    self.estrength.unwrap_or(0)
                }

                pub fn clear_estrength(&mut self) {
                    self.estrength = ::std::option::Option::None;
                }

                pub fn has_estrength(&self) -> bool {
                    self.estrength.is_some()
                }

                // Param is passed by value, moved
                pub fn set_estrength(&mut self, v: i32) {
                    self.estrength = ::std::option::Option::Some(v);
                }

                // optional string ssid = 3;

                pub fn ssid(&self) -> &str {
                    match self.ssid.as_ref() {
                        Some(v) => v,
                        None => "",
                    }
                }

                pub fn clear_ssid(&mut self) {
                    self.ssid = ::std::option::Option::None;
                }

                pub fn has_ssid(&self) -> bool {
                    self.ssid.is_some()
                }

                // Param is passed by value, moved
                pub fn set_ssid(&mut self, v: ::std::string::String) {
                    self.ssid = ::std::option::Option::Some(v);
                }

                // Mutable pointer to the field.
                // If field is not initialized, it is initialized with default value first.
                pub fn mut_ssid(&mut self) -> &mut ::std::string::String {
                    if self.ssid.is_none() {
                        self.ssid = ::std::option::Option::Some(::std::string::String::new());
                    }
                    self.ssid.as_mut().unwrap()
                }

                // Take field
                pub fn take_ssid(&mut self) -> ::std::string::String {
                    self.ssid.take().unwrap_or_else(|| ::std::string::String::new())
                }

                // optional bool is_active = 4;

                pub fn is_active(&self) -> bool {
                    self.is_active.unwrap_or(false)
                }

                pub fn clear_is_active(&mut self) {
                    self.is_active = ::std::option::Option::None;
                }

                pub fn has_is_active(&self) -> bool {
                    self.is_active.is_some()
                }

                // Param is passed by value, moved
                pub fn set_is_active(&mut self, v: bool) {
                    self.is_active = ::std::option::Option::Some(v);
                }

                // optional bool is_autoconnect = 5;

                pub fn is_autoconnect(&self) -> bool {
                    self.is_autoconnect.unwrap_or(false)
                }

                pub fn clear_is_autoconnect(&mut self) {
                    self.is_autoconnect = ::std::option::Option::None;
                }

                pub fn has_is_autoconnect(&self) -> bool {
                    self.is_autoconnect.is_some()
                }

                // Param is passed by value, moved
                pub fn set_is_autoconnect(&mut self, v: bool) {
                    self.is_autoconnect = ::std::option::Option::Some(v);
                }

                // optional int32 esecurity = 6;

                pub fn esecurity(&self) -> i32 {
                    self.esecurity.unwrap_or(0)
                }

                pub fn clear_esecurity(&mut self) {
                    self.esecurity = ::std::option::Option::None;
                }

                pub fn has_esecurity(&self) -> bool {
                    self.esecurity.is_some()
                }

                // Param is passed by value, moved
                pub fn set_esecurity(&mut self, v: i32) {
                    self.esecurity = ::std::option::Option::Some(v);
                }

                // optional string user_name = 7;

                pub fn user_name(&self) -> &str {
                    match self.user_name.as_ref() {
                        Some(v) => v,
                        None => "",
                    }
                }

                pub fn clear_user_name(&mut self) {
                    self.user_name = ::std::option::Option::None;
                }

                pub fn has_user_name(&self) -> bool {
                    self.user_name.is_some()
                }

                // Param is passed by value, moved
                pub fn set_user_name(&mut self, v: ::std::string::String) {
                    self.user_name = ::std::option::Option::Some(v);
                }

                // Mutable pointer to the field.
                // If field is not initialized, it is initialized with default value first.
                pub fn mut_user_name(&mut self) -> &mut ::std::string::String {
                    if self.user_name.is_none() {
                        self.user_name = ::std::option::Option::Some(::std::string::String::new());
                    }
                    self.user_name.as_mut().unwrap()
                }

                // Take field
                pub fn take_user_name(&mut self) -> ::std::string::String {
                    self.user_name.take().unwrap_or_else(|| ::std::string::String::new())
                }

                // optional string password = 8;

                pub fn password(&self) -> &str {
                    match self.password.as_ref() {
                        Some(v) => v,
                        None => "",
                    }
                }

                pub fn clear_password(&mut self) {
                    self.password = ::std::option::Option::None;
                }

                pub fn has_password(&self) -> bool {
                    self.password.is_some()
                }

                // Param is passed by value, moved
                pub fn set_password(&mut self, v: ::std::string::String) {
                    self.password = ::std::option::Option::Some(v);
                }

                // Mutable pointer to the field.
                // If field is not initialized, it is initialized with default value first.
                pub fn mut_password(&mut self) -> &mut ::std::string::String {
                    if self.password.is_none() {
                        self.password = ::std::option::Option::Some(::std::string::String::new());
                    }
                    self.password.as_mut().unwrap()
                }

                // Take field
                pub fn take_password(&mut self) -> ::std::string::String {
                    self.password.take().unwrap_or_else(|| ::std::string::String::new())
                }

                // optional int32 strength_raw = 9;

                pub fn strength_raw(&self) -> i32 {
                    self.strength_raw.unwrap_or(0)
                }

                pub fn clear_strength_raw(&mut self) {
                    self.strength_raw = ::std::option::Option::None;
                }

                pub fn has_strength_raw(&self) -> bool {
                    self.strength_raw.is_some()
                }

                // Param is passed by value, moved
                pub fn set_strength_raw(&mut self, v: i32) {
                    self.strength_raw = ::std::option::Option::Some(v);
                }
            }

            impl ::protobuf::Message for AP {
                const NAME: &'static str = "AP";

                fn is_initialized(&self) -> bool {
                    true
                }

                fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => {
                                self.id = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            16 => {
                                self.estrength = ::std::option::Option::Some(is.read_int32()?);
                            },
                            26 => {
                                self.ssid = ::std::option::Option::Some(is.read_string()?);
                            },
                            32 => {
                                self.is_active = ::std::option::Option::Some(is.read_bool()?);
                            },
                            40 => {
                                self.is_autoconnect = ::std::option::Option::Some(is.read_bool()?);
                            },
                            48 => {
                                self.esecurity = ::std::option::Option::Some(is.read_int32()?);
                            },
                            58 => {
                                self.user_name = ::std::option::Option::Some(is.read_string()?);
                            },
                            66 => {
                                self.password = ::std::option::Option::Some(is.read_string()?);
                            },
                            72 => {
                                self.strength_raw = ::std::option::Option::Some(is.read_int32()?);
                            },
                            tag => {
                                ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                            },
                        };
                    }
                    ::std::result::Result::Ok(())
                }

                // Compute sizes of nested messages
                #[allow(unused_variables)]
                fn compute_size(&self) -> u64 {
                    let mut my_size = 0;
                    if let Some(v) = self.id {
                        my_size += ::protobuf::rt::uint32_size(1, v);
                    }
                    if let Some(v) = self.estrength {
                        my_size += ::protobuf::rt::int32_size(2, v);
                    }
                    if let Some(v) = self.ssid.as_ref() {
                        my_size += ::protobuf::rt::string_size(3, &v);
                    }
                    if let Some(v) = self.is_active {
                        my_size += 1 + 1;
                    }
                    if let Some(v) = self.is_autoconnect {
                        my_size += 1 + 1;
                    }
                    if let Some(v) = self.esecurity {
                        my_size += ::protobuf::rt::int32_size(6, v);
                    }
                    if let Some(v) = self.user_name.as_ref() {
                        my_size += ::protobuf::rt::string_size(7, &v);
                    }
                    if let Some(v) = self.password.as_ref() {
                        my_size += ::protobuf::rt::string_size(8, &v);
                    }
                    if let Some(v) = self.strength_raw {
                        my_size += ::protobuf::rt::int32_size(9, v);
                    }
                    my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                    self.special_fields.cached_size().set(my_size as u32);
                    my_size
                }

                fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                    if let Some(v) = self.id {
                        os.write_uint32(1, v)?;
                    }
                    if let Some(v) = self.estrength {
                        os.write_int32(2, v)?;
                    }
                    if let Some(v) = self.ssid.as_ref() {
                        os.write_string(3, v)?;
                    }
                    if let Some(v) = self.is_active {
                        os.write_bool(4, v)?;
                    }
                    if let Some(v) = self.is_autoconnect {
                        os.write_bool(5, v)?;
                    }
                    if let Some(v) = self.esecurity {
                        os.write_int32(6, v)?;
                    }
                    if let Some(v) = self.user_name.as_ref() {
                        os.write_string(7, v)?;
                    }
                    if let Some(v) = self.password.as_ref() {
                        os.write_string(8, v)?;
                    }
                    if let Some(v) = self.strength_raw {
                        os.write_int32(9, v)?;
                    }
                    os.write_unknown_fields(self.special_fields.unknown_fields())?;
                    ::std::result::Result::Ok(())
                }

                fn special_fields(&self) -> &::protobuf::SpecialFields {
                    &self.special_fields
                }

                fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                    &mut self.special_fields
                }

                fn new() -> AP {
                    AP::new()
                }

                fn clear(&mut self) {
                    self.id = ::std::option::Option::None;
                    self.estrength = ::std::option::Option::None;
                    self.ssid = ::std::option::Option::None;
                    self.is_active = ::std::option::Option::None;
                    self.is_autoconnect = ::std::option::Option::None;
                    self.esecurity = ::std::option::Option::None;
                    self.user_name = ::std::option::Option::None;
                    self.password = ::std::option::Option::None;
                    self.strength_raw = ::std::option::Option::None;
                    self.special_fields.clear();
                }

                fn default_instance() -> &'static AP {
                    static instance: AP = AP {
                        id: ::std::option::Option::None,
                        estrength: ::std::option::Option::None,
                        ssid: ::std::option::Option::None,
                        is_active: ::std::option::Option::None,
                        is_autoconnect: ::std::option::Option::None,
                        esecurity: ::std::option::Option::None,
                        user_name: ::std::option::Option::None,
                        password: ::std::option::Option::None,
                        strength_raw: ::std::option::Option::None,
                        special_fields: ::protobuf::SpecialFields::new(),
                    };
                    &instance
                }
            }
        }
    }
}

// @@protoc_insertion_point(message:CMsgNetworkDeviceConnect)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgNetworkDeviceConnect {
    // message fields
    // @@protoc_insertion_point(field:CMsgNetworkDeviceConnect.device_id)
    pub device_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgNetworkDeviceConnect.credentials)
    pub credentials: ::protobuf::MessageField<cmsg_network_device_connect::Credentials>,
    // @@protoc_insertion_point(field:CMsgNetworkDeviceConnect.ip4)
    pub ip4: ::protobuf::MessageField<CMsgNetworkDeviceIP4Config>,
    // @@protoc_insertion_point(field:CMsgNetworkDeviceConnect.ip6)
    pub ip6: ::protobuf::MessageField<CMsgNetworkDeviceIP6Config>,
    // message oneof groups
    pub ap_info: ::std::option::Option<cmsg_network_device_connect::Ap_info>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgNetworkDeviceConnect.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgNetworkDeviceConnect {
    fn default() -> &'a CMsgNetworkDeviceConnect {
        <CMsgNetworkDeviceConnect as ::protobuf::Message>::default_instance()
    }
}

impl CMsgNetworkDeviceConnect {
    pub fn new() -> CMsgNetworkDeviceConnect {
        ::std::default::Default::default()
    }

    // optional uint32 device_id = 1;

    pub fn device_id(&self) -> u32 {
        self.device_id.unwrap_or(0u32)
    }

    pub fn clear_device_id(&mut self) {
        self.device_id = ::std::option::Option::None;
    }

    pub fn has_device_id(&self) -> bool {
        self.device_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_id(&mut self, v: u32) {
        self.device_id = ::std::option::Option::Some(v);
    }

    // optional .CMsgNetworkDeviceConnect.KnownAP ap_known = 2;

    pub fn ap_known(&self) -> &cmsg_network_device_connect::KnownAP {
        match self.ap_info {
            ::std::option::Option::Some(cmsg_network_device_connect::Ap_info::ApKnown(ref v)) => v,
            _ => <cmsg_network_device_connect::KnownAP as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_ap_known(&mut self) {
        self.ap_info = ::std::option::Option::None;
    }

    pub fn has_ap_known(&self) -> bool {
        match self.ap_info {
            ::std::option::Option::Some(cmsg_network_device_connect::Ap_info::ApKnown(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ap_known(&mut self, v: cmsg_network_device_connect::KnownAP) {
        self.ap_info = ::std::option::Option::Some(cmsg_network_device_connect::Ap_info::ApKnown(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ap_known(&mut self) -> &mut cmsg_network_device_connect::KnownAP {
        if let ::std::option::Option::Some(cmsg_network_device_connect::Ap_info::ApKnown(_)) = self.ap_info {
        } else {
            self.ap_info = ::std::option::Option::Some(cmsg_network_device_connect::Ap_info::ApKnown(cmsg_network_device_connect::KnownAP::new()));
        }
        match self.ap_info {
            ::std::option::Option::Some(cmsg_network_device_connect::Ap_info::ApKnown(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ap_known(&mut self) -> cmsg_network_device_connect::KnownAP {
        if self.has_ap_known() {
            match self.ap_info.take() {
                ::std::option::Option::Some(cmsg_network_device_connect::Ap_info::ApKnown(v)) => v,
                _ => panic!(),
            }
        } else {
            cmsg_network_device_connect::KnownAP::new()
        }
    }

    // optional .CMsgNetworkDeviceConnect.CustomAP ap_custom = 3;

    pub fn ap_custom(&self) -> &cmsg_network_device_connect::CustomAP {
        match self.ap_info {
            ::std::option::Option::Some(cmsg_network_device_connect::Ap_info::ApCustom(ref v)) => v,
            _ => <cmsg_network_device_connect::CustomAP as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_ap_custom(&mut self) {
        self.ap_info = ::std::option::Option::None;
    }

    pub fn has_ap_custom(&self) -> bool {
        match self.ap_info {
            ::std::option::Option::Some(cmsg_network_device_connect::Ap_info::ApCustom(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ap_custom(&mut self, v: cmsg_network_device_connect::CustomAP) {
        self.ap_info = ::std::option::Option::Some(cmsg_network_device_connect::Ap_info::ApCustom(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ap_custom(&mut self) -> &mut cmsg_network_device_connect::CustomAP {
        if let ::std::option::Option::Some(cmsg_network_device_connect::Ap_info::ApCustom(_)) = self.ap_info {
        } else {
            self.ap_info = ::std::option::Option::Some(cmsg_network_device_connect::Ap_info::ApCustom(cmsg_network_device_connect::CustomAP::new()));
        }
        match self.ap_info {
            ::std::option::Option::Some(cmsg_network_device_connect::Ap_info::ApCustom(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ap_custom(&mut self) -> cmsg_network_device_connect::CustomAP {
        if self.has_ap_custom() {
            match self.ap_info.take() {
                ::std::option::Option::Some(cmsg_network_device_connect::Ap_info::ApCustom(v)) => v,
                _ => panic!(),
            }
        } else {
            cmsg_network_device_connect::CustomAP::new()
        }
    }
}

impl ::protobuf::Message for CMsgNetworkDeviceConnect {
    const NAME: &'static str = "CMsgNetworkDeviceConnect";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.device_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.credentials)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ip4)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ip6)?;
                },
                18 => {
                    self.ap_info = ::std::option::Option::Some(cmsg_network_device_connect::Ap_info::ApKnown(is.read_message()?));
                },
                26 => {
                    self.ap_info = ::std::option::Option::Some(cmsg_network_device_connect::Ap_info::ApCustom(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.device_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.credentials.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ip4.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ip6.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.ap_info {
            match v {
                &cmsg_network_device_connect::Ap_info::ApKnown(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_network_device_connect::Ap_info::ApCustom(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.device_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.credentials.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.ip4.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.ip6.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.ap_info {
            match v {
                &cmsg_network_device_connect::Ap_info::ApKnown(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &cmsg_network_device_connect::Ap_info::ApCustom(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgNetworkDeviceConnect {
        CMsgNetworkDeviceConnect::new()
    }

    fn clear(&mut self) {
        self.device_id = ::std::option::Option::None;
        self.credentials.clear();
        self.ip4.clear();
        self.ip6.clear();
        self.ap_info = ::std::option::Option::None;
        self.ap_info = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgNetworkDeviceConnect {
        static instance: CMsgNetworkDeviceConnect = CMsgNetworkDeviceConnect {
            device_id: ::std::option::Option::None,
            credentials: ::protobuf::MessageField::none(),
            ip4: ::protobuf::MessageField::none(),
            ip6: ::protobuf::MessageField::none(),
            ap_info: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgNetworkDeviceConnect`
pub mod cmsg_network_device_connect {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:CMsgNetworkDeviceConnect.ap_info)
    pub enum Ap_info {
        // @@protoc_insertion_point(oneof_field:CMsgNetworkDeviceConnect.ap_known)
        ApKnown(KnownAP),
        // @@protoc_insertion_point(oneof_field:CMsgNetworkDeviceConnect.ap_custom)
        ApCustom(CustomAP),
    }

    impl ::protobuf::Oneof for Ap_info {
    }

    impl Ap_info {
    }
    // @@protoc_insertion_point(message:CMsgNetworkDeviceConnect.KnownAP)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct KnownAP {
        // message fields
        // @@protoc_insertion_point(field:CMsgNetworkDeviceConnect.KnownAP.ap_id)
        pub ap_id: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgNetworkDeviceConnect.KnownAP.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a KnownAP {
        fn default() -> &'a KnownAP {
            <KnownAP as ::protobuf::Message>::default_instance()
        }
    }

    impl KnownAP {
        pub fn new() -> KnownAP {
            ::std::default::Default::default()
        }

        // optional uint32 ap_id = 1;

        pub fn ap_id(&self) -> u32 {
            self.ap_id.unwrap_or(0)
        }

        pub fn clear_ap_id(&mut self) {
            self.ap_id = ::std::option::Option::None;
        }

        pub fn has_ap_id(&self) -> bool {
            self.ap_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ap_id(&mut self, v: u32) {
            self.ap_id = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for KnownAP {
        const NAME: &'static str = "KnownAP";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.ap_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.ap_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.ap_id {
                os.write_uint32(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> KnownAP {
            KnownAP::new()
        }

        fn clear(&mut self) {
            self.ap_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static KnownAP {
            static instance: KnownAP = KnownAP {
                ap_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgNetworkDeviceConnect.CustomAP)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CustomAP {
        // message fields
        // @@protoc_insertion_point(field:CMsgNetworkDeviceConnect.CustomAP.ssid)
        pub ssid: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgNetworkDeviceConnect.CustomAP.esecurity)
        pub esecurity: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgNetworkDeviceConnect.CustomAP.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CustomAP {
        fn default() -> &'a CustomAP {
            <CustomAP as ::protobuf::Message>::default_instance()
        }
    }

    impl CustomAP {
        pub fn new() -> CustomAP {
            ::std::default::Default::default()
        }

        // optional string ssid = 1;

        pub fn ssid(&self) -> &str {
            match self.ssid.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_ssid(&mut self) {
            self.ssid = ::std::option::Option::None;
        }

        pub fn has_ssid(&self) -> bool {
            self.ssid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ssid(&mut self, v: ::std::string::String) {
            self.ssid = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_ssid(&mut self) -> &mut ::std::string::String {
            if self.ssid.is_none() {
                self.ssid = ::std::option::Option::Some(::std::string::String::new());
            }
            self.ssid.as_mut().unwrap()
        }

        // Take field
        pub fn take_ssid(&mut self) -> ::std::string::String {
            self.ssid.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 esecurity = 2;

        pub fn esecurity(&self) -> i32 {
            self.esecurity.unwrap_or(0)
        }

        pub fn clear_esecurity(&mut self) {
            self.esecurity = ::std::option::Option::None;
        }

        pub fn has_esecurity(&self) -> bool {
            self.esecurity.is_some()
        }

        // Param is passed by value, moved
        pub fn set_esecurity(&mut self, v: i32) {
            self.esecurity = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for CustomAP {
        const NAME: &'static str = "CustomAP";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.ssid = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.esecurity = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.ssid.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.esecurity {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.ssid.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.esecurity {
                os.write_int32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CustomAP {
            CustomAP::new()
        }

        fn clear(&mut self) {
            self.ssid = ::std::option::Option::None;
            self.esecurity = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CustomAP {
            static instance: CustomAP = CustomAP {
                ssid: ::std::option::Option::None,
                esecurity: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgNetworkDeviceConnect.Credentials)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Credentials {
        // message fields
        // @@protoc_insertion_point(field:CMsgNetworkDeviceConnect.Credentials.username)
        pub username: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgNetworkDeviceConnect.Credentials.password)
        pub password: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgNetworkDeviceConnect.Credentials.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Credentials {
        fn default() -> &'a Credentials {
            <Credentials as ::protobuf::Message>::default_instance()
        }
    }

    impl Credentials {
        pub fn new() -> Credentials {
            ::std::default::Default::default()
        }

        // optional string username = 1;

        pub fn username(&self) -> &str {
            match self.username.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_username(&mut self) {
            self.username = ::std::option::Option::None;
        }

        pub fn has_username(&self) -> bool {
            self.username.is_some()
        }

        // Param is passed by value, moved
        pub fn set_username(&mut self, v: ::std::string::String) {
            self.username = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_username(&mut self) -> &mut ::std::string::String {
            if self.username.is_none() {
                self.username = ::std::option::Option::Some(::std::string::String::new());
            }
            self.username.as_mut().unwrap()
        }

        // Take field
        pub fn take_username(&mut self) -> ::std::string::String {
            self.username.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string password = 2;

        pub fn password(&self) -> &str {
            match self.password.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_password(&mut self) {
            self.password = ::std::option::Option::None;
        }

        pub fn has_password(&self) -> bool {
            self.password.is_some()
        }

        // Param is passed by value, moved
        pub fn set_password(&mut self, v: ::std::string::String) {
            self.password = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_password(&mut self) -> &mut ::std::string::String {
            if self.password.is_none() {
                self.password = ::std::option::Option::Some(::std::string::String::new());
            }
            self.password.as_mut().unwrap()
        }

        // Take field
        pub fn take_password(&mut self) -> ::std::string::String {
            self.password.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::protobuf::Message for Credentials {
        const NAME: &'static str = "Credentials";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.username = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.password = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.username.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.password.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.username.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.password.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Credentials {
            Credentials::new()
        }

        fn clear(&mut self) {
            self.username = ::std::option::Option::None;
            self.password = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Credentials {
            static instance: Credentials = Credentials {
                username: ::std::option::Option::None,
                password: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgStorageDevicesData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgStorageDevicesData {
    // message fields
    // @@protoc_insertion_point(field:CMsgStorageDevicesData.drives)
    pub drives: ::std::vec::Vec<cmsg_storage_devices_data::Drive>,
    // @@protoc_insertion_point(field:CMsgStorageDevicesData.block_devices)
    pub block_devices: ::std::vec::Vec<cmsg_storage_devices_data::BlockDevice>,
    // @@protoc_insertion_point(field:CMsgStorageDevicesData.is_unmount_supported)
    pub is_unmount_supported: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgStorageDevicesData.is_trim_supported)
    pub is_trim_supported: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgStorageDevicesData.is_trim_running)
    pub is_trim_running: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgStorageDevicesData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgStorageDevicesData {
    fn default() -> &'a CMsgStorageDevicesData {
        <CMsgStorageDevicesData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgStorageDevicesData {
    pub fn new() -> CMsgStorageDevicesData {
        ::std::default::Default::default()
    }

    // optional bool is_unmount_supported = 3;

    pub fn is_unmount_supported(&self) -> bool {
        self.is_unmount_supported.unwrap_or(false)
    }

    pub fn clear_is_unmount_supported(&mut self) {
        self.is_unmount_supported = ::std::option::Option::None;
    }

    pub fn has_is_unmount_supported(&self) -> bool {
        self.is_unmount_supported.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_unmount_supported(&mut self, v: bool) {
        self.is_unmount_supported = ::std::option::Option::Some(v);
    }

    // optional bool is_trim_supported = 4;

    pub fn is_trim_supported(&self) -> bool {
        self.is_trim_supported.unwrap_or(false)
    }

    pub fn clear_is_trim_supported(&mut self) {
        self.is_trim_supported = ::std::option::Option::None;
    }

    pub fn has_is_trim_supported(&self) -> bool {
        self.is_trim_supported.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_trim_supported(&mut self, v: bool) {
        self.is_trim_supported = ::std::option::Option::Some(v);
    }

    // optional bool is_trim_running = 5;

    pub fn is_trim_running(&self) -> bool {
        self.is_trim_running.unwrap_or(false)
    }

    pub fn clear_is_trim_running(&mut self) {
        self.is_trim_running = ::std::option::Option::None;
    }

    pub fn has_is_trim_running(&self) -> bool {
        self.is_trim_running.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_trim_running(&mut self, v: bool) {
        self.is_trim_running = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgStorageDevicesData {
    const NAME: &'static str = "CMsgStorageDevicesData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.drives.push(is.read_message()?);
                },
                18 => {
                    self.block_devices.push(is.read_message()?);
                },
                24 => {
                    self.is_unmount_supported = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.is_trim_supported = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.is_trim_running = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.drives {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.block_devices {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.is_unmount_supported {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_trim_supported {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_trim_running {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.drives {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.block_devices {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.is_unmount_supported {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.is_trim_supported {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.is_trim_running {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgStorageDevicesData {
        CMsgStorageDevicesData::new()
    }

    fn clear(&mut self) {
        self.drives.clear();
        self.block_devices.clear();
        self.is_unmount_supported = ::std::option::Option::None;
        self.is_trim_supported = ::std::option::Option::None;
        self.is_trim_running = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgStorageDevicesData {
        static instance: CMsgStorageDevicesData = CMsgStorageDevicesData {
            drives: ::std::vec::Vec::new(),
            block_devices: ::std::vec::Vec::new(),
            is_unmount_supported: ::std::option::Option::None,
            is_trim_supported: ::std::option::Option::None,
            is_trim_running: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgStorageDevicesData`
pub mod cmsg_storage_devices_data {
    // @@protoc_insertion_point(message:CMsgStorageDevicesData.Drive)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Drive {
        // message fields
        // @@protoc_insertion_point(field:CMsgStorageDevicesData.Drive.id)
        pub id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgStorageDevicesData.Drive.model)
        pub model: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgStorageDevicesData.Drive.vendor)
        pub vendor: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgStorageDevicesData.Drive.serial)
        pub serial: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgStorageDevicesData.Drive.is_ejectable)
        pub is_ejectable: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgStorageDevicesData.Drive.size_bytes)
        pub size_bytes: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgStorageDevicesData.Drive.media_type)
        pub media_type: ::std::option::Option<::protobuf::EnumOrUnknown<super::super::enums::EStorageDriveMediaType>>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgStorageDevicesData.Drive.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Drive {
        fn default() -> &'a Drive {
            <Drive as ::protobuf::Message>::default_instance()
        }
    }

    impl Drive {
        pub fn new() -> Drive {
            ::std::default::Default::default()
        }

        // optional uint32 id = 1;

        pub fn id(&self) -> u32 {
            self.id.unwrap_or(0u32)
        }

        pub fn clear_id(&mut self) {
            self.id = ::std::option::Option::None;
        }

        pub fn has_id(&self) -> bool {
            self.id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_id(&mut self, v: u32) {
            self.id = ::std::option::Option::Some(v);
        }

        // optional string model = 2;

        pub fn model(&self) -> &str {
            match self.model.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_model(&mut self) {
            self.model = ::std::option::Option::None;
        }

        pub fn has_model(&self) -> bool {
            self.model.is_some()
        }

        // Param is passed by value, moved
        pub fn set_model(&mut self, v: ::std::string::String) {
            self.model = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_model(&mut self) -> &mut ::std::string::String {
            if self.model.is_none() {
                self.model = ::std::option::Option::Some(::std::string::String::new());
            }
            self.model.as_mut().unwrap()
        }

        // Take field
        pub fn take_model(&mut self) -> ::std::string::String {
            self.model.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string vendor = 3;

        pub fn vendor(&self) -> &str {
            match self.vendor.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_vendor(&mut self) {
            self.vendor = ::std::option::Option::None;
        }

        pub fn has_vendor(&self) -> bool {
            self.vendor.is_some()
        }

        // Param is passed by value, moved
        pub fn set_vendor(&mut self, v: ::std::string::String) {
            self.vendor = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_vendor(&mut self) -> &mut ::std::string::String {
            if self.vendor.is_none() {
                self.vendor = ::std::option::Option::Some(::std::string::String::new());
            }
            self.vendor.as_mut().unwrap()
        }

        // Take field
        pub fn take_vendor(&mut self) -> ::std::string::String {
            self.vendor.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string serial = 4;

        pub fn serial(&self) -> &str {
            match self.serial.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_serial(&mut self) {
            self.serial = ::std::option::Option::None;
        }

        pub fn has_serial(&self) -> bool {
            self.serial.is_some()
        }

        // Param is passed by value, moved
        pub fn set_serial(&mut self, v: ::std::string::String) {
            self.serial = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_serial(&mut self) -> &mut ::std::string::String {
            if self.serial.is_none() {
                self.serial = ::std::option::Option::Some(::std::string::String::new());
            }
            self.serial.as_mut().unwrap()
        }

        // Take field
        pub fn take_serial(&mut self) -> ::std::string::String {
            self.serial.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool is_ejectable = 5;

        pub fn is_ejectable(&self) -> bool {
            self.is_ejectable.unwrap_or(false)
        }

        pub fn clear_is_ejectable(&mut self) {
            self.is_ejectable = ::std::option::Option::None;
        }

        pub fn has_is_ejectable(&self) -> bool {
            self.is_ejectable.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_ejectable(&mut self, v: bool) {
            self.is_ejectable = ::std::option::Option::Some(v);
        }

        // optional uint64 size_bytes = 6;

        pub fn size_bytes(&self) -> u64 {
            self.size_bytes.unwrap_or(0)
        }

        pub fn clear_size_bytes(&mut self) {
            self.size_bytes = ::std::option::Option::None;
        }

        pub fn has_size_bytes(&self) -> bool {
            self.size_bytes.is_some()
        }

        // Param is passed by value, moved
        pub fn set_size_bytes(&mut self, v: u64) {
            self.size_bytes = ::std::option::Option::Some(v);
        }

        // optional .EStorageDriveMediaType media_type = 7;

        pub fn media_type(&self) -> super::super::enums::EStorageDriveMediaType {
            match self.media_type {
                Some(e) => e.enum_value_or(super::super::enums::EStorageDriveMediaType::k_EStorageDriveMediaType_Invalid),
                None => super::super::enums::EStorageDriveMediaType::k_EStorageDriveMediaType_Invalid,
            }
        }

        pub fn clear_media_type(&mut self) {
            self.media_type = ::std::option::Option::None;
        }

        pub fn has_media_type(&self) -> bool {
            self.media_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_media_type(&mut self, v: super::super::enums::EStorageDriveMediaType) {
            self.media_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }
    }

    impl ::protobuf::Message for Drive {
        const NAME: &'static str = "Drive";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.model = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.vendor = ::std::option::Option::Some(is.read_string()?);
                    },
                    34 => {
                        self.serial = ::std::option::Option::Some(is.read_string()?);
                    },
                    40 => {
                        self.is_ejectable = ::std::option::Option::Some(is.read_bool()?);
                    },
                    48 => {
                        self.size_bytes = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    56 => {
                        self.media_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.model.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.vendor.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.serial.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            if let Some(v) = self.is_ejectable {
                my_size += 1 + 1;
            }
            if let Some(v) = self.size_bytes {
                my_size += ::protobuf::rt::uint64_size(6, v);
            }
            if let Some(v) = self.media_type {
                my_size += ::protobuf::rt::int32_size(7, v.value());
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.model.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.vendor.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.serial.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.is_ejectable {
                os.write_bool(5, v)?;
            }
            if let Some(v) = self.size_bytes {
                os.write_uint64(6, v)?;
            }
            if let Some(v) = self.media_type {
                os.write_enum(7, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Drive {
            Drive::new()
        }

        fn clear(&mut self) {
            self.id = ::std::option::Option::None;
            self.model = ::std::option::Option::None;
            self.vendor = ::std::option::Option::None;
            self.serial = ::std::option::Option::None;
            self.is_ejectable = ::std::option::Option::None;
            self.size_bytes = ::std::option::Option::None;
            self.media_type = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Drive {
            static instance: Drive = Drive {
                id: ::std::option::Option::None,
                model: ::std::option::Option::None,
                vendor: ::std::option::Option::None,
                serial: ::std::option::Option::None,
                is_ejectable: ::std::option::Option::None,
                size_bytes: ::std::option::Option::None,
                media_type: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgStorageDevicesData.BlockDevice)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct BlockDevice {
        // message fields
        // @@protoc_insertion_point(field:CMsgStorageDevicesData.BlockDevice.id)
        pub id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgStorageDevicesData.BlockDevice.drive_id)
        pub drive_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgStorageDevicesData.BlockDevice.path)
        pub path: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgStorageDevicesData.BlockDevice.friendly_path)
        pub friendly_path: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgStorageDevicesData.BlockDevice.label)
        pub label: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgStorageDevicesData.BlockDevice.size_bytes)
        pub size_bytes: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgStorageDevicesData.BlockDevice.is_formattable)
        pub is_formattable: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgStorageDevicesData.BlockDevice.is_read_only)
        pub is_read_only: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgStorageDevicesData.BlockDevice.is_root_device)
        pub is_root_device: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgStorageDevicesData.BlockDevice.content_type)
        pub content_type: ::std::option::Option<::protobuf::EnumOrUnknown<super::super::enums::EStorageBlockContentType>>,
        // @@protoc_insertion_point(field:CMsgStorageDevicesData.BlockDevice.filesystem_type)
        pub filesystem_type: ::std::option::Option<::protobuf::EnumOrUnknown<super::super::enums::EStorageBlockFileSystemType>>,
        // @@protoc_insertion_point(field:CMsgStorageDevicesData.BlockDevice.mount_path)
        pub mount_path: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgStorageDevicesData.BlockDevice.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BlockDevice {
        fn default() -> &'a BlockDevice {
            <BlockDevice as ::protobuf::Message>::default_instance()
        }
    }

    impl BlockDevice {
        pub fn new() -> BlockDevice {
            ::std::default::Default::default()
        }

        // optional uint32 id = 1;

        pub fn id(&self) -> u32 {
            self.id.unwrap_or(0u32)
        }

        pub fn clear_id(&mut self) {
            self.id = ::std::option::Option::None;
        }

        pub fn has_id(&self) -> bool {
            self.id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_id(&mut self, v: u32) {
            self.id = ::std::option::Option::Some(v);
        }

        // optional uint32 drive_id = 2;

        pub fn drive_id(&self) -> u32 {
            self.drive_id.unwrap_or(0u32)
        }

        pub fn clear_drive_id(&mut self) {
            self.drive_id = ::std::option::Option::None;
        }

        pub fn has_drive_id(&self) -> bool {
            self.drive_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_drive_id(&mut self, v: u32) {
            self.drive_id = ::std::option::Option::Some(v);
        }

        // optional string path = 3;

        pub fn path(&self) -> &str {
            match self.path.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_path(&mut self) {
            self.path = ::std::option::Option::None;
        }

        pub fn has_path(&self) -> bool {
            self.path.is_some()
        }

        // Param is passed by value, moved
        pub fn set_path(&mut self, v: ::std::string::String) {
            self.path = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_path(&mut self) -> &mut ::std::string::String {
            if self.path.is_none() {
                self.path = ::std::option::Option::Some(::std::string::String::new());
            }
            self.path.as_mut().unwrap()
        }

        // Take field
        pub fn take_path(&mut self) -> ::std::string::String {
            self.path.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string friendly_path = 4;

        pub fn friendly_path(&self) -> &str {
            match self.friendly_path.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_friendly_path(&mut self) {
            self.friendly_path = ::std::option::Option::None;
        }

        pub fn has_friendly_path(&self) -> bool {
            self.friendly_path.is_some()
        }

        // Param is passed by value, moved
        pub fn set_friendly_path(&mut self, v: ::std::string::String) {
            self.friendly_path = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_friendly_path(&mut self) -> &mut ::std::string::String {
            if self.friendly_path.is_none() {
                self.friendly_path = ::std::option::Option::Some(::std::string::String::new());
            }
            self.friendly_path.as_mut().unwrap()
        }

        // Take field
        pub fn take_friendly_path(&mut self) -> ::std::string::String {
            self.friendly_path.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string label = 5;

        pub fn label(&self) -> &str {
            match self.label.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_label(&mut self) {
            self.label = ::std::option::Option::None;
        }

        pub fn has_label(&self) -> bool {
            self.label.is_some()
        }

        // Param is passed by value, moved
        pub fn set_label(&mut self, v: ::std::string::String) {
            self.label = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_label(&mut self) -> &mut ::std::string::String {
            if self.label.is_none() {
                self.label = ::std::option::Option::Some(::std::string::String::new());
            }
            self.label.as_mut().unwrap()
        }

        // Take field
        pub fn take_label(&mut self) -> ::std::string::String {
            self.label.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint64 size_bytes = 6;

        pub fn size_bytes(&self) -> u64 {
            self.size_bytes.unwrap_or(0)
        }

        pub fn clear_size_bytes(&mut self) {
            self.size_bytes = ::std::option::Option::None;
        }

        pub fn has_size_bytes(&self) -> bool {
            self.size_bytes.is_some()
        }

        // Param is passed by value, moved
        pub fn set_size_bytes(&mut self, v: u64) {
            self.size_bytes = ::std::option::Option::Some(v);
        }

        // optional bool is_formattable = 7;

        pub fn is_formattable(&self) -> bool {
            self.is_formattable.unwrap_or(false)
        }

        pub fn clear_is_formattable(&mut self) {
            self.is_formattable = ::std::option::Option::None;
        }

        pub fn has_is_formattable(&self) -> bool {
            self.is_formattable.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_formattable(&mut self, v: bool) {
            self.is_formattable = ::std::option::Option::Some(v);
        }

        // optional bool is_read_only = 8;

        pub fn is_read_only(&self) -> bool {
            self.is_read_only.unwrap_or(false)
        }

        pub fn clear_is_read_only(&mut self) {
            self.is_read_only = ::std::option::Option::None;
        }

        pub fn has_is_read_only(&self) -> bool {
            self.is_read_only.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_read_only(&mut self, v: bool) {
            self.is_read_only = ::std::option::Option::Some(v);
        }

        // optional bool is_root_device = 9;

        pub fn is_root_device(&self) -> bool {
            self.is_root_device.unwrap_or(false)
        }

        pub fn clear_is_root_device(&mut self) {
            self.is_root_device = ::std::option::Option::None;
        }

        pub fn has_is_root_device(&self) -> bool {
            self.is_root_device.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_root_device(&mut self, v: bool) {
            self.is_root_device = ::std::option::Option::Some(v);
        }

        // optional .EStorageBlockContentType content_type = 10;

        pub fn content_type(&self) -> super::super::enums::EStorageBlockContentType {
            match self.content_type {
                Some(e) => e.enum_value_or(super::super::enums::EStorageBlockContentType::k_EStorageBlockContentType_Invalid),
                None => super::super::enums::EStorageBlockContentType::k_EStorageBlockContentType_Invalid,
            }
        }

        pub fn clear_content_type(&mut self) {
            self.content_type = ::std::option::Option::None;
        }

        pub fn has_content_type(&self) -> bool {
            self.content_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_content_type(&mut self, v: super::super::enums::EStorageBlockContentType) {
            self.content_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional .EStorageBlockFileSystemType filesystem_type = 11;

        pub fn filesystem_type(&self) -> super::super::enums::EStorageBlockFileSystemType {
            match self.filesystem_type {
                Some(e) => e.enum_value_or(super::super::enums::EStorageBlockFileSystemType::k_EStorageBlockFileSystemType_Invalid),
                None => super::super::enums::EStorageBlockFileSystemType::k_EStorageBlockFileSystemType_Invalid,
            }
        }

        pub fn clear_filesystem_type(&mut self) {
            self.filesystem_type = ::std::option::Option::None;
        }

        pub fn has_filesystem_type(&self) -> bool {
            self.filesystem_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_filesystem_type(&mut self, v: super::super::enums::EStorageBlockFileSystemType) {
            self.filesystem_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional string mount_path = 12;

        pub fn mount_path(&self) -> &str {
            match self.mount_path.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_mount_path(&mut self) {
            self.mount_path = ::std::option::Option::None;
        }

        pub fn has_mount_path(&self) -> bool {
            self.mount_path.is_some()
        }

        // Param is passed by value, moved
        pub fn set_mount_path(&mut self, v: ::std::string::String) {
            self.mount_path = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_mount_path(&mut self) -> &mut ::std::string::String {
            if self.mount_path.is_none() {
                self.mount_path = ::std::option::Option::Some(::std::string::String::new());
            }
            self.mount_path.as_mut().unwrap()
        }

        // Take field
        pub fn take_mount_path(&mut self) -> ::std::string::String {
            self.mount_path.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::protobuf::Message for BlockDevice {
        const NAME: &'static str = "BlockDevice";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.drive_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.path = ::std::option::Option::Some(is.read_string()?);
                    },
                    34 => {
                        self.friendly_path = ::std::option::Option::Some(is.read_string()?);
                    },
                    42 => {
                        self.label = ::std::option::Option::Some(is.read_string()?);
                    },
                    48 => {
                        self.size_bytes = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    56 => {
                        self.is_formattable = ::std::option::Option::Some(is.read_bool()?);
                    },
                    64 => {
                        self.is_read_only = ::std::option::Option::Some(is.read_bool()?);
                    },
                    72 => {
                        self.is_root_device = ::std::option::Option::Some(is.read_bool()?);
                    },
                    80 => {
                        self.content_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    88 => {
                        self.filesystem_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    98 => {
                        self.mount_path = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.drive_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.path.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.friendly_path.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            if let Some(v) = self.label.as_ref() {
                my_size += ::protobuf::rt::string_size(5, &v);
            }
            if let Some(v) = self.size_bytes {
                my_size += ::protobuf::rt::uint64_size(6, v);
            }
            if let Some(v) = self.is_formattable {
                my_size += 1 + 1;
            }
            if let Some(v) = self.is_read_only {
                my_size += 1 + 1;
            }
            if let Some(v) = self.is_root_device {
                my_size += 1 + 1;
            }
            if let Some(v) = self.content_type {
                my_size += ::protobuf::rt::int32_size(10, v.value());
            }
            if let Some(v) = self.filesystem_type {
                my_size += ::protobuf::rt::int32_size(11, v.value());
            }
            if let Some(v) = self.mount_path.as_ref() {
                my_size += ::protobuf::rt::string_size(12, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.drive_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.path.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.friendly_path.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.label.as_ref() {
                os.write_string(5, v)?;
            }
            if let Some(v) = self.size_bytes {
                os.write_uint64(6, v)?;
            }
            if let Some(v) = self.is_formattable {
                os.write_bool(7, v)?;
            }
            if let Some(v) = self.is_read_only {
                os.write_bool(8, v)?;
            }
            if let Some(v) = self.is_root_device {
                os.write_bool(9, v)?;
            }
            if let Some(v) = self.content_type {
                os.write_enum(10, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.filesystem_type {
                os.write_enum(11, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.mount_path.as_ref() {
                os.write_string(12, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BlockDevice {
            BlockDevice::new()
        }

        fn clear(&mut self) {
            self.id = ::std::option::Option::None;
            self.drive_id = ::std::option::Option::None;
            self.path = ::std::option::Option::None;
            self.friendly_path = ::std::option::Option::None;
            self.label = ::std::option::Option::None;
            self.size_bytes = ::std::option::Option::None;
            self.is_formattable = ::std::option::Option::None;
            self.is_read_only = ::std::option::Option::None;
            self.is_root_device = ::std::option::Option::None;
            self.content_type = ::std::option::Option::None;
            self.filesystem_type = ::std::option::Option::None;
            self.mount_path = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BlockDevice {
            static instance: BlockDevice = BlockDevice {
                id: ::std::option::Option::None,
                drive_id: ::std::option::Option::None,
                path: ::std::option::Option::None,
                friendly_path: ::std::option::Option::None,
                label: ::std::option::Option::None,
                size_bytes: ::std::option::Option::None,
                is_formattable: ::std::option::Option::None,
                is_read_only: ::std::option::Option::None,
                is_root_device: ::std::option::Option::None,
                content_type: ::std::option::Option::None,
                filesystem_type: ::std::option::Option::None,
                mount_path: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CCloud_PendingRemoteOperation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCloud_PendingRemoteOperation {
    // message fields
    // @@protoc_insertion_point(field:CCloud_PendingRemoteOperation.operation)
    pub operation: ::std::option::Option<::protobuf::EnumOrUnknown<ECloudPendingRemoteOperation>>,
    // @@protoc_insertion_point(field:CCloud_PendingRemoteOperation.machine_name)
    pub machine_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCloud_PendingRemoteOperation.client_id)
    pub client_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCloud_PendingRemoteOperation.time_last_updated)
    pub time_last_updated: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCloud_PendingRemoteOperation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCloud_PendingRemoteOperation {
    fn default() -> &'a CCloud_PendingRemoteOperation {
        <CCloud_PendingRemoteOperation as ::protobuf::Message>::default_instance()
    }
}

impl CCloud_PendingRemoteOperation {
    pub fn new() -> CCloud_PendingRemoteOperation {
        ::std::default::Default::default()
    }

    // optional .ECloudPendingRemoteOperation operation = 1;

    pub fn operation(&self) -> ECloudPendingRemoteOperation {
        match self.operation {
            Some(e) => e.enum_value_or(ECloudPendingRemoteOperation::k_ECloudPendingRemoteOperationNone),
            None => ECloudPendingRemoteOperation::k_ECloudPendingRemoteOperationNone,
        }
    }

    pub fn clear_operation(&mut self) {
        self.operation = ::std::option::Option::None;
    }

    pub fn has_operation(&self) -> bool {
        self.operation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operation(&mut self, v: ECloudPendingRemoteOperation) {
        self.operation = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string machine_name = 2;

    pub fn machine_name(&self) -> &str {
        match self.machine_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_machine_name(&mut self) {
        self.machine_name = ::std::option::Option::None;
    }

    pub fn has_machine_name(&self) -> bool {
        self.machine_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_machine_name(&mut self, v: ::std::string::String) {
        self.machine_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_machine_name(&mut self) -> &mut ::std::string::String {
        if self.machine_name.is_none() {
            self.machine_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.machine_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_machine_name(&mut self) -> ::std::string::String {
        self.machine_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 client_id = 3;

    pub fn client_id(&self) -> u64 {
        self.client_id.unwrap_or(0)
    }

    pub fn clear_client_id(&mut self) {
        self.client_id = ::std::option::Option::None;
    }

    pub fn has_client_id(&self) -> bool {
        self.client_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_id(&mut self, v: u64) {
        self.client_id = ::std::option::Option::Some(v);
    }

    // optional uint32 time_last_updated = 4;

    pub fn time_last_updated(&self) -> u32 {
        self.time_last_updated.unwrap_or(0)
    }

    pub fn clear_time_last_updated(&mut self) {
        self.time_last_updated = ::std::option::Option::None;
    }

    pub fn has_time_last_updated(&self) -> bool {
        self.time_last_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_last_updated(&mut self, v: u32) {
        self.time_last_updated = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCloud_PendingRemoteOperation {
    const NAME: &'static str = "CCloud_PendingRemoteOperation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.operation = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.machine_name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.client_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.time_last_updated = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.operation {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.machine_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.client_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.time_last_updated {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.operation {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.machine_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.client_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.time_last_updated {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCloud_PendingRemoteOperation {
        CCloud_PendingRemoteOperation::new()
    }

    fn clear(&mut self) {
        self.operation = ::std::option::Option::None;
        self.machine_name = ::std::option::Option::None;
        self.client_id = ::std::option::Option::None;
        self.time_last_updated = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCloud_PendingRemoteOperation {
        static instance: CCloud_PendingRemoteOperation = CCloud_PendingRemoteOperation {
            operation: ::std::option::Option::None,
            machine_name: ::std::option::Option::None,
            client_id: ::std::option::Option::None,
            time_last_updated: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgCloudPendingRemoteOperations)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCloudPendingRemoteOperations {
    // message fields
    // @@protoc_insertion_point(field:CMsgCloudPendingRemoteOperations.operations)
    pub operations: ::std::vec::Vec<CCloud_PendingRemoteOperation>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCloudPendingRemoteOperations.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCloudPendingRemoteOperations {
    fn default() -> &'a CMsgCloudPendingRemoteOperations {
        <CMsgCloudPendingRemoteOperations as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCloudPendingRemoteOperations {
    pub fn new() -> CMsgCloudPendingRemoteOperations {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgCloudPendingRemoteOperations {
    const NAME: &'static str = "CMsgCloudPendingRemoteOperations";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.operations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.operations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.operations {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCloudPendingRemoteOperations {
        CMsgCloudPendingRemoteOperations::new()
    }

    fn clear(&mut self) {
        self.operations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCloudPendingRemoteOperations {
        static instance: CMsgCloudPendingRemoteOperations = CMsgCloudPendingRemoteOperations {
            operations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgBluetoothDevicesData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBluetoothDevicesData {
    // message fields
    // @@protoc_insertion_point(field:CMsgBluetoothDevicesData.adapters)
    pub adapters: ::std::vec::Vec<cmsg_bluetooth_devices_data::Adapter>,
    // @@protoc_insertion_point(field:CMsgBluetoothDevicesData.devices)
    pub devices: ::std::vec::Vec<cmsg_bluetooth_devices_data::Device>,
    // @@protoc_insertion_point(field:CMsgBluetoothDevicesData.manager)
    pub manager: ::protobuf::MessageField<cmsg_bluetooth_devices_data::Manager>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBluetoothDevicesData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBluetoothDevicesData {
    fn default() -> &'a CMsgBluetoothDevicesData {
        <CMsgBluetoothDevicesData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBluetoothDevicesData {
    pub fn new() -> CMsgBluetoothDevicesData {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgBluetoothDevicesData {
    const NAME: &'static str = "CMsgBluetoothDevicesData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.adapters.push(is.read_message()?);
                },
                18 => {
                    self.devices.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.manager)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.adapters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.devices {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.manager.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.adapters {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.devices {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.manager.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBluetoothDevicesData {
        CMsgBluetoothDevicesData::new()
    }

    fn clear(&mut self) {
        self.adapters.clear();
        self.devices.clear();
        self.manager.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBluetoothDevicesData {
        static instance: CMsgBluetoothDevicesData = CMsgBluetoothDevicesData {
            adapters: ::std::vec::Vec::new(),
            devices: ::std::vec::Vec::new(),
            manager: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgBluetoothDevicesData`
pub mod cmsg_bluetooth_devices_data {
    // @@protoc_insertion_point(message:CMsgBluetoothDevicesData.Adapter)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Adapter {
        // message fields
        // @@protoc_insertion_point(field:CMsgBluetoothDevicesData.Adapter.id)
        pub id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgBluetoothDevicesData.Adapter.mac)
        pub mac: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgBluetoothDevicesData.Adapter.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgBluetoothDevicesData.Adapter.is_enabled)
        pub is_enabled: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgBluetoothDevicesData.Adapter.is_discovering)
        pub is_discovering: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgBluetoothDevicesData.Adapter.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Adapter {
        fn default() -> &'a Adapter {
            <Adapter as ::protobuf::Message>::default_instance()
        }
    }

    impl Adapter {
        pub fn new() -> Adapter {
            ::std::default::Default::default()
        }

        // optional uint32 id = 1;

        pub fn id(&self) -> u32 {
            self.id.unwrap_or(0u32)
        }

        pub fn clear_id(&mut self) {
            self.id = ::std::option::Option::None;
        }

        pub fn has_id(&self) -> bool {
            self.id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_id(&mut self, v: u32) {
            self.id = ::std::option::Option::Some(v);
        }

        // optional string mac = 2;

        pub fn mac(&self) -> &str {
            match self.mac.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_mac(&mut self) {
            self.mac = ::std::option::Option::None;
        }

        pub fn has_mac(&self) -> bool {
            self.mac.is_some()
        }

        // Param is passed by value, moved
        pub fn set_mac(&mut self, v: ::std::string::String) {
            self.mac = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_mac(&mut self) -> &mut ::std::string::String {
            if self.mac.is_none() {
                self.mac = ::std::option::Option::Some(::std::string::String::new());
            }
            self.mac.as_mut().unwrap()
        }

        // Take field
        pub fn take_mac(&mut self) -> ::std::string::String {
            self.mac.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string name = 3;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool is_enabled = 4;

        pub fn is_enabled(&self) -> bool {
            self.is_enabled.unwrap_or(false)
        }

        pub fn clear_is_enabled(&mut self) {
            self.is_enabled = ::std::option::Option::None;
        }

        pub fn has_is_enabled(&self) -> bool {
            self.is_enabled.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_enabled(&mut self, v: bool) {
            self.is_enabled = ::std::option::Option::Some(v);
        }

        // optional bool is_discovering = 5;

        pub fn is_discovering(&self) -> bool {
            self.is_discovering.unwrap_or(false)
        }

        pub fn clear_is_discovering(&mut self) {
            self.is_discovering = ::std::option::Option::None;
        }

        pub fn has_is_discovering(&self) -> bool {
            self.is_discovering.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_discovering(&mut self, v: bool) {
            self.is_discovering = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Adapter {
        const NAME: &'static str = "Adapter";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.mac = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    32 => {
                        self.is_enabled = ::std::option::Option::Some(is.read_bool()?);
                    },
                    40 => {
                        self.is_discovering = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.mac.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.is_enabled {
                my_size += 1 + 1;
            }
            if let Some(v) = self.is_discovering {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.mac.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.is_enabled {
                os.write_bool(4, v)?;
            }
            if let Some(v) = self.is_discovering {
                os.write_bool(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Adapter {
            Adapter::new()
        }

        fn clear(&mut self) {
            self.id = ::std::option::Option::None;
            self.mac = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.is_enabled = ::std::option::Option::None;
            self.is_discovering = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Adapter {
            static instance: Adapter = Adapter {
                id: ::std::option::Option::None,
                mac: ::std::option::Option::None,
                name: ::std::option::Option::None,
                is_enabled: ::std::option::Option::None,
                is_discovering: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgBluetoothDevicesData.Device)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Device {
        // message fields
        // @@protoc_insertion_point(field:CMsgBluetoothDevicesData.Device.id)
        pub id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgBluetoothDevicesData.Device.adapter_id)
        pub adapter_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgBluetoothDevicesData.Device.etype)
        pub etype: ::std::option::Option<::protobuf::EnumOrUnknown<super::super::enums::EBluetoothDeviceType>>,
        // @@protoc_insertion_point(field:CMsgBluetoothDevicesData.Device.mac)
        pub mac: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgBluetoothDevicesData.Device.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgBluetoothDevicesData.Device.is_connected)
        pub is_connected: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgBluetoothDevicesData.Device.is_paired)
        pub is_paired: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgBluetoothDevicesData.Device.strength_raw)
        pub strength_raw: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgBluetoothDevicesData.Device.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Device {
        fn default() -> &'a Device {
            <Device as ::protobuf::Message>::default_instance()
        }
    }

    impl Device {
        pub fn new() -> Device {
            ::std::default::Default::default()
        }

        // optional uint32 id = 1;

        pub fn id(&self) -> u32 {
            self.id.unwrap_or(0u32)
        }

        pub fn clear_id(&mut self) {
            self.id = ::std::option::Option::None;
        }

        pub fn has_id(&self) -> bool {
            self.id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_id(&mut self, v: u32) {
            self.id = ::std::option::Option::Some(v);
        }

        // optional uint32 adapter_id = 2;

        pub fn adapter_id(&self) -> u32 {
            self.adapter_id.unwrap_or(0u32)
        }

        pub fn clear_adapter_id(&mut self) {
            self.adapter_id = ::std::option::Option::None;
        }

        pub fn has_adapter_id(&self) -> bool {
            self.adapter_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_adapter_id(&mut self, v: u32) {
            self.adapter_id = ::std::option::Option::Some(v);
        }

        // optional .EBluetoothDeviceType etype = 3;

        pub fn etype(&self) -> super::super::enums::EBluetoothDeviceType {
            match self.etype {
                Some(e) => e.enum_value_or(super::super::enums::EBluetoothDeviceType::k_BluetoothDeviceType_Invalid),
                None => super::super::enums::EBluetoothDeviceType::k_BluetoothDeviceType_Invalid,
            }
        }

        pub fn clear_etype(&mut self) {
            self.etype = ::std::option::Option::None;
        }

        pub fn has_etype(&self) -> bool {
            self.etype.is_some()
        }

        // Param is passed by value, moved
        pub fn set_etype(&mut self, v: super::super::enums::EBluetoothDeviceType) {
            self.etype = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional string mac = 4;

        pub fn mac(&self) -> &str {
            match self.mac.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_mac(&mut self) {
            self.mac = ::std::option::Option::None;
        }

        pub fn has_mac(&self) -> bool {
            self.mac.is_some()
        }

        // Param is passed by value, moved
        pub fn set_mac(&mut self, v: ::std::string::String) {
            self.mac = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_mac(&mut self) -> &mut ::std::string::String {
            if self.mac.is_none() {
                self.mac = ::std::option::Option::Some(::std::string::String::new());
            }
            self.mac.as_mut().unwrap()
        }

        // Take field
        pub fn take_mac(&mut self) -> ::std::string::String {
            self.mac.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string name = 5;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool is_connected = 6;

        pub fn is_connected(&self) -> bool {
            self.is_connected.unwrap_or(false)
        }

        pub fn clear_is_connected(&mut self) {
            self.is_connected = ::std::option::Option::None;
        }

        pub fn has_is_connected(&self) -> bool {
            self.is_connected.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_connected(&mut self, v: bool) {
            self.is_connected = ::std::option::Option::Some(v);
        }

        // optional bool is_paired = 7;

        pub fn is_paired(&self) -> bool {
            self.is_paired.unwrap_or(false)
        }

        pub fn clear_is_paired(&mut self) {
            self.is_paired = ::std::option::Option::None;
        }

        pub fn has_is_paired(&self) -> bool {
            self.is_paired.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_paired(&mut self, v: bool) {
            self.is_paired = ::std::option::Option::Some(v);
        }

        // optional int32 strength_raw = 8;

        pub fn strength_raw(&self) -> i32 {
            self.strength_raw.unwrap_or(0)
        }

        pub fn clear_strength_raw(&mut self) {
            self.strength_raw = ::std::option::Option::None;
        }

        pub fn has_strength_raw(&self) -> bool {
            self.strength_raw.is_some()
        }

        // Param is passed by value, moved
        pub fn set_strength_raw(&mut self, v: i32) {
            self.strength_raw = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Device {
        const NAME: &'static str = "Device";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.adapter_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.etype = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    34 => {
                        self.mac = ::std::option::Option::Some(is.read_string()?);
                    },
                    42 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    48 => {
                        self.is_connected = ::std::option::Option::Some(is.read_bool()?);
                    },
                    56 => {
                        self.is_paired = ::std::option::Option::Some(is.read_bool()?);
                    },
                    64 => {
                        self.strength_raw = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.adapter_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.etype {
                my_size += ::protobuf::rt::int32_size(3, v.value());
            }
            if let Some(v) = self.mac.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(5, &v);
            }
            if let Some(v) = self.is_connected {
                my_size += 1 + 1;
            }
            if let Some(v) = self.is_paired {
                my_size += 1 + 1;
            }
            if let Some(v) = self.strength_raw {
                my_size += ::protobuf::rt::int32_size(8, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.adapter_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.etype {
                os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.mac.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(5, v)?;
            }
            if let Some(v) = self.is_connected {
                os.write_bool(6, v)?;
            }
            if let Some(v) = self.is_paired {
                os.write_bool(7, v)?;
            }
            if let Some(v) = self.strength_raw {
                os.write_int32(8, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Device {
            Device::new()
        }

        fn clear(&mut self) {
            self.id = ::std::option::Option::None;
            self.adapter_id = ::std::option::Option::None;
            self.etype = ::std::option::Option::None;
            self.mac = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.is_connected = ::std::option::Option::None;
            self.is_paired = ::std::option::Option::None;
            self.strength_raw = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Device {
            static instance: Device = Device {
                id: ::std::option::Option::None,
                adapter_id: ::std::option::Option::None,
                etype: ::std::option::Option::None,
                mac: ::std::option::Option::None,
                name: ::std::option::Option::None,
                is_connected: ::std::option::Option::None,
                is_paired: ::std::option::Option::None,
                strength_raw: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgBluetoothDevicesData.Manager)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Manager {
        // message fields
        // @@protoc_insertion_point(field:CMsgBluetoothDevicesData.Manager.is_bluetooth_enabled)
        pub is_bluetooth_enabled: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgBluetoothDevicesData.Manager.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Manager {
        fn default() -> &'a Manager {
            <Manager as ::protobuf::Message>::default_instance()
        }
    }

    impl Manager {
        pub fn new() -> Manager {
            ::std::default::Default::default()
        }

        // optional bool is_bluetooth_enabled = 1;

        pub fn is_bluetooth_enabled(&self) -> bool {
            self.is_bluetooth_enabled.unwrap_or(false)
        }

        pub fn clear_is_bluetooth_enabled(&mut self) {
            self.is_bluetooth_enabled = ::std::option::Option::None;
        }

        pub fn has_is_bluetooth_enabled(&self) -> bool {
            self.is_bluetooth_enabled.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_bluetooth_enabled(&mut self, v: bool) {
            self.is_bluetooth_enabled = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Manager {
        const NAME: &'static str = "Manager";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.is_bluetooth_enabled = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.is_bluetooth_enabled {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.is_bluetooth_enabled {
                os.write_bool(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Manager {
            Manager::new()
        }

        fn clear(&mut self) {
            self.is_bluetooth_enabled = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Manager {
            static instance: Manager = Manager {
                is_bluetooth_enabled: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgSystemPerfDiagnosticEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemPerfDiagnosticEntry {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemPerfDiagnosticEntry.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSystemPerfDiagnosticEntry.value)
    pub value: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemPerfDiagnosticEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemPerfDiagnosticEntry {
    fn default() -> &'a CMsgSystemPerfDiagnosticEntry {
        <CMsgSystemPerfDiagnosticEntry as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSystemPerfDiagnosticEntry {
    pub fn new() -> CMsgSystemPerfDiagnosticEntry {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 2;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgSystemPerfDiagnosticEntry {
    const NAME: &'static str = "CMsgSystemPerfDiagnosticEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemPerfDiagnosticEntry {
        CMsgSystemPerfDiagnosticEntry::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemPerfDiagnosticEntry {
        static instance: CMsgSystemPerfDiagnosticEntry = CMsgSystemPerfDiagnosticEntry {
            name: ::std::option::Option::None,
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSystemPerfNetworkInterface)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemPerfNetworkInterface {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemPerfNetworkInterface.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSystemPerfNetworkInterface.timestamp)
    pub timestamp: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgSystemPerfNetworkInterface.tx_bytes_total)
    pub tx_bytes_total: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:CMsgSystemPerfNetworkInterface.rx_bytes_total)
    pub rx_bytes_total: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:CMsgSystemPerfNetworkInterface.tx_bytes_per_sec)
    pub tx_bytes_per_sec: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfNetworkInterface.rx_bytes_per_sec)
    pub rx_bytes_per_sec: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemPerfNetworkInterface.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemPerfNetworkInterface {
    fn default() -> &'a CMsgSystemPerfNetworkInterface {
        <CMsgSystemPerfNetworkInterface as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSystemPerfNetworkInterface {
    pub fn new() -> CMsgSystemPerfNetworkInterface {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional double timestamp = 2;

    pub fn timestamp(&self) -> f64 {
        self.timestamp.unwrap_or(0.)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: f64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional int64 tx_bytes_total = 3;

    pub fn tx_bytes_total(&self) -> i64 {
        self.tx_bytes_total.unwrap_or(0)
    }

    pub fn clear_tx_bytes_total(&mut self) {
        self.tx_bytes_total = ::std::option::Option::None;
    }

    pub fn has_tx_bytes_total(&self) -> bool {
        self.tx_bytes_total.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tx_bytes_total(&mut self, v: i64) {
        self.tx_bytes_total = ::std::option::Option::Some(v);
    }

    // optional int64 rx_bytes_total = 4;

    pub fn rx_bytes_total(&self) -> i64 {
        self.rx_bytes_total.unwrap_or(0)
    }

    pub fn clear_rx_bytes_total(&mut self) {
        self.rx_bytes_total = ::std::option::Option::None;
    }

    pub fn has_rx_bytes_total(&self) -> bool {
        self.rx_bytes_total.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rx_bytes_total(&mut self, v: i64) {
        self.rx_bytes_total = ::std::option::Option::Some(v);
    }

    // optional int32 tx_bytes_per_sec = 5;

    pub fn tx_bytes_per_sec(&self) -> i32 {
        self.tx_bytes_per_sec.unwrap_or(0)
    }

    pub fn clear_tx_bytes_per_sec(&mut self) {
        self.tx_bytes_per_sec = ::std::option::Option::None;
    }

    pub fn has_tx_bytes_per_sec(&self) -> bool {
        self.tx_bytes_per_sec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tx_bytes_per_sec(&mut self, v: i32) {
        self.tx_bytes_per_sec = ::std::option::Option::Some(v);
    }

    // optional int32 rx_bytes_per_sec = 6;

    pub fn rx_bytes_per_sec(&self) -> i32 {
        self.rx_bytes_per_sec.unwrap_or(0)
    }

    pub fn clear_rx_bytes_per_sec(&mut self) {
        self.rx_bytes_per_sec = ::std::option::Option::None;
    }

    pub fn has_rx_bytes_per_sec(&self) -> bool {
        self.rx_bytes_per_sec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rx_bytes_per_sec(&mut self, v: i32) {
        self.rx_bytes_per_sec = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSystemPerfNetworkInterface {
    const NAME: &'static str = "CMsgSystemPerfNetworkInterface";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                17 => {
                    self.timestamp = ::std::option::Option::Some(is.read_double()?);
                },
                24 => {
                    self.tx_bytes_total = ::std::option::Option::Some(is.read_int64()?);
                },
                32 => {
                    self.rx_bytes_total = ::std::option::Option::Some(is.read_int64()?);
                },
                40 => {
                    self.tx_bytes_per_sec = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.rx_bytes_per_sec = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.timestamp {
            my_size += 1 + 8;
        }
        if let Some(v) = self.tx_bytes_total {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        if let Some(v) = self.rx_bytes_total {
            my_size += ::protobuf::rt::int64_size(4, v);
        }
        if let Some(v) = self.tx_bytes_per_sec {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.rx_bytes_per_sec {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.tx_bytes_total {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.rx_bytes_total {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.tx_bytes_per_sec {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.rx_bytes_per_sec {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemPerfNetworkInterface {
        CMsgSystemPerfNetworkInterface::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.tx_bytes_total = ::std::option::Option::None;
        self.rx_bytes_total = ::std::option::Option::None;
        self.tx_bytes_per_sec = ::std::option::Option::None;
        self.rx_bytes_per_sec = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemPerfNetworkInterface {
        static instance: CMsgSystemPerfNetworkInterface = CMsgSystemPerfNetworkInterface {
            name: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            tx_bytes_total: ::std::option::Option::None,
            rx_bytes_total: ::std::option::Option::None,
            tx_bytes_per_sec: ::std::option::Option::None,
            rx_bytes_per_sec: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSystemPerfDiagnosticInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemPerfDiagnosticInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemPerfDiagnosticInfo.entries)
    pub entries: ::std::vec::Vec<CMsgSystemPerfDiagnosticEntry>,
    // @@protoc_insertion_point(field:CMsgSystemPerfDiagnosticInfo.interfaces)
    pub interfaces: ::std::vec::Vec<CMsgSystemPerfNetworkInterface>,
    // @@protoc_insertion_point(field:CMsgSystemPerfDiagnosticInfo.battery_temp_c)
    pub battery_temp_c: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemPerfDiagnosticInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemPerfDiagnosticInfo {
    fn default() -> &'a CMsgSystemPerfDiagnosticInfo {
        <CMsgSystemPerfDiagnosticInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSystemPerfDiagnosticInfo {
    pub fn new() -> CMsgSystemPerfDiagnosticInfo {
        ::std::default::Default::default()
    }

    // optional float battery_temp_c = 3;

    pub fn battery_temp_c(&self) -> f32 {
        self.battery_temp_c.unwrap_or(0.)
    }

    pub fn clear_battery_temp_c(&mut self) {
        self.battery_temp_c = ::std::option::Option::None;
    }

    pub fn has_battery_temp_c(&self) -> bool {
        self.battery_temp_c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_battery_temp_c(&mut self, v: f32) {
        self.battery_temp_c = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSystemPerfDiagnosticInfo {
    const NAME: &'static str = "CMsgSystemPerfDiagnosticInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.entries.push(is.read_message()?);
                },
                18 => {
                    self.interfaces.push(is.read_message()?);
                },
                29 => {
                    self.battery_temp_c = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.interfaces {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.battery_temp_c {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.entries {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.interfaces {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.battery_temp_c {
            os.write_float(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemPerfDiagnosticInfo {
        CMsgSystemPerfDiagnosticInfo::new()
    }

    fn clear(&mut self) {
        self.entries.clear();
        self.interfaces.clear();
        self.battery_temp_c = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemPerfDiagnosticInfo {
        static instance: CMsgSystemPerfDiagnosticInfo = CMsgSystemPerfDiagnosticInfo {
            entries: ::std::vec::Vec::new(),
            interfaces: ::std::vec::Vec::new(),
            battery_temp_c: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSystemPerfLimits)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemPerfLimits {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.cpu_governor_manual_min_mhz)
    pub cpu_governor_manual_min_mhz: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.cpu_governor_manual_max_mhz)
    pub cpu_governor_manual_max_mhz: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.fsr_sharpness_min)
    pub fsr_sharpness_min: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.fsr_sharpness_max)
    pub fsr_sharpness_max: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.gpu_performance_manual_min_mhz)
    pub gpu_performance_manual_min_mhz: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.gpu_performance_manual_max_mhz)
    pub gpu_performance_manual_max_mhz: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.perf_overlay_is_standalone)
    pub perf_overlay_is_standalone: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.is_dynamic_vrs_available)
    pub is_dynamic_vrs_available: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.is_manual_display_refresh_rate_available)
    pub is_manual_display_refresh_rate_available: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.gpu_performance_levels_available)
    pub gpu_performance_levels_available: ::std::vec::Vec<::protobuf::EnumOrUnknown<super::enums::EGPUPerformanceLevel>>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.display_refresh_manual_hz_min)
    pub display_refresh_manual_hz_min: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.display_refresh_manual_hz_max)
    pub display_refresh_manual_hz_max: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.fps_limit_options)
    pub fps_limit_options: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.tdp_limit_min)
    pub tdp_limit_min: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.tdp_limit_max)
    pub tdp_limit_max: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.is_nis_supported)
    pub is_nis_supported: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.nis_sharpness_min)
    pub nis_sharpness_min: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.nis_sharpness_max)
    pub nis_sharpness_max: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.display_external_refresh_manual_hz_min)
    pub display_external_refresh_manual_hz_min: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.display_external_refresh_manual_hz_max)
    pub display_external_refresh_manual_hz_max: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.fps_limit_options_external)
    pub fps_limit_options_external: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.is_tearing_supported)
    pub is_tearing_supported: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.is_vrr_supported)
    pub is_vrr_supported: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.is_dynamic_refresh_rate_in_steam_supported)
    pub is_dynamic_refresh_rate_in_steam_supported: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.is_split_scaling_and_filtering_supported)
    pub is_split_scaling_and_filtering_supported: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.split_scaling_filters_available)
    pub split_scaling_filters_available: ::std::vec::Vec<::protobuf::EnumOrUnknown<super::enums::ESplitScalingFilter>>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.split_scaling_scalers_available)
    pub split_scaling_scalers_available: ::std::vec::Vec<::protobuf::EnumOrUnknown<super::enums::ESplitScalingScaler>>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.is_hdr_supported)
    pub is_hdr_supported: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfLimits.display_refresh_manual_hz_oc_max)
    pub display_refresh_manual_hz_oc_max: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemPerfLimits.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemPerfLimits {
    fn default() -> &'a CMsgSystemPerfLimits {
        <CMsgSystemPerfLimits as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSystemPerfLimits {
    pub fn new() -> CMsgSystemPerfLimits {
        ::std::default::Default::default()
    }

    // optional int32 cpu_governor_manual_min_mhz = 1;

    pub fn cpu_governor_manual_min_mhz(&self) -> i32 {
        self.cpu_governor_manual_min_mhz.unwrap_or(0)
    }

    pub fn clear_cpu_governor_manual_min_mhz(&mut self) {
        self.cpu_governor_manual_min_mhz = ::std::option::Option::None;
    }

    pub fn has_cpu_governor_manual_min_mhz(&self) -> bool {
        self.cpu_governor_manual_min_mhz.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_governor_manual_min_mhz(&mut self, v: i32) {
        self.cpu_governor_manual_min_mhz = ::std::option::Option::Some(v);
    }

    // optional int32 cpu_governor_manual_max_mhz = 2;

    pub fn cpu_governor_manual_max_mhz(&self) -> i32 {
        self.cpu_governor_manual_max_mhz.unwrap_or(0)
    }

    pub fn clear_cpu_governor_manual_max_mhz(&mut self) {
        self.cpu_governor_manual_max_mhz = ::std::option::Option::None;
    }

    pub fn has_cpu_governor_manual_max_mhz(&self) -> bool {
        self.cpu_governor_manual_max_mhz.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_governor_manual_max_mhz(&mut self, v: i32) {
        self.cpu_governor_manual_max_mhz = ::std::option::Option::Some(v);
    }

    // optional int32 fsr_sharpness_min = 3;

    pub fn fsr_sharpness_min(&self) -> i32 {
        self.fsr_sharpness_min.unwrap_or(0)
    }

    pub fn clear_fsr_sharpness_min(&mut self) {
        self.fsr_sharpness_min = ::std::option::Option::None;
    }

    pub fn has_fsr_sharpness_min(&self) -> bool {
        self.fsr_sharpness_min.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsr_sharpness_min(&mut self, v: i32) {
        self.fsr_sharpness_min = ::std::option::Option::Some(v);
    }

    // optional int32 fsr_sharpness_max = 4;

    pub fn fsr_sharpness_max(&self) -> i32 {
        self.fsr_sharpness_max.unwrap_or(0)
    }

    pub fn clear_fsr_sharpness_max(&mut self) {
        self.fsr_sharpness_max = ::std::option::Option::None;
    }

    pub fn has_fsr_sharpness_max(&self) -> bool {
        self.fsr_sharpness_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsr_sharpness_max(&mut self, v: i32) {
        self.fsr_sharpness_max = ::std::option::Option::Some(v);
    }

    // optional int32 gpu_performance_manual_min_mhz = 5;

    pub fn gpu_performance_manual_min_mhz(&self) -> i32 {
        self.gpu_performance_manual_min_mhz.unwrap_or(0)
    }

    pub fn clear_gpu_performance_manual_min_mhz(&mut self) {
        self.gpu_performance_manual_min_mhz = ::std::option::Option::None;
    }

    pub fn has_gpu_performance_manual_min_mhz(&self) -> bool {
        self.gpu_performance_manual_min_mhz.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gpu_performance_manual_min_mhz(&mut self, v: i32) {
        self.gpu_performance_manual_min_mhz = ::std::option::Option::Some(v);
    }

    // optional int32 gpu_performance_manual_max_mhz = 6;

    pub fn gpu_performance_manual_max_mhz(&self) -> i32 {
        self.gpu_performance_manual_max_mhz.unwrap_or(0)
    }

    pub fn clear_gpu_performance_manual_max_mhz(&mut self) {
        self.gpu_performance_manual_max_mhz = ::std::option::Option::None;
    }

    pub fn has_gpu_performance_manual_max_mhz(&self) -> bool {
        self.gpu_performance_manual_max_mhz.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gpu_performance_manual_max_mhz(&mut self, v: i32) {
        self.gpu_performance_manual_max_mhz = ::std::option::Option::Some(v);
    }

    // optional bool perf_overlay_is_standalone = 7;

    pub fn perf_overlay_is_standalone(&self) -> bool {
        self.perf_overlay_is_standalone.unwrap_or(false)
    }

    pub fn clear_perf_overlay_is_standalone(&mut self) {
        self.perf_overlay_is_standalone = ::std::option::Option::None;
    }

    pub fn has_perf_overlay_is_standalone(&self) -> bool {
        self.perf_overlay_is_standalone.is_some()
    }

    // Param is passed by value, moved
    pub fn set_perf_overlay_is_standalone(&mut self, v: bool) {
        self.perf_overlay_is_standalone = ::std::option::Option::Some(v);
    }

    // optional bool is_dynamic_vrs_available = 8;

    pub fn is_dynamic_vrs_available(&self) -> bool {
        self.is_dynamic_vrs_available.unwrap_or(false)
    }

    pub fn clear_is_dynamic_vrs_available(&mut self) {
        self.is_dynamic_vrs_available = ::std::option::Option::None;
    }

    pub fn has_is_dynamic_vrs_available(&self) -> bool {
        self.is_dynamic_vrs_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_dynamic_vrs_available(&mut self, v: bool) {
        self.is_dynamic_vrs_available = ::std::option::Option::Some(v);
    }

    // optional bool is_manual_display_refresh_rate_available = 9;

    pub fn is_manual_display_refresh_rate_available(&self) -> bool {
        self.is_manual_display_refresh_rate_available.unwrap_or(false)
    }

    pub fn clear_is_manual_display_refresh_rate_available(&mut self) {
        self.is_manual_display_refresh_rate_available = ::std::option::Option::None;
    }

    pub fn has_is_manual_display_refresh_rate_available(&self) -> bool {
        self.is_manual_display_refresh_rate_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_manual_display_refresh_rate_available(&mut self, v: bool) {
        self.is_manual_display_refresh_rate_available = ::std::option::Option::Some(v);
    }

    // optional int32 display_refresh_manual_hz_min = 11;

    pub fn display_refresh_manual_hz_min(&self) -> i32 {
        self.display_refresh_manual_hz_min.unwrap_or(0)
    }

    pub fn clear_display_refresh_manual_hz_min(&mut self) {
        self.display_refresh_manual_hz_min = ::std::option::Option::None;
    }

    pub fn has_display_refresh_manual_hz_min(&self) -> bool {
        self.display_refresh_manual_hz_min.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_refresh_manual_hz_min(&mut self, v: i32) {
        self.display_refresh_manual_hz_min = ::std::option::Option::Some(v);
    }

    // optional int32 display_refresh_manual_hz_max = 12;

    pub fn display_refresh_manual_hz_max(&self) -> i32 {
        self.display_refresh_manual_hz_max.unwrap_or(0)
    }

    pub fn clear_display_refresh_manual_hz_max(&mut self) {
        self.display_refresh_manual_hz_max = ::std::option::Option::None;
    }

    pub fn has_display_refresh_manual_hz_max(&self) -> bool {
        self.display_refresh_manual_hz_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_refresh_manual_hz_max(&mut self, v: i32) {
        self.display_refresh_manual_hz_max = ::std::option::Option::Some(v);
    }

    // optional int32 tdp_limit_min = 14;

    pub fn tdp_limit_min(&self) -> i32 {
        self.tdp_limit_min.unwrap_or(0)
    }

    pub fn clear_tdp_limit_min(&mut self) {
        self.tdp_limit_min = ::std::option::Option::None;
    }

    pub fn has_tdp_limit_min(&self) -> bool {
        self.tdp_limit_min.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tdp_limit_min(&mut self, v: i32) {
        self.tdp_limit_min = ::std::option::Option::Some(v);
    }

    // optional int32 tdp_limit_max = 15;

    pub fn tdp_limit_max(&self) -> i32 {
        self.tdp_limit_max.unwrap_or(0)
    }

    pub fn clear_tdp_limit_max(&mut self) {
        self.tdp_limit_max = ::std::option::Option::None;
    }

    pub fn has_tdp_limit_max(&self) -> bool {
        self.tdp_limit_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tdp_limit_max(&mut self, v: i32) {
        self.tdp_limit_max = ::std::option::Option::Some(v);
    }

    // optional bool is_nis_supported = 16;

    pub fn is_nis_supported(&self) -> bool {
        self.is_nis_supported.unwrap_or(false)
    }

    pub fn clear_is_nis_supported(&mut self) {
        self.is_nis_supported = ::std::option::Option::None;
    }

    pub fn has_is_nis_supported(&self) -> bool {
        self.is_nis_supported.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_nis_supported(&mut self, v: bool) {
        self.is_nis_supported = ::std::option::Option::Some(v);
    }

    // optional int32 nis_sharpness_min = 17;

    pub fn nis_sharpness_min(&self) -> i32 {
        self.nis_sharpness_min.unwrap_or(0)
    }

    pub fn clear_nis_sharpness_min(&mut self) {
        self.nis_sharpness_min = ::std::option::Option::None;
    }

    pub fn has_nis_sharpness_min(&self) -> bool {
        self.nis_sharpness_min.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nis_sharpness_min(&mut self, v: i32) {
        self.nis_sharpness_min = ::std::option::Option::Some(v);
    }

    // optional int32 nis_sharpness_max = 18;

    pub fn nis_sharpness_max(&self) -> i32 {
        self.nis_sharpness_max.unwrap_or(0)
    }

    pub fn clear_nis_sharpness_max(&mut self) {
        self.nis_sharpness_max = ::std::option::Option::None;
    }

    pub fn has_nis_sharpness_max(&self) -> bool {
        self.nis_sharpness_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nis_sharpness_max(&mut self, v: i32) {
        self.nis_sharpness_max = ::std::option::Option::Some(v);
    }

    // optional int32 display_external_refresh_manual_hz_min = 19;

    pub fn display_external_refresh_manual_hz_min(&self) -> i32 {
        self.display_external_refresh_manual_hz_min.unwrap_or(0)
    }

    pub fn clear_display_external_refresh_manual_hz_min(&mut self) {
        self.display_external_refresh_manual_hz_min = ::std::option::Option::None;
    }

    pub fn has_display_external_refresh_manual_hz_min(&self) -> bool {
        self.display_external_refresh_manual_hz_min.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_external_refresh_manual_hz_min(&mut self, v: i32) {
        self.display_external_refresh_manual_hz_min = ::std::option::Option::Some(v);
    }

    // optional int32 display_external_refresh_manual_hz_max = 20;

    pub fn display_external_refresh_manual_hz_max(&self) -> i32 {
        self.display_external_refresh_manual_hz_max.unwrap_or(0)
    }

    pub fn clear_display_external_refresh_manual_hz_max(&mut self) {
        self.display_external_refresh_manual_hz_max = ::std::option::Option::None;
    }

    pub fn has_display_external_refresh_manual_hz_max(&self) -> bool {
        self.display_external_refresh_manual_hz_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_external_refresh_manual_hz_max(&mut self, v: i32) {
        self.display_external_refresh_manual_hz_max = ::std::option::Option::Some(v);
    }

    // optional bool is_tearing_supported = 22;

    pub fn is_tearing_supported(&self) -> bool {
        self.is_tearing_supported.unwrap_or(false)
    }

    pub fn clear_is_tearing_supported(&mut self) {
        self.is_tearing_supported = ::std::option::Option::None;
    }

    pub fn has_is_tearing_supported(&self) -> bool {
        self.is_tearing_supported.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_tearing_supported(&mut self, v: bool) {
        self.is_tearing_supported = ::std::option::Option::Some(v);
    }

    // optional bool is_vrr_supported = 23;

    pub fn is_vrr_supported(&self) -> bool {
        self.is_vrr_supported.unwrap_or(false)
    }

    pub fn clear_is_vrr_supported(&mut self) {
        self.is_vrr_supported = ::std::option::Option::None;
    }

    pub fn has_is_vrr_supported(&self) -> bool {
        self.is_vrr_supported.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_vrr_supported(&mut self, v: bool) {
        self.is_vrr_supported = ::std::option::Option::Some(v);
    }

    // optional bool is_dynamic_refresh_rate_in_steam_supported = 24;

    pub fn is_dynamic_refresh_rate_in_steam_supported(&self) -> bool {
        self.is_dynamic_refresh_rate_in_steam_supported.unwrap_or(false)
    }

    pub fn clear_is_dynamic_refresh_rate_in_steam_supported(&mut self) {
        self.is_dynamic_refresh_rate_in_steam_supported = ::std::option::Option::None;
    }

    pub fn has_is_dynamic_refresh_rate_in_steam_supported(&self) -> bool {
        self.is_dynamic_refresh_rate_in_steam_supported.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_dynamic_refresh_rate_in_steam_supported(&mut self, v: bool) {
        self.is_dynamic_refresh_rate_in_steam_supported = ::std::option::Option::Some(v);
    }

    // optional bool is_split_scaling_and_filtering_supported = 25;

    pub fn is_split_scaling_and_filtering_supported(&self) -> bool {
        self.is_split_scaling_and_filtering_supported.unwrap_or(false)
    }

    pub fn clear_is_split_scaling_and_filtering_supported(&mut self) {
        self.is_split_scaling_and_filtering_supported = ::std::option::Option::None;
    }

    pub fn has_is_split_scaling_and_filtering_supported(&self) -> bool {
        self.is_split_scaling_and_filtering_supported.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_split_scaling_and_filtering_supported(&mut self, v: bool) {
        self.is_split_scaling_and_filtering_supported = ::std::option::Option::Some(v);
    }

    // optional bool is_hdr_supported = 28;

    pub fn is_hdr_supported(&self) -> bool {
        self.is_hdr_supported.unwrap_or(false)
    }

    pub fn clear_is_hdr_supported(&mut self) {
        self.is_hdr_supported = ::std::option::Option::None;
    }

    pub fn has_is_hdr_supported(&self) -> bool {
        self.is_hdr_supported.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_hdr_supported(&mut self, v: bool) {
        self.is_hdr_supported = ::std::option::Option::Some(v);
    }

    // optional int32 display_refresh_manual_hz_oc_max = 29;

    pub fn display_refresh_manual_hz_oc_max(&self) -> i32 {
        self.display_refresh_manual_hz_oc_max.unwrap_or(0)
    }

    pub fn clear_display_refresh_manual_hz_oc_max(&mut self) {
        self.display_refresh_manual_hz_oc_max = ::std::option::Option::None;
    }

    pub fn has_display_refresh_manual_hz_oc_max(&self) -> bool {
        self.display_refresh_manual_hz_oc_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_refresh_manual_hz_oc_max(&mut self, v: i32) {
        self.display_refresh_manual_hz_oc_max = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSystemPerfLimits {
    const NAME: &'static str = "CMsgSystemPerfLimits";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.cpu_governor_manual_min_mhz = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.cpu_governor_manual_max_mhz = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.fsr_sharpness_min = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.fsr_sharpness_max = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.gpu_performance_manual_min_mhz = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.gpu_performance_manual_max_mhz = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.perf_overlay_is_standalone = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.is_dynamic_vrs_available = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.is_manual_display_refresh_rate_available = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.gpu_performance_levels_available.push(is.read_enum_or_unknown()?);
                },
                82 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.gpu_performance_levels_available)?
                },
                88 => {
                    self.display_refresh_manual_hz_min = ::std::option::Option::Some(is.read_int32()?);
                },
                96 => {
                    self.display_refresh_manual_hz_max = ::std::option::Option::Some(is.read_int32()?);
                },
                106 => {
                    is.read_repeated_packed_int32_into(&mut self.fps_limit_options)?;
                },
                104 => {
                    self.fps_limit_options.push(is.read_int32()?);
                },
                112 => {
                    self.tdp_limit_min = ::std::option::Option::Some(is.read_int32()?);
                },
                120 => {
                    self.tdp_limit_max = ::std::option::Option::Some(is.read_int32()?);
                },
                128 => {
                    self.is_nis_supported = ::std::option::Option::Some(is.read_bool()?);
                },
                136 => {
                    self.nis_sharpness_min = ::std::option::Option::Some(is.read_int32()?);
                },
                144 => {
                    self.nis_sharpness_max = ::std::option::Option::Some(is.read_int32()?);
                },
                152 => {
                    self.display_external_refresh_manual_hz_min = ::std::option::Option::Some(is.read_int32()?);
                },
                160 => {
                    self.display_external_refresh_manual_hz_max = ::std::option::Option::Some(is.read_int32()?);
                },
                170 => {
                    is.read_repeated_packed_int32_into(&mut self.fps_limit_options_external)?;
                },
                168 => {
                    self.fps_limit_options_external.push(is.read_int32()?);
                },
                176 => {
                    self.is_tearing_supported = ::std::option::Option::Some(is.read_bool()?);
                },
                184 => {
                    self.is_vrr_supported = ::std::option::Option::Some(is.read_bool()?);
                },
                192 => {
                    self.is_dynamic_refresh_rate_in_steam_supported = ::std::option::Option::Some(is.read_bool()?);
                },
                200 => {
                    self.is_split_scaling_and_filtering_supported = ::std::option::Option::Some(is.read_bool()?);
                },
                208 => {
                    self.split_scaling_filters_available.push(is.read_enum_or_unknown()?);
                },
                210 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.split_scaling_filters_available)?
                },
                216 => {
                    self.split_scaling_scalers_available.push(is.read_enum_or_unknown()?);
                },
                218 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.split_scaling_scalers_available)?
                },
                224 => {
                    self.is_hdr_supported = ::std::option::Option::Some(is.read_bool()?);
                },
                232 => {
                    self.display_refresh_manual_hz_oc_max = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cpu_governor_manual_min_mhz {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.cpu_governor_manual_max_mhz {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.fsr_sharpness_min {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.fsr_sharpness_max {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.gpu_performance_manual_min_mhz {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.gpu_performance_manual_max_mhz {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.perf_overlay_is_standalone {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_dynamic_vrs_available {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_manual_display_refresh_rate_available {
            my_size += 1 + 1;
        }
        for value in &self.gpu_performance_levels_available {
            my_size += ::protobuf::rt::int32_size(10, value.value());
        };
        if let Some(v) = self.display_refresh_manual_hz_min {
            my_size += ::protobuf::rt::int32_size(11, v);
        }
        if let Some(v) = self.display_refresh_manual_hz_max {
            my_size += ::protobuf::rt::int32_size(12, v);
        }
        for value in &self.fps_limit_options {
            my_size += ::protobuf::rt::int32_size(13, *value);
        };
        if let Some(v) = self.tdp_limit_min {
            my_size += ::protobuf::rt::int32_size(14, v);
        }
        if let Some(v) = self.tdp_limit_max {
            my_size += ::protobuf::rt::int32_size(15, v);
        }
        if let Some(v) = self.is_nis_supported {
            my_size += 2 + 1;
        }
        if let Some(v) = self.nis_sharpness_min {
            my_size += ::protobuf::rt::int32_size(17, v);
        }
        if let Some(v) = self.nis_sharpness_max {
            my_size += ::protobuf::rt::int32_size(18, v);
        }
        if let Some(v) = self.display_external_refresh_manual_hz_min {
            my_size += ::protobuf::rt::int32_size(19, v);
        }
        if let Some(v) = self.display_external_refresh_manual_hz_max {
            my_size += ::protobuf::rt::int32_size(20, v);
        }
        for value in &self.fps_limit_options_external {
            my_size += ::protobuf::rt::int32_size(21, *value);
        };
        if let Some(v) = self.is_tearing_supported {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_vrr_supported {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_dynamic_refresh_rate_in_steam_supported {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_split_scaling_and_filtering_supported {
            my_size += 2 + 1;
        }
        for value in &self.split_scaling_filters_available {
            my_size += ::protobuf::rt::int32_size(26, value.value());
        };
        for value in &self.split_scaling_scalers_available {
            my_size += ::protobuf::rt::int32_size(27, value.value());
        };
        if let Some(v) = self.is_hdr_supported {
            my_size += 2 + 1;
        }
        if let Some(v) = self.display_refresh_manual_hz_oc_max {
            my_size += ::protobuf::rt::int32_size(29, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cpu_governor_manual_min_mhz {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.cpu_governor_manual_max_mhz {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.fsr_sharpness_min {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.fsr_sharpness_max {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.gpu_performance_manual_min_mhz {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.gpu_performance_manual_max_mhz {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.perf_overlay_is_standalone {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.is_dynamic_vrs_available {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.is_manual_display_refresh_rate_available {
            os.write_bool(9, v)?;
        }
        for v in &self.gpu_performance_levels_available {
            os.write_enum(10, ::protobuf::EnumOrUnknown::value(v))?;
        };
        if let Some(v) = self.display_refresh_manual_hz_min {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.display_refresh_manual_hz_max {
            os.write_int32(12, v)?;
        }
        for v in &self.fps_limit_options {
            os.write_int32(13, *v)?;
        };
        if let Some(v) = self.tdp_limit_min {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.tdp_limit_max {
            os.write_int32(15, v)?;
        }
        if let Some(v) = self.is_nis_supported {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.nis_sharpness_min {
            os.write_int32(17, v)?;
        }
        if let Some(v) = self.nis_sharpness_max {
            os.write_int32(18, v)?;
        }
        if let Some(v) = self.display_external_refresh_manual_hz_min {
            os.write_int32(19, v)?;
        }
        if let Some(v) = self.display_external_refresh_manual_hz_max {
            os.write_int32(20, v)?;
        }
        for v in &self.fps_limit_options_external {
            os.write_int32(21, *v)?;
        };
        if let Some(v) = self.is_tearing_supported {
            os.write_bool(22, v)?;
        }
        if let Some(v) = self.is_vrr_supported {
            os.write_bool(23, v)?;
        }
        if let Some(v) = self.is_dynamic_refresh_rate_in_steam_supported {
            os.write_bool(24, v)?;
        }
        if let Some(v) = self.is_split_scaling_and_filtering_supported {
            os.write_bool(25, v)?;
        }
        for v in &self.split_scaling_filters_available {
            os.write_enum(26, ::protobuf::EnumOrUnknown::value(v))?;
        };
        for v in &self.split_scaling_scalers_available {
            os.write_enum(27, ::protobuf::EnumOrUnknown::value(v))?;
        };
        if let Some(v) = self.is_hdr_supported {
            os.write_bool(28, v)?;
        }
        if let Some(v) = self.display_refresh_manual_hz_oc_max {
            os.write_int32(29, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemPerfLimits {
        CMsgSystemPerfLimits::new()
    }

    fn clear(&mut self) {
        self.cpu_governor_manual_min_mhz = ::std::option::Option::None;
        self.cpu_governor_manual_max_mhz = ::std::option::Option::None;
        self.fsr_sharpness_min = ::std::option::Option::None;
        self.fsr_sharpness_max = ::std::option::Option::None;
        self.gpu_performance_manual_min_mhz = ::std::option::Option::None;
        self.gpu_performance_manual_max_mhz = ::std::option::Option::None;
        self.perf_overlay_is_standalone = ::std::option::Option::None;
        self.is_dynamic_vrs_available = ::std::option::Option::None;
        self.is_manual_display_refresh_rate_available = ::std::option::Option::None;
        self.gpu_performance_levels_available.clear();
        self.display_refresh_manual_hz_min = ::std::option::Option::None;
        self.display_refresh_manual_hz_max = ::std::option::Option::None;
        self.fps_limit_options.clear();
        self.tdp_limit_min = ::std::option::Option::None;
        self.tdp_limit_max = ::std::option::Option::None;
        self.is_nis_supported = ::std::option::Option::None;
        self.nis_sharpness_min = ::std::option::Option::None;
        self.nis_sharpness_max = ::std::option::Option::None;
        self.display_external_refresh_manual_hz_min = ::std::option::Option::None;
        self.display_external_refresh_manual_hz_max = ::std::option::Option::None;
        self.fps_limit_options_external.clear();
        self.is_tearing_supported = ::std::option::Option::None;
        self.is_vrr_supported = ::std::option::Option::None;
        self.is_dynamic_refresh_rate_in_steam_supported = ::std::option::Option::None;
        self.is_split_scaling_and_filtering_supported = ::std::option::Option::None;
        self.split_scaling_filters_available.clear();
        self.split_scaling_scalers_available.clear();
        self.is_hdr_supported = ::std::option::Option::None;
        self.display_refresh_manual_hz_oc_max = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemPerfLimits {
        static instance: CMsgSystemPerfLimits = CMsgSystemPerfLimits {
            cpu_governor_manual_min_mhz: ::std::option::Option::None,
            cpu_governor_manual_max_mhz: ::std::option::Option::None,
            fsr_sharpness_min: ::std::option::Option::None,
            fsr_sharpness_max: ::std::option::Option::None,
            gpu_performance_manual_min_mhz: ::std::option::Option::None,
            gpu_performance_manual_max_mhz: ::std::option::Option::None,
            perf_overlay_is_standalone: ::std::option::Option::None,
            is_dynamic_vrs_available: ::std::option::Option::None,
            is_manual_display_refresh_rate_available: ::std::option::Option::None,
            gpu_performance_levels_available: ::std::vec::Vec::new(),
            display_refresh_manual_hz_min: ::std::option::Option::None,
            display_refresh_manual_hz_max: ::std::option::Option::None,
            fps_limit_options: ::std::vec::Vec::new(),
            tdp_limit_min: ::std::option::Option::None,
            tdp_limit_max: ::std::option::Option::None,
            is_nis_supported: ::std::option::Option::None,
            nis_sharpness_min: ::std::option::Option::None,
            nis_sharpness_max: ::std::option::Option::None,
            display_external_refresh_manual_hz_min: ::std::option::Option::None,
            display_external_refresh_manual_hz_max: ::std::option::Option::None,
            fps_limit_options_external: ::std::vec::Vec::new(),
            is_tearing_supported: ::std::option::Option::None,
            is_vrr_supported: ::std::option::Option::None,
            is_dynamic_refresh_rate_in_steam_supported: ::std::option::Option::None,
            is_split_scaling_and_filtering_supported: ::std::option::Option::None,
            split_scaling_filters_available: ::std::vec::Vec::new(),
            split_scaling_scalers_available: ::std::vec::Vec::new(),
            is_hdr_supported: ::std::option::Option::None,
            display_refresh_manual_hz_oc_max: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSystemPerfSettingsGlobal)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemPerfSettingsGlobal {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsGlobal.diagnostic_update_rate)
    pub diagnostic_update_rate: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsGlobal.system_trace_service_state)
    pub system_trace_service_state: ::std::option::Option<::protobuf::EnumOrUnknown<super::enums::ESystemServiceState>>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsGlobal.graphics_profiling_service_state)
    pub graphics_profiling_service_state: ::std::option::Option<::protobuf::EnumOrUnknown<super::enums::ESystemServiceState>>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsGlobal.perf_overlay_service_state)
    pub perf_overlay_service_state: ::std::option::Option<::protobuf::EnumOrUnknown<super::enums::ESystemServiceState>>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsGlobal.perf_overlay_level)
    pub perf_overlay_level: ::std::option::Option<::protobuf::EnumOrUnknown<super::enums::EGraphicsPerfOverlayLevel>>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsGlobal.is_show_perf_overlay_over_steam_enabled)
    pub is_show_perf_overlay_over_steam_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsGlobal.is_advanced_settings_enabled)
    pub is_advanced_settings_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsGlobal.allow_external_display_refresh_control)
    pub allow_external_display_refresh_control: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsGlobal.is_hdr_enabled)
    pub is_hdr_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsGlobal.hdr_on_sdr_tonemap_operator)
    pub hdr_on_sdr_tonemap_operator: ::std::option::Option<::protobuf::EnumOrUnknown<super::enums::EHDRToneMapOperator>>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsGlobal.is_hdr_debug_heatmap_enabled)
    pub is_hdr_debug_heatmap_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsGlobal.force_hdr_wide_gammut_for_sdr)
    pub force_hdr_wide_gammut_for_sdr: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsGlobal.allow_experimental_hdr)
    pub allow_experimental_hdr: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsGlobal.sdr_to_hdr_brightness)
    pub sdr_to_hdr_brightness: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsGlobal.debug_force_hdr_support)
    pub debug_force_hdr_support: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsGlobal.force_hdr_10pq_output_debug)
    pub force_hdr_10pq_output_debug: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsGlobal.is_display_oc_enabled)
    pub is_display_oc_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsGlobal.is_color_management_enabled)
    pub is_color_management_enabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemPerfSettingsGlobal.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemPerfSettingsGlobal {
    fn default() -> &'a CMsgSystemPerfSettingsGlobal {
        <CMsgSystemPerfSettingsGlobal as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSystemPerfSettingsGlobal {
    pub fn new() -> CMsgSystemPerfSettingsGlobal {
        ::std::default::Default::default()
    }

    // optional float diagnostic_update_rate = 1;

    pub fn diagnostic_update_rate(&self) -> f32 {
        self.diagnostic_update_rate.unwrap_or(0.)
    }

    pub fn clear_diagnostic_update_rate(&mut self) {
        self.diagnostic_update_rate = ::std::option::Option::None;
    }

    pub fn has_diagnostic_update_rate(&self) -> bool {
        self.diagnostic_update_rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_diagnostic_update_rate(&mut self, v: f32) {
        self.diagnostic_update_rate = ::std::option::Option::Some(v);
    }

    // optional .ESystemServiceState system_trace_service_state = 2;

    pub fn system_trace_service_state(&self) -> super::enums::ESystemServiceState {
        match self.system_trace_service_state {
            Some(e) => e.enum_value_or(super::enums::ESystemServiceState::k_ESystemServiceState_Unavailable),
            None => super::enums::ESystemServiceState::k_ESystemServiceState_Unavailable,
        }
    }

    pub fn clear_system_trace_service_state(&mut self) {
        self.system_trace_service_state = ::std::option::Option::None;
    }

    pub fn has_system_trace_service_state(&self) -> bool {
        self.system_trace_service_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_system_trace_service_state(&mut self, v: super::enums::ESystemServiceState) {
        self.system_trace_service_state = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .ESystemServiceState graphics_profiling_service_state = 3;

    pub fn graphics_profiling_service_state(&self) -> super::enums::ESystemServiceState {
        match self.graphics_profiling_service_state {
            Some(e) => e.enum_value_or(super::enums::ESystemServiceState::k_ESystemServiceState_Unavailable),
            None => super::enums::ESystemServiceState::k_ESystemServiceState_Unavailable,
        }
    }

    pub fn clear_graphics_profiling_service_state(&mut self) {
        self.graphics_profiling_service_state = ::std::option::Option::None;
    }

    pub fn has_graphics_profiling_service_state(&self) -> bool {
        self.graphics_profiling_service_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_graphics_profiling_service_state(&mut self, v: super::enums::ESystemServiceState) {
        self.graphics_profiling_service_state = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .ESystemServiceState perf_overlay_service_state = 4;

    pub fn perf_overlay_service_state(&self) -> super::enums::ESystemServiceState {
        match self.perf_overlay_service_state {
            Some(e) => e.enum_value_or(super::enums::ESystemServiceState::k_ESystemServiceState_Unavailable),
            None => super::enums::ESystemServiceState::k_ESystemServiceState_Unavailable,
        }
    }

    pub fn clear_perf_overlay_service_state(&mut self) {
        self.perf_overlay_service_state = ::std::option::Option::None;
    }

    pub fn has_perf_overlay_service_state(&self) -> bool {
        self.perf_overlay_service_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_perf_overlay_service_state(&mut self, v: super::enums::ESystemServiceState) {
        self.perf_overlay_service_state = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .EGraphicsPerfOverlayLevel perf_overlay_level = 5;

    pub fn perf_overlay_level(&self) -> super::enums::EGraphicsPerfOverlayLevel {
        match self.perf_overlay_level {
            Some(e) => e.enum_value_or(super::enums::EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Hidden),
            None => super::enums::EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Hidden,
        }
    }

    pub fn clear_perf_overlay_level(&mut self) {
        self.perf_overlay_level = ::std::option::Option::None;
    }

    pub fn has_perf_overlay_level(&self) -> bool {
        self.perf_overlay_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_perf_overlay_level(&mut self, v: super::enums::EGraphicsPerfOverlayLevel) {
        self.perf_overlay_level = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool is_show_perf_overlay_over_steam_enabled = 6;

    pub fn is_show_perf_overlay_over_steam_enabled(&self) -> bool {
        self.is_show_perf_overlay_over_steam_enabled.unwrap_or(false)
    }

    pub fn clear_is_show_perf_overlay_over_steam_enabled(&mut self) {
        self.is_show_perf_overlay_over_steam_enabled = ::std::option::Option::None;
    }

    pub fn has_is_show_perf_overlay_over_steam_enabled(&self) -> bool {
        self.is_show_perf_overlay_over_steam_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_show_perf_overlay_over_steam_enabled(&mut self, v: bool) {
        self.is_show_perf_overlay_over_steam_enabled = ::std::option::Option::Some(v);
    }

    // optional bool is_advanced_settings_enabled = 7;

    pub fn is_advanced_settings_enabled(&self) -> bool {
        self.is_advanced_settings_enabled.unwrap_or(false)
    }

    pub fn clear_is_advanced_settings_enabled(&mut self) {
        self.is_advanced_settings_enabled = ::std::option::Option::None;
    }

    pub fn has_is_advanced_settings_enabled(&self) -> bool {
        self.is_advanced_settings_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_advanced_settings_enabled(&mut self, v: bool) {
        self.is_advanced_settings_enabled = ::std::option::Option::Some(v);
    }

    // optional bool allow_external_display_refresh_control = 8;

    pub fn allow_external_display_refresh_control(&self) -> bool {
        self.allow_external_display_refresh_control.unwrap_or(false)
    }

    pub fn clear_allow_external_display_refresh_control(&mut self) {
        self.allow_external_display_refresh_control = ::std::option::Option::None;
    }

    pub fn has_allow_external_display_refresh_control(&self) -> bool {
        self.allow_external_display_refresh_control.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_external_display_refresh_control(&mut self, v: bool) {
        self.allow_external_display_refresh_control = ::std::option::Option::Some(v);
    }

    // optional bool is_hdr_enabled = 9;

    pub fn is_hdr_enabled(&self) -> bool {
        self.is_hdr_enabled.unwrap_or(false)
    }

    pub fn clear_is_hdr_enabled(&mut self) {
        self.is_hdr_enabled = ::std::option::Option::None;
    }

    pub fn has_is_hdr_enabled(&self) -> bool {
        self.is_hdr_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_hdr_enabled(&mut self, v: bool) {
        self.is_hdr_enabled = ::std::option::Option::Some(v);
    }

    // optional .EHDRToneMapOperator hdr_on_sdr_tonemap_operator = 12;

    pub fn hdr_on_sdr_tonemap_operator(&self) -> super::enums::EHDRToneMapOperator {
        match self.hdr_on_sdr_tonemap_operator {
            Some(e) => e.enum_value_or(super::enums::EHDRToneMapOperator::k_EHDRToneMapOperator_Invalid),
            None => super::enums::EHDRToneMapOperator::k_EHDRToneMapOperator_Invalid,
        }
    }

    pub fn clear_hdr_on_sdr_tonemap_operator(&mut self) {
        self.hdr_on_sdr_tonemap_operator = ::std::option::Option::None;
    }

    pub fn has_hdr_on_sdr_tonemap_operator(&self) -> bool {
        self.hdr_on_sdr_tonemap_operator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hdr_on_sdr_tonemap_operator(&mut self, v: super::enums::EHDRToneMapOperator) {
        self.hdr_on_sdr_tonemap_operator = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool is_hdr_debug_heatmap_enabled = 13;

    pub fn is_hdr_debug_heatmap_enabled(&self) -> bool {
        self.is_hdr_debug_heatmap_enabled.unwrap_or(false)
    }

    pub fn clear_is_hdr_debug_heatmap_enabled(&mut self) {
        self.is_hdr_debug_heatmap_enabled = ::std::option::Option::None;
    }

    pub fn has_is_hdr_debug_heatmap_enabled(&self) -> bool {
        self.is_hdr_debug_heatmap_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_hdr_debug_heatmap_enabled(&mut self, v: bool) {
        self.is_hdr_debug_heatmap_enabled = ::std::option::Option::Some(v);
    }

    // optional bool force_hdr_wide_gammut_for_sdr = 15;

    pub fn force_hdr_wide_gammut_for_sdr(&self) -> bool {
        self.force_hdr_wide_gammut_for_sdr.unwrap_or(true)
    }

    pub fn clear_force_hdr_wide_gammut_for_sdr(&mut self) {
        self.force_hdr_wide_gammut_for_sdr = ::std::option::Option::None;
    }

    pub fn has_force_hdr_wide_gammut_for_sdr(&self) -> bool {
        self.force_hdr_wide_gammut_for_sdr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force_hdr_wide_gammut_for_sdr(&mut self, v: bool) {
        self.force_hdr_wide_gammut_for_sdr = ::std::option::Option::Some(v);
    }

    // optional bool allow_experimental_hdr = 16;

    pub fn allow_experimental_hdr(&self) -> bool {
        self.allow_experimental_hdr.unwrap_or(false)
    }

    pub fn clear_allow_experimental_hdr(&mut self) {
        self.allow_experimental_hdr = ::std::option::Option::None;
    }

    pub fn has_allow_experimental_hdr(&self) -> bool {
        self.allow_experimental_hdr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_experimental_hdr(&mut self, v: bool) {
        self.allow_experimental_hdr = ::std::option::Option::Some(v);
    }

    // optional float sdr_to_hdr_brightness = 17;

    pub fn sdr_to_hdr_brightness(&self) -> f32 {
        self.sdr_to_hdr_brightness.unwrap_or(0.)
    }

    pub fn clear_sdr_to_hdr_brightness(&mut self) {
        self.sdr_to_hdr_brightness = ::std::option::Option::None;
    }

    pub fn has_sdr_to_hdr_brightness(&self) -> bool {
        self.sdr_to_hdr_brightness.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sdr_to_hdr_brightness(&mut self, v: f32) {
        self.sdr_to_hdr_brightness = ::std::option::Option::Some(v);
    }

    // optional bool debug_force_hdr_support = 18;

    pub fn debug_force_hdr_support(&self) -> bool {
        self.debug_force_hdr_support.unwrap_or(false)
    }

    pub fn clear_debug_force_hdr_support(&mut self) {
        self.debug_force_hdr_support = ::std::option::Option::None;
    }

    pub fn has_debug_force_hdr_support(&self) -> bool {
        self.debug_force_hdr_support.is_some()
    }

    // Param is passed by value, moved
    pub fn set_debug_force_hdr_support(&mut self, v: bool) {
        self.debug_force_hdr_support = ::std::option::Option::Some(v);
    }

    // optional bool force_hdr_10pq_output_debug = 19;

    pub fn force_hdr_10pq_output_debug(&self) -> bool {
        self.force_hdr_10pq_output_debug.unwrap_or(false)
    }

    pub fn clear_force_hdr_10pq_output_debug(&mut self) {
        self.force_hdr_10pq_output_debug = ::std::option::Option::None;
    }

    pub fn has_force_hdr_10pq_output_debug(&self) -> bool {
        self.force_hdr_10pq_output_debug.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force_hdr_10pq_output_debug(&mut self, v: bool) {
        self.force_hdr_10pq_output_debug = ::std::option::Option::Some(v);
    }

    // optional bool is_display_oc_enabled = 20;

    pub fn is_display_oc_enabled(&self) -> bool {
        self.is_display_oc_enabled.unwrap_or(false)
    }

    pub fn clear_is_display_oc_enabled(&mut self) {
        self.is_display_oc_enabled = ::std::option::Option::None;
    }

    pub fn has_is_display_oc_enabled(&self) -> bool {
        self.is_display_oc_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_display_oc_enabled(&mut self, v: bool) {
        self.is_display_oc_enabled = ::std::option::Option::Some(v);
    }

    // optional bool is_color_management_enabled = 21;

    pub fn is_color_management_enabled(&self) -> bool {
        self.is_color_management_enabled.unwrap_or(false)
    }

    pub fn clear_is_color_management_enabled(&mut self) {
        self.is_color_management_enabled = ::std::option::Option::None;
    }

    pub fn has_is_color_management_enabled(&self) -> bool {
        self.is_color_management_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_color_management_enabled(&mut self, v: bool) {
        self.is_color_management_enabled = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSystemPerfSettingsGlobal {
    const NAME: &'static str = "CMsgSystemPerfSettingsGlobal";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.diagnostic_update_rate = ::std::option::Option::Some(is.read_float()?);
                },
                16 => {
                    self.system_trace_service_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.graphics_profiling_service_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.perf_overlay_service_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.perf_overlay_level = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                48 => {
                    self.is_show_perf_overlay_over_steam_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.is_advanced_settings_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.allow_external_display_refresh_control = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.is_hdr_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                96 => {
                    self.hdr_on_sdr_tonemap_operator = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                104 => {
                    self.is_hdr_debug_heatmap_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                120 => {
                    self.force_hdr_wide_gammut_for_sdr = ::std::option::Option::Some(is.read_bool()?);
                },
                128 => {
                    self.allow_experimental_hdr = ::std::option::Option::Some(is.read_bool()?);
                },
                141 => {
                    self.sdr_to_hdr_brightness = ::std::option::Option::Some(is.read_float()?);
                },
                144 => {
                    self.debug_force_hdr_support = ::std::option::Option::Some(is.read_bool()?);
                },
                152 => {
                    self.force_hdr_10pq_output_debug = ::std::option::Option::Some(is.read_bool()?);
                },
                160 => {
                    self.is_display_oc_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                168 => {
                    self.is_color_management_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.diagnostic_update_rate {
            my_size += 1 + 4;
        }
        if let Some(v) = self.system_trace_service_state {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.graphics_profiling_service_state {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.perf_overlay_service_state {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.perf_overlay_level {
            my_size += ::protobuf::rt::int32_size(5, v.value());
        }
        if let Some(v) = self.is_show_perf_overlay_over_steam_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_advanced_settings_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.allow_external_display_refresh_control {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_hdr_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.hdr_on_sdr_tonemap_operator {
            my_size += ::protobuf::rt::int32_size(12, v.value());
        }
        if let Some(v) = self.is_hdr_debug_heatmap_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.force_hdr_wide_gammut_for_sdr {
            my_size += 1 + 1;
        }
        if let Some(v) = self.allow_experimental_hdr {
            my_size += 2 + 1;
        }
        if let Some(v) = self.sdr_to_hdr_brightness {
            my_size += 2 + 4;
        }
        if let Some(v) = self.debug_force_hdr_support {
            my_size += 2 + 1;
        }
        if let Some(v) = self.force_hdr_10pq_output_debug {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_display_oc_enabled {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_color_management_enabled {
            my_size += 2 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.diagnostic_update_rate {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.system_trace_service_state {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.graphics_profiling_service_state {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.perf_overlay_service_state {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.perf_overlay_level {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.is_show_perf_overlay_over_steam_enabled {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.is_advanced_settings_enabled {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.allow_external_display_refresh_control {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.is_hdr_enabled {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.hdr_on_sdr_tonemap_operator {
            os.write_enum(12, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.is_hdr_debug_heatmap_enabled {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.force_hdr_wide_gammut_for_sdr {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.allow_experimental_hdr {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.sdr_to_hdr_brightness {
            os.write_float(17, v)?;
        }
        if let Some(v) = self.debug_force_hdr_support {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.force_hdr_10pq_output_debug {
            os.write_bool(19, v)?;
        }
        if let Some(v) = self.is_display_oc_enabled {
            os.write_bool(20, v)?;
        }
        if let Some(v) = self.is_color_management_enabled {
            os.write_bool(21, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemPerfSettingsGlobal {
        CMsgSystemPerfSettingsGlobal::new()
    }

    fn clear(&mut self) {
        self.diagnostic_update_rate = ::std::option::Option::None;
        self.system_trace_service_state = ::std::option::Option::None;
        self.graphics_profiling_service_state = ::std::option::Option::None;
        self.perf_overlay_service_state = ::std::option::Option::None;
        self.perf_overlay_level = ::std::option::Option::None;
        self.is_show_perf_overlay_over_steam_enabled = ::std::option::Option::None;
        self.is_advanced_settings_enabled = ::std::option::Option::None;
        self.allow_external_display_refresh_control = ::std::option::Option::None;
        self.is_hdr_enabled = ::std::option::Option::None;
        self.hdr_on_sdr_tonemap_operator = ::std::option::Option::None;
        self.is_hdr_debug_heatmap_enabled = ::std::option::Option::None;
        self.force_hdr_wide_gammut_for_sdr = ::std::option::Option::None;
        self.allow_experimental_hdr = ::std::option::Option::None;
        self.sdr_to_hdr_brightness = ::std::option::Option::None;
        self.debug_force_hdr_support = ::std::option::Option::None;
        self.force_hdr_10pq_output_debug = ::std::option::Option::None;
        self.is_display_oc_enabled = ::std::option::Option::None;
        self.is_color_management_enabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemPerfSettingsGlobal {
        static instance: CMsgSystemPerfSettingsGlobal = CMsgSystemPerfSettingsGlobal {
            diagnostic_update_rate: ::std::option::Option::None,
            system_trace_service_state: ::std::option::Option::None,
            graphics_profiling_service_state: ::std::option::Option::None,
            perf_overlay_service_state: ::std::option::Option::None,
            perf_overlay_level: ::std::option::Option::None,
            is_show_perf_overlay_over_steam_enabled: ::std::option::Option::None,
            is_advanced_settings_enabled: ::std::option::Option::None,
            allow_external_display_refresh_control: ::std::option::Option::None,
            is_hdr_enabled: ::std::option::Option::None,
            hdr_on_sdr_tonemap_operator: ::std::option::Option::None,
            is_hdr_debug_heatmap_enabled: ::std::option::Option::None,
            force_hdr_wide_gammut_for_sdr: ::std::option::Option::None,
            allow_experimental_hdr: ::std::option::Option::None,
            sdr_to_hdr_brightness: ::std::option::Option::None,
            debug_force_hdr_support: ::std::option::Option::None,
            force_hdr_10pq_output_debug: ::std::option::Option::None,
            is_display_oc_enabled: ::std::option::Option::None,
            is_color_management_enabled: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSystemPerfSettingsPerApp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemPerfSettingsPerApp {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.gpu_performance_manual_mhz)
    pub gpu_performance_manual_mhz: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.fps_limit)
    pub fps_limit: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.is_variable_resolution_enabled)
    pub is_variable_resolution_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.is_dynamic_refresh_rate_enabled)
    pub is_dynamic_refresh_rate_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.tdp_limit)
    pub tdp_limit: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.cpu_governor)
    pub cpu_governor: ::std::option::Option<::protobuf::EnumOrUnknown<super::enums::ECPUGovernor>>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.cpu_governor_manual_mhz)
    pub cpu_governor_manual_mhz: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.scaling_filter)
    pub scaling_filter: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.fsr_sharpness)
    pub fsr_sharpness: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.is_fps_limit_enabled)
    pub is_fps_limit_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.is_tdp_limit_enabled)
    pub is_tdp_limit_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.is_low_latency_mode_enabled)
    pub is_low_latency_mode_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.display_refresh_manual_hz)
    pub display_refresh_manual_hz: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.is_game_perf_profile_enabled)
    pub is_game_perf_profile_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.gpu_performance_level)
    pub gpu_performance_level: ::std::option::Option<::protobuf::EnumOrUnknown<super::enums::EGPUPerformanceLevel>>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.nis_sharpness)
    pub nis_sharpness: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.display_external_refresh_manual_hz)
    pub display_external_refresh_manual_hz: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.fps_limit_external)
    pub fps_limit_external: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.is_tearing_enabled)
    pub is_tearing_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.is_vrr_enabled)
    pub is_vrr_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.is_composite_debug_enabled)
    pub is_composite_debug_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.force_composite)
    pub force_composite: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.use_dynamic_refresh_rate_in_steam)
    pub use_dynamic_refresh_rate_in_steam: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.split_scaling_filter)
    pub split_scaling_filter: ::std::option::Option<::protobuf::EnumOrUnknown<super::enums::ESplitScalingFilter>>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsPerApp.split_scaling_scaler)
    pub split_scaling_scaler: ::std::option::Option<::protobuf::EnumOrUnknown<super::enums::ESplitScalingScaler>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemPerfSettingsPerApp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemPerfSettingsPerApp {
    fn default() -> &'a CMsgSystemPerfSettingsPerApp {
        <CMsgSystemPerfSettingsPerApp as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSystemPerfSettingsPerApp {
    pub fn new() -> CMsgSystemPerfSettingsPerApp {
        ::std::default::Default::default()
    }

    // optional int32 gpu_performance_manual_mhz = 1;

    pub fn gpu_performance_manual_mhz(&self) -> i32 {
        self.gpu_performance_manual_mhz.unwrap_or(0)
    }

    pub fn clear_gpu_performance_manual_mhz(&mut self) {
        self.gpu_performance_manual_mhz = ::std::option::Option::None;
    }

    pub fn has_gpu_performance_manual_mhz(&self) -> bool {
        self.gpu_performance_manual_mhz.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gpu_performance_manual_mhz(&mut self, v: i32) {
        self.gpu_performance_manual_mhz = ::std::option::Option::Some(v);
    }

    // optional int32 fps_limit = 2;

    pub fn fps_limit(&self) -> i32 {
        self.fps_limit.unwrap_or(0)
    }

    pub fn clear_fps_limit(&mut self) {
        self.fps_limit = ::std::option::Option::None;
    }

    pub fn has_fps_limit(&self) -> bool {
        self.fps_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fps_limit(&mut self, v: i32) {
        self.fps_limit = ::std::option::Option::Some(v);
    }

    // optional bool is_variable_resolution_enabled = 3;

    pub fn is_variable_resolution_enabled(&self) -> bool {
        self.is_variable_resolution_enabled.unwrap_or(false)
    }

    pub fn clear_is_variable_resolution_enabled(&mut self) {
        self.is_variable_resolution_enabled = ::std::option::Option::None;
    }

    pub fn has_is_variable_resolution_enabled(&self) -> bool {
        self.is_variable_resolution_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_variable_resolution_enabled(&mut self, v: bool) {
        self.is_variable_resolution_enabled = ::std::option::Option::Some(v);
    }

    // optional bool is_dynamic_refresh_rate_enabled = 4;

    pub fn is_dynamic_refresh_rate_enabled(&self) -> bool {
        self.is_dynamic_refresh_rate_enabled.unwrap_or(false)
    }

    pub fn clear_is_dynamic_refresh_rate_enabled(&mut self) {
        self.is_dynamic_refresh_rate_enabled = ::std::option::Option::None;
    }

    pub fn has_is_dynamic_refresh_rate_enabled(&self) -> bool {
        self.is_dynamic_refresh_rate_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_dynamic_refresh_rate_enabled(&mut self, v: bool) {
        self.is_dynamic_refresh_rate_enabled = ::std::option::Option::Some(v);
    }

    // optional int32 tdp_limit = 5;

    pub fn tdp_limit(&self) -> i32 {
        self.tdp_limit.unwrap_or(0)
    }

    pub fn clear_tdp_limit(&mut self) {
        self.tdp_limit = ::std::option::Option::None;
    }

    pub fn has_tdp_limit(&self) -> bool {
        self.tdp_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tdp_limit(&mut self, v: i32) {
        self.tdp_limit = ::std::option::Option::Some(v);
    }

    // optional .ECPUGovernor cpu_governor = 6;

    pub fn cpu_governor(&self) -> super::enums::ECPUGovernor {
        match self.cpu_governor {
            Some(e) => e.enum_value_or(super::enums::ECPUGovernor::k_ECPUGovernor_Invalid),
            None => super::enums::ECPUGovernor::k_ECPUGovernor_Invalid,
        }
    }

    pub fn clear_cpu_governor(&mut self) {
        self.cpu_governor = ::std::option::Option::None;
    }

    pub fn has_cpu_governor(&self) -> bool {
        self.cpu_governor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_governor(&mut self, v: super::enums::ECPUGovernor) {
        self.cpu_governor = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 cpu_governor_manual_mhz = 7;

    pub fn cpu_governor_manual_mhz(&self) -> i32 {
        self.cpu_governor_manual_mhz.unwrap_or(0)
    }

    pub fn clear_cpu_governor_manual_mhz(&mut self) {
        self.cpu_governor_manual_mhz = ::std::option::Option::None;
    }

    pub fn has_cpu_governor_manual_mhz(&self) -> bool {
        self.cpu_governor_manual_mhz.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_governor_manual_mhz(&mut self, v: i32) {
        self.cpu_governor_manual_mhz = ::std::option::Option::Some(v);
    }

    // optional int32 scaling_filter = 8;

    pub fn scaling_filter(&self) -> i32 {
        self.scaling_filter.unwrap_or(0)
    }

    pub fn clear_scaling_filter(&mut self) {
        self.scaling_filter = ::std::option::Option::None;
    }

    pub fn has_scaling_filter(&self) -> bool {
        self.scaling_filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scaling_filter(&mut self, v: i32) {
        self.scaling_filter = ::std::option::Option::Some(v);
    }

    // optional int32 fsr_sharpness = 9;

    pub fn fsr_sharpness(&self) -> i32 {
        self.fsr_sharpness.unwrap_or(0)
    }

    pub fn clear_fsr_sharpness(&mut self) {
        self.fsr_sharpness = ::std::option::Option::None;
    }

    pub fn has_fsr_sharpness(&self) -> bool {
        self.fsr_sharpness.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsr_sharpness(&mut self, v: i32) {
        self.fsr_sharpness = ::std::option::Option::Some(v);
    }

    // optional bool is_fps_limit_enabled = 10;

    pub fn is_fps_limit_enabled(&self) -> bool {
        self.is_fps_limit_enabled.unwrap_or(false)
    }

    pub fn clear_is_fps_limit_enabled(&mut self) {
        self.is_fps_limit_enabled = ::std::option::Option::None;
    }

    pub fn has_is_fps_limit_enabled(&self) -> bool {
        self.is_fps_limit_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_fps_limit_enabled(&mut self, v: bool) {
        self.is_fps_limit_enabled = ::std::option::Option::Some(v);
    }

    // optional bool is_tdp_limit_enabled = 11;

    pub fn is_tdp_limit_enabled(&self) -> bool {
        self.is_tdp_limit_enabled.unwrap_or(false)
    }

    pub fn clear_is_tdp_limit_enabled(&mut self) {
        self.is_tdp_limit_enabled = ::std::option::Option::None;
    }

    pub fn has_is_tdp_limit_enabled(&self) -> bool {
        self.is_tdp_limit_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_tdp_limit_enabled(&mut self, v: bool) {
        self.is_tdp_limit_enabled = ::std::option::Option::Some(v);
    }

    // optional bool is_low_latency_mode_enabled = 12;

    pub fn is_low_latency_mode_enabled(&self) -> bool {
        self.is_low_latency_mode_enabled.unwrap_or(false)
    }

    pub fn clear_is_low_latency_mode_enabled(&mut self) {
        self.is_low_latency_mode_enabled = ::std::option::Option::None;
    }

    pub fn has_is_low_latency_mode_enabled(&self) -> bool {
        self.is_low_latency_mode_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_low_latency_mode_enabled(&mut self, v: bool) {
        self.is_low_latency_mode_enabled = ::std::option::Option::Some(v);
    }

    // optional int32 display_refresh_manual_hz = 13;

    pub fn display_refresh_manual_hz(&self) -> i32 {
        self.display_refresh_manual_hz.unwrap_or(0)
    }

    pub fn clear_display_refresh_manual_hz(&mut self) {
        self.display_refresh_manual_hz = ::std::option::Option::None;
    }

    pub fn has_display_refresh_manual_hz(&self) -> bool {
        self.display_refresh_manual_hz.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_refresh_manual_hz(&mut self, v: i32) {
        self.display_refresh_manual_hz = ::std::option::Option::Some(v);
    }

    // optional bool is_game_perf_profile_enabled = 14;

    pub fn is_game_perf_profile_enabled(&self) -> bool {
        self.is_game_perf_profile_enabled.unwrap_or(false)
    }

    pub fn clear_is_game_perf_profile_enabled(&mut self) {
        self.is_game_perf_profile_enabled = ::std::option::Option::None;
    }

    pub fn has_is_game_perf_profile_enabled(&self) -> bool {
        self.is_game_perf_profile_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_game_perf_profile_enabled(&mut self, v: bool) {
        self.is_game_perf_profile_enabled = ::std::option::Option::Some(v);
    }

    // optional .EGPUPerformanceLevel gpu_performance_level = 15;

    pub fn gpu_performance_level(&self) -> super::enums::EGPUPerformanceLevel {
        match self.gpu_performance_level {
            Some(e) => e.enum_value_or(super::enums::EGPUPerformanceLevel::k_EGPUPerformanceLevel_Invalid),
            None => super::enums::EGPUPerformanceLevel::k_EGPUPerformanceLevel_Invalid,
        }
    }

    pub fn clear_gpu_performance_level(&mut self) {
        self.gpu_performance_level = ::std::option::Option::None;
    }

    pub fn has_gpu_performance_level(&self) -> bool {
        self.gpu_performance_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gpu_performance_level(&mut self, v: super::enums::EGPUPerformanceLevel) {
        self.gpu_performance_level = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 nis_sharpness = 16;

    pub fn nis_sharpness(&self) -> i32 {
        self.nis_sharpness.unwrap_or(0)
    }

    pub fn clear_nis_sharpness(&mut self) {
        self.nis_sharpness = ::std::option::Option::None;
    }

    pub fn has_nis_sharpness(&self) -> bool {
        self.nis_sharpness.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nis_sharpness(&mut self, v: i32) {
        self.nis_sharpness = ::std::option::Option::Some(v);
    }

    // optional int32 display_external_refresh_manual_hz = 17;

    pub fn display_external_refresh_manual_hz(&self) -> i32 {
        self.display_external_refresh_manual_hz.unwrap_or(0)
    }

    pub fn clear_display_external_refresh_manual_hz(&mut self) {
        self.display_external_refresh_manual_hz = ::std::option::Option::None;
    }

    pub fn has_display_external_refresh_manual_hz(&self) -> bool {
        self.display_external_refresh_manual_hz.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_external_refresh_manual_hz(&mut self, v: i32) {
        self.display_external_refresh_manual_hz = ::std::option::Option::Some(v);
    }

    // optional int32 fps_limit_external = 18;

    pub fn fps_limit_external(&self) -> i32 {
        self.fps_limit_external.unwrap_or(0)
    }

    pub fn clear_fps_limit_external(&mut self) {
        self.fps_limit_external = ::std::option::Option::None;
    }

    pub fn has_fps_limit_external(&self) -> bool {
        self.fps_limit_external.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fps_limit_external(&mut self, v: i32) {
        self.fps_limit_external = ::std::option::Option::Some(v);
    }

    // optional bool is_tearing_enabled = 19;

    pub fn is_tearing_enabled(&self) -> bool {
        self.is_tearing_enabled.unwrap_or(false)
    }

    pub fn clear_is_tearing_enabled(&mut self) {
        self.is_tearing_enabled = ::std::option::Option::None;
    }

    pub fn has_is_tearing_enabled(&self) -> bool {
        self.is_tearing_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_tearing_enabled(&mut self, v: bool) {
        self.is_tearing_enabled = ::std::option::Option::Some(v);
    }

    // optional bool is_vrr_enabled = 20;

    pub fn is_vrr_enabled(&self) -> bool {
        self.is_vrr_enabled.unwrap_or(false)
    }

    pub fn clear_is_vrr_enabled(&mut self) {
        self.is_vrr_enabled = ::std::option::Option::None;
    }

    pub fn has_is_vrr_enabled(&self) -> bool {
        self.is_vrr_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_vrr_enabled(&mut self, v: bool) {
        self.is_vrr_enabled = ::std::option::Option::Some(v);
    }

    // optional bool is_composite_debug_enabled = 21;

    pub fn is_composite_debug_enabled(&self) -> bool {
        self.is_composite_debug_enabled.unwrap_or(false)
    }

    pub fn clear_is_composite_debug_enabled(&mut self) {
        self.is_composite_debug_enabled = ::std::option::Option::None;
    }

    pub fn has_is_composite_debug_enabled(&self) -> bool {
        self.is_composite_debug_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_composite_debug_enabled(&mut self, v: bool) {
        self.is_composite_debug_enabled = ::std::option::Option::Some(v);
    }

    // optional bool force_composite = 22;

    pub fn force_composite(&self) -> bool {
        self.force_composite.unwrap_or(false)
    }

    pub fn clear_force_composite(&mut self) {
        self.force_composite = ::std::option::Option::None;
    }

    pub fn has_force_composite(&self) -> bool {
        self.force_composite.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force_composite(&mut self, v: bool) {
        self.force_composite = ::std::option::Option::Some(v);
    }

    // optional bool use_dynamic_refresh_rate_in_steam = 23;

    pub fn use_dynamic_refresh_rate_in_steam(&self) -> bool {
        self.use_dynamic_refresh_rate_in_steam.unwrap_or(false)
    }

    pub fn clear_use_dynamic_refresh_rate_in_steam(&mut self) {
        self.use_dynamic_refresh_rate_in_steam = ::std::option::Option::None;
    }

    pub fn has_use_dynamic_refresh_rate_in_steam(&self) -> bool {
        self.use_dynamic_refresh_rate_in_steam.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_dynamic_refresh_rate_in_steam(&mut self, v: bool) {
        self.use_dynamic_refresh_rate_in_steam = ::std::option::Option::Some(v);
    }

    // optional .ESplitScalingFilter split_scaling_filter = 24;

    pub fn split_scaling_filter(&self) -> super::enums::ESplitScalingFilter {
        match self.split_scaling_filter {
            Some(e) => e.enum_value_or(super::enums::ESplitScalingFilter::k_ESplitScalingFilter_Invalid),
            None => super::enums::ESplitScalingFilter::k_ESplitScalingFilter_Invalid,
        }
    }

    pub fn clear_split_scaling_filter(&mut self) {
        self.split_scaling_filter = ::std::option::Option::None;
    }

    pub fn has_split_scaling_filter(&self) -> bool {
        self.split_scaling_filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_split_scaling_filter(&mut self, v: super::enums::ESplitScalingFilter) {
        self.split_scaling_filter = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .ESplitScalingScaler split_scaling_scaler = 25;

    pub fn split_scaling_scaler(&self) -> super::enums::ESplitScalingScaler {
        match self.split_scaling_scaler {
            Some(e) => e.enum_value_or(super::enums::ESplitScalingScaler::k_ESplitScalingScaler_Invalid),
            None => super::enums::ESplitScalingScaler::k_ESplitScalingScaler_Invalid,
        }
    }

    pub fn clear_split_scaling_scaler(&mut self) {
        self.split_scaling_scaler = ::std::option::Option::None;
    }

    pub fn has_split_scaling_scaler(&self) -> bool {
        self.split_scaling_scaler.is_some()
    }

    // Param is passed by value, moved
    pub fn set_split_scaling_scaler(&mut self, v: super::enums::ESplitScalingScaler) {
        self.split_scaling_scaler = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::protobuf::Message for CMsgSystemPerfSettingsPerApp {
    const NAME: &'static str = "CMsgSystemPerfSettingsPerApp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.gpu_performance_manual_mhz = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.fps_limit = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.is_variable_resolution_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.is_dynamic_refresh_rate_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.tdp_limit = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.cpu_governor = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                56 => {
                    self.cpu_governor_manual_mhz = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.scaling_filter = ::std::option::Option::Some(is.read_int32()?);
                },
                72 => {
                    self.fsr_sharpness = ::std::option::Option::Some(is.read_int32()?);
                },
                80 => {
                    self.is_fps_limit_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.is_tdp_limit_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                96 => {
                    self.is_low_latency_mode_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.display_refresh_manual_hz = ::std::option::Option::Some(is.read_int32()?);
                },
                112 => {
                    self.is_game_perf_profile_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                120 => {
                    self.gpu_performance_level = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                128 => {
                    self.nis_sharpness = ::std::option::Option::Some(is.read_int32()?);
                },
                136 => {
                    self.display_external_refresh_manual_hz = ::std::option::Option::Some(is.read_int32()?);
                },
                144 => {
                    self.fps_limit_external = ::std::option::Option::Some(is.read_int32()?);
                },
                152 => {
                    self.is_tearing_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                160 => {
                    self.is_vrr_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                168 => {
                    self.is_composite_debug_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                176 => {
                    self.force_composite = ::std::option::Option::Some(is.read_bool()?);
                },
                184 => {
                    self.use_dynamic_refresh_rate_in_steam = ::std::option::Option::Some(is.read_bool()?);
                },
                192 => {
                    self.split_scaling_filter = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                200 => {
                    self.split_scaling_scaler = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gpu_performance_manual_mhz {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.fps_limit {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.is_variable_resolution_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_dynamic_refresh_rate_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.tdp_limit {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.cpu_governor {
            my_size += ::protobuf::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.cpu_governor_manual_mhz {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.scaling_filter {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.fsr_sharpness {
            my_size += ::protobuf::rt::int32_size(9, v);
        }
        if let Some(v) = self.is_fps_limit_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_tdp_limit_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_low_latency_mode_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.display_refresh_manual_hz {
            my_size += ::protobuf::rt::int32_size(13, v);
        }
        if let Some(v) = self.is_game_perf_profile_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.gpu_performance_level {
            my_size += ::protobuf::rt::int32_size(15, v.value());
        }
        if let Some(v) = self.nis_sharpness {
            my_size += ::protobuf::rt::int32_size(16, v);
        }
        if let Some(v) = self.display_external_refresh_manual_hz {
            my_size += ::protobuf::rt::int32_size(17, v);
        }
        if let Some(v) = self.fps_limit_external {
            my_size += ::protobuf::rt::int32_size(18, v);
        }
        if let Some(v) = self.is_tearing_enabled {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_vrr_enabled {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_composite_debug_enabled {
            my_size += 2 + 1;
        }
        if let Some(v) = self.force_composite {
            my_size += 2 + 1;
        }
        if let Some(v) = self.use_dynamic_refresh_rate_in_steam {
            my_size += 2 + 1;
        }
        if let Some(v) = self.split_scaling_filter {
            my_size += ::protobuf::rt::int32_size(24, v.value());
        }
        if let Some(v) = self.split_scaling_scaler {
            my_size += ::protobuf::rt::int32_size(25, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.gpu_performance_manual_mhz {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.fps_limit {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.is_variable_resolution_enabled {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.is_dynamic_refresh_rate_enabled {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.tdp_limit {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.cpu_governor {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.cpu_governor_manual_mhz {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.scaling_filter {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.fsr_sharpness {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.is_fps_limit_enabled {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.is_tdp_limit_enabled {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.is_low_latency_mode_enabled {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.display_refresh_manual_hz {
            os.write_int32(13, v)?;
        }
        if let Some(v) = self.is_game_perf_profile_enabled {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.gpu_performance_level {
            os.write_enum(15, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.nis_sharpness {
            os.write_int32(16, v)?;
        }
        if let Some(v) = self.display_external_refresh_manual_hz {
            os.write_int32(17, v)?;
        }
        if let Some(v) = self.fps_limit_external {
            os.write_int32(18, v)?;
        }
        if let Some(v) = self.is_tearing_enabled {
            os.write_bool(19, v)?;
        }
        if let Some(v) = self.is_vrr_enabled {
            os.write_bool(20, v)?;
        }
        if let Some(v) = self.is_composite_debug_enabled {
            os.write_bool(21, v)?;
        }
        if let Some(v) = self.force_composite {
            os.write_bool(22, v)?;
        }
        if let Some(v) = self.use_dynamic_refresh_rate_in_steam {
            os.write_bool(23, v)?;
        }
        if let Some(v) = self.split_scaling_filter {
            os.write_enum(24, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.split_scaling_scaler {
            os.write_enum(25, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemPerfSettingsPerApp {
        CMsgSystemPerfSettingsPerApp::new()
    }

    fn clear(&mut self) {
        self.gpu_performance_manual_mhz = ::std::option::Option::None;
        self.fps_limit = ::std::option::Option::None;
        self.is_variable_resolution_enabled = ::std::option::Option::None;
        self.is_dynamic_refresh_rate_enabled = ::std::option::Option::None;
        self.tdp_limit = ::std::option::Option::None;
        self.cpu_governor = ::std::option::Option::None;
        self.cpu_governor_manual_mhz = ::std::option::Option::None;
        self.scaling_filter = ::std::option::Option::None;
        self.fsr_sharpness = ::std::option::Option::None;
        self.is_fps_limit_enabled = ::std::option::Option::None;
        self.is_tdp_limit_enabled = ::std::option::Option::None;
        self.is_low_latency_mode_enabled = ::std::option::Option::None;
        self.display_refresh_manual_hz = ::std::option::Option::None;
        self.is_game_perf_profile_enabled = ::std::option::Option::None;
        self.gpu_performance_level = ::std::option::Option::None;
        self.nis_sharpness = ::std::option::Option::None;
        self.display_external_refresh_manual_hz = ::std::option::Option::None;
        self.fps_limit_external = ::std::option::Option::None;
        self.is_tearing_enabled = ::std::option::Option::None;
        self.is_vrr_enabled = ::std::option::Option::None;
        self.is_composite_debug_enabled = ::std::option::Option::None;
        self.force_composite = ::std::option::Option::None;
        self.use_dynamic_refresh_rate_in_steam = ::std::option::Option::None;
        self.split_scaling_filter = ::std::option::Option::None;
        self.split_scaling_scaler = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemPerfSettingsPerApp {
        static instance: CMsgSystemPerfSettingsPerApp = CMsgSystemPerfSettingsPerApp {
            gpu_performance_manual_mhz: ::std::option::Option::None,
            fps_limit: ::std::option::Option::None,
            is_variable_resolution_enabled: ::std::option::Option::None,
            is_dynamic_refresh_rate_enabled: ::std::option::Option::None,
            tdp_limit: ::std::option::Option::None,
            cpu_governor: ::std::option::Option::None,
            cpu_governor_manual_mhz: ::std::option::Option::None,
            scaling_filter: ::std::option::Option::None,
            fsr_sharpness: ::std::option::Option::None,
            is_fps_limit_enabled: ::std::option::Option::None,
            is_tdp_limit_enabled: ::std::option::Option::None,
            is_low_latency_mode_enabled: ::std::option::Option::None,
            display_refresh_manual_hz: ::std::option::Option::None,
            is_game_perf_profile_enabled: ::std::option::Option::None,
            gpu_performance_level: ::std::option::Option::None,
            nis_sharpness: ::std::option::Option::None,
            display_external_refresh_manual_hz: ::std::option::Option::None,
            fps_limit_external: ::std::option::Option::None,
            is_tearing_enabled: ::std::option::Option::None,
            is_vrr_enabled: ::std::option::Option::None,
            is_composite_debug_enabled: ::std::option::Option::None,
            force_composite: ::std::option::Option::None,
            use_dynamic_refresh_rate_in_steam: ::std::option::Option::None,
            split_scaling_filter: ::std::option::Option::None,
            split_scaling_scaler: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSystemPerfSettings)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemPerfSettings {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemPerfSettings.global)
    pub global: ::protobuf::MessageField<CMsgSystemPerfSettingsGlobal>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettings.per_app)
    pub per_app: ::protobuf::MessageField<CMsgSystemPerfSettingsPerApp>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemPerfSettings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemPerfSettings {
    fn default() -> &'a CMsgSystemPerfSettings {
        <CMsgSystemPerfSettings as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSystemPerfSettings {
    pub fn new() -> CMsgSystemPerfSettings {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgSystemPerfSettings {
    const NAME: &'static str = "CMsgSystemPerfSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.global)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.per_app)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.global.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.per_app.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.global.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.per_app.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemPerfSettings {
        CMsgSystemPerfSettings::new()
    }

    fn clear(&mut self) {
        self.global.clear();
        self.per_app.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemPerfSettings {
        static instance: CMsgSystemPerfSettings = CMsgSystemPerfSettings {
            global: ::protobuf::MessageField::none(),
            per_app: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSystemPerfSettingsV1)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemPerfSettingsV1 {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsV1.diagnostic_update_rate)
    pub diagnostic_update_rate: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsV1.system_trace_service_state)
    pub system_trace_service_state: ::std::option::Option<::protobuf::EnumOrUnknown<super::enums::ESystemServiceState>>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsV1.graphics_profiling_service_state)
    pub graphics_profiling_service_state: ::std::option::Option<::protobuf::EnumOrUnknown<super::enums::ESystemServiceState>>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsV1.perf_overlay_service_state)
    pub perf_overlay_service_state: ::std::option::Option<::protobuf::EnumOrUnknown<super::enums::ESystemServiceState>>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsV1.perf_overlay_level)
    pub perf_overlay_level: ::std::option::Option<::protobuf::EnumOrUnknown<super::enums::EGraphicsPerfOverlayLevel>>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsV1.gpu_performance_level)
    pub gpu_performance_level: ::std::option::Option<::protobuf::EnumOrUnknown<super::enums::EGPUPerformanceLevel>>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsV1.gpu_performance_manual_mhz)
    pub gpu_performance_manual_mhz: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsV1.fps_limit)
    pub fps_limit: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsV1.is_variable_resolution_enabled)
    pub is_variable_resolution_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsV1.is_dynamic_refresh_rate_enabled)
    pub is_dynamic_refresh_rate_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsV1.tdp_limit)
    pub tdp_limit: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsV1.cpu_governor)
    pub cpu_governor: ::std::option::Option<::protobuf::EnumOrUnknown<super::enums::ECPUGovernor>>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsV1.cpu_governor_manual_mhz)
    pub cpu_governor_manual_mhz: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsV1.scaling_filter)
    pub scaling_filter: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsV1.fsr_sharpness)
    pub fsr_sharpness: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsV1.is_fps_limit_enabled)
    pub is_fps_limit_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsV1.is_tdp_limit_enabled)
    pub is_tdp_limit_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsV1.is_show_perf_overlay_over_steam_enabled)
    pub is_show_perf_overlay_over_steam_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsV1.is_low_latency_mode_enabled)
    pub is_low_latency_mode_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsV1.display_refresh_manual_hz)
    pub display_refresh_manual_hz: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemPerfSettingsV1.is_game_perf_profile_enabled)
    pub is_game_perf_profile_enabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemPerfSettingsV1.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemPerfSettingsV1 {
    fn default() -> &'a CMsgSystemPerfSettingsV1 {
        <CMsgSystemPerfSettingsV1 as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSystemPerfSettingsV1 {
    pub fn new() -> CMsgSystemPerfSettingsV1 {
        ::std::default::Default::default()
    }

    // optional float diagnostic_update_rate = 1;

    pub fn diagnostic_update_rate(&self) -> f32 {
        self.diagnostic_update_rate.unwrap_or(0.)
    }

    pub fn clear_diagnostic_update_rate(&mut self) {
        self.diagnostic_update_rate = ::std::option::Option::None;
    }

    pub fn has_diagnostic_update_rate(&self) -> bool {
        self.diagnostic_update_rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_diagnostic_update_rate(&mut self, v: f32) {
        self.diagnostic_update_rate = ::std::option::Option::Some(v);
    }

    // optional .ESystemServiceState system_trace_service_state = 2;

    pub fn system_trace_service_state(&self) -> super::enums::ESystemServiceState {
        match self.system_trace_service_state {
            Some(e) => e.enum_value_or(super::enums::ESystemServiceState::k_ESystemServiceState_Unavailable),
            None => super::enums::ESystemServiceState::k_ESystemServiceState_Unavailable,
        }
    }

    pub fn clear_system_trace_service_state(&mut self) {
        self.system_trace_service_state = ::std::option::Option::None;
    }

    pub fn has_system_trace_service_state(&self) -> bool {
        self.system_trace_service_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_system_trace_service_state(&mut self, v: super::enums::ESystemServiceState) {
        self.system_trace_service_state = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .ESystemServiceState graphics_profiling_service_state = 3;

    pub fn graphics_profiling_service_state(&self) -> super::enums::ESystemServiceState {
        match self.graphics_profiling_service_state {
            Some(e) => e.enum_value_or(super::enums::ESystemServiceState::k_ESystemServiceState_Unavailable),
            None => super::enums::ESystemServiceState::k_ESystemServiceState_Unavailable,
        }
    }

    pub fn clear_graphics_profiling_service_state(&mut self) {
        self.graphics_profiling_service_state = ::std::option::Option::None;
    }

    pub fn has_graphics_profiling_service_state(&self) -> bool {
        self.graphics_profiling_service_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_graphics_profiling_service_state(&mut self, v: super::enums::ESystemServiceState) {
        self.graphics_profiling_service_state = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .ESystemServiceState perf_overlay_service_state = 4;

    pub fn perf_overlay_service_state(&self) -> super::enums::ESystemServiceState {
        match self.perf_overlay_service_state {
            Some(e) => e.enum_value_or(super::enums::ESystemServiceState::k_ESystemServiceState_Unavailable),
            None => super::enums::ESystemServiceState::k_ESystemServiceState_Unavailable,
        }
    }

    pub fn clear_perf_overlay_service_state(&mut self) {
        self.perf_overlay_service_state = ::std::option::Option::None;
    }

    pub fn has_perf_overlay_service_state(&self) -> bool {
        self.perf_overlay_service_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_perf_overlay_service_state(&mut self, v: super::enums::ESystemServiceState) {
        self.perf_overlay_service_state = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .EGraphicsPerfOverlayLevel perf_overlay_level = 5;

    pub fn perf_overlay_level(&self) -> super::enums::EGraphicsPerfOverlayLevel {
        match self.perf_overlay_level {
            Some(e) => e.enum_value_or(super::enums::EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Hidden),
            None => super::enums::EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Hidden,
        }
    }

    pub fn clear_perf_overlay_level(&mut self) {
        self.perf_overlay_level = ::std::option::Option::None;
    }

    pub fn has_perf_overlay_level(&self) -> bool {
        self.perf_overlay_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_perf_overlay_level(&mut self, v: super::enums::EGraphicsPerfOverlayLevel) {
        self.perf_overlay_level = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .EGPUPerformanceLevel gpu_performance_level = 6;

    pub fn gpu_performance_level(&self) -> super::enums::EGPUPerformanceLevel {
        match self.gpu_performance_level {
            Some(e) => e.enum_value_or(super::enums::EGPUPerformanceLevel::k_EGPUPerformanceLevel_Invalid),
            None => super::enums::EGPUPerformanceLevel::k_EGPUPerformanceLevel_Invalid,
        }
    }

    pub fn clear_gpu_performance_level(&mut self) {
        self.gpu_performance_level = ::std::option::Option::None;
    }

    pub fn has_gpu_performance_level(&self) -> bool {
        self.gpu_performance_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gpu_performance_level(&mut self, v: super::enums::EGPUPerformanceLevel) {
        self.gpu_performance_level = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 gpu_performance_manual_mhz = 7;

    pub fn gpu_performance_manual_mhz(&self) -> i32 {
        self.gpu_performance_manual_mhz.unwrap_or(0)
    }

    pub fn clear_gpu_performance_manual_mhz(&mut self) {
        self.gpu_performance_manual_mhz = ::std::option::Option::None;
    }

    pub fn has_gpu_performance_manual_mhz(&self) -> bool {
        self.gpu_performance_manual_mhz.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gpu_performance_manual_mhz(&mut self, v: i32) {
        self.gpu_performance_manual_mhz = ::std::option::Option::Some(v);
    }

    // optional int32 fps_limit = 8;

    pub fn fps_limit(&self) -> i32 {
        self.fps_limit.unwrap_or(0)
    }

    pub fn clear_fps_limit(&mut self) {
        self.fps_limit = ::std::option::Option::None;
    }

    pub fn has_fps_limit(&self) -> bool {
        self.fps_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fps_limit(&mut self, v: i32) {
        self.fps_limit = ::std::option::Option::Some(v);
    }

    // optional bool is_variable_resolution_enabled = 9;

    pub fn is_variable_resolution_enabled(&self) -> bool {
        self.is_variable_resolution_enabled.unwrap_or(false)
    }

    pub fn clear_is_variable_resolution_enabled(&mut self) {
        self.is_variable_resolution_enabled = ::std::option::Option::None;
    }

    pub fn has_is_variable_resolution_enabled(&self) -> bool {
        self.is_variable_resolution_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_variable_resolution_enabled(&mut self, v: bool) {
        self.is_variable_resolution_enabled = ::std::option::Option::Some(v);
    }

    // optional bool is_dynamic_refresh_rate_enabled = 10;

    pub fn is_dynamic_refresh_rate_enabled(&self) -> bool {
        self.is_dynamic_refresh_rate_enabled.unwrap_or(false)
    }

    pub fn clear_is_dynamic_refresh_rate_enabled(&mut self) {
        self.is_dynamic_refresh_rate_enabled = ::std::option::Option::None;
    }

    pub fn has_is_dynamic_refresh_rate_enabled(&self) -> bool {
        self.is_dynamic_refresh_rate_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_dynamic_refresh_rate_enabled(&mut self, v: bool) {
        self.is_dynamic_refresh_rate_enabled = ::std::option::Option::Some(v);
    }

    // optional int32 tdp_limit = 11;

    pub fn tdp_limit(&self) -> i32 {
        self.tdp_limit.unwrap_or(0)
    }

    pub fn clear_tdp_limit(&mut self) {
        self.tdp_limit = ::std::option::Option::None;
    }

    pub fn has_tdp_limit(&self) -> bool {
        self.tdp_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tdp_limit(&mut self, v: i32) {
        self.tdp_limit = ::std::option::Option::Some(v);
    }

    // optional .ECPUGovernor cpu_governor = 12;

    pub fn cpu_governor(&self) -> super::enums::ECPUGovernor {
        match self.cpu_governor {
            Some(e) => e.enum_value_or(super::enums::ECPUGovernor::k_ECPUGovernor_Invalid),
            None => super::enums::ECPUGovernor::k_ECPUGovernor_Invalid,
        }
    }

    pub fn clear_cpu_governor(&mut self) {
        self.cpu_governor = ::std::option::Option::None;
    }

    pub fn has_cpu_governor(&self) -> bool {
        self.cpu_governor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_governor(&mut self, v: super::enums::ECPUGovernor) {
        self.cpu_governor = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 cpu_governor_manual_mhz = 13;

    pub fn cpu_governor_manual_mhz(&self) -> i32 {
        self.cpu_governor_manual_mhz.unwrap_or(0)
    }

    pub fn clear_cpu_governor_manual_mhz(&mut self) {
        self.cpu_governor_manual_mhz = ::std::option::Option::None;
    }

    pub fn has_cpu_governor_manual_mhz(&self) -> bool {
        self.cpu_governor_manual_mhz.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_governor_manual_mhz(&mut self, v: i32) {
        self.cpu_governor_manual_mhz = ::std::option::Option::Some(v);
    }

    // optional int32 scaling_filter = 14;

    pub fn scaling_filter(&self) -> i32 {
        self.scaling_filter.unwrap_or(0)
    }

    pub fn clear_scaling_filter(&mut self) {
        self.scaling_filter = ::std::option::Option::None;
    }

    pub fn has_scaling_filter(&self) -> bool {
        self.scaling_filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scaling_filter(&mut self, v: i32) {
        self.scaling_filter = ::std::option::Option::Some(v);
    }

    // optional int32 fsr_sharpness = 15;

    pub fn fsr_sharpness(&self) -> i32 {
        self.fsr_sharpness.unwrap_or(0)
    }

    pub fn clear_fsr_sharpness(&mut self) {
        self.fsr_sharpness = ::std::option::Option::None;
    }

    pub fn has_fsr_sharpness(&self) -> bool {
        self.fsr_sharpness.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsr_sharpness(&mut self, v: i32) {
        self.fsr_sharpness = ::std::option::Option::Some(v);
    }

    // optional bool is_fps_limit_enabled = 16;

    pub fn is_fps_limit_enabled(&self) -> bool {
        self.is_fps_limit_enabled.unwrap_or(false)
    }

    pub fn clear_is_fps_limit_enabled(&mut self) {
        self.is_fps_limit_enabled = ::std::option::Option::None;
    }

    pub fn has_is_fps_limit_enabled(&self) -> bool {
        self.is_fps_limit_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_fps_limit_enabled(&mut self, v: bool) {
        self.is_fps_limit_enabled = ::std::option::Option::Some(v);
    }

    // optional bool is_tdp_limit_enabled = 17;

    pub fn is_tdp_limit_enabled(&self) -> bool {
        self.is_tdp_limit_enabled.unwrap_or(false)
    }

    pub fn clear_is_tdp_limit_enabled(&mut self) {
        self.is_tdp_limit_enabled = ::std::option::Option::None;
    }

    pub fn has_is_tdp_limit_enabled(&self) -> bool {
        self.is_tdp_limit_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_tdp_limit_enabled(&mut self, v: bool) {
        self.is_tdp_limit_enabled = ::std::option::Option::Some(v);
    }

    // optional bool is_show_perf_overlay_over_steam_enabled = 18;

    pub fn is_show_perf_overlay_over_steam_enabled(&self) -> bool {
        self.is_show_perf_overlay_over_steam_enabled.unwrap_or(false)
    }

    pub fn clear_is_show_perf_overlay_over_steam_enabled(&mut self) {
        self.is_show_perf_overlay_over_steam_enabled = ::std::option::Option::None;
    }

    pub fn has_is_show_perf_overlay_over_steam_enabled(&self) -> bool {
        self.is_show_perf_overlay_over_steam_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_show_perf_overlay_over_steam_enabled(&mut self, v: bool) {
        self.is_show_perf_overlay_over_steam_enabled = ::std::option::Option::Some(v);
    }

    // optional bool is_low_latency_mode_enabled = 19;

    pub fn is_low_latency_mode_enabled(&self) -> bool {
        self.is_low_latency_mode_enabled.unwrap_or(false)
    }

    pub fn clear_is_low_latency_mode_enabled(&mut self) {
        self.is_low_latency_mode_enabled = ::std::option::Option::None;
    }

    pub fn has_is_low_latency_mode_enabled(&self) -> bool {
        self.is_low_latency_mode_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_low_latency_mode_enabled(&mut self, v: bool) {
        self.is_low_latency_mode_enabled = ::std::option::Option::Some(v);
    }

    // optional int32 display_refresh_manual_hz = 20;

    pub fn display_refresh_manual_hz(&self) -> i32 {
        self.display_refresh_manual_hz.unwrap_or(0)
    }

    pub fn clear_display_refresh_manual_hz(&mut self) {
        self.display_refresh_manual_hz = ::std::option::Option::None;
    }

    pub fn has_display_refresh_manual_hz(&self) -> bool {
        self.display_refresh_manual_hz.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_refresh_manual_hz(&mut self, v: i32) {
        self.display_refresh_manual_hz = ::std::option::Option::Some(v);
    }

    // optional bool is_game_perf_profile_enabled = 21;

    pub fn is_game_perf_profile_enabled(&self) -> bool {
        self.is_game_perf_profile_enabled.unwrap_or(false)
    }

    pub fn clear_is_game_perf_profile_enabled(&mut self) {
        self.is_game_perf_profile_enabled = ::std::option::Option::None;
    }

    pub fn has_is_game_perf_profile_enabled(&self) -> bool {
        self.is_game_perf_profile_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_game_perf_profile_enabled(&mut self, v: bool) {
        self.is_game_perf_profile_enabled = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSystemPerfSettingsV1 {
    const NAME: &'static str = "CMsgSystemPerfSettingsV1";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.diagnostic_update_rate = ::std::option::Option::Some(is.read_float()?);
                },
                16 => {
                    self.system_trace_service_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.graphics_profiling_service_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.perf_overlay_service_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.perf_overlay_level = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                48 => {
                    self.gpu_performance_level = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                56 => {
                    self.gpu_performance_manual_mhz = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.fps_limit = ::std::option::Option::Some(is.read_int32()?);
                },
                72 => {
                    self.is_variable_resolution_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.is_dynamic_refresh_rate_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.tdp_limit = ::std::option::Option::Some(is.read_int32()?);
                },
                96 => {
                    self.cpu_governor = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                104 => {
                    self.cpu_governor_manual_mhz = ::std::option::Option::Some(is.read_int32()?);
                },
                112 => {
                    self.scaling_filter = ::std::option::Option::Some(is.read_int32()?);
                },
                120 => {
                    self.fsr_sharpness = ::std::option::Option::Some(is.read_int32()?);
                },
                128 => {
                    self.is_fps_limit_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                136 => {
                    self.is_tdp_limit_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                144 => {
                    self.is_show_perf_overlay_over_steam_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                152 => {
                    self.is_low_latency_mode_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                160 => {
                    self.display_refresh_manual_hz = ::std::option::Option::Some(is.read_int32()?);
                },
                168 => {
                    self.is_game_perf_profile_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.diagnostic_update_rate {
            my_size += 1 + 4;
        }
        if let Some(v) = self.system_trace_service_state {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.graphics_profiling_service_state {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.perf_overlay_service_state {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.perf_overlay_level {
            my_size += ::protobuf::rt::int32_size(5, v.value());
        }
        if let Some(v) = self.gpu_performance_level {
            my_size += ::protobuf::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.gpu_performance_manual_mhz {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.fps_limit {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.is_variable_resolution_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_dynamic_refresh_rate_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.tdp_limit {
            my_size += ::protobuf::rt::int32_size(11, v);
        }
        if let Some(v) = self.cpu_governor {
            my_size += ::protobuf::rt::int32_size(12, v.value());
        }
        if let Some(v) = self.cpu_governor_manual_mhz {
            my_size += ::protobuf::rt::int32_size(13, v);
        }
        if let Some(v) = self.scaling_filter {
            my_size += ::protobuf::rt::int32_size(14, v);
        }
        if let Some(v) = self.fsr_sharpness {
            my_size += ::protobuf::rt::int32_size(15, v);
        }
        if let Some(v) = self.is_fps_limit_enabled {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_tdp_limit_enabled {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_show_perf_overlay_over_steam_enabled {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_low_latency_mode_enabled {
            my_size += 2 + 1;
        }
        if let Some(v) = self.display_refresh_manual_hz {
            my_size += ::protobuf::rt::int32_size(20, v);
        }
        if let Some(v) = self.is_game_perf_profile_enabled {
            my_size += 2 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.diagnostic_update_rate {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.system_trace_service_state {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.graphics_profiling_service_state {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.perf_overlay_service_state {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.perf_overlay_level {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.gpu_performance_level {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.gpu_performance_manual_mhz {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.fps_limit {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.is_variable_resolution_enabled {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.is_dynamic_refresh_rate_enabled {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.tdp_limit {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.cpu_governor {
            os.write_enum(12, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.cpu_governor_manual_mhz {
            os.write_int32(13, v)?;
        }
        if let Some(v) = self.scaling_filter {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.fsr_sharpness {
            os.write_int32(15, v)?;
        }
        if let Some(v) = self.is_fps_limit_enabled {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.is_tdp_limit_enabled {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.is_show_perf_overlay_over_steam_enabled {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.is_low_latency_mode_enabled {
            os.write_bool(19, v)?;
        }
        if let Some(v) = self.display_refresh_manual_hz {
            os.write_int32(20, v)?;
        }
        if let Some(v) = self.is_game_perf_profile_enabled {
            os.write_bool(21, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemPerfSettingsV1 {
        CMsgSystemPerfSettingsV1::new()
    }

    fn clear(&mut self) {
        self.diagnostic_update_rate = ::std::option::Option::None;
        self.system_trace_service_state = ::std::option::Option::None;
        self.graphics_profiling_service_state = ::std::option::Option::None;
        self.perf_overlay_service_state = ::std::option::Option::None;
        self.perf_overlay_level = ::std::option::Option::None;
        self.gpu_performance_level = ::std::option::Option::None;
        self.gpu_performance_manual_mhz = ::std::option::Option::None;
        self.fps_limit = ::std::option::Option::None;
        self.is_variable_resolution_enabled = ::std::option::Option::None;
        self.is_dynamic_refresh_rate_enabled = ::std::option::Option::None;
        self.tdp_limit = ::std::option::Option::None;
        self.cpu_governor = ::std::option::Option::None;
        self.cpu_governor_manual_mhz = ::std::option::Option::None;
        self.scaling_filter = ::std::option::Option::None;
        self.fsr_sharpness = ::std::option::Option::None;
        self.is_fps_limit_enabled = ::std::option::Option::None;
        self.is_tdp_limit_enabled = ::std::option::Option::None;
        self.is_show_perf_overlay_over_steam_enabled = ::std::option::Option::None;
        self.is_low_latency_mode_enabled = ::std::option::Option::None;
        self.display_refresh_manual_hz = ::std::option::Option::None;
        self.is_game_perf_profile_enabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemPerfSettingsV1 {
        static instance: CMsgSystemPerfSettingsV1 = CMsgSystemPerfSettingsV1 {
            diagnostic_update_rate: ::std::option::Option::None,
            system_trace_service_state: ::std::option::Option::None,
            graphics_profiling_service_state: ::std::option::Option::None,
            perf_overlay_service_state: ::std::option::Option::None,
            perf_overlay_level: ::std::option::Option::None,
            gpu_performance_level: ::std::option::Option::None,
            gpu_performance_manual_mhz: ::std::option::Option::None,
            fps_limit: ::std::option::Option::None,
            is_variable_resolution_enabled: ::std::option::Option::None,
            is_dynamic_refresh_rate_enabled: ::std::option::Option::None,
            tdp_limit: ::std::option::Option::None,
            cpu_governor: ::std::option::Option::None,
            cpu_governor_manual_mhz: ::std::option::Option::None,
            scaling_filter: ::std::option::Option::None,
            fsr_sharpness: ::std::option::Option::None,
            is_fps_limit_enabled: ::std::option::Option::None,
            is_tdp_limit_enabled: ::std::option::Option::None,
            is_show_perf_overlay_over_steam_enabled: ::std::option::Option::None,
            is_low_latency_mode_enabled: ::std::option::Option::None,
            display_refresh_manual_hz: ::std::option::Option::None,
            is_game_perf_profile_enabled: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSystemPerfState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemPerfState {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemPerfState.limits)
    pub limits: ::protobuf::MessageField<CMsgSystemPerfLimits>,
    // @@protoc_insertion_point(field:CMsgSystemPerfState.settings)
    pub settings: ::protobuf::MessageField<CMsgSystemPerfSettings>,
    // @@protoc_insertion_point(field:CMsgSystemPerfState.current_game_id)
    pub current_game_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSystemPerfState.active_profile_game_id)
    pub active_profile_game_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemPerfState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemPerfState {
    fn default() -> &'a CMsgSystemPerfState {
        <CMsgSystemPerfState as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSystemPerfState {
    pub fn new() -> CMsgSystemPerfState {
        ::std::default::Default::default()
    }

    // optional uint64 current_game_id = 3;

    pub fn current_game_id(&self) -> u64 {
        self.current_game_id.unwrap_or(0)
    }

    pub fn clear_current_game_id(&mut self) {
        self.current_game_id = ::std::option::Option::None;
    }

    pub fn has_current_game_id(&self) -> bool {
        self.current_game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_game_id(&mut self, v: u64) {
        self.current_game_id = ::std::option::Option::Some(v);
    }

    // optional uint64 active_profile_game_id = 4;

    pub fn active_profile_game_id(&self) -> u64 {
        self.active_profile_game_id.unwrap_or(0)
    }

    pub fn clear_active_profile_game_id(&mut self) {
        self.active_profile_game_id = ::std::option::Option::None;
    }

    pub fn has_active_profile_game_id(&self) -> bool {
        self.active_profile_game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_profile_game_id(&mut self, v: u64) {
        self.active_profile_game_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSystemPerfState {
    const NAME: &'static str = "CMsgSystemPerfState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.limits)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.settings)?;
                },
                24 => {
                    self.current_game_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.active_profile_game_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.limits.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.current_game_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.active_profile_game_id {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.limits.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.settings.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.current_game_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.active_profile_game_id {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemPerfState {
        CMsgSystemPerfState::new()
    }

    fn clear(&mut self) {
        self.limits.clear();
        self.settings.clear();
        self.current_game_id = ::std::option::Option::None;
        self.active_profile_game_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemPerfState {
        static instance: CMsgSystemPerfState = CMsgSystemPerfState {
            limits: ::protobuf::MessageField::none(),
            settings: ::protobuf::MessageField::none(),
            current_game_id: ::std::option::Option::None,
            active_profile_game_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSystemPerfUpdateSettings)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemPerfUpdateSettings {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemPerfUpdateSettings.gameid)
    pub gameid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSystemPerfUpdateSettings.skip_storage_update)
    pub skip_storage_update: ::std::option::Option<bool>,
    // message oneof groups
    pub update: ::std::option::Option<cmsg_system_perf_update_settings::Update>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemPerfUpdateSettings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemPerfUpdateSettings {
    fn default() -> &'a CMsgSystemPerfUpdateSettings {
        <CMsgSystemPerfUpdateSettings as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSystemPerfUpdateSettings {
    pub fn new() -> CMsgSystemPerfUpdateSettings {
        ::std::default::Default::default()
    }

    // optional uint64 gameid = 1;

    pub fn gameid(&self) -> u64 {
        self.gameid.unwrap_or(0)
    }

    pub fn clear_gameid(&mut self) {
        self.gameid = ::std::option::Option::None;
    }

    pub fn has_gameid(&self) -> bool {
        self.gameid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameid(&mut self, v: u64) {
        self.gameid = ::std::option::Option::Some(v);
    }

    // optional bool skip_storage_update = 4;

    pub fn skip_storage_update(&self) -> bool {
        self.skip_storage_update.unwrap_or(false)
    }

    pub fn clear_skip_storage_update(&mut self) {
        self.skip_storage_update = ::std::option::Option::None;
    }

    pub fn has_skip_storage_update(&self) -> bool {
        self.skip_storage_update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skip_storage_update(&mut self, v: bool) {
        self.skip_storage_update = ::std::option::Option::Some(v);
    }

    // optional bool reset_to_default = 2;

    pub fn reset_to_default(&self) -> bool {
        match self.update {
            ::std::option::Option::Some(cmsg_system_perf_update_settings::Update::ResetToDefault(v)) => v,
            _ => false,
        }
    }

    pub fn clear_reset_to_default(&mut self) {
        self.update = ::std::option::Option::None;
    }

    pub fn has_reset_to_default(&self) -> bool {
        match self.update {
            ::std::option::Option::Some(cmsg_system_perf_update_settings::Update::ResetToDefault(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_reset_to_default(&mut self, v: bool) {
        self.update = ::std::option::Option::Some(cmsg_system_perf_update_settings::Update::ResetToDefault(v))
    }

    // optional .CMsgSystemPerfSettings settings_delta = 3;

    pub fn settings_delta(&self) -> &CMsgSystemPerfSettings {
        match self.update {
            ::std::option::Option::Some(cmsg_system_perf_update_settings::Update::SettingsDelta(ref v)) => v,
            _ => <CMsgSystemPerfSettings as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_settings_delta(&mut self) {
        self.update = ::std::option::Option::None;
    }

    pub fn has_settings_delta(&self) -> bool {
        match self.update {
            ::std::option::Option::Some(cmsg_system_perf_update_settings::Update::SettingsDelta(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_settings_delta(&mut self, v: CMsgSystemPerfSettings) {
        self.update = ::std::option::Option::Some(cmsg_system_perf_update_settings::Update::SettingsDelta(v))
    }

    // Mutable pointer to the field.
    pub fn mut_settings_delta(&mut self) -> &mut CMsgSystemPerfSettings {
        if let ::std::option::Option::Some(cmsg_system_perf_update_settings::Update::SettingsDelta(_)) = self.update {
        } else {
            self.update = ::std::option::Option::Some(cmsg_system_perf_update_settings::Update::SettingsDelta(CMsgSystemPerfSettings::new()));
        }
        match self.update {
            ::std::option::Option::Some(cmsg_system_perf_update_settings::Update::SettingsDelta(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_settings_delta(&mut self) -> CMsgSystemPerfSettings {
        if self.has_settings_delta() {
            match self.update.take() {
                ::std::option::Option::Some(cmsg_system_perf_update_settings::Update::SettingsDelta(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgSystemPerfSettings::new()
        }
    }
}

impl ::protobuf::Message for CMsgSystemPerfUpdateSettings {
    const NAME: &'static str = "CMsgSystemPerfUpdateSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.gameid = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.skip_storage_update = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.update = ::std::option::Option::Some(cmsg_system_perf_update_settings::Update::ResetToDefault(is.read_bool()?));
                },
                26 => {
                    self.update = ::std::option::Option::Some(cmsg_system_perf_update_settings::Update::SettingsDelta(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gameid {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.skip_storage_update {
            my_size += 1 + 1;
        }
        if let ::std::option::Option::Some(ref v) = self.update {
            match v {
                &cmsg_system_perf_update_settings::Update::ResetToDefault(v) => {
                    my_size += 1 + 1;
                },
                &cmsg_system_perf_update_settings::Update::SettingsDelta(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.gameid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.skip_storage_update {
            os.write_bool(4, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.update {
            match v {
                &cmsg_system_perf_update_settings::Update::ResetToDefault(v) => {
                    os.write_bool(2, v)?;
                },
                &cmsg_system_perf_update_settings::Update::SettingsDelta(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemPerfUpdateSettings {
        CMsgSystemPerfUpdateSettings::new()
    }

    fn clear(&mut self) {
        self.gameid = ::std::option::Option::None;
        self.skip_storage_update = ::std::option::Option::None;
        self.update = ::std::option::Option::None;
        self.update = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemPerfUpdateSettings {
        static instance: CMsgSystemPerfUpdateSettings = CMsgSystemPerfUpdateSettings {
            gameid: ::std::option::Option::None,
            skip_storage_update: ::std::option::Option::None,
            update: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSystemPerfUpdateSettings`
pub mod cmsg_system_perf_update_settings {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:CMsgSystemPerfUpdateSettings.update)
    pub enum Update {
        // @@protoc_insertion_point(oneof_field:CMsgSystemPerfUpdateSettings.reset_to_default)
        ResetToDefault(bool),
        // @@protoc_insertion_point(oneof_field:CMsgSystemPerfUpdateSettings.settings_delta)
        SettingsDelta(super::CMsgSystemPerfSettings),
    }

    impl ::protobuf::Oneof for Update {
    }

    impl Update {
    }
}

// @@protoc_insertion_point(message:CMsgSystemDockUpdateState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemDockUpdateState {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemDockUpdateState.state)
    pub state: ::std::option::Option<::protobuf::EnumOrUnknown<super::enums::EUpdaterState>>,
    // @@protoc_insertion_point(field:CMsgSystemDockUpdateState.rtime_last_checked)
    pub rtime_last_checked: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSystemDockUpdateState.version_current)
    pub version_current: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSystemDockUpdateState.version_available)
    pub version_available: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSystemDockUpdateState.stage_progress)
    pub stage_progress: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSystemDockUpdateState.rtime_estimated_completion)
    pub rtime_estimated_completion: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSystemDockUpdateState.old_fw_workaround)
    pub old_fw_workaround: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemDockUpdateState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemDockUpdateState {
    fn default() -> &'a CMsgSystemDockUpdateState {
        <CMsgSystemDockUpdateState as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSystemDockUpdateState {
    pub fn new() -> CMsgSystemDockUpdateState {
        ::std::default::Default::default()
    }

    // optional .EUpdaterState state = 1;

    pub fn state(&self) -> super::enums::EUpdaterState {
        match self.state {
            Some(e) => e.enum_value_or(super::enums::EUpdaterState::k_EUpdaterState_Invalid),
            None => super::enums::EUpdaterState::k_EUpdaterState_Invalid,
        }
    }

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: super::enums::EUpdaterState) {
        self.state = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional fixed32 rtime_last_checked = 2;

    pub fn rtime_last_checked(&self) -> u32 {
        self.rtime_last_checked.unwrap_or(0)
    }

    pub fn clear_rtime_last_checked(&mut self) {
        self.rtime_last_checked = ::std::option::Option::None;
    }

    pub fn has_rtime_last_checked(&self) -> bool {
        self.rtime_last_checked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime_last_checked(&mut self, v: u32) {
        self.rtime_last_checked = ::std::option::Option::Some(v);
    }

    // optional string version_current = 3;

    pub fn version_current(&self) -> &str {
        match self.version_current.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_version_current(&mut self) {
        self.version_current = ::std::option::Option::None;
    }

    pub fn has_version_current(&self) -> bool {
        self.version_current.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version_current(&mut self, v: ::std::string::String) {
        self.version_current = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_current(&mut self) -> &mut ::std::string::String {
        if self.version_current.is_none() {
            self.version_current = ::std::option::Option::Some(::std::string::String::new());
        }
        self.version_current.as_mut().unwrap()
    }

    // Take field
    pub fn take_version_current(&mut self) -> ::std::string::String {
        self.version_current.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string version_available = 4;

    pub fn version_available(&self) -> &str {
        match self.version_available.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_version_available(&mut self) {
        self.version_available = ::std::option::Option::None;
    }

    pub fn has_version_available(&self) -> bool {
        self.version_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version_available(&mut self, v: ::std::string::String) {
        self.version_available = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_available(&mut self) -> &mut ::std::string::String {
        if self.version_available.is_none() {
            self.version_available = ::std::option::Option::Some(::std::string::String::new());
        }
        self.version_available.as_mut().unwrap()
    }

    // Take field
    pub fn take_version_available(&mut self) -> ::std::string::String {
        self.version_available.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional float stage_progress = 5;

    pub fn stage_progress(&self) -> f32 {
        self.stage_progress.unwrap_or(0.)
    }

    pub fn clear_stage_progress(&mut self) {
        self.stage_progress = ::std::option::Option::None;
    }

    pub fn has_stage_progress(&self) -> bool {
        self.stage_progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stage_progress(&mut self, v: f32) {
        self.stage_progress = ::std::option::Option::Some(v);
    }

    // optional fixed32 rtime_estimated_completion = 6;

    pub fn rtime_estimated_completion(&self) -> u32 {
        self.rtime_estimated_completion.unwrap_or(0)
    }

    pub fn clear_rtime_estimated_completion(&mut self) {
        self.rtime_estimated_completion = ::std::option::Option::None;
    }

    pub fn has_rtime_estimated_completion(&self) -> bool {
        self.rtime_estimated_completion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime_estimated_completion(&mut self, v: u32) {
        self.rtime_estimated_completion = ::std::option::Option::Some(v);
    }

    // optional int32 old_fw_workaround = 7;

    pub fn old_fw_workaround(&self) -> i32 {
        self.old_fw_workaround.unwrap_or(0)
    }

    pub fn clear_old_fw_workaround(&mut self) {
        self.old_fw_workaround = ::std::option::Option::None;
    }

    pub fn has_old_fw_workaround(&self) -> bool {
        self.old_fw_workaround.is_some()
    }

    // Param is passed by value, moved
    pub fn set_old_fw_workaround(&mut self, v: i32) {
        self.old_fw_workaround = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSystemDockUpdateState {
    const NAME: &'static str = "CMsgSystemDockUpdateState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                21 => {
                    self.rtime_last_checked = ::std::option::Option::Some(is.read_fixed32()?);
                },
                26 => {
                    self.version_current = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.version_available = ::std::option::Option::Some(is.read_string()?);
                },
                45 => {
                    self.stage_progress = ::std::option::Option::Some(is.read_float()?);
                },
                53 => {
                    self.rtime_estimated_completion = ::std::option::Option::Some(is.read_fixed32()?);
                },
                56 => {
                    self.old_fw_workaround = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.state {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.rtime_last_checked {
            my_size += 1 + 4;
        }
        if let Some(v) = self.version_current.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.version_available.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.stage_progress {
            my_size += 1 + 4;
        }
        if let Some(v) = self.rtime_estimated_completion {
            my_size += 1 + 4;
        }
        if let Some(v) = self.old_fw_workaround {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.state {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.rtime_last_checked {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.version_current.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.version_available.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.stage_progress {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.rtime_estimated_completion {
            os.write_fixed32(6, v)?;
        }
        if let Some(v) = self.old_fw_workaround {
            os.write_int32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemDockUpdateState {
        CMsgSystemDockUpdateState::new()
    }

    fn clear(&mut self) {
        self.state = ::std::option::Option::None;
        self.rtime_last_checked = ::std::option::Option::None;
        self.version_current = ::std::option::Option::None;
        self.version_available = ::std::option::Option::None;
        self.stage_progress = ::std::option::Option::None;
        self.rtime_estimated_completion = ::std::option::Option::None;
        self.old_fw_workaround = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemDockUpdateState {
        static instance: CMsgSystemDockUpdateState = CMsgSystemDockUpdateState {
            state: ::std::option::Option::None,
            rtime_last_checked: ::std::option::Option::None,
            version_current: ::std::option::Option::None,
            version_available: ::std::option::Option::None,
            stage_progress: ::std::option::Option::None,
            rtime_estimated_completion: ::std::option::Option::None,
            old_fw_workaround: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSystemDockState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemDockState {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemDockState.update_state)
    pub update_state: ::protobuf::MessageField<CMsgSystemDockUpdateState>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemDockState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemDockState {
    fn default() -> &'a CMsgSystemDockState {
        <CMsgSystemDockState as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSystemDockState {
    pub fn new() -> CMsgSystemDockState {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgSystemDockState {
    const NAME: &'static str = "CMsgSystemDockState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.update_state)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.update_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.update_state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemDockState {
        CMsgSystemDockState::new()
    }

    fn clear(&mut self) {
        self.update_state.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemDockState {
        static instance: CMsgSystemDockState = CMsgSystemDockState {
            update_state: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSystemDockUpdateFirmware)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemDockUpdateFirmware {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemDockUpdateFirmware.check_only)
    pub check_only: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemDockUpdateFirmware.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemDockUpdateFirmware {
    fn default() -> &'a CMsgSystemDockUpdateFirmware {
        <CMsgSystemDockUpdateFirmware as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSystemDockUpdateFirmware {
    pub fn new() -> CMsgSystemDockUpdateFirmware {
        ::std::default::Default::default()
    }

    // optional bool check_only = 1;

    pub fn check_only(&self) -> bool {
        self.check_only.unwrap_or(false)
    }

    pub fn clear_check_only(&mut self) {
        self.check_only = ::std::option::Option::None;
    }

    pub fn has_check_only(&self) -> bool {
        self.check_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_check_only(&mut self, v: bool) {
        self.check_only = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSystemDockUpdateFirmware {
    const NAME: &'static str = "CMsgSystemDockUpdateFirmware";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.check_only = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.check_only {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.check_only {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemDockUpdateFirmware {
        CMsgSystemDockUpdateFirmware::new()
    }

    fn clear(&mut self) {
        self.check_only = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemDockUpdateFirmware {
        static instance: CMsgSystemDockUpdateFirmware = CMsgSystemDockUpdateFirmware {
            check_only: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSystemAudioVolume)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemAudioVolume {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemAudioVolume.entries)
    pub entries: ::std::vec::Vec<cmsg_system_audio_volume::ChannelEntry>,
    // @@protoc_insertion_point(field:CMsgSystemAudioVolume.is_muted)
    pub is_muted: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemAudioVolume.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemAudioVolume {
    fn default() -> &'a CMsgSystemAudioVolume {
        <CMsgSystemAudioVolume as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSystemAudioVolume {
    pub fn new() -> CMsgSystemAudioVolume {
        ::std::default::Default::default()
    }

    // optional bool is_muted = 2;

    pub fn is_muted(&self) -> bool {
        self.is_muted.unwrap_or(false)
    }

    pub fn clear_is_muted(&mut self) {
        self.is_muted = ::std::option::Option::None;
    }

    pub fn has_is_muted(&self) -> bool {
        self.is_muted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_muted(&mut self, v: bool) {
        self.is_muted = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSystemAudioVolume {
    const NAME: &'static str = "CMsgSystemAudioVolume";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.entries.push(is.read_message()?);
                },
                16 => {
                    self.is_muted = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.is_muted {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.entries {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.is_muted {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemAudioVolume {
        CMsgSystemAudioVolume::new()
    }

    fn clear(&mut self) {
        self.entries.clear();
        self.is_muted = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemAudioVolume {
        static instance: CMsgSystemAudioVolume = CMsgSystemAudioVolume {
            entries: ::std::vec::Vec::new(),
            is_muted: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSystemAudioVolume`
pub mod cmsg_system_audio_volume {
    // @@protoc_insertion_point(message:CMsgSystemAudioVolume.ChannelEntry)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ChannelEntry {
        // message fields
        // @@protoc_insertion_point(field:CMsgSystemAudioVolume.ChannelEntry.echannel)
        pub echannel: ::std::option::Option<::protobuf::EnumOrUnknown<super::super::enums::ESystemAudioChannel>>,
        // @@protoc_insertion_point(field:CMsgSystemAudioVolume.ChannelEntry.volume)
        pub volume: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSystemAudioVolume.ChannelEntry.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ChannelEntry {
        fn default() -> &'a ChannelEntry {
            <ChannelEntry as ::protobuf::Message>::default_instance()
        }
    }

    impl ChannelEntry {
        pub fn new() -> ChannelEntry {
            ::std::default::Default::default()
        }

        // optional .ESystemAudioChannel echannel = 1;

        pub fn echannel(&self) -> super::super::enums::ESystemAudioChannel {
            match self.echannel {
                Some(e) => e.enum_value_or(super::super::enums::ESystemAudioChannel::k_SystemAudioChannel_Invalid),
                None => super::super::enums::ESystemAudioChannel::k_SystemAudioChannel_Invalid,
            }
        }

        pub fn clear_echannel(&mut self) {
            self.echannel = ::std::option::Option::None;
        }

        pub fn has_echannel(&self) -> bool {
            self.echannel.is_some()
        }

        // Param is passed by value, moved
        pub fn set_echannel(&mut self, v: super::super::enums::ESystemAudioChannel) {
            self.echannel = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional float volume = 2;

        pub fn volume(&self) -> f32 {
            self.volume.unwrap_or(0.)
        }

        pub fn clear_volume(&mut self) {
            self.volume = ::std::option::Option::None;
        }

        pub fn has_volume(&self) -> bool {
            self.volume.is_some()
        }

        // Param is passed by value, moved
        pub fn set_volume(&mut self, v: f32) {
            self.volume = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for ChannelEntry {
        const NAME: &'static str = "ChannelEntry";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.echannel = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    21 => {
                        self.volume = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.echannel {
                my_size += ::protobuf::rt::int32_size(1, v.value());
            }
            if let Some(v) = self.volume {
                my_size += 1 + 4;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.echannel {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.volume {
                os.write_float(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ChannelEntry {
            ChannelEntry::new()
        }

        fn clear(&mut self) {
            self.echannel = ::std::option::Option::None;
            self.volume = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ChannelEntry {
            static instance: ChannelEntry = ChannelEntry {
                echannel: ::std::option::Option::None,
                volume: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgSystemAudioManagerObject)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemAudioManagerObject {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerObject.id)
    pub id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerObject.rtime_last_update)
    pub rtime_last_update: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemAudioManagerObject.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemAudioManagerObject {
    fn default() -> &'a CMsgSystemAudioManagerObject {
        <CMsgSystemAudioManagerObject as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSystemAudioManagerObject {
    pub fn new() -> CMsgSystemAudioManagerObject {
        ::std::default::Default::default()
    }

    // optional uint32 id = 1;

    pub fn id(&self) -> u32 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional fixed32 rtime_last_update = 2;

    pub fn rtime_last_update(&self) -> u32 {
        self.rtime_last_update.unwrap_or(0)
    }

    pub fn clear_rtime_last_update(&mut self) {
        self.rtime_last_update = ::std::option::Option::None;
    }

    pub fn has_rtime_last_update(&self) -> bool {
        self.rtime_last_update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime_last_update(&mut self, v: u32) {
        self.rtime_last_update = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSystemAudioManagerObject {
    const NAME: &'static str = "CMsgSystemAudioManagerObject";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.rtime_last_update = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.rtime_last_update {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.rtime_last_update {
            os.write_fixed32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemAudioManagerObject {
        CMsgSystemAudioManagerObject::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.rtime_last_update = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemAudioManagerObject {
        static instance: CMsgSystemAudioManagerObject = CMsgSystemAudioManagerObject {
            id: ::std::option::Option::None,
            rtime_last_update: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSystemAudioManagerDevice)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemAudioManagerDevice {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerDevice.base)
    pub base: ::protobuf::MessageField<CMsgSystemAudioManagerObject>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerDevice.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerDevice.nick)
    pub nick: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerDevice.description)
    pub description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerDevice.api)
    pub api: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemAudioManagerDevice.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemAudioManagerDevice {
    fn default() -> &'a CMsgSystemAudioManagerDevice {
        <CMsgSystemAudioManagerDevice as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSystemAudioManagerDevice {
    pub fn new() -> CMsgSystemAudioManagerDevice {
        ::std::default::Default::default()
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string nick = 3;

    pub fn nick(&self) -> &str {
        match self.nick.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_nick(&mut self) {
        self.nick = ::std::option::Option::None;
    }

    pub fn has_nick(&self) -> bool {
        self.nick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nick(&mut self, v: ::std::string::String) {
        self.nick = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nick(&mut self) -> &mut ::std::string::String {
        if self.nick.is_none() {
            self.nick = ::std::option::Option::Some(::std::string::String::new());
        }
        self.nick.as_mut().unwrap()
    }

    // Take field
    pub fn take_nick(&mut self) -> ::std::string::String {
        self.nick.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string description = 4;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string api = 5;

    pub fn api(&self) -> &str {
        match self.api.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_api(&mut self) {
        self.api = ::std::option::Option::None;
    }

    pub fn has_api(&self) -> bool {
        self.api.is_some()
    }

    // Param is passed by value, moved
    pub fn set_api(&mut self, v: ::std::string::String) {
        self.api = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_api(&mut self) -> &mut ::std::string::String {
        if self.api.is_none() {
            self.api = ::std::option::Option::Some(::std::string::String::new());
        }
        self.api.as_mut().unwrap()
    }

    // Take field
    pub fn take_api(&mut self) -> ::std::string::String {
        self.api.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgSystemAudioManagerDevice {
    const NAME: &'static str = "CMsgSystemAudioManagerDevice";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.base)?;
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.nick = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.api = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.nick.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.api.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.nick.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.api.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemAudioManagerDevice {
        CMsgSystemAudioManagerDevice::new()
    }

    fn clear(&mut self) {
        self.base.clear();
        self.name = ::std::option::Option::None;
        self.nick = ::std::option::Option::None;
        self.description = ::std::option::Option::None;
        self.api = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemAudioManagerDevice {
        static instance: CMsgSystemAudioManagerDevice = CMsgSystemAudioManagerDevice {
            base: ::protobuf::MessageField::none(),
            name: ::std::option::Option::None,
            nick: ::std::option::Option::None,
            description: ::std::option::Option::None,
            api: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSystemAudioManagerNode)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemAudioManagerNode {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerNode.base)
    pub base: ::protobuf::MessageField<CMsgSystemAudioManagerObject>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerNode.device_id)
    pub device_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerNode.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerNode.nick)
    pub nick: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerNode.description)
    pub description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerNode.edirection)
    pub edirection: ::std::option::Option<::protobuf::EnumOrUnknown<super::enums::ESystemAudioDirection>>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerNode.volume)
    pub volume: ::protobuf::MessageField<CMsgSystemAudioVolume>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemAudioManagerNode.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemAudioManagerNode {
    fn default() -> &'a CMsgSystemAudioManagerNode {
        <CMsgSystemAudioManagerNode as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSystemAudioManagerNode {
    pub fn new() -> CMsgSystemAudioManagerNode {
        ::std::default::Default::default()
    }

    // optional uint32 device_id = 2;

    pub fn device_id(&self) -> u32 {
        self.device_id.unwrap_or(0)
    }

    pub fn clear_device_id(&mut self) {
        self.device_id = ::std::option::Option::None;
    }

    pub fn has_device_id(&self) -> bool {
        self.device_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_id(&mut self, v: u32) {
        self.device_id = ::std::option::Option::Some(v);
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string nick = 4;

    pub fn nick(&self) -> &str {
        match self.nick.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_nick(&mut self) {
        self.nick = ::std::option::Option::None;
    }

    pub fn has_nick(&self) -> bool {
        self.nick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nick(&mut self, v: ::std::string::String) {
        self.nick = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nick(&mut self) -> &mut ::std::string::String {
        if self.nick.is_none() {
            self.nick = ::std::option::Option::Some(::std::string::String::new());
        }
        self.nick.as_mut().unwrap()
    }

    // Take field
    pub fn take_nick(&mut self) -> ::std::string::String {
        self.nick.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string description = 5;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .ESystemAudioDirection edirection = 6;

    pub fn edirection(&self) -> super::enums::ESystemAudioDirection {
        match self.edirection {
            Some(e) => e.enum_value_or(super::enums::ESystemAudioDirection::k_SystemAudioDirection_Invalid),
            None => super::enums::ESystemAudioDirection::k_SystemAudioDirection_Invalid,
        }
    }

    pub fn clear_edirection(&mut self) {
        self.edirection = ::std::option::Option::None;
    }

    pub fn has_edirection(&self) -> bool {
        self.edirection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_edirection(&mut self, v: super::enums::ESystemAudioDirection) {
        self.edirection = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::protobuf::Message for CMsgSystemAudioManagerNode {
    const NAME: &'static str = "CMsgSystemAudioManagerNode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.base)?;
                },
                16 => {
                    self.device_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.nick = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.edirection = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.volume)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.device_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.nick.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.edirection {
            my_size += ::protobuf::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.volume.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.device_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.nick.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.edirection {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.volume.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemAudioManagerNode {
        CMsgSystemAudioManagerNode::new()
    }

    fn clear(&mut self) {
        self.base.clear();
        self.device_id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.nick = ::std::option::Option::None;
        self.description = ::std::option::Option::None;
        self.edirection = ::std::option::Option::None;
        self.volume.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemAudioManagerNode {
        static instance: CMsgSystemAudioManagerNode = CMsgSystemAudioManagerNode {
            base: ::protobuf::MessageField::none(),
            device_id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            nick: ::std::option::Option::None,
            description: ::std::option::Option::None,
            edirection: ::std::option::Option::None,
            volume: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSystemAudioManagerPort)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemAudioManagerPort {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerPort.base)
    pub base: ::protobuf::MessageField<CMsgSystemAudioManagerObject>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerPort.node_id)
    pub node_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerPort.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerPort.alias)
    pub alias: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerPort.etype)
    pub etype: ::std::option::Option<::protobuf::EnumOrUnknown<super::enums::ESystemAudioPortType>>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerPort.edirection)
    pub edirection: ::std::option::Option<::protobuf::EnumOrUnknown<super::enums::ESystemAudioPortDirection>>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerPort.is_physical)
    pub is_physical: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerPort.is_terminal)
    pub is_terminal: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerPort.is_control)
    pub is_control: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerPort.is_monitor)
    pub is_monitor: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemAudioManagerPort.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemAudioManagerPort {
    fn default() -> &'a CMsgSystemAudioManagerPort {
        <CMsgSystemAudioManagerPort as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSystemAudioManagerPort {
    pub fn new() -> CMsgSystemAudioManagerPort {
        ::std::default::Default::default()
    }

    // optional uint32 node_id = 3;

    pub fn node_id(&self) -> u32 {
        self.node_id.unwrap_or(0)
    }

    pub fn clear_node_id(&mut self) {
        self.node_id = ::std::option::Option::None;
    }

    pub fn has_node_id(&self) -> bool {
        self.node_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_id(&mut self, v: u32) {
        self.node_id = ::std::option::Option::Some(v);
    }

    // optional string name = 4;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string alias = 5;

    pub fn alias(&self) -> &str {
        match self.alias.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_alias(&mut self) {
        self.alias = ::std::option::Option::None;
    }

    pub fn has_alias(&self) -> bool {
        self.alias.is_some()
    }

    // Param is passed by value, moved
    pub fn set_alias(&mut self, v: ::std::string::String) {
        self.alias = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_alias(&mut self) -> &mut ::std::string::String {
        if self.alias.is_none() {
            self.alias = ::std::option::Option::Some(::std::string::String::new());
        }
        self.alias.as_mut().unwrap()
    }

    // Take field
    pub fn take_alias(&mut self) -> ::std::string::String {
        self.alias.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .ESystemAudioPortType etype = 6;

    pub fn etype(&self) -> super::enums::ESystemAudioPortType {
        match self.etype {
            Some(e) => e.enum_value_or(super::enums::ESystemAudioPortType::k_SystemAudioPortType_Invalid),
            None => super::enums::ESystemAudioPortType::k_SystemAudioPortType_Invalid,
        }
    }

    pub fn clear_etype(&mut self) {
        self.etype = ::std::option::Option::None;
    }

    pub fn has_etype(&self) -> bool {
        self.etype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_etype(&mut self, v: super::enums::ESystemAudioPortType) {
        self.etype = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .ESystemAudioPortDirection edirection = 7;

    pub fn edirection(&self) -> super::enums::ESystemAudioPortDirection {
        match self.edirection {
            Some(e) => e.enum_value_or(super::enums::ESystemAudioPortDirection::k_SystemAudioPortDirection_Invalid),
            None => super::enums::ESystemAudioPortDirection::k_SystemAudioPortDirection_Invalid,
        }
    }

    pub fn clear_edirection(&mut self) {
        self.edirection = ::std::option::Option::None;
    }

    pub fn has_edirection(&self) -> bool {
        self.edirection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_edirection(&mut self, v: super::enums::ESystemAudioPortDirection) {
        self.edirection = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool is_physical = 8;

    pub fn is_physical(&self) -> bool {
        self.is_physical.unwrap_or(false)
    }

    pub fn clear_is_physical(&mut self) {
        self.is_physical = ::std::option::Option::None;
    }

    pub fn has_is_physical(&self) -> bool {
        self.is_physical.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_physical(&mut self, v: bool) {
        self.is_physical = ::std::option::Option::Some(v);
    }

    // optional bool is_terminal = 9;

    pub fn is_terminal(&self) -> bool {
        self.is_terminal.unwrap_or(false)
    }

    pub fn clear_is_terminal(&mut self) {
        self.is_terminal = ::std::option::Option::None;
    }

    pub fn has_is_terminal(&self) -> bool {
        self.is_terminal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_terminal(&mut self, v: bool) {
        self.is_terminal = ::std::option::Option::Some(v);
    }

    // optional bool is_control = 10;

    pub fn is_control(&self) -> bool {
        self.is_control.unwrap_or(false)
    }

    pub fn clear_is_control(&mut self) {
        self.is_control = ::std::option::Option::None;
    }

    pub fn has_is_control(&self) -> bool {
        self.is_control.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_control(&mut self, v: bool) {
        self.is_control = ::std::option::Option::Some(v);
    }

    // optional bool is_monitor = 11;

    pub fn is_monitor(&self) -> bool {
        self.is_monitor.unwrap_or(false)
    }

    pub fn clear_is_monitor(&mut self) {
        self.is_monitor = ::std::option::Option::None;
    }

    pub fn has_is_monitor(&self) -> bool {
        self.is_monitor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_monitor(&mut self, v: bool) {
        self.is_monitor = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSystemAudioManagerPort {
    const NAME: &'static str = "CMsgSystemAudioManagerPort";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.base)?;
                },
                24 => {
                    self.node_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.alias = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.etype = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                56 => {
                    self.edirection = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                64 => {
                    self.is_physical = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.is_terminal = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.is_control = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.is_monitor = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.node_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.alias.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.etype {
            my_size += ::protobuf::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.edirection {
            my_size += ::protobuf::rt::int32_size(7, v.value());
        }
        if let Some(v) = self.is_physical {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_terminal {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_control {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_monitor {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.node_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.alias.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.etype {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.edirection {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.is_physical {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.is_terminal {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.is_control {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.is_monitor {
            os.write_bool(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemAudioManagerPort {
        CMsgSystemAudioManagerPort::new()
    }

    fn clear(&mut self) {
        self.base.clear();
        self.node_id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.alias = ::std::option::Option::None;
        self.etype = ::std::option::Option::None;
        self.edirection = ::std::option::Option::None;
        self.is_physical = ::std::option::Option::None;
        self.is_terminal = ::std::option::Option::None;
        self.is_control = ::std::option::Option::None;
        self.is_monitor = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemAudioManagerPort {
        static instance: CMsgSystemAudioManagerPort = CMsgSystemAudioManagerPort {
            base: ::protobuf::MessageField::none(),
            node_id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            alias: ::std::option::Option::None,
            etype: ::std::option::Option::None,
            edirection: ::std::option::Option::None,
            is_physical: ::std::option::Option::None,
            is_terminal: ::std::option::Option::None,
            is_control: ::std::option::Option::None,
            is_monitor: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSystemAudioManagerLink)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemAudioManagerLink {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerLink.base)
    pub base: ::protobuf::MessageField<CMsgSystemAudioManagerObject>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerLink.output_node_id)
    pub output_node_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerLink.output_port_id)
    pub output_port_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerLink.input_node_id)
    pub input_node_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerLink.input_port_id)
    pub input_port_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemAudioManagerLink.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemAudioManagerLink {
    fn default() -> &'a CMsgSystemAudioManagerLink {
        <CMsgSystemAudioManagerLink as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSystemAudioManagerLink {
    pub fn new() -> CMsgSystemAudioManagerLink {
        ::std::default::Default::default()
    }

    // optional uint32 output_node_id = 2;

    pub fn output_node_id(&self) -> u32 {
        self.output_node_id.unwrap_or(0)
    }

    pub fn clear_output_node_id(&mut self) {
        self.output_node_id = ::std::option::Option::None;
    }

    pub fn has_output_node_id(&self) -> bool {
        self.output_node_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_output_node_id(&mut self, v: u32) {
        self.output_node_id = ::std::option::Option::Some(v);
    }

    // optional uint32 output_port_id = 3;

    pub fn output_port_id(&self) -> u32 {
        self.output_port_id.unwrap_or(0)
    }

    pub fn clear_output_port_id(&mut self) {
        self.output_port_id = ::std::option::Option::None;
    }

    pub fn has_output_port_id(&self) -> bool {
        self.output_port_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_output_port_id(&mut self, v: u32) {
        self.output_port_id = ::std::option::Option::Some(v);
    }

    // optional uint32 input_node_id = 4;

    pub fn input_node_id(&self) -> u32 {
        self.input_node_id.unwrap_or(0)
    }

    pub fn clear_input_node_id(&mut self) {
        self.input_node_id = ::std::option::Option::None;
    }

    pub fn has_input_node_id(&self) -> bool {
        self.input_node_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_node_id(&mut self, v: u32) {
        self.input_node_id = ::std::option::Option::Some(v);
    }

    // optional uint32 input_port_id = 5;

    pub fn input_port_id(&self) -> u32 {
        self.input_port_id.unwrap_or(0)
    }

    pub fn clear_input_port_id(&mut self) {
        self.input_port_id = ::std::option::Option::None;
    }

    pub fn has_input_port_id(&self) -> bool {
        self.input_port_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_port_id(&mut self, v: u32) {
        self.input_port_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSystemAudioManagerLink {
    const NAME: &'static str = "CMsgSystemAudioManagerLink";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.base)?;
                },
                16 => {
                    self.output_node_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.output_port_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.input_node_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.input_port_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.output_node_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.output_port_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.input_node_id {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.input_port_id {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.output_node_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.output_port_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.input_node_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.input_port_id {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemAudioManagerLink {
        CMsgSystemAudioManagerLink::new()
    }

    fn clear(&mut self) {
        self.base.clear();
        self.output_node_id = ::std::option::Option::None;
        self.output_port_id = ::std::option::Option::None;
        self.input_node_id = ::std::option::Option::None;
        self.input_port_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemAudioManagerLink {
        static instance: CMsgSystemAudioManagerLink = CMsgSystemAudioManagerLink {
            base: ::protobuf::MessageField::none(),
            output_node_id: ::std::option::Option::None,
            output_port_id: ::std::option::Option::None,
            input_node_id: ::std::option::Option::None,
            input_port_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSystemAudioManagerStateHW)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemAudioManagerStateHW {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerStateHW.devices)
    pub devices: ::std::vec::Vec<CMsgSystemAudioManagerDevice>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerStateHW.nodes)
    pub nodes: ::std::vec::Vec<CMsgSystemAudioManagerNode>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerStateHW.ports)
    pub ports: ::std::vec::Vec<CMsgSystemAudioManagerPort>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerStateHW.links)
    pub links: ::std::vec::Vec<CMsgSystemAudioManagerLink>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemAudioManagerStateHW.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemAudioManagerStateHW {
    fn default() -> &'a CMsgSystemAudioManagerStateHW {
        <CMsgSystemAudioManagerStateHW as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSystemAudioManagerStateHW {
    pub fn new() -> CMsgSystemAudioManagerStateHW {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgSystemAudioManagerStateHW {
    const NAME: &'static str = "CMsgSystemAudioManagerStateHW";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.devices.push(is.read_message()?);
                },
                18 => {
                    self.nodes.push(is.read_message()?);
                },
                26 => {
                    self.ports.push(is.read_message()?);
                },
                34 => {
                    self.links.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.devices {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.nodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.ports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.links {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.devices {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.nodes {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.ports {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.links {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemAudioManagerStateHW {
        CMsgSystemAudioManagerStateHW::new()
    }

    fn clear(&mut self) {
        self.devices.clear();
        self.nodes.clear();
        self.ports.clear();
        self.links.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemAudioManagerStateHW {
        static instance: CMsgSystemAudioManagerStateHW = CMsgSystemAudioManagerStateHW {
            devices: ::std::vec::Vec::new(),
            nodes: ::std::vec::Vec::new(),
            ports: ::std::vec::Vec::new(),
            links: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSystemAudioManagerState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemAudioManagerState {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerState.rtime_filter)
    pub rtime_filter: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerState.counter)
    pub counter: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerState.hw)
    pub hw: ::protobuf::MessageField<CMsgSystemAudioManagerStateHW>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemAudioManagerState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemAudioManagerState {
    fn default() -> &'a CMsgSystemAudioManagerState {
        <CMsgSystemAudioManagerState as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSystemAudioManagerState {
    pub fn new() -> CMsgSystemAudioManagerState {
        ::std::default::Default::default()
    }

    // optional fixed32 rtime_filter = 1;

    pub fn rtime_filter(&self) -> u32 {
        self.rtime_filter.unwrap_or(0)
    }

    pub fn clear_rtime_filter(&mut self) {
        self.rtime_filter = ::std::option::Option::None;
    }

    pub fn has_rtime_filter(&self) -> bool {
        self.rtime_filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime_filter(&mut self, v: u32) {
        self.rtime_filter = ::std::option::Option::Some(v);
    }

    // optional int32 counter = 2;

    pub fn counter(&self) -> i32 {
        self.counter.unwrap_or(0)
    }

    pub fn clear_counter(&mut self) {
        self.counter = ::std::option::Option::None;
    }

    pub fn has_counter(&self) -> bool {
        self.counter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_counter(&mut self, v: i32) {
        self.counter = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSystemAudioManagerState {
    const NAME: &'static str = "CMsgSystemAudioManagerState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.rtime_filter = ::std::option::Option::Some(is.read_fixed32()?);
                },
                16 => {
                    self.counter = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.hw)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rtime_filter {
            my_size += 1 + 4;
        }
        if let Some(v) = self.counter {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.hw.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.rtime_filter {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.counter {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.hw.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemAudioManagerState {
        CMsgSystemAudioManagerState::new()
    }

    fn clear(&mut self) {
        self.rtime_filter = ::std::option::Option::None;
        self.counter = ::std::option::Option::None;
        self.hw.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemAudioManagerState {
        static instance: CMsgSystemAudioManagerState = CMsgSystemAudioManagerState {
            rtime_filter: ::std::option::Option::None,
            counter: ::std::option::Option::None,
            hw: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSystemAudioManagerUpdateSomething)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemAudioManagerUpdateSomething {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemAudioManagerUpdateSomething.counter)
    pub counter: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemAudioManagerUpdateSomething.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemAudioManagerUpdateSomething {
    fn default() -> &'a CMsgSystemAudioManagerUpdateSomething {
        <CMsgSystemAudioManagerUpdateSomething as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSystemAudioManagerUpdateSomething {
    pub fn new() -> CMsgSystemAudioManagerUpdateSomething {
        ::std::default::Default::default()
    }

    // optional int32 counter = 1;

    pub fn counter(&self) -> i32 {
        self.counter.unwrap_or(0)
    }

    pub fn clear_counter(&mut self) {
        self.counter = ::std::option::Option::None;
    }

    pub fn has_counter(&self) -> bool {
        self.counter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_counter(&mut self, v: i32) {
        self.counter = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSystemAudioManagerUpdateSomething {
    const NAME: &'static str = "CMsgSystemAudioManagerUpdateSomething";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.counter = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.counter {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.counter {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemAudioManagerUpdateSomething {
        CMsgSystemAudioManagerUpdateSomething::new()
    }

    fn clear(&mut self) {
        self.counter = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemAudioManagerUpdateSomething {
        static instance: CMsgSystemAudioManagerUpdateSomething = CMsgSystemAudioManagerUpdateSomething {
            counter: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSystemDisplayMode)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemDisplayMode {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemDisplayMode.id)
    pub id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemDisplayMode.width)
    pub width: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemDisplayMode.height)
    pub height: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemDisplayMode.refresh_hz)
    pub refresh_hz: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemDisplayMode.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemDisplayMode {
    fn default() -> &'a CMsgSystemDisplayMode {
        <CMsgSystemDisplayMode as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSystemDisplayMode {
    pub fn new() -> CMsgSystemDisplayMode {
        ::std::default::Default::default()
    }

    // optional int32 id = 1;

    pub fn id(&self) -> i32 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional int32 width = 2;

    pub fn width(&self) -> i32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: i32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional int32 height = 3;

    pub fn height(&self) -> i32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional int32 refresh_hz = 4;

    pub fn refresh_hz(&self) -> i32 {
        self.refresh_hz.unwrap_or(0)
    }

    pub fn clear_refresh_hz(&mut self) {
        self.refresh_hz = ::std::option::Option::None;
    }

    pub fn has_refresh_hz(&self) -> bool {
        self.refresh_hz.is_some()
    }

    // Param is passed by value, moved
    pub fn set_refresh_hz(&mut self, v: i32) {
        self.refresh_hz = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSystemDisplayMode {
    const NAME: &'static str = "CMsgSystemDisplayMode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.width = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.height = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.refresh_hz = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.refresh_hz {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.width {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.height {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.refresh_hz {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemDisplayMode {
        CMsgSystemDisplayMode::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.refresh_hz = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemDisplayMode {
        static instance: CMsgSystemDisplayMode = CMsgSystemDisplayMode {
            id: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            refresh_hz: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSystemDisplay)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemDisplay {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemDisplay.id)
    pub id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemDisplay.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSystemDisplay.description)
    pub description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSystemDisplay.is_primary)
    pub is_primary: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemDisplay.is_enabled)
    pub is_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemDisplay.is_internal)
    pub is_internal: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemDisplay.has_mode_override)
    pub has_mode_override: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemDisplay.width_mm)
    pub width_mm: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemDisplay.height_mm)
    pub height_mm: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemDisplay.current_mode_id)
    pub current_mode_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemDisplay.modes)
    pub modes: ::std::vec::Vec<CMsgSystemDisplayMode>,
    // @@protoc_insertion_point(field:CMsgSystemDisplay.refresh_rate_min)
    pub refresh_rate_min: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemDisplay.refresh_rate_max)
    pub refresh_rate_max: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemDisplay.is_vrr_capable)
    pub is_vrr_capable: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemDisplay.is_vrr_enabled)
    pub is_vrr_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemDisplay.is_hdr_capable)
    pub is_hdr_capable: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemDisplay.is_hdr_enabled)
    pub is_hdr_enabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemDisplay.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemDisplay {
    fn default() -> &'a CMsgSystemDisplay {
        <CMsgSystemDisplay as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSystemDisplay {
    pub fn new() -> CMsgSystemDisplay {
        ::std::default::Default::default()
    }

    // optional int32 id = 1;

    pub fn id(&self) -> i32 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string description = 3;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_primary = 4;

    pub fn is_primary(&self) -> bool {
        self.is_primary.unwrap_or(false)
    }

    pub fn clear_is_primary(&mut self) {
        self.is_primary = ::std::option::Option::None;
    }

    pub fn has_is_primary(&self) -> bool {
        self.is_primary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_primary(&mut self, v: bool) {
        self.is_primary = ::std::option::Option::Some(v);
    }

    // optional bool is_enabled = 5;

    pub fn is_enabled(&self) -> bool {
        self.is_enabled.unwrap_or(false)
    }

    pub fn clear_is_enabled(&mut self) {
        self.is_enabled = ::std::option::Option::None;
    }

    pub fn has_is_enabled(&self) -> bool {
        self.is_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_enabled(&mut self, v: bool) {
        self.is_enabled = ::std::option::Option::Some(v);
    }

    // optional bool is_internal = 6;

    pub fn is_internal(&self) -> bool {
        self.is_internal.unwrap_or(false)
    }

    pub fn clear_is_internal(&mut self) {
        self.is_internal = ::std::option::Option::None;
    }

    pub fn has_is_internal(&self) -> bool {
        self.is_internal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_internal(&mut self, v: bool) {
        self.is_internal = ::std::option::Option::Some(v);
    }

    // optional bool has_mode_override = 7;

    pub fn has_mode_override(&self) -> bool {
        self.has_mode_override.unwrap_or(false)
    }

    pub fn clear_has_mode_override(&mut self) {
        self.has_mode_override = ::std::option::Option::None;
    }

    pub fn has_has_mode_override(&self) -> bool {
        self.has_mode_override.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_mode_override(&mut self, v: bool) {
        self.has_mode_override = ::std::option::Option::Some(v);
    }

    // optional int32 width_mm = 8;

    pub fn width_mm(&self) -> i32 {
        self.width_mm.unwrap_or(0)
    }

    pub fn clear_width_mm(&mut self) {
        self.width_mm = ::std::option::Option::None;
    }

    pub fn has_width_mm(&self) -> bool {
        self.width_mm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width_mm(&mut self, v: i32) {
        self.width_mm = ::std::option::Option::Some(v);
    }

    // optional int32 height_mm = 9;

    pub fn height_mm(&self) -> i32 {
        self.height_mm.unwrap_or(0)
    }

    pub fn clear_height_mm(&mut self) {
        self.height_mm = ::std::option::Option::None;
    }

    pub fn has_height_mm(&self) -> bool {
        self.height_mm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height_mm(&mut self, v: i32) {
        self.height_mm = ::std::option::Option::Some(v);
    }

    // optional int32 current_mode_id = 10;

    pub fn current_mode_id(&self) -> i32 {
        self.current_mode_id.unwrap_or(0)
    }

    pub fn clear_current_mode_id(&mut self) {
        self.current_mode_id = ::std::option::Option::None;
    }

    pub fn has_current_mode_id(&self) -> bool {
        self.current_mode_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_mode_id(&mut self, v: i32) {
        self.current_mode_id = ::std::option::Option::Some(v);
    }

    // optional int32 refresh_rate_min = 12;

    pub fn refresh_rate_min(&self) -> i32 {
        self.refresh_rate_min.unwrap_or(0)
    }

    pub fn clear_refresh_rate_min(&mut self) {
        self.refresh_rate_min = ::std::option::Option::None;
    }

    pub fn has_refresh_rate_min(&self) -> bool {
        self.refresh_rate_min.is_some()
    }

    // Param is passed by value, moved
    pub fn set_refresh_rate_min(&mut self, v: i32) {
        self.refresh_rate_min = ::std::option::Option::Some(v);
    }

    // optional int32 refresh_rate_max = 13;

    pub fn refresh_rate_max(&self) -> i32 {
        self.refresh_rate_max.unwrap_or(0)
    }

    pub fn clear_refresh_rate_max(&mut self) {
        self.refresh_rate_max = ::std::option::Option::None;
    }

    pub fn has_refresh_rate_max(&self) -> bool {
        self.refresh_rate_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_refresh_rate_max(&mut self, v: i32) {
        self.refresh_rate_max = ::std::option::Option::Some(v);
    }

    // optional bool is_vrr_capable = 14;

    pub fn is_vrr_capable(&self) -> bool {
        self.is_vrr_capable.unwrap_or(false)
    }

    pub fn clear_is_vrr_capable(&mut self) {
        self.is_vrr_capable = ::std::option::Option::None;
    }

    pub fn has_is_vrr_capable(&self) -> bool {
        self.is_vrr_capable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_vrr_capable(&mut self, v: bool) {
        self.is_vrr_capable = ::std::option::Option::Some(v);
    }

    // optional bool is_vrr_enabled = 15;

    pub fn is_vrr_enabled(&self) -> bool {
        self.is_vrr_enabled.unwrap_or(false)
    }

    pub fn clear_is_vrr_enabled(&mut self) {
        self.is_vrr_enabled = ::std::option::Option::None;
    }

    pub fn has_is_vrr_enabled(&self) -> bool {
        self.is_vrr_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_vrr_enabled(&mut self, v: bool) {
        self.is_vrr_enabled = ::std::option::Option::Some(v);
    }

    // optional bool is_hdr_capable = 16;

    pub fn is_hdr_capable(&self) -> bool {
        self.is_hdr_capable.unwrap_or(false)
    }

    pub fn clear_is_hdr_capable(&mut self) {
        self.is_hdr_capable = ::std::option::Option::None;
    }

    pub fn has_is_hdr_capable(&self) -> bool {
        self.is_hdr_capable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_hdr_capable(&mut self, v: bool) {
        self.is_hdr_capable = ::std::option::Option::Some(v);
    }

    // optional bool is_hdr_enabled = 17;

    pub fn is_hdr_enabled(&self) -> bool {
        self.is_hdr_enabled.unwrap_or(false)
    }

    pub fn clear_is_hdr_enabled(&mut self) {
        self.is_hdr_enabled = ::std::option::Option::None;
    }

    pub fn has_is_hdr_enabled(&self) -> bool {
        self.is_hdr_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_hdr_enabled(&mut self, v: bool) {
        self.is_hdr_enabled = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSystemDisplay {
    const NAME: &'static str = "CMsgSystemDisplay";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.is_primary = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.is_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.is_internal = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.has_mode_override = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.width_mm = ::std::option::Option::Some(is.read_int32()?);
                },
                72 => {
                    self.height_mm = ::std::option::Option::Some(is.read_int32()?);
                },
                80 => {
                    self.current_mode_id = ::std::option::Option::Some(is.read_int32()?);
                },
                90 => {
                    self.modes.push(is.read_message()?);
                },
                96 => {
                    self.refresh_rate_min = ::std::option::Option::Some(is.read_int32()?);
                },
                104 => {
                    self.refresh_rate_max = ::std::option::Option::Some(is.read_int32()?);
                },
                112 => {
                    self.is_vrr_capable = ::std::option::Option::Some(is.read_bool()?);
                },
                120 => {
                    self.is_vrr_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                128 => {
                    self.is_hdr_capable = ::std::option::Option::Some(is.read_bool()?);
                },
                136 => {
                    self.is_hdr_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.is_primary {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_internal {
            my_size += 1 + 1;
        }
        if let Some(v) = self.has_mode_override {
            my_size += 1 + 1;
        }
        if let Some(v) = self.width_mm {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.height_mm {
            my_size += ::protobuf::rt::int32_size(9, v);
        }
        if let Some(v) = self.current_mode_id {
            my_size += ::protobuf::rt::int32_size(10, v);
        }
        for value in &self.modes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.refresh_rate_min {
            my_size += ::protobuf::rt::int32_size(12, v);
        }
        if let Some(v) = self.refresh_rate_max {
            my_size += ::protobuf::rt::int32_size(13, v);
        }
        if let Some(v) = self.is_vrr_capable {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_vrr_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_hdr_capable {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_hdr_enabled {
            my_size += 2 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.is_primary {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.is_enabled {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.is_internal {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.has_mode_override {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.width_mm {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.height_mm {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.current_mode_id {
            os.write_int32(10, v)?;
        }
        for v in &self.modes {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        if let Some(v) = self.refresh_rate_min {
            os.write_int32(12, v)?;
        }
        if let Some(v) = self.refresh_rate_max {
            os.write_int32(13, v)?;
        }
        if let Some(v) = self.is_vrr_capable {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.is_vrr_enabled {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.is_hdr_capable {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.is_hdr_enabled {
            os.write_bool(17, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemDisplay {
        CMsgSystemDisplay::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.description = ::std::option::Option::None;
        self.is_primary = ::std::option::Option::None;
        self.is_enabled = ::std::option::Option::None;
        self.is_internal = ::std::option::Option::None;
        self.has_mode_override = ::std::option::Option::None;
        self.width_mm = ::std::option::Option::None;
        self.height_mm = ::std::option::Option::None;
        self.current_mode_id = ::std::option::Option::None;
        self.modes.clear();
        self.refresh_rate_min = ::std::option::Option::None;
        self.refresh_rate_max = ::std::option::Option::None;
        self.is_vrr_capable = ::std::option::Option::None;
        self.is_vrr_enabled = ::std::option::Option::None;
        self.is_hdr_capable = ::std::option::Option::None;
        self.is_hdr_enabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemDisplay {
        static instance: CMsgSystemDisplay = CMsgSystemDisplay {
            id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            description: ::std::option::Option::None,
            is_primary: ::std::option::Option::None,
            is_enabled: ::std::option::Option::None,
            is_internal: ::std::option::Option::None,
            has_mode_override: ::std::option::Option::None,
            width_mm: ::std::option::Option::None,
            height_mm: ::std::option::Option::None,
            current_mode_id: ::std::option::Option::None,
            modes: ::std::vec::Vec::new(),
            refresh_rate_min: ::std::option::Option::None,
            refresh_rate_max: ::std::option::Option::None,
            is_vrr_capable: ::std::option::Option::None,
            is_vrr_enabled: ::std::option::Option::None,
            is_hdr_capable: ::std::option::Option::None,
            is_hdr_enabled: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSystemDisplayManagerState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemDisplayManagerState {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemDisplayManagerState.displays)
    pub displays: ::std::vec::Vec<CMsgSystemDisplay>,
    // @@protoc_insertion_point(field:CMsgSystemDisplayManagerState.is_mode_switching_supported)
    pub is_mode_switching_supported: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemDisplayManagerState.compatibility_mode)
    pub compatibility_mode: ::std::option::Option<::protobuf::EnumOrUnknown<super::enums::ESystemDisplayCompatibilityMode>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemDisplayManagerState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemDisplayManagerState {
    fn default() -> &'a CMsgSystemDisplayManagerState {
        <CMsgSystemDisplayManagerState as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSystemDisplayManagerState {
    pub fn new() -> CMsgSystemDisplayManagerState {
        ::std::default::Default::default()
    }

    // optional bool is_mode_switching_supported = 2;

    pub fn is_mode_switching_supported(&self) -> bool {
        self.is_mode_switching_supported.unwrap_or(false)
    }

    pub fn clear_is_mode_switching_supported(&mut self) {
        self.is_mode_switching_supported = ::std::option::Option::None;
    }

    pub fn has_is_mode_switching_supported(&self) -> bool {
        self.is_mode_switching_supported.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_mode_switching_supported(&mut self, v: bool) {
        self.is_mode_switching_supported = ::std::option::Option::Some(v);
    }

    // optional .ESystemDisplayCompatibilityMode compatibility_mode = 3;

    pub fn compatibility_mode(&self) -> super::enums::ESystemDisplayCompatibilityMode {
        match self.compatibility_mode {
            Some(e) => e.enum_value_or(super::enums::ESystemDisplayCompatibilityMode::k_ESystemDisplayCompatibilityMode_Invalid),
            None => super::enums::ESystemDisplayCompatibilityMode::k_ESystemDisplayCompatibilityMode_Invalid,
        }
    }

    pub fn clear_compatibility_mode(&mut self) {
        self.compatibility_mode = ::std::option::Option::None;
    }

    pub fn has_compatibility_mode(&self) -> bool {
        self.compatibility_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_compatibility_mode(&mut self, v: super::enums::ESystemDisplayCompatibilityMode) {
        self.compatibility_mode = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::protobuf::Message for CMsgSystemDisplayManagerState {
    const NAME: &'static str = "CMsgSystemDisplayManagerState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.displays.push(is.read_message()?);
                },
                16 => {
                    self.is_mode_switching_supported = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.compatibility_mode = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.displays {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.is_mode_switching_supported {
            my_size += 1 + 1;
        }
        if let Some(v) = self.compatibility_mode {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.displays {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.is_mode_switching_supported {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.compatibility_mode {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemDisplayManagerState {
        CMsgSystemDisplayManagerState::new()
    }

    fn clear(&mut self) {
        self.displays.clear();
        self.is_mode_switching_supported = ::std::option::Option::None;
        self.compatibility_mode = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemDisplayManagerState {
        static instance: CMsgSystemDisplayManagerState = CMsgSystemDisplayManagerState {
            displays: ::std::vec::Vec::new(),
            is_mode_switching_supported: ::std::option::Option::None,
            compatibility_mode: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSystemDisplayManagerSetMode)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemDisplayManagerSetMode {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemDisplayManagerSetMode.display_id)
    pub display_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSystemDisplayManagerSetMode.mode_id)
    pub mode_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemDisplayManagerSetMode.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemDisplayManagerSetMode {
    fn default() -> &'a CMsgSystemDisplayManagerSetMode {
        <CMsgSystemDisplayManagerSetMode as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSystemDisplayManagerSetMode {
    pub fn new() -> CMsgSystemDisplayManagerSetMode {
        ::std::default::Default::default()
    }

    // optional int32 display_id = 1;

    pub fn display_id(&self) -> i32 {
        self.display_id.unwrap_or(0)
    }

    pub fn clear_display_id(&mut self) {
        self.display_id = ::std::option::Option::None;
    }

    pub fn has_display_id(&self) -> bool {
        self.display_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_id(&mut self, v: i32) {
        self.display_id = ::std::option::Option::Some(v);
    }

    // optional int32 mode_id = 2;

    pub fn mode_id(&self) -> i32 {
        self.mode_id.unwrap_or(0)
    }

    pub fn clear_mode_id(&mut self) {
        self.mode_id = ::std::option::Option::None;
    }

    pub fn has_mode_id(&self) -> bool {
        self.mode_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode_id(&mut self, v: i32) {
        self.mode_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSystemDisplayManagerSetMode {
    const NAME: &'static str = "CMsgSystemDisplayManagerSetMode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.display_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.mode_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.display_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.mode_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.display_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.mode_id {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemDisplayManagerSetMode {
        CMsgSystemDisplayManagerSetMode::new()
    }

    fn clear(&mut self) {
        self.display_id = ::std::option::Option::None;
        self.mode_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemDisplayManagerSetMode {
        static instance: CMsgSystemDisplayManagerSetMode = CMsgSystemDisplayManagerSetMode {
            display_id: ::std::option::Option::None,
            mode_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSystemManagerSettings)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemManagerSettings {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.idle_backlight_dim_battery_seconds)
    pub idle_backlight_dim_battery_seconds: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.idle_backlight_dim_ac_seconds)
    pub idle_backlight_dim_ac_seconds: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.idle_suspend_battery_seconds)
    pub idle_suspend_battery_seconds: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.idle_suspend_ac_seconds)
    pub idle_suspend_ac_seconds: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.idle_suspend_supressed)
    pub idle_suspend_supressed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.is_adaptive_brightness_available)
    pub is_adaptive_brightness_available: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.display_adaptive_brightness_enabled)
    pub display_adaptive_brightness_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.display_nightmode_enabled)
    pub display_nightmode_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.display_nightmode_tintstrength)
    pub display_nightmode_tintstrength: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.display_nightmode_maxhue)
    pub display_nightmode_maxhue: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.display_nightmode_maxsat)
    pub display_nightmode_maxsat: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.display_nightmode_uiexp)
    pub display_nightmode_uiexp: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.display_nightmode_blend)
    pub display_nightmode_blend: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.display_nightmode_reset)
    pub display_nightmode_reset: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.display_nightmode_schedule_enabled)
    pub display_nightmode_schedule_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.display_nightmode_schedule_starttime)
    pub display_nightmode_schedule_starttime: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.display_nightmode_schedule_endtime)
    pub display_nightmode_schedule_endtime: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.display_diagnostics_enabled)
    pub display_diagnostics_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.als_lux_latest)
    pub als_lux_latest: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.als_lux_median)
    pub als_lux_median: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.display_backlight_raw)
    pub display_backlight_raw: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.display_brightness_adaptivemin)
    pub display_brightness_adaptivemin: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.display_brightness_adaptivemax)
    pub display_brightness_adaptivemax: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.is_wifi_powersave_enabled)
    pub is_wifi_powersave_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.is_fan_control_available)
    pub is_fan_control_available: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.fan_control_mode)
    pub fan_control_mode: ::std::option::Option<::protobuf::EnumOrUnknown<super::enums::ESystemFanControlMode>>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.is_display_brightness_available)
    pub is_display_brightness_available: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.is_display_colormanagement_available)
    pub is_display_colormanagement_available: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemManagerSettings.display_colorgamut)
    pub display_colorgamut: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemManagerSettings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemManagerSettings {
    fn default() -> &'a CMsgSystemManagerSettings {
        <CMsgSystemManagerSettings as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSystemManagerSettings {
    pub fn new() -> CMsgSystemManagerSettings {
        ::std::default::Default::default()
    }

    // optional float idle_backlight_dim_battery_seconds = 1;

    pub fn idle_backlight_dim_battery_seconds(&self) -> f32 {
        self.idle_backlight_dim_battery_seconds.unwrap_or(0.)
    }

    pub fn clear_idle_backlight_dim_battery_seconds(&mut self) {
        self.idle_backlight_dim_battery_seconds = ::std::option::Option::None;
    }

    pub fn has_idle_backlight_dim_battery_seconds(&self) -> bool {
        self.idle_backlight_dim_battery_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_idle_backlight_dim_battery_seconds(&mut self, v: f32) {
        self.idle_backlight_dim_battery_seconds = ::std::option::Option::Some(v);
    }

    // optional float idle_backlight_dim_ac_seconds = 2;

    pub fn idle_backlight_dim_ac_seconds(&self) -> f32 {
        self.idle_backlight_dim_ac_seconds.unwrap_or(0.)
    }

    pub fn clear_idle_backlight_dim_ac_seconds(&mut self) {
        self.idle_backlight_dim_ac_seconds = ::std::option::Option::None;
    }

    pub fn has_idle_backlight_dim_ac_seconds(&self) -> bool {
        self.idle_backlight_dim_ac_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_idle_backlight_dim_ac_seconds(&mut self, v: f32) {
        self.idle_backlight_dim_ac_seconds = ::std::option::Option::Some(v);
    }

    // optional float idle_suspend_battery_seconds = 3;

    pub fn idle_suspend_battery_seconds(&self) -> f32 {
        self.idle_suspend_battery_seconds.unwrap_or(0.)
    }

    pub fn clear_idle_suspend_battery_seconds(&mut self) {
        self.idle_suspend_battery_seconds = ::std::option::Option::None;
    }

    pub fn has_idle_suspend_battery_seconds(&self) -> bool {
        self.idle_suspend_battery_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_idle_suspend_battery_seconds(&mut self, v: f32) {
        self.idle_suspend_battery_seconds = ::std::option::Option::Some(v);
    }

    // optional float idle_suspend_ac_seconds = 4;

    pub fn idle_suspend_ac_seconds(&self) -> f32 {
        self.idle_suspend_ac_seconds.unwrap_or(0.)
    }

    pub fn clear_idle_suspend_ac_seconds(&mut self) {
        self.idle_suspend_ac_seconds = ::std::option::Option::None;
    }

    pub fn has_idle_suspend_ac_seconds(&self) -> bool {
        self.idle_suspend_ac_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_idle_suspend_ac_seconds(&mut self, v: f32) {
        self.idle_suspend_ac_seconds = ::std::option::Option::Some(v);
    }

    // optional bool idle_suspend_supressed = 5;

    pub fn idle_suspend_supressed(&self) -> bool {
        self.idle_suspend_supressed.unwrap_or(false)
    }

    pub fn clear_idle_suspend_supressed(&mut self) {
        self.idle_suspend_supressed = ::std::option::Option::None;
    }

    pub fn has_idle_suspend_supressed(&self) -> bool {
        self.idle_suspend_supressed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_idle_suspend_supressed(&mut self, v: bool) {
        self.idle_suspend_supressed = ::std::option::Option::Some(v);
    }

    // optional bool is_adaptive_brightness_available = 6;

    pub fn is_adaptive_brightness_available(&self) -> bool {
        self.is_adaptive_brightness_available.unwrap_or(false)
    }

    pub fn clear_is_adaptive_brightness_available(&mut self) {
        self.is_adaptive_brightness_available = ::std::option::Option::None;
    }

    pub fn has_is_adaptive_brightness_available(&self) -> bool {
        self.is_adaptive_brightness_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_adaptive_brightness_available(&mut self, v: bool) {
        self.is_adaptive_brightness_available = ::std::option::Option::Some(v);
    }

    // optional bool display_adaptive_brightness_enabled = 7;

    pub fn display_adaptive_brightness_enabled(&self) -> bool {
        self.display_adaptive_brightness_enabled.unwrap_or(false)
    }

    pub fn clear_display_adaptive_brightness_enabled(&mut self) {
        self.display_adaptive_brightness_enabled = ::std::option::Option::None;
    }

    pub fn has_display_adaptive_brightness_enabled(&self) -> bool {
        self.display_adaptive_brightness_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_adaptive_brightness_enabled(&mut self, v: bool) {
        self.display_adaptive_brightness_enabled = ::std::option::Option::Some(v);
    }

    // optional bool display_nightmode_enabled = 10;

    pub fn display_nightmode_enabled(&self) -> bool {
        self.display_nightmode_enabled.unwrap_or(false)
    }

    pub fn clear_display_nightmode_enabled(&mut self) {
        self.display_nightmode_enabled = ::std::option::Option::None;
    }

    pub fn has_display_nightmode_enabled(&self) -> bool {
        self.display_nightmode_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_nightmode_enabled(&mut self, v: bool) {
        self.display_nightmode_enabled = ::std::option::Option::Some(v);
    }

    // optional float display_nightmode_tintstrength = 11;

    pub fn display_nightmode_tintstrength(&self) -> f32 {
        self.display_nightmode_tintstrength.unwrap_or(0.)
    }

    pub fn clear_display_nightmode_tintstrength(&mut self) {
        self.display_nightmode_tintstrength = ::std::option::Option::None;
    }

    pub fn has_display_nightmode_tintstrength(&self) -> bool {
        self.display_nightmode_tintstrength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_nightmode_tintstrength(&mut self, v: f32) {
        self.display_nightmode_tintstrength = ::std::option::Option::Some(v);
    }

    // optional float display_nightmode_maxhue = 12;

    pub fn display_nightmode_maxhue(&self) -> f32 {
        self.display_nightmode_maxhue.unwrap_or(0.)
    }

    pub fn clear_display_nightmode_maxhue(&mut self) {
        self.display_nightmode_maxhue = ::std::option::Option::None;
    }

    pub fn has_display_nightmode_maxhue(&self) -> bool {
        self.display_nightmode_maxhue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_nightmode_maxhue(&mut self, v: f32) {
        self.display_nightmode_maxhue = ::std::option::Option::Some(v);
    }

    // optional float display_nightmode_maxsat = 13;

    pub fn display_nightmode_maxsat(&self) -> f32 {
        self.display_nightmode_maxsat.unwrap_or(0.)
    }

    pub fn clear_display_nightmode_maxsat(&mut self) {
        self.display_nightmode_maxsat = ::std::option::Option::None;
    }

    pub fn has_display_nightmode_maxsat(&self) -> bool {
        self.display_nightmode_maxsat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_nightmode_maxsat(&mut self, v: f32) {
        self.display_nightmode_maxsat = ::std::option::Option::Some(v);
    }

    // optional float display_nightmode_uiexp = 14;

    pub fn display_nightmode_uiexp(&self) -> f32 {
        self.display_nightmode_uiexp.unwrap_or(0.)
    }

    pub fn clear_display_nightmode_uiexp(&mut self) {
        self.display_nightmode_uiexp = ::std::option::Option::None;
    }

    pub fn has_display_nightmode_uiexp(&self) -> bool {
        self.display_nightmode_uiexp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_nightmode_uiexp(&mut self, v: f32) {
        self.display_nightmode_uiexp = ::std::option::Option::Some(v);
    }

    // optional float display_nightmode_blend = 15;

    pub fn display_nightmode_blend(&self) -> f32 {
        self.display_nightmode_blend.unwrap_or(0.)
    }

    pub fn clear_display_nightmode_blend(&mut self) {
        self.display_nightmode_blend = ::std::option::Option::None;
    }

    pub fn has_display_nightmode_blend(&self) -> bool {
        self.display_nightmode_blend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_nightmode_blend(&mut self, v: f32) {
        self.display_nightmode_blend = ::std::option::Option::Some(v);
    }

    // optional bool display_nightmode_reset = 16;

    pub fn display_nightmode_reset(&self) -> bool {
        self.display_nightmode_reset.unwrap_or(false)
    }

    pub fn clear_display_nightmode_reset(&mut self) {
        self.display_nightmode_reset = ::std::option::Option::None;
    }

    pub fn has_display_nightmode_reset(&self) -> bool {
        self.display_nightmode_reset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_nightmode_reset(&mut self, v: bool) {
        self.display_nightmode_reset = ::std::option::Option::Some(v);
    }

    // optional bool display_nightmode_schedule_enabled = 17;

    pub fn display_nightmode_schedule_enabled(&self) -> bool {
        self.display_nightmode_schedule_enabled.unwrap_or(false)
    }

    pub fn clear_display_nightmode_schedule_enabled(&mut self) {
        self.display_nightmode_schedule_enabled = ::std::option::Option::None;
    }

    pub fn has_display_nightmode_schedule_enabled(&self) -> bool {
        self.display_nightmode_schedule_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_nightmode_schedule_enabled(&mut self, v: bool) {
        self.display_nightmode_schedule_enabled = ::std::option::Option::Some(v);
    }

    // optional float display_nightmode_schedule_starttime = 18;

    pub fn display_nightmode_schedule_starttime(&self) -> f32 {
        self.display_nightmode_schedule_starttime.unwrap_or(0.)
    }

    pub fn clear_display_nightmode_schedule_starttime(&mut self) {
        self.display_nightmode_schedule_starttime = ::std::option::Option::None;
    }

    pub fn has_display_nightmode_schedule_starttime(&self) -> bool {
        self.display_nightmode_schedule_starttime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_nightmode_schedule_starttime(&mut self, v: f32) {
        self.display_nightmode_schedule_starttime = ::std::option::Option::Some(v);
    }

    // optional float display_nightmode_schedule_endtime = 19;

    pub fn display_nightmode_schedule_endtime(&self) -> f32 {
        self.display_nightmode_schedule_endtime.unwrap_or(0.)
    }

    pub fn clear_display_nightmode_schedule_endtime(&mut self) {
        self.display_nightmode_schedule_endtime = ::std::option::Option::None;
    }

    pub fn has_display_nightmode_schedule_endtime(&self) -> bool {
        self.display_nightmode_schedule_endtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_nightmode_schedule_endtime(&mut self, v: f32) {
        self.display_nightmode_schedule_endtime = ::std::option::Option::Some(v);
    }

    // optional bool display_diagnostics_enabled = 20;

    pub fn display_diagnostics_enabled(&self) -> bool {
        self.display_diagnostics_enabled.unwrap_or(false)
    }

    pub fn clear_display_diagnostics_enabled(&mut self) {
        self.display_diagnostics_enabled = ::std::option::Option::None;
    }

    pub fn has_display_diagnostics_enabled(&self) -> bool {
        self.display_diagnostics_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_diagnostics_enabled(&mut self, v: bool) {
        self.display_diagnostics_enabled = ::std::option::Option::Some(v);
    }

    // optional float als_lux_latest = 21;

    pub fn als_lux_latest(&self) -> f32 {
        self.als_lux_latest.unwrap_or(0.)
    }

    pub fn clear_als_lux_latest(&mut self) {
        self.als_lux_latest = ::std::option::Option::None;
    }

    pub fn has_als_lux_latest(&self) -> bool {
        self.als_lux_latest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_als_lux_latest(&mut self, v: f32) {
        self.als_lux_latest = ::std::option::Option::Some(v);
    }

    // optional float als_lux_median = 22;

    pub fn als_lux_median(&self) -> f32 {
        self.als_lux_median.unwrap_or(0.)
    }

    pub fn clear_als_lux_median(&mut self) {
        self.als_lux_median = ::std::option::Option::None;
    }

    pub fn has_als_lux_median(&self) -> bool {
        self.als_lux_median.is_some()
    }

    // Param is passed by value, moved
    pub fn set_als_lux_median(&mut self, v: f32) {
        self.als_lux_median = ::std::option::Option::Some(v);
    }

    // optional float display_backlight_raw = 23;

    pub fn display_backlight_raw(&self) -> f32 {
        self.display_backlight_raw.unwrap_or(0.)
    }

    pub fn clear_display_backlight_raw(&mut self) {
        self.display_backlight_raw = ::std::option::Option::None;
    }

    pub fn has_display_backlight_raw(&self) -> bool {
        self.display_backlight_raw.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_backlight_raw(&mut self, v: f32) {
        self.display_backlight_raw = ::std::option::Option::Some(v);
    }

    // optional float display_brightness_adaptivemin = 24;

    pub fn display_brightness_adaptivemin(&self) -> f32 {
        self.display_brightness_adaptivemin.unwrap_or(0.)
    }

    pub fn clear_display_brightness_adaptivemin(&mut self) {
        self.display_brightness_adaptivemin = ::std::option::Option::None;
    }

    pub fn has_display_brightness_adaptivemin(&self) -> bool {
        self.display_brightness_adaptivemin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_brightness_adaptivemin(&mut self, v: f32) {
        self.display_brightness_adaptivemin = ::std::option::Option::Some(v);
    }

    // optional float display_brightness_adaptivemax = 25;

    pub fn display_brightness_adaptivemax(&self) -> f32 {
        self.display_brightness_adaptivemax.unwrap_or(0.)
    }

    pub fn clear_display_brightness_adaptivemax(&mut self) {
        self.display_brightness_adaptivemax = ::std::option::Option::None;
    }

    pub fn has_display_brightness_adaptivemax(&self) -> bool {
        self.display_brightness_adaptivemax.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_brightness_adaptivemax(&mut self, v: f32) {
        self.display_brightness_adaptivemax = ::std::option::Option::Some(v);
    }

    // optional bool is_wifi_powersave_enabled = 26;

    pub fn is_wifi_powersave_enabled(&self) -> bool {
        self.is_wifi_powersave_enabled.unwrap_or(false)
    }

    pub fn clear_is_wifi_powersave_enabled(&mut self) {
        self.is_wifi_powersave_enabled = ::std::option::Option::None;
    }

    pub fn has_is_wifi_powersave_enabled(&self) -> bool {
        self.is_wifi_powersave_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_wifi_powersave_enabled(&mut self, v: bool) {
        self.is_wifi_powersave_enabled = ::std::option::Option::Some(v);
    }

    // optional bool is_fan_control_available = 27;

    pub fn is_fan_control_available(&self) -> bool {
        self.is_fan_control_available.unwrap_or(false)
    }

    pub fn clear_is_fan_control_available(&mut self) {
        self.is_fan_control_available = ::std::option::Option::None;
    }

    pub fn has_is_fan_control_available(&self) -> bool {
        self.is_fan_control_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_fan_control_available(&mut self, v: bool) {
        self.is_fan_control_available = ::std::option::Option::Some(v);
    }

    // optional .ESystemFanControlMode fan_control_mode = 28;

    pub fn fan_control_mode(&self) -> super::enums::ESystemFanControlMode {
        match self.fan_control_mode {
            Some(e) => e.enum_value_or(super::enums::ESystemFanControlMode::k_SystemFanControlMode_Invalid),
            None => super::enums::ESystemFanControlMode::k_SystemFanControlMode_Invalid,
        }
    }

    pub fn clear_fan_control_mode(&mut self) {
        self.fan_control_mode = ::std::option::Option::None;
    }

    pub fn has_fan_control_mode(&self) -> bool {
        self.fan_control_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fan_control_mode(&mut self, v: super::enums::ESystemFanControlMode) {
        self.fan_control_mode = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool is_display_brightness_available = 29;

    pub fn is_display_brightness_available(&self) -> bool {
        self.is_display_brightness_available.unwrap_or(false)
    }

    pub fn clear_is_display_brightness_available(&mut self) {
        self.is_display_brightness_available = ::std::option::Option::None;
    }

    pub fn has_is_display_brightness_available(&self) -> bool {
        self.is_display_brightness_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_display_brightness_available(&mut self, v: bool) {
        self.is_display_brightness_available = ::std::option::Option::Some(v);
    }

    // optional bool is_display_colormanagement_available = 31;

    pub fn is_display_colormanagement_available(&self) -> bool {
        self.is_display_colormanagement_available.unwrap_or(false)
    }

    pub fn clear_is_display_colormanagement_available(&mut self) {
        self.is_display_colormanagement_available = ::std::option::Option::None;
    }

    pub fn has_is_display_colormanagement_available(&self) -> bool {
        self.is_display_colormanagement_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_display_colormanagement_available(&mut self, v: bool) {
        self.is_display_colormanagement_available = ::std::option::Option::Some(v);
    }

    // optional float display_colorgamut = 32;

    pub fn display_colorgamut(&self) -> f32 {
        self.display_colorgamut.unwrap_or(0.)
    }

    pub fn clear_display_colorgamut(&mut self) {
        self.display_colorgamut = ::std::option::Option::None;
    }

    pub fn has_display_colorgamut(&self) -> bool {
        self.display_colorgamut.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_colorgamut(&mut self, v: f32) {
        self.display_colorgamut = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSystemManagerSettings {
    const NAME: &'static str = "CMsgSystemManagerSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.idle_backlight_dim_battery_seconds = ::std::option::Option::Some(is.read_float()?);
                },
                21 => {
                    self.idle_backlight_dim_ac_seconds = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.idle_suspend_battery_seconds = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.idle_suspend_ac_seconds = ::std::option::Option::Some(is.read_float()?);
                },
                40 => {
                    self.idle_suspend_supressed = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.is_adaptive_brightness_available = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.display_adaptive_brightness_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.display_nightmode_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                93 => {
                    self.display_nightmode_tintstrength = ::std::option::Option::Some(is.read_float()?);
                },
                101 => {
                    self.display_nightmode_maxhue = ::std::option::Option::Some(is.read_float()?);
                },
                109 => {
                    self.display_nightmode_maxsat = ::std::option::Option::Some(is.read_float()?);
                },
                117 => {
                    self.display_nightmode_uiexp = ::std::option::Option::Some(is.read_float()?);
                },
                125 => {
                    self.display_nightmode_blend = ::std::option::Option::Some(is.read_float()?);
                },
                128 => {
                    self.display_nightmode_reset = ::std::option::Option::Some(is.read_bool()?);
                },
                136 => {
                    self.display_nightmode_schedule_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                149 => {
                    self.display_nightmode_schedule_starttime = ::std::option::Option::Some(is.read_float()?);
                },
                157 => {
                    self.display_nightmode_schedule_endtime = ::std::option::Option::Some(is.read_float()?);
                },
                160 => {
                    self.display_diagnostics_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                173 => {
                    self.als_lux_latest = ::std::option::Option::Some(is.read_float()?);
                },
                181 => {
                    self.als_lux_median = ::std::option::Option::Some(is.read_float()?);
                },
                189 => {
                    self.display_backlight_raw = ::std::option::Option::Some(is.read_float()?);
                },
                197 => {
                    self.display_brightness_adaptivemin = ::std::option::Option::Some(is.read_float()?);
                },
                205 => {
                    self.display_brightness_adaptivemax = ::std::option::Option::Some(is.read_float()?);
                },
                208 => {
                    self.is_wifi_powersave_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                216 => {
                    self.is_fan_control_available = ::std::option::Option::Some(is.read_bool()?);
                },
                224 => {
                    self.fan_control_mode = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                232 => {
                    self.is_display_brightness_available = ::std::option::Option::Some(is.read_bool()?);
                },
                248 => {
                    self.is_display_colormanagement_available = ::std::option::Option::Some(is.read_bool()?);
                },
                261 => {
                    self.display_colorgamut = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.idle_backlight_dim_battery_seconds {
            my_size += 1 + 4;
        }
        if let Some(v) = self.idle_backlight_dim_ac_seconds {
            my_size += 1 + 4;
        }
        if let Some(v) = self.idle_suspend_battery_seconds {
            my_size += 1 + 4;
        }
        if let Some(v) = self.idle_suspend_ac_seconds {
            my_size += 1 + 4;
        }
        if let Some(v) = self.idle_suspend_supressed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_adaptive_brightness_available {
            my_size += 1 + 1;
        }
        if let Some(v) = self.display_adaptive_brightness_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.display_nightmode_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.display_nightmode_tintstrength {
            my_size += 1 + 4;
        }
        if let Some(v) = self.display_nightmode_maxhue {
            my_size += 1 + 4;
        }
        if let Some(v) = self.display_nightmode_maxsat {
            my_size += 1 + 4;
        }
        if let Some(v) = self.display_nightmode_uiexp {
            my_size += 1 + 4;
        }
        if let Some(v) = self.display_nightmode_blend {
            my_size += 1 + 4;
        }
        if let Some(v) = self.display_nightmode_reset {
            my_size += 2 + 1;
        }
        if let Some(v) = self.display_nightmode_schedule_enabled {
            my_size += 2 + 1;
        }
        if let Some(v) = self.display_nightmode_schedule_starttime {
            my_size += 2 + 4;
        }
        if let Some(v) = self.display_nightmode_schedule_endtime {
            my_size += 2 + 4;
        }
        if let Some(v) = self.display_diagnostics_enabled {
            my_size += 2 + 1;
        }
        if let Some(v) = self.als_lux_latest {
            my_size += 2 + 4;
        }
        if let Some(v) = self.als_lux_median {
            my_size += 2 + 4;
        }
        if let Some(v) = self.display_backlight_raw {
            my_size += 2 + 4;
        }
        if let Some(v) = self.display_brightness_adaptivemin {
            my_size += 2 + 4;
        }
        if let Some(v) = self.display_brightness_adaptivemax {
            my_size += 2 + 4;
        }
        if let Some(v) = self.is_wifi_powersave_enabled {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_fan_control_available {
            my_size += 2 + 1;
        }
        if let Some(v) = self.fan_control_mode {
            my_size += ::protobuf::rt::int32_size(28, v.value());
        }
        if let Some(v) = self.is_display_brightness_available {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_display_colormanagement_available {
            my_size += 2 + 1;
        }
        if let Some(v) = self.display_colorgamut {
            my_size += 2 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.idle_backlight_dim_battery_seconds {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.idle_backlight_dim_ac_seconds {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.idle_suspend_battery_seconds {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.idle_suspend_ac_seconds {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.idle_suspend_supressed {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.is_adaptive_brightness_available {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.display_adaptive_brightness_enabled {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.display_nightmode_enabled {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.display_nightmode_tintstrength {
            os.write_float(11, v)?;
        }
        if let Some(v) = self.display_nightmode_maxhue {
            os.write_float(12, v)?;
        }
        if let Some(v) = self.display_nightmode_maxsat {
            os.write_float(13, v)?;
        }
        if let Some(v) = self.display_nightmode_uiexp {
            os.write_float(14, v)?;
        }
        if let Some(v) = self.display_nightmode_blend {
            os.write_float(15, v)?;
        }
        if let Some(v) = self.display_nightmode_reset {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.display_nightmode_schedule_enabled {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.display_nightmode_schedule_starttime {
            os.write_float(18, v)?;
        }
        if let Some(v) = self.display_nightmode_schedule_endtime {
            os.write_float(19, v)?;
        }
        if let Some(v) = self.display_diagnostics_enabled {
            os.write_bool(20, v)?;
        }
        if let Some(v) = self.als_lux_latest {
            os.write_float(21, v)?;
        }
        if let Some(v) = self.als_lux_median {
            os.write_float(22, v)?;
        }
        if let Some(v) = self.display_backlight_raw {
            os.write_float(23, v)?;
        }
        if let Some(v) = self.display_brightness_adaptivemin {
            os.write_float(24, v)?;
        }
        if let Some(v) = self.display_brightness_adaptivemax {
            os.write_float(25, v)?;
        }
        if let Some(v) = self.is_wifi_powersave_enabled {
            os.write_bool(26, v)?;
        }
        if let Some(v) = self.is_fan_control_available {
            os.write_bool(27, v)?;
        }
        if let Some(v) = self.fan_control_mode {
            os.write_enum(28, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.is_display_brightness_available {
            os.write_bool(29, v)?;
        }
        if let Some(v) = self.is_display_colormanagement_available {
            os.write_bool(31, v)?;
        }
        if let Some(v) = self.display_colorgamut {
            os.write_float(32, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemManagerSettings {
        CMsgSystemManagerSettings::new()
    }

    fn clear(&mut self) {
        self.idle_backlight_dim_battery_seconds = ::std::option::Option::None;
        self.idle_backlight_dim_ac_seconds = ::std::option::Option::None;
        self.idle_suspend_battery_seconds = ::std::option::Option::None;
        self.idle_suspend_ac_seconds = ::std::option::Option::None;
        self.idle_suspend_supressed = ::std::option::Option::None;
        self.is_adaptive_brightness_available = ::std::option::Option::None;
        self.display_adaptive_brightness_enabled = ::std::option::Option::None;
        self.display_nightmode_enabled = ::std::option::Option::None;
        self.display_nightmode_tintstrength = ::std::option::Option::None;
        self.display_nightmode_maxhue = ::std::option::Option::None;
        self.display_nightmode_maxsat = ::std::option::Option::None;
        self.display_nightmode_uiexp = ::std::option::Option::None;
        self.display_nightmode_blend = ::std::option::Option::None;
        self.display_nightmode_reset = ::std::option::Option::None;
        self.display_nightmode_schedule_enabled = ::std::option::Option::None;
        self.display_nightmode_schedule_starttime = ::std::option::Option::None;
        self.display_nightmode_schedule_endtime = ::std::option::Option::None;
        self.display_diagnostics_enabled = ::std::option::Option::None;
        self.als_lux_latest = ::std::option::Option::None;
        self.als_lux_median = ::std::option::Option::None;
        self.display_backlight_raw = ::std::option::Option::None;
        self.display_brightness_adaptivemin = ::std::option::Option::None;
        self.display_brightness_adaptivemax = ::std::option::Option::None;
        self.is_wifi_powersave_enabled = ::std::option::Option::None;
        self.is_fan_control_available = ::std::option::Option::None;
        self.fan_control_mode = ::std::option::Option::None;
        self.is_display_brightness_available = ::std::option::Option::None;
        self.is_display_colormanagement_available = ::std::option::Option::None;
        self.display_colorgamut = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemManagerSettings {
        static instance: CMsgSystemManagerSettings = CMsgSystemManagerSettings {
            idle_backlight_dim_battery_seconds: ::std::option::Option::None,
            idle_backlight_dim_ac_seconds: ::std::option::Option::None,
            idle_suspend_battery_seconds: ::std::option::Option::None,
            idle_suspend_ac_seconds: ::std::option::Option::None,
            idle_suspend_supressed: ::std::option::Option::None,
            is_adaptive_brightness_available: ::std::option::Option::None,
            display_adaptive_brightness_enabled: ::std::option::Option::None,
            display_nightmode_enabled: ::std::option::Option::None,
            display_nightmode_tintstrength: ::std::option::Option::None,
            display_nightmode_maxhue: ::std::option::Option::None,
            display_nightmode_maxsat: ::std::option::Option::None,
            display_nightmode_uiexp: ::std::option::Option::None,
            display_nightmode_blend: ::std::option::Option::None,
            display_nightmode_reset: ::std::option::Option::None,
            display_nightmode_schedule_enabled: ::std::option::Option::None,
            display_nightmode_schedule_starttime: ::std::option::Option::None,
            display_nightmode_schedule_endtime: ::std::option::Option::None,
            display_diagnostics_enabled: ::std::option::Option::None,
            als_lux_latest: ::std::option::Option::None,
            als_lux_median: ::std::option::Option::None,
            display_backlight_raw: ::std::option::Option::None,
            display_brightness_adaptivemin: ::std::option::Option::None,
            display_brightness_adaptivemax: ::std::option::Option::None,
            is_wifi_powersave_enabled: ::std::option::Option::None,
            is_fan_control_available: ::std::option::Option::None,
            fan_control_mode: ::std::option::Option::None,
            is_display_brightness_available: ::std::option::Option::None,
            is_display_colormanagement_available: ::std::option::Option::None,
            display_colorgamut: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSelectOSBranchParams)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSelectOSBranchParams {
    // message fields
    // @@protoc_insertion_point(field:CMsgSelectOSBranchParams.branch)
    pub branch: ::std::option::Option<::protobuf::EnumOrUnknown<super::enums::EOSBranch>>,
    // @@protoc_insertion_point(field:CMsgSelectOSBranchParams.custom_branch)
    pub custom_branch: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSelectOSBranchParams.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSelectOSBranchParams {
    fn default() -> &'a CMsgSelectOSBranchParams {
        <CMsgSelectOSBranchParams as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSelectOSBranchParams {
    pub fn new() -> CMsgSelectOSBranchParams {
        ::std::default::Default::default()
    }

    // optional .EOSBranch branch = 1;

    pub fn branch(&self) -> super::enums::EOSBranch {
        match self.branch {
            Some(e) => e.enum_value_or(super::enums::EOSBranch::k_EOSBranch_Unknown),
            None => super::enums::EOSBranch::k_EOSBranch_Unknown,
        }
    }

    pub fn clear_branch(&mut self) {
        self.branch = ::std::option::Option::None;
    }

    pub fn has_branch(&self) -> bool {
        self.branch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_branch(&mut self, v: super::enums::EOSBranch) {
        self.branch = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string custom_branch = 2;

    pub fn custom_branch(&self) -> &str {
        match self.custom_branch.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_custom_branch(&mut self) {
        self.custom_branch = ::std::option::Option::None;
    }

    pub fn has_custom_branch(&self) -> bool {
        self.custom_branch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_branch(&mut self, v: ::std::string::String) {
        self.custom_branch = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_branch(&mut self) -> &mut ::std::string::String {
        if self.custom_branch.is_none() {
            self.custom_branch = ::std::option::Option::Some(::std::string::String::new());
        }
        self.custom_branch.as_mut().unwrap()
    }

    // Take field
    pub fn take_custom_branch(&mut self) -> ::std::string::String {
        self.custom_branch.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgSelectOSBranchParams {
    const NAME: &'static str = "CMsgSelectOSBranchParams";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.branch = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.custom_branch = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.branch {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.custom_branch.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.branch {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.custom_branch.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSelectOSBranchParams {
        CMsgSelectOSBranchParams::new()
    }

    fn clear(&mut self) {
        self.branch = ::std::option::Option::None;
        self.custom_branch = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSelectOSBranchParams {
        static instance: CMsgSelectOSBranchParams = CMsgSelectOSBranchParams {
            branch: ::std::option::Option::None,
            custom_branch: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSystemUpdateProgress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemUpdateProgress {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemUpdateProgress.stage_progress)
    pub stage_progress: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSystemUpdateProgress.stage_size_bytes)
    pub stage_size_bytes: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:CMsgSystemUpdateProgress.rtime_estimated_completion)
    pub rtime_estimated_completion: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemUpdateProgress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemUpdateProgress {
    fn default() -> &'a CMsgSystemUpdateProgress {
        <CMsgSystemUpdateProgress as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSystemUpdateProgress {
    pub fn new() -> CMsgSystemUpdateProgress {
        ::std::default::Default::default()
    }

    // optional float stage_progress = 1;

    pub fn stage_progress(&self) -> f32 {
        self.stage_progress.unwrap_or(0.)
    }

    pub fn clear_stage_progress(&mut self) {
        self.stage_progress = ::std::option::Option::None;
    }

    pub fn has_stage_progress(&self) -> bool {
        self.stage_progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stage_progress(&mut self, v: f32) {
        self.stage_progress = ::std::option::Option::Some(v);
    }

    // optional int64 stage_size_bytes = 2;

    pub fn stage_size_bytes(&self) -> i64 {
        self.stage_size_bytes.unwrap_or(0)
    }

    pub fn clear_stage_size_bytes(&mut self) {
        self.stage_size_bytes = ::std::option::Option::None;
    }

    pub fn has_stage_size_bytes(&self) -> bool {
        self.stage_size_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stage_size_bytes(&mut self, v: i64) {
        self.stage_size_bytes = ::std::option::Option::Some(v);
    }

    // optional fixed32 rtime_estimated_completion = 3;

    pub fn rtime_estimated_completion(&self) -> u32 {
        self.rtime_estimated_completion.unwrap_or(0)
    }

    pub fn clear_rtime_estimated_completion(&mut self) {
        self.rtime_estimated_completion = ::std::option::Option::None;
    }

    pub fn has_rtime_estimated_completion(&self) -> bool {
        self.rtime_estimated_completion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime_estimated_completion(&mut self, v: u32) {
        self.rtime_estimated_completion = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSystemUpdateProgress {
    const NAME: &'static str = "CMsgSystemUpdateProgress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.stage_progress = ::std::option::Option::Some(is.read_float()?);
                },
                16 => {
                    self.stage_size_bytes = ::std::option::Option::Some(is.read_int64()?);
                },
                29 => {
                    self.rtime_estimated_completion = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.stage_progress {
            my_size += 1 + 4;
        }
        if let Some(v) = self.stage_size_bytes {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.rtime_estimated_completion {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.stage_progress {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.stage_size_bytes {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.rtime_estimated_completion {
            os.write_fixed32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemUpdateProgress {
        CMsgSystemUpdateProgress::new()
    }

    fn clear(&mut self) {
        self.stage_progress = ::std::option::Option::None;
        self.stage_size_bytes = ::std::option::Option::None;
        self.rtime_estimated_completion = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemUpdateProgress {
        static instance: CMsgSystemUpdateProgress = CMsgSystemUpdateProgress {
            stage_progress: ::std::option::Option::None,
            stage_size_bytes: ::std::option::Option::None,
            rtime_estimated_completion: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSystemUpdateCheckResult)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemUpdateCheckResult {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemUpdateCheckResult.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<super::enums::EUpdaterType>>,
    // @@protoc_insertion_point(field:CMsgSystemUpdateCheckResult.eresult)
    pub eresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSystemUpdateCheckResult.rtime_checked)
    pub rtime_checked: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSystemUpdateCheckResult.available)
    pub available: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemUpdateCheckResult.version)
    pub version: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSystemUpdateCheckResult.auto_message)
    pub auto_message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemUpdateCheckResult.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemUpdateCheckResult {
    fn default() -> &'a CMsgSystemUpdateCheckResult {
        <CMsgSystemUpdateCheckResult as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSystemUpdateCheckResult {
    pub fn new() -> CMsgSystemUpdateCheckResult {
        ::std::default::Default::default()
    }

    // optional .EUpdaterType type = 1;

    pub fn type_(&self) -> super::enums::EUpdaterType {
        match self.type_ {
            Some(e) => e.enum_value_or(super::enums::EUpdaterType::k_EUpdaterType_Invalid),
            None => super::enums::EUpdaterType::k_EUpdaterType_Invalid,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: super::enums::EUpdaterType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 eresult = 2;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional fixed32 rtime_checked = 3;

    pub fn rtime_checked(&self) -> u32 {
        self.rtime_checked.unwrap_or(0)
    }

    pub fn clear_rtime_checked(&mut self) {
        self.rtime_checked = ::std::option::Option::None;
    }

    pub fn has_rtime_checked(&self) -> bool {
        self.rtime_checked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime_checked(&mut self, v: u32) {
        self.rtime_checked = ::std::option::Option::Some(v);
    }

    // optional bool available = 4;

    pub fn available(&self) -> bool {
        self.available.unwrap_or(false)
    }

    pub fn clear_available(&mut self) {
        self.available = ::std::option::Option::None;
    }

    pub fn has_available(&self) -> bool {
        self.available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_available(&mut self, v: bool) {
        self.available = ::std::option::Option::Some(v);
    }

    // optional string version = 5;

    pub fn version(&self) -> &str {
        match self.version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        if self.version.is_none() {
            self.version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        self.version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string auto_message = 6;

    pub fn auto_message(&self) -> &str {
        match self.auto_message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_auto_message(&mut self) {
        self.auto_message = ::std::option::Option::None;
    }

    pub fn has_auto_message(&self) -> bool {
        self.auto_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auto_message(&mut self, v: ::std::string::String) {
        self.auto_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auto_message(&mut self) -> &mut ::std::string::String {
        if self.auto_message.is_none() {
            self.auto_message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.auto_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_auto_message(&mut self) -> ::std::string::String {
        self.auto_message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgSystemUpdateCheckResult {
    const NAME: &'static str = "CMsgSystemUpdateCheckResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                29 => {
                    self.rtime_checked = ::std::option::Option::Some(is.read_fixed32()?);
                },
                32 => {
                    self.available = ::std::option::Option::Some(is.read_bool()?);
                },
                42 => {
                    self.version = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.auto_message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.rtime_checked {
            my_size += 1 + 4;
        }
        if let Some(v) = self.available {
            my_size += 1 + 1;
        }
        if let Some(v) = self.version.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.auto_message.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.eresult {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.rtime_checked {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.available {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.version.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.auto_message.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemUpdateCheckResult {
        CMsgSystemUpdateCheckResult::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.rtime_checked = ::std::option::Option::None;
        self.available = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.auto_message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemUpdateCheckResult {
        static instance: CMsgSystemUpdateCheckResult = CMsgSystemUpdateCheckResult {
            type_: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            rtime_checked: ::std::option::Option::None,
            available: ::std::option::Option::None,
            version: ::std::option::Option::None,
            auto_message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSystemUpdateApplyParams)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemUpdateApplyParams {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemUpdateApplyParams.apply_types)
    pub apply_types: ::std::vec::Vec<::protobuf::EnumOrUnknown<super::enums::EUpdaterType>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemUpdateApplyParams.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemUpdateApplyParams {
    fn default() -> &'a CMsgSystemUpdateApplyParams {
        <CMsgSystemUpdateApplyParams as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSystemUpdateApplyParams {
    pub fn new() -> CMsgSystemUpdateApplyParams {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgSystemUpdateApplyParams {
    const NAME: &'static str = "CMsgSystemUpdateApplyParams";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.apply_types.push(is.read_enum_or_unknown()?);
                },
                10 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.apply_types)?
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.apply_types {
            my_size += ::protobuf::rt::int32_size(1, value.value());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.apply_types {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(v))?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemUpdateApplyParams {
        CMsgSystemUpdateApplyParams::new()
    }

    fn clear(&mut self) {
        self.apply_types.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemUpdateApplyParams {
        static instance: CMsgSystemUpdateApplyParams = CMsgSystemUpdateApplyParams {
            apply_types: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSystemUpdateApplyResult)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemUpdateApplyResult {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemUpdateApplyResult.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<super::enums::EUpdaterType>>,
    // @@protoc_insertion_point(field:CMsgSystemUpdateApplyResult.eresult)
    pub eresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSystemUpdateApplyResult.requires_client_restart)
    pub requires_client_restart: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSystemUpdateApplyResult.requires_system_restart)
    pub requires_system_restart: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemUpdateApplyResult.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemUpdateApplyResult {
    fn default() -> &'a CMsgSystemUpdateApplyResult {
        <CMsgSystemUpdateApplyResult as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSystemUpdateApplyResult {
    pub fn new() -> CMsgSystemUpdateApplyResult {
        ::std::default::Default::default()
    }

    // optional .EUpdaterType type = 1;

    pub fn type_(&self) -> super::enums::EUpdaterType {
        match self.type_ {
            Some(e) => e.enum_value_or(super::enums::EUpdaterType::k_EUpdaterType_Invalid),
            None => super::enums::EUpdaterType::k_EUpdaterType_Invalid,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: super::enums::EUpdaterType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 eresult = 2;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional bool requires_client_restart = 3;

    pub fn requires_client_restart(&self) -> bool {
        self.requires_client_restart.unwrap_or(false)
    }

    pub fn clear_requires_client_restart(&mut self) {
        self.requires_client_restart = ::std::option::Option::None;
    }

    pub fn has_requires_client_restart(&self) -> bool {
        self.requires_client_restart.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requires_client_restart(&mut self, v: bool) {
        self.requires_client_restart = ::std::option::Option::Some(v);
    }

    // optional bool requires_system_restart = 4;

    pub fn requires_system_restart(&self) -> bool {
        self.requires_system_restart.unwrap_or(false)
    }

    pub fn clear_requires_system_restart(&mut self) {
        self.requires_system_restart = ::std::option::Option::None;
    }

    pub fn has_requires_system_restart(&self) -> bool {
        self.requires_system_restart.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requires_system_restart(&mut self, v: bool) {
        self.requires_system_restart = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSystemUpdateApplyResult {
    const NAME: &'static str = "CMsgSystemUpdateApplyResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.requires_client_restart = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.requires_system_restart = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.requires_client_restart {
            my_size += 1 + 1;
        }
        if let Some(v) = self.requires_system_restart {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.eresult {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.requires_client_restart {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.requires_system_restart {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemUpdateApplyResult {
        CMsgSystemUpdateApplyResult::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.requires_client_restart = ::std::option::Option::None;
        self.requires_system_restart = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemUpdateApplyResult {
        static instance: CMsgSystemUpdateApplyResult = CMsgSystemUpdateApplyResult {
            type_: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            requires_client_restart: ::std::option::Option::None,
            requires_system_restart: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSystemUpdateState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemUpdateState {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemUpdateState.state)
    pub state: ::std::option::Option<::protobuf::EnumOrUnknown<super::enums::EUpdaterState>>,
    // @@protoc_insertion_point(field:CMsgSystemUpdateState.progress)
    pub progress: ::protobuf::MessageField<CMsgSystemUpdateProgress>,
    // @@protoc_insertion_point(field:CMsgSystemUpdateState.update_check_results)
    pub update_check_results: ::std::vec::Vec<CMsgSystemUpdateCheckResult>,
    // @@protoc_insertion_point(field:CMsgSystemUpdateState.update_apply_results)
    pub update_apply_results: ::std::vec::Vec<CMsgSystemUpdateApplyResult>,
    // @@protoc_insertion_point(field:CMsgSystemUpdateState.supports_os_updates)
    pub supports_os_updates: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemUpdateState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemUpdateState {
    fn default() -> &'a CMsgSystemUpdateState {
        <CMsgSystemUpdateState as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSystemUpdateState {
    pub fn new() -> CMsgSystemUpdateState {
        ::std::default::Default::default()
    }

    // optional .EUpdaterState state = 1;

    pub fn state(&self) -> super::enums::EUpdaterState {
        match self.state {
            Some(e) => e.enum_value_or(super::enums::EUpdaterState::k_EUpdaterState_Invalid),
            None => super::enums::EUpdaterState::k_EUpdaterState_Invalid,
        }
    }

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: super::enums::EUpdaterState) {
        self.state = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool supports_os_updates = 5;

    pub fn supports_os_updates(&self) -> bool {
        self.supports_os_updates.unwrap_or(false)
    }

    pub fn clear_supports_os_updates(&mut self) {
        self.supports_os_updates = ::std::option::Option::None;
    }

    pub fn has_supports_os_updates(&self) -> bool {
        self.supports_os_updates.is_some()
    }

    // Param is passed by value, moved
    pub fn set_supports_os_updates(&mut self, v: bool) {
        self.supports_os_updates = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSystemUpdateState {
    const NAME: &'static str = "CMsgSystemUpdateState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.progress)?;
                },
                26 => {
                    self.update_check_results.push(is.read_message()?);
                },
                34 => {
                    self.update_apply_results.push(is.read_message()?);
                },
                40 => {
                    self.supports_os_updates = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.state {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.progress.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.update_check_results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.update_apply_results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.supports_os_updates {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.state {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.progress.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.update_check_results {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.update_apply_results {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.supports_os_updates {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemUpdateState {
        CMsgSystemUpdateState::new()
    }

    fn clear(&mut self) {
        self.state = ::std::option::Option::None;
        self.progress.clear();
        self.update_check_results.clear();
        self.update_apply_results.clear();
        self.supports_os_updates = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemUpdateState {
        static instance: CMsgSystemUpdateState = CMsgSystemUpdateState {
            state: ::std::option::Option::None,
            progress: ::protobuf::MessageField::none(),
            update_check_results: ::std::vec::Vec::new(),
            update_apply_results: ::std::vec::Vec::new(),
            supports_os_updates: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgAchievementChange)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAchievementChange {
    // message fields
    // @@protoc_insertion_point(field:CMsgAchievementChange.appid)
    pub appid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAchievementChange.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAchievementChange {
    fn default() -> &'a CMsgAchievementChange {
        <CMsgAchievementChange as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAchievementChange {
    pub fn new() -> CMsgAchievementChange {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgAchievementChange {
    const NAME: &'static str = "CMsgAchievementChange";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAchievementChange {
        CMsgAchievementChange::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAchievementChange {
        static instance: CMsgAchievementChange = CMsgAchievementChange {
            appid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgCellList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCellList {
    // message fields
    // @@protoc_insertion_point(field:CMsgCellList.cells)
    pub cells: ::std::vec::Vec<cmsg_cell_list::Cell>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCellList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCellList {
    fn default() -> &'a CMsgCellList {
        <CMsgCellList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCellList {
    pub fn new() -> CMsgCellList {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgCellList {
    const NAME: &'static str = "CMsgCellList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.cells.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.cells {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.cells {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCellList {
        CMsgCellList::new()
    }

    fn clear(&mut self) {
        self.cells.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCellList {
        static instance: CMsgCellList = CMsgCellList {
            cells: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgCellList`
pub mod cmsg_cell_list {
    // @@protoc_insertion_point(message:CMsgCellList.Cell)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Cell {
        // message fields
        // @@protoc_insertion_point(field:CMsgCellList.Cell.cell_id)
        pub cell_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgCellList.Cell.loc_name)
        pub loc_name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgCellList.Cell.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Cell {
        fn default() -> &'a Cell {
            <Cell as ::protobuf::Message>::default_instance()
        }
    }

    impl Cell {
        pub fn new() -> Cell {
            ::std::default::Default::default()
        }

        // optional uint32 cell_id = 1;

        pub fn cell_id(&self) -> u32 {
            self.cell_id.unwrap_or(0)
        }

        pub fn clear_cell_id(&mut self) {
            self.cell_id = ::std::option::Option::None;
        }

        pub fn has_cell_id(&self) -> bool {
            self.cell_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_cell_id(&mut self, v: u32) {
            self.cell_id = ::std::option::Option::Some(v);
        }

        // optional string loc_name = 2;

        pub fn loc_name(&self) -> &str {
            match self.loc_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_loc_name(&mut self) {
            self.loc_name = ::std::option::Option::None;
        }

        pub fn has_loc_name(&self) -> bool {
            self.loc_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_loc_name(&mut self, v: ::std::string::String) {
            self.loc_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_loc_name(&mut self) -> &mut ::std::string::String {
            if self.loc_name.is_none() {
                self.loc_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.loc_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_loc_name(&mut self) -> ::std::string::String {
            self.loc_name.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::protobuf::Message for Cell {
        const NAME: &'static str = "Cell";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.cell_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.loc_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.cell_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.loc_name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.cell_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.loc_name.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Cell {
            Cell::new()
        }

        fn clear(&mut self) {
            self.cell_id = ::std::option::Option::None;
            self.loc_name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Cell {
            static instance: Cell = Cell {
                cell_id: ::std::option::Option::None,
                loc_name: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgShortcutInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgShortcutInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgShortcutInfo.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgShortcutInfo.exe)
    pub exe: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgShortcutInfo.start_dir)
    pub start_dir: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgShortcutInfo.icon)
    pub icon: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgShortcutInfo.path)
    pub path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgShortcutInfo.args)
    pub args: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgShortcutInfo.app_name)
    pub app_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgShortcutInfo.override_appid)
    pub override_appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgShortcutInfo.flatpak_appid)
    pub flatpak_appid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgShortcutInfo.tags)
    pub tags: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgShortcutInfo.is_remote)
    pub is_remote: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgShortcutInfo.is_hidden)
    pub is_hidden: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgShortcutInfo.is_temporary)
    pub is_temporary: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgShortcutInfo.is_openvr)
    pub is_openvr: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgShortcutInfo.allow_desktop_config)
    pub allow_desktop_config: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgShortcutInfo.allow_overlay)
    pub allow_overlay: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgShortcutInfo.rt_last_played_time)
    pub rt_last_played_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgShortcutInfo.is_devkit_shortcut)
    pub is_devkit_shortcut: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgShortcutInfo.devkit_gameid)
    pub devkit_gameid: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgShortcutInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgShortcutInfo {
    fn default() -> &'a CMsgShortcutInfo {
        <CMsgShortcutInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgShortcutInfo {
    pub fn new() -> CMsgShortcutInfo {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string exe = 2;

    pub fn exe(&self) -> &str {
        match self.exe.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_exe(&mut self) {
        self.exe = ::std::option::Option::None;
    }

    pub fn has_exe(&self) -> bool {
        self.exe.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exe(&mut self, v: ::std::string::String) {
        self.exe = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exe(&mut self) -> &mut ::std::string::String {
        if self.exe.is_none() {
            self.exe = ::std::option::Option::Some(::std::string::String::new());
        }
        self.exe.as_mut().unwrap()
    }

    // Take field
    pub fn take_exe(&mut self) -> ::std::string::String {
        self.exe.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string start_dir = 3;

    pub fn start_dir(&self) -> &str {
        match self.start_dir.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_start_dir(&mut self) {
        self.start_dir = ::std::option::Option::None;
    }

    pub fn has_start_dir(&self) -> bool {
        self.start_dir.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_dir(&mut self, v: ::std::string::String) {
        self.start_dir = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_dir(&mut self) -> &mut ::std::string::String {
        if self.start_dir.is_none() {
            self.start_dir = ::std::option::Option::Some(::std::string::String::new());
        }
        self.start_dir.as_mut().unwrap()
    }

    // Take field
    pub fn take_start_dir(&mut self) -> ::std::string::String {
        self.start_dir.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string icon = 4;

    pub fn icon(&self) -> &str {
        match self.icon.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_icon(&mut self) {
        self.icon = ::std::option::Option::None;
    }

    pub fn has_icon(&self) -> bool {
        self.icon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_icon(&mut self, v: ::std::string::String) {
        self.icon = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon(&mut self) -> &mut ::std::string::String {
        if self.icon.is_none() {
            self.icon = ::std::option::Option::Some(::std::string::String::new());
        }
        self.icon.as_mut().unwrap()
    }

    // Take field
    pub fn take_icon(&mut self) -> ::std::string::String {
        self.icon.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string path = 5;

    pub fn path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_path(&mut self) {
        self.path = ::std::option::Option::None;
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string args = 6;

    pub fn args(&self) -> &str {
        match self.args.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_args(&mut self) {
        self.args = ::std::option::Option::None;
    }

    pub fn has_args(&self) -> bool {
        self.args.is_some()
    }

    // Param is passed by value, moved
    pub fn set_args(&mut self, v: ::std::string::String) {
        self.args = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_args(&mut self) -> &mut ::std::string::String {
        if self.args.is_none() {
            self.args = ::std::option::Option::Some(::std::string::String::new());
        }
        self.args.as_mut().unwrap()
    }

    // Take field
    pub fn take_args(&mut self) -> ::std::string::String {
        self.args.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string app_name = 7;

    pub fn app_name(&self) -> &str {
        match self.app_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_app_name(&mut self) {
        self.app_name = ::std::option::Option::None;
    }

    pub fn has_app_name(&self) -> bool {
        self.app_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_name(&mut self, v: ::std::string::String) {
        self.app_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_name(&mut self) -> &mut ::std::string::String {
        if self.app_name.is_none() {
            self.app_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.app_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_app_name(&mut self) -> ::std::string::String {
        self.app_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 override_appid = 8;

    pub fn override_appid(&self) -> u32 {
        self.override_appid.unwrap_or(0)
    }

    pub fn clear_override_appid(&mut self) {
        self.override_appid = ::std::option::Option::None;
    }

    pub fn has_override_appid(&self) -> bool {
        self.override_appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_override_appid(&mut self, v: u32) {
        self.override_appid = ::std::option::Option::Some(v);
    }

    // optional string flatpak_appid = 9;

    pub fn flatpak_appid(&self) -> &str {
        match self.flatpak_appid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_flatpak_appid(&mut self) {
        self.flatpak_appid = ::std::option::Option::None;
    }

    pub fn has_flatpak_appid(&self) -> bool {
        self.flatpak_appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flatpak_appid(&mut self, v: ::std::string::String) {
        self.flatpak_appid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_flatpak_appid(&mut self) -> &mut ::std::string::String {
        if self.flatpak_appid.is_none() {
            self.flatpak_appid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.flatpak_appid.as_mut().unwrap()
    }

    // Take field
    pub fn take_flatpak_appid(&mut self) -> ::std::string::String {
        self.flatpak_appid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_remote = 11;

    pub fn is_remote(&self) -> bool {
        self.is_remote.unwrap_or(false)
    }

    pub fn clear_is_remote(&mut self) {
        self.is_remote = ::std::option::Option::None;
    }

    pub fn has_is_remote(&self) -> bool {
        self.is_remote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_remote(&mut self, v: bool) {
        self.is_remote = ::std::option::Option::Some(v);
    }

    // optional bool is_hidden = 12;

    pub fn is_hidden(&self) -> bool {
        self.is_hidden.unwrap_or(false)
    }

    pub fn clear_is_hidden(&mut self) {
        self.is_hidden = ::std::option::Option::None;
    }

    pub fn has_is_hidden(&self) -> bool {
        self.is_hidden.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_hidden(&mut self, v: bool) {
        self.is_hidden = ::std::option::Option::Some(v);
    }

    // optional bool is_temporary = 13;

    pub fn is_temporary(&self) -> bool {
        self.is_temporary.unwrap_or(false)
    }

    pub fn clear_is_temporary(&mut self) {
        self.is_temporary = ::std::option::Option::None;
    }

    pub fn has_is_temporary(&self) -> bool {
        self.is_temporary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_temporary(&mut self, v: bool) {
        self.is_temporary = ::std::option::Option::Some(v);
    }

    // optional bool is_openvr = 14;

    pub fn is_openvr(&self) -> bool {
        self.is_openvr.unwrap_or(false)
    }

    pub fn clear_is_openvr(&mut self) {
        self.is_openvr = ::std::option::Option::None;
    }

    pub fn has_is_openvr(&self) -> bool {
        self.is_openvr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_openvr(&mut self, v: bool) {
        self.is_openvr = ::std::option::Option::Some(v);
    }

    // optional bool allow_desktop_config = 15;

    pub fn allow_desktop_config(&self) -> bool {
        self.allow_desktop_config.unwrap_or(false)
    }

    pub fn clear_allow_desktop_config(&mut self) {
        self.allow_desktop_config = ::std::option::Option::None;
    }

    pub fn has_allow_desktop_config(&self) -> bool {
        self.allow_desktop_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_desktop_config(&mut self, v: bool) {
        self.allow_desktop_config = ::std::option::Option::Some(v);
    }

    // optional bool allow_overlay = 16;

    pub fn allow_overlay(&self) -> bool {
        self.allow_overlay.unwrap_or(false)
    }

    pub fn clear_allow_overlay(&mut self) {
        self.allow_overlay = ::std::option::Option::None;
    }

    pub fn has_allow_overlay(&self) -> bool {
        self.allow_overlay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_overlay(&mut self, v: bool) {
        self.allow_overlay = ::std::option::Option::Some(v);
    }

    // optional uint32 rt_last_played_time = 17;

    pub fn rt_last_played_time(&self) -> u32 {
        self.rt_last_played_time.unwrap_or(0)
    }

    pub fn clear_rt_last_played_time(&mut self) {
        self.rt_last_played_time = ::std::option::Option::None;
    }

    pub fn has_rt_last_played_time(&self) -> bool {
        self.rt_last_played_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rt_last_played_time(&mut self, v: u32) {
        self.rt_last_played_time = ::std::option::Option::Some(v);
    }

    // optional bool is_devkit_shortcut = 18;

    pub fn is_devkit_shortcut(&self) -> bool {
        self.is_devkit_shortcut.unwrap_or(false)
    }

    pub fn clear_is_devkit_shortcut(&mut self) {
        self.is_devkit_shortcut = ::std::option::Option::None;
    }

    pub fn has_is_devkit_shortcut(&self) -> bool {
        self.is_devkit_shortcut.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_devkit_shortcut(&mut self, v: bool) {
        self.is_devkit_shortcut = ::std::option::Option::Some(v);
    }

    // optional string devkit_gameid = 19;

    pub fn devkit_gameid(&self) -> &str {
        match self.devkit_gameid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_devkit_gameid(&mut self) {
        self.devkit_gameid = ::std::option::Option::None;
    }

    pub fn has_devkit_gameid(&self) -> bool {
        self.devkit_gameid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_devkit_gameid(&mut self, v: ::std::string::String) {
        self.devkit_gameid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_devkit_gameid(&mut self) -> &mut ::std::string::String {
        if self.devkit_gameid.is_none() {
            self.devkit_gameid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.devkit_gameid.as_mut().unwrap()
    }

    // Take field
    pub fn take_devkit_gameid(&mut self) -> ::std::string::String {
        self.devkit_gameid.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgShortcutInfo {
    const NAME: &'static str = "CMsgShortcutInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.exe = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.start_dir = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.icon = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.path = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.args = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.app_name = ::std::option::Option::Some(is.read_string()?);
                },
                64 => {
                    self.override_appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                74 => {
                    self.flatpak_appid = ::std::option::Option::Some(is.read_string()?);
                },
                82 => {
                    self.tags.push(is.read_string()?);
                },
                88 => {
                    self.is_remote = ::std::option::Option::Some(is.read_bool()?);
                },
                96 => {
                    self.is_hidden = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.is_temporary = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.is_openvr = ::std::option::Option::Some(is.read_bool()?);
                },
                120 => {
                    self.allow_desktop_config = ::std::option::Option::Some(is.read_bool()?);
                },
                128 => {
                    self.allow_overlay = ::std::option::Option::Some(is.read_bool()?);
                },
                136 => {
                    self.rt_last_played_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                144 => {
                    self.is_devkit_shortcut = ::std::option::Option::Some(is.read_bool()?);
                },
                154 => {
                    self.devkit_gameid = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.exe.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.start_dir.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.icon.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.args.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.app_name.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.override_appid {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.flatpak_appid.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        if let Some(v) = self.is_remote {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_hidden {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_temporary {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_openvr {
            my_size += 1 + 1;
        }
        if let Some(v) = self.allow_desktop_config {
            my_size += 1 + 1;
        }
        if let Some(v) = self.allow_overlay {
            my_size += 2 + 1;
        }
        if let Some(v) = self.rt_last_played_time {
            my_size += ::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.is_devkit_shortcut {
            my_size += 2 + 1;
        }
        if let Some(v) = self.devkit_gameid.as_ref() {
            my_size += ::protobuf::rt::string_size(19, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.exe.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.start_dir.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.icon.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.path.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.args.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.app_name.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.override_appid {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.flatpak_appid.as_ref() {
            os.write_string(9, v)?;
        }
        for v in &self.tags {
            os.write_string(10, &v)?;
        };
        if let Some(v) = self.is_remote {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.is_hidden {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.is_temporary {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.is_openvr {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.allow_desktop_config {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.allow_overlay {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.rt_last_played_time {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.is_devkit_shortcut {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.devkit_gameid.as_ref() {
            os.write_string(19, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgShortcutInfo {
        CMsgShortcutInfo::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.exe = ::std::option::Option::None;
        self.start_dir = ::std::option::Option::None;
        self.icon = ::std::option::Option::None;
        self.path = ::std::option::Option::None;
        self.args = ::std::option::Option::None;
        self.app_name = ::std::option::Option::None;
        self.override_appid = ::std::option::Option::None;
        self.flatpak_appid = ::std::option::Option::None;
        self.tags.clear();
        self.is_remote = ::std::option::Option::None;
        self.is_hidden = ::std::option::Option::None;
        self.is_temporary = ::std::option::Option::None;
        self.is_openvr = ::std::option::Option::None;
        self.allow_desktop_config = ::std::option::Option::None;
        self.allow_overlay = ::std::option::Option::None;
        self.rt_last_played_time = ::std::option::Option::None;
        self.is_devkit_shortcut = ::std::option::Option::None;
        self.devkit_gameid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgShortcutInfo {
        static instance: CMsgShortcutInfo = CMsgShortcutInfo {
            appid: ::std::option::Option::None,
            exe: ::std::option::Option::None,
            start_dir: ::std::option::Option::None,
            icon: ::std::option::Option::None,
            path: ::std::option::Option::None,
            args: ::std::option::Option::None,
            app_name: ::std::option::Option::None,
            override_appid: ::std::option::Option::None,
            flatpak_appid: ::std::option::Option::None,
            tags: ::std::vec::Vec::new(),
            is_remote: ::std::option::Option::None,
            is_hidden: ::std::option::Option::None,
            is_temporary: ::std::option::Option::None,
            is_openvr: ::std::option::Option::None,
            allow_desktop_config: ::std::option::Option::None,
            allow_overlay: ::std::option::Option::None,
            rt_last_played_time: ::std::option::Option::None,
            is_devkit_shortcut: ::std::option::Option::None,
            devkit_gameid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgShortcutAppIds)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgShortcutAppIds {
    // message fields
    // @@protoc_insertion_point(field:CMsgShortcutAppIds.appids)
    pub appids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgShortcutAppIds.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgShortcutAppIds {
    fn default() -> &'a CMsgShortcutAppIds {
        <CMsgShortcutAppIds as ::protobuf::Message>::default_instance()
    }
}

impl CMsgShortcutAppIds {
    pub fn new() -> CMsgShortcutAppIds {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgShortcutAppIds {
    const NAME: &'static str = "CMsgShortcutAppIds";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.appids)?;
                },
                8 => {
                    self.appids.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.appids {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.appids {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgShortcutAppIds {
        CMsgShortcutAppIds::new()
    }

    fn clear(&mut self) {
        self.appids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgShortcutAppIds {
        static instance: CMsgShortcutAppIds = CMsgShortcutAppIds {
            appids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgMonitorInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMonitorInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgMonitorInfo.selected_display_name)
    pub selected_display_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgMonitorInfo.monitors)
    pub monitors: ::std::vec::Vec<cmsg_monitor_info::MonitorInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMonitorInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMonitorInfo {
    fn default() -> &'a CMsgMonitorInfo {
        <CMsgMonitorInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMonitorInfo {
    pub fn new() -> CMsgMonitorInfo {
        ::std::default::Default::default()
    }

    // required string selected_display_name = 1;

    pub fn selected_display_name(&self) -> &str {
        match self.selected_display_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_selected_display_name(&mut self) {
        self.selected_display_name = ::std::option::Option::None;
    }

    pub fn has_selected_display_name(&self) -> bool {
        self.selected_display_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selected_display_name(&mut self, v: ::std::string::String) {
        self.selected_display_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selected_display_name(&mut self) -> &mut ::std::string::String {
        if self.selected_display_name.is_none() {
            self.selected_display_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.selected_display_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_selected_display_name(&mut self) -> ::std::string::String {
        self.selected_display_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgMonitorInfo {
    const NAME: &'static str = "CMsgMonitorInfo";

    fn is_initialized(&self) -> bool {
        if self.selected_display_name.is_none() {
            return false;
        }
        for v in &self.monitors {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.selected_display_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.monitors.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.selected_display_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.monitors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.selected_display_name.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.monitors {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMonitorInfo {
        CMsgMonitorInfo::new()
    }

    fn clear(&mut self) {
        self.selected_display_name = ::std::option::Option::None;
        self.monitors.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMonitorInfo {
        static instance: CMsgMonitorInfo = CMsgMonitorInfo {
            selected_display_name: ::std::option::Option::None,
            monitors: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgMonitorInfo`
pub mod cmsg_monitor_info {
    // @@protoc_insertion_point(message:CMsgMonitorInfo.MonitorInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct MonitorInfo {
        // message fields
        // @@protoc_insertion_point(field:CMsgMonitorInfo.MonitorInfo.monitor_device_name)
        pub monitor_device_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgMonitorInfo.MonitorInfo.monitor_display_name)
        pub monitor_display_name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgMonitorInfo.MonitorInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MonitorInfo {
        fn default() -> &'a MonitorInfo {
            <MonitorInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl MonitorInfo {
        pub fn new() -> MonitorInfo {
            ::std::default::Default::default()
        }

        // required string monitor_device_name = 1;

        pub fn monitor_device_name(&self) -> &str {
            match self.monitor_device_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_monitor_device_name(&mut self) {
            self.monitor_device_name = ::std::option::Option::None;
        }

        pub fn has_monitor_device_name(&self) -> bool {
            self.monitor_device_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_monitor_device_name(&mut self, v: ::std::string::String) {
            self.monitor_device_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_monitor_device_name(&mut self) -> &mut ::std::string::String {
            if self.monitor_device_name.is_none() {
                self.monitor_device_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.monitor_device_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_monitor_device_name(&mut self) -> ::std::string::String {
            self.monitor_device_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // required string monitor_display_name = 2;

        pub fn monitor_display_name(&self) -> &str {
            match self.monitor_display_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_monitor_display_name(&mut self) {
            self.monitor_display_name = ::std::option::Option::None;
        }

        pub fn has_monitor_display_name(&self) -> bool {
            self.monitor_display_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_monitor_display_name(&mut self, v: ::std::string::String) {
            self.monitor_display_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_monitor_display_name(&mut self) -> &mut ::std::string::String {
            if self.monitor_display_name.is_none() {
                self.monitor_display_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.monitor_display_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_monitor_display_name(&mut self) -> ::std::string::String {
            self.monitor_display_name.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::protobuf::Message for MonitorInfo {
        const NAME: &'static str = "MonitorInfo";

        fn is_initialized(&self) -> bool {
            if self.monitor_device_name.is_none() {
                return false;
            }
            if self.monitor_display_name.is_none() {
                return false;
            }
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.monitor_device_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.monitor_display_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.monitor_device_name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.monitor_display_name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.monitor_device_name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.monitor_display_name.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MonitorInfo {
            MonitorInfo::new()
        }

        fn clear(&mut self) {
            self.monitor_device_name = ::std::option::Option::None;
            self.monitor_display_name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MonitorInfo {
            static instance: MonitorInfo = MonitorInfo {
                monitor_device_name: ::std::option::Option::None,
                monitor_display_name: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgGenerateSystemReportReply)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGenerateSystemReportReply {
    // message fields
    // @@protoc_insertion_point(field:CMsgGenerateSystemReportReply.report_id)
    pub report_id: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGenerateSystemReportReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGenerateSystemReportReply {
    fn default() -> &'a CMsgGenerateSystemReportReply {
        <CMsgGenerateSystemReportReply as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGenerateSystemReportReply {
    pub fn new() -> CMsgGenerateSystemReportReply {
        ::std::default::Default::default()
    }

    // optional string report_id = 1;

    pub fn report_id(&self) -> &str {
        match self.report_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_report_id(&mut self) {
        self.report_id = ::std::option::Option::None;
    }

    pub fn has_report_id(&self) -> bool {
        self.report_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_report_id(&mut self, v: ::std::string::String) {
        self.report_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_report_id(&mut self) -> &mut ::std::string::String {
        if self.report_id.is_none() {
            self.report_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.report_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_report_id(&mut self) -> ::std::string::String {
        self.report_id.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgGenerateSystemReportReply {
    const NAME: &'static str = "CMsgGenerateSystemReportReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.report_id = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.report_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.report_id.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGenerateSystemReportReply {
        CMsgGenerateSystemReportReply::new()
    }

    fn clear(&mut self) {
        self.report_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGenerateSystemReportReply {
        static instance: CMsgGenerateSystemReportReply = CMsgGenerateSystemReportReply {
            report_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgWebUITransportInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgWebUITransportInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgWebUITransportInfo.port)
    pub port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgWebUITransportInfo.auth_key)
    pub auth_key: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgWebUITransportInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgWebUITransportInfo {
    fn default() -> &'a CMsgWebUITransportInfo {
        <CMsgWebUITransportInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgWebUITransportInfo {
    pub fn new() -> CMsgWebUITransportInfo {
        ::std::default::Default::default()
    }

    // optional uint32 port = 1;

    pub fn port(&self) -> u32 {
        self.port.unwrap_or(0)
    }

    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = ::std::option::Option::Some(v);
    }

    // optional string auth_key = 2;

    pub fn auth_key(&self) -> &str {
        match self.auth_key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_auth_key(&mut self) {
        self.auth_key = ::std::option::Option::None;
    }

    pub fn has_auth_key(&self) -> bool {
        self.auth_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auth_key(&mut self, v: ::std::string::String) {
        self.auth_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_key(&mut self) -> &mut ::std::string::String {
        if self.auth_key.is_none() {
            self.auth_key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.auth_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_auth_key(&mut self) -> ::std::string::String {
        self.auth_key.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgWebUITransportInfo {
    const NAME: &'static str = "CMsgWebUITransportInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.port = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.auth_key = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.port {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.auth_key.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.port {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.auth_key.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgWebUITransportInfo {
        CMsgWebUITransportInfo::new()
    }

    fn clear(&mut self) {
        self.port = ::std::option::Option::None;
        self.auth_key = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgWebUITransportInfo {
        static instance: CMsgWebUITransportInfo = CMsgWebUITransportInfo {
            port: ::std::option::Option::None,
            auth_key: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ECloudPendingRemoteOperation)
pub enum ECloudPendingRemoteOperation {
    // @@protoc_insertion_point(enum_value:ECloudPendingRemoteOperation.k_ECloudPendingRemoteOperationNone)
    k_ECloudPendingRemoteOperationNone = 0,
    // @@protoc_insertion_point(enum_value:ECloudPendingRemoteOperation.k_ECloudPendingRemoteOperationAppSessionActive)
    k_ECloudPendingRemoteOperationAppSessionActive = 1,
    // @@protoc_insertion_point(enum_value:ECloudPendingRemoteOperation.k_ECloudPendingRemoteOperationUploadInProgress)
    k_ECloudPendingRemoteOperationUploadInProgress = 2,
    // @@protoc_insertion_point(enum_value:ECloudPendingRemoteOperation.k_ECloudPendingRemoteOperationUploadPending)
    k_ECloudPendingRemoteOperationUploadPending = 3,
    // @@protoc_insertion_point(enum_value:ECloudPendingRemoteOperation.k_ECloudPendingRemoteOperationAppSessionSuspended)
    k_ECloudPendingRemoteOperationAppSessionSuspended = 4,
}

impl ::protobuf::Enum for ECloudPendingRemoteOperation {
    const NAME: &'static str = "ECloudPendingRemoteOperation";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ECloudPendingRemoteOperation> {
        match value {
            0 => ::std::option::Option::Some(ECloudPendingRemoteOperation::k_ECloudPendingRemoteOperationNone),
            1 => ::std::option::Option::Some(ECloudPendingRemoteOperation::k_ECloudPendingRemoteOperationAppSessionActive),
            2 => ::std::option::Option::Some(ECloudPendingRemoteOperation::k_ECloudPendingRemoteOperationUploadInProgress),
            3 => ::std::option::Option::Some(ECloudPendingRemoteOperation::k_ECloudPendingRemoteOperationUploadPending),
            4 => ::std::option::Option::Some(ECloudPendingRemoteOperation::k_ECloudPendingRemoteOperationAppSessionSuspended),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ECloudPendingRemoteOperation> {
        match str {
            "k_ECloudPendingRemoteOperationNone" => ::std::option::Option::Some(ECloudPendingRemoteOperation::k_ECloudPendingRemoteOperationNone),
            "k_ECloudPendingRemoteOperationAppSessionActive" => ::std::option::Option::Some(ECloudPendingRemoteOperation::k_ECloudPendingRemoteOperationAppSessionActive),
            "k_ECloudPendingRemoteOperationUploadInProgress" => ::std::option::Option::Some(ECloudPendingRemoteOperation::k_ECloudPendingRemoteOperationUploadInProgress),
            "k_ECloudPendingRemoteOperationUploadPending" => ::std::option::Option::Some(ECloudPendingRemoteOperation::k_ECloudPendingRemoteOperationUploadPending),
            "k_ECloudPendingRemoteOperationAppSessionSuspended" => ::std::option::Option::Some(ECloudPendingRemoteOperation::k_ECloudPendingRemoteOperationAppSessionSuspended),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ECloudPendingRemoteOperation] = &[
        ECloudPendingRemoteOperation::k_ECloudPendingRemoteOperationNone,
        ECloudPendingRemoteOperation::k_ECloudPendingRemoteOperationAppSessionActive,
        ECloudPendingRemoteOperation::k_ECloudPendingRemoteOperationUploadInProgress,
        ECloudPendingRemoteOperation::k_ECloudPendingRemoteOperationUploadPending,
        ECloudPendingRemoteOperation::k_ECloudPendingRemoteOperationAppSessionSuspended,
    ];
}

impl ::std::default::Default for ECloudPendingRemoteOperation {
    fn default() -> Self {
        ECloudPendingRemoteOperation::k_ECloudPendingRemoteOperationNone
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESteamDeckKeyboardLayout)
pub enum ESteamDeckKeyboardLayout {
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_QWERTY)
    k_ESteamDeckKeyboardLayout_QWERTY = 0,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Bulgarian)
    k_ESteamDeckKeyboardLayout_Bulgarian = 1,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Chinese_Simplified)
    k_ESteamDeckKeyboardLayout_Chinese_Simplified = 2,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Chinese_Traditional)
    k_ESteamDeckKeyboardLayout_Chinese_Traditional = 3,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Czech)
    k_ESteamDeckKeyboardLayout_Czech = 4,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Danish)
    k_ESteamDeckKeyboardLayout_Danish = 5,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Finnish)
    k_ESteamDeckKeyboardLayout_Finnish = 6,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_French)
    k_ESteamDeckKeyboardLayout_French = 7,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_German)
    k_ESteamDeckKeyboardLayout_German = 8,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Greek)
    k_ESteamDeckKeyboardLayout_Greek = 9,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Hungarian)
    k_ESteamDeckKeyboardLayout_Hungarian = 10,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Italian)
    k_ESteamDeckKeyboardLayout_Italian = 11,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Japanese)
    k_ESteamDeckKeyboardLayout_Japanese = 12,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Korean)
    k_ESteamDeckKeyboardLayout_Korean = 13,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Norwegian)
    k_ESteamDeckKeyboardLayout_Norwegian = 14,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Polish)
    k_ESteamDeckKeyboardLayout_Polish = 15,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Portuguese)
    k_ESteamDeckKeyboardLayout_Portuguese = 16,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Romanian)
    k_ESteamDeckKeyboardLayout_Romanian = 17,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Russian)
    k_ESteamDeckKeyboardLayout_Russian = 18,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Spanish)
    k_ESteamDeckKeyboardLayout_Spanish = 19,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Swedish)
    k_ESteamDeckKeyboardLayout_Swedish = 20,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Thai)
    k_ESteamDeckKeyboardLayout_Thai = 21,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Turkish_F)
    k_ESteamDeckKeyboardLayout_Turkish_F = 22,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Turkish_Q)
    k_ESteamDeckKeyboardLayout_Turkish_Q = 23,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Ukrainian)
    k_ESteamDeckKeyboardLayout_Ukrainian = 24,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Vietnamese)
    k_ESteamDeckKeyboardLayout_Vietnamese = 25,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_QWERTY_International)
    k_ESteamDeckKeyboardLayout_QWERTY_International = 26,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Dvorak)
    k_ESteamDeckKeyboardLayout_Dvorak = 27,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Colemak)
    k_ESteamDeckKeyboardLayout_Colemak = 28,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Bulgarian_Phonetic_Traditional)
    k_ESteamDeckKeyboardLayout_Bulgarian_Phonetic_Traditional = 29,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Bulgarian_Phonetic)
    k_ESteamDeckKeyboardLayout_Bulgarian_Phonetic = 30,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Chinese_Traditional_Bopomofo)
    k_ESteamDeckKeyboardLayout_Chinese_Traditional_Bopomofo = 31,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Chinese_Traditional_Cangjie)
    k_ESteamDeckKeyboardLayout_Chinese_Traditional_Cangjie = 32,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Japanese_Kana)
    k_ESteamDeckKeyboardLayout_Japanese_Kana = 33,
    // @@protoc_insertion_point(enum_value:ESteamDeckKeyboardLayout.k_ESteamDeckKeyboardLayout_Chinese_Traditional_Quick)
    k_ESteamDeckKeyboardLayout_Chinese_Traditional_Quick = 34,
}

impl ::protobuf::Enum for ESteamDeckKeyboardLayout {
    const NAME: &'static str = "ESteamDeckKeyboardLayout";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESteamDeckKeyboardLayout> {
        match value {
            0 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_QWERTY),
            1 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Bulgarian),
            2 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Chinese_Simplified),
            3 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Chinese_Traditional),
            4 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Czech),
            5 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Danish),
            6 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Finnish),
            7 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_French),
            8 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_German),
            9 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Greek),
            10 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Hungarian),
            11 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Italian),
            12 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Japanese),
            13 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Korean),
            14 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Norwegian),
            15 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Polish),
            16 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Portuguese),
            17 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Romanian),
            18 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Russian),
            19 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Spanish),
            20 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Swedish),
            21 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Thai),
            22 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Turkish_F),
            23 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Turkish_Q),
            24 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Ukrainian),
            25 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Vietnamese),
            26 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_QWERTY_International),
            27 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Dvorak),
            28 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Colemak),
            29 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Bulgarian_Phonetic_Traditional),
            30 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Bulgarian_Phonetic),
            31 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Chinese_Traditional_Bopomofo),
            32 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Chinese_Traditional_Cangjie),
            33 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Japanese_Kana),
            34 => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Chinese_Traditional_Quick),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESteamDeckKeyboardLayout> {
        match str {
            "k_ESteamDeckKeyboardLayout_QWERTY" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_QWERTY),
            "k_ESteamDeckKeyboardLayout_Bulgarian" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Bulgarian),
            "k_ESteamDeckKeyboardLayout_Chinese_Simplified" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Chinese_Simplified),
            "k_ESteamDeckKeyboardLayout_Chinese_Traditional" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Chinese_Traditional),
            "k_ESteamDeckKeyboardLayout_Czech" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Czech),
            "k_ESteamDeckKeyboardLayout_Danish" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Danish),
            "k_ESteamDeckKeyboardLayout_Finnish" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Finnish),
            "k_ESteamDeckKeyboardLayout_French" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_French),
            "k_ESteamDeckKeyboardLayout_German" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_German),
            "k_ESteamDeckKeyboardLayout_Greek" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Greek),
            "k_ESteamDeckKeyboardLayout_Hungarian" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Hungarian),
            "k_ESteamDeckKeyboardLayout_Italian" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Italian),
            "k_ESteamDeckKeyboardLayout_Japanese" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Japanese),
            "k_ESteamDeckKeyboardLayout_Korean" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Korean),
            "k_ESteamDeckKeyboardLayout_Norwegian" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Norwegian),
            "k_ESteamDeckKeyboardLayout_Polish" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Polish),
            "k_ESteamDeckKeyboardLayout_Portuguese" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Portuguese),
            "k_ESteamDeckKeyboardLayout_Romanian" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Romanian),
            "k_ESteamDeckKeyboardLayout_Russian" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Russian),
            "k_ESteamDeckKeyboardLayout_Spanish" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Spanish),
            "k_ESteamDeckKeyboardLayout_Swedish" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Swedish),
            "k_ESteamDeckKeyboardLayout_Thai" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Thai),
            "k_ESteamDeckKeyboardLayout_Turkish_F" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Turkish_F),
            "k_ESteamDeckKeyboardLayout_Turkish_Q" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Turkish_Q),
            "k_ESteamDeckKeyboardLayout_Ukrainian" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Ukrainian),
            "k_ESteamDeckKeyboardLayout_Vietnamese" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Vietnamese),
            "k_ESteamDeckKeyboardLayout_QWERTY_International" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_QWERTY_International),
            "k_ESteamDeckKeyboardLayout_Dvorak" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Dvorak),
            "k_ESteamDeckKeyboardLayout_Colemak" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Colemak),
            "k_ESteamDeckKeyboardLayout_Bulgarian_Phonetic_Traditional" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Bulgarian_Phonetic_Traditional),
            "k_ESteamDeckKeyboardLayout_Bulgarian_Phonetic" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Bulgarian_Phonetic),
            "k_ESteamDeckKeyboardLayout_Chinese_Traditional_Bopomofo" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Chinese_Traditional_Bopomofo),
            "k_ESteamDeckKeyboardLayout_Chinese_Traditional_Cangjie" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Chinese_Traditional_Cangjie),
            "k_ESteamDeckKeyboardLayout_Japanese_Kana" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Japanese_Kana),
            "k_ESteamDeckKeyboardLayout_Chinese_Traditional_Quick" => ::std::option::Option::Some(ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Chinese_Traditional_Quick),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESteamDeckKeyboardLayout] = &[
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_QWERTY,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Bulgarian,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Chinese_Simplified,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Chinese_Traditional,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Czech,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Danish,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Finnish,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_French,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_German,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Greek,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Hungarian,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Italian,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Japanese,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Korean,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Norwegian,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Polish,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Portuguese,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Romanian,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Russian,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Spanish,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Swedish,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Thai,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Turkish_F,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Turkish_Q,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Ukrainian,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Vietnamese,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_QWERTY_International,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Dvorak,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Colemak,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Bulgarian_Phonetic_Traditional,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Bulgarian_Phonetic,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Chinese_Traditional_Bopomofo,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Chinese_Traditional_Cangjie,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Japanese_Kana,
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_Chinese_Traditional_Quick,
    ];
}

impl ::std::default::Default for ESteamDeckKeyboardLayout {
    fn default() -> Self {
        ESteamDeckKeyboardLayout::k_ESteamDeckKeyboardLayout_QWERTY
    }
}

#[allow(unused_imports)]
use crate::enums::*;
impl crate::RpcMessage for SteamMessagesClientIClientForcedEnumDependencies {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgNetworkDeviceIP4Address {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgNetworkDeviceIP4Config {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgNetworkDeviceIP6Address {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgNetworkDeviceIP6Config {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgNetworkDevicesData {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgNetworkDeviceConnect {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgStorageDevicesData {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CCloud_PendingRemoteOperation {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgCloudPendingRemoteOperations {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgBluetoothDevicesData {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSystemPerfDiagnosticEntry {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSystemPerfNetworkInterface {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSystemPerfDiagnosticInfo {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSystemPerfLimits {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSystemPerfSettingsGlobal {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSystemPerfSettingsPerApp {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSystemPerfSettings {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSystemPerfSettingsV1 {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSystemPerfState {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSystemPerfUpdateSettings {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSystemDockUpdateState {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSystemDockState {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSystemDockUpdateFirmware {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSystemAudioVolume {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSystemAudioManagerObject {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSystemAudioManagerDevice {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSystemAudioManagerNode {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSystemAudioManagerPort {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSystemAudioManagerLink {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSystemAudioManagerStateHW {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSystemAudioManagerState {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSystemAudioManagerUpdateSomething {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSystemDisplayMode {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSystemDisplay {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSystemDisplayManagerState {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSystemDisplayManagerSetMode {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSystemManagerSettings {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSelectOSBranchParams {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSystemUpdateProgress {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSystemUpdateCheckResult {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSystemUpdateApplyParams {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSystemUpdateApplyResult {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgSystemUpdateState {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgAchievementChange {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgCellList {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgShortcutInfo {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgShortcutAppIds {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgMonitorInfo {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgGenerateSystemReportReply {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgWebUITransportInfo {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
