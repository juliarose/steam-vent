// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_clientserver_friends.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:CMsgClientFriendMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientFriendMsg {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientFriendMsg.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientFriendMsg.chat_entry_type)
    pub chat_entry_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientFriendMsg.message)
    pub message: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientFriendMsg.rtime32_server_timestamp)
    pub rtime32_server_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientFriendMsg.echo_to_sender)
    pub echo_to_sender: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientFriendMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientFriendMsg {
    fn default() -> &'a CMsgClientFriendMsg {
        <CMsgClientFriendMsg as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientFriendMsg {
    pub fn new() -> CMsgClientFriendMsg {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional int32 chat_entry_type = 2;

    pub fn chat_entry_type(&self) -> i32 {
        self.chat_entry_type.unwrap_or(0)
    }

    pub fn clear_chat_entry_type(&mut self) {
        self.chat_entry_type = ::std::option::Option::None;
    }

    pub fn has_chat_entry_type(&self) -> bool {
        self.chat_entry_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_entry_type(&mut self, v: i32) {
        self.chat_entry_type = ::std::option::Option::Some(v);
    }

    // optional bytes message = 3;

    pub fn message(&self) -> &[u8] {
        match self.message.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::vec::Vec<u8>) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::vec::Vec<u8> {
        self.message.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed32 rtime32_server_timestamp = 4;

    pub fn rtime32_server_timestamp(&self) -> u32 {
        self.rtime32_server_timestamp.unwrap_or(0)
    }

    pub fn clear_rtime32_server_timestamp(&mut self) {
        self.rtime32_server_timestamp = ::std::option::Option::None;
    }

    pub fn has_rtime32_server_timestamp(&self) -> bool {
        self.rtime32_server_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_server_timestamp(&mut self, v: u32) {
        self.rtime32_server_timestamp = ::std::option::Option::Some(v);
    }

    // optional bool echo_to_sender = 5;

    pub fn echo_to_sender(&self) -> bool {
        self.echo_to_sender.unwrap_or(false)
    }

    pub fn clear_echo_to_sender(&mut self) {
        self.echo_to_sender = ::std::option::Option::None;
    }

    pub fn has_echo_to_sender(&self) -> bool {
        self.echo_to_sender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_echo_to_sender(&mut self, v: bool) {
        self.echo_to_sender = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientFriendMsg {
    const NAME: &'static str = "CMsgClientFriendMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.chat_entry_type = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.message = ::std::option::Option::Some(is.read_bytes()?);
                },
                37 => {
                    self.rtime32_server_timestamp = ::std::option::Option::Some(is.read_fixed32()?);
                },
                40 => {
                    self.echo_to_sender = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.chat_entry_type {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.rtime32_server_timestamp {
            my_size += 1 + 4;
        }
        if let Some(v) = self.echo_to_sender {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.chat_entry_type {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.rtime32_server_timestamp {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.echo_to_sender {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientFriendMsg {
        CMsgClientFriendMsg::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.chat_entry_type = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.rtime32_server_timestamp = ::std::option::Option::None;
        self.echo_to_sender = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientFriendMsg {
        static instance: CMsgClientFriendMsg = CMsgClientFriendMsg {
            steamid: ::std::option::Option::None,
            chat_entry_type: ::std::option::Option::None,
            message: ::std::option::Option::None,
            rtime32_server_timestamp: ::std::option::Option::None,
            echo_to_sender: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientFriendMsgIncoming)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientFriendMsgIncoming {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientFriendMsgIncoming.steamid_from)
    pub steamid_from: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientFriendMsgIncoming.chat_entry_type)
    pub chat_entry_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientFriendMsgIncoming.from_limited_account)
    pub from_limited_account: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientFriendMsgIncoming.message)
    pub message: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientFriendMsgIncoming.rtime32_server_timestamp)
    pub rtime32_server_timestamp: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientFriendMsgIncoming.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientFriendMsgIncoming {
    fn default() -> &'a CMsgClientFriendMsgIncoming {
        <CMsgClientFriendMsgIncoming as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientFriendMsgIncoming {
    pub fn new() -> CMsgClientFriendMsgIncoming {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_from = 1;

    pub fn steamid_from(&self) -> u64 {
        self.steamid_from.unwrap_or(0)
    }

    pub fn clear_steamid_from(&mut self) {
        self.steamid_from = ::std::option::Option::None;
    }

    pub fn has_steamid_from(&self) -> bool {
        self.steamid_from.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_from(&mut self, v: u64) {
        self.steamid_from = ::std::option::Option::Some(v);
    }

    // optional int32 chat_entry_type = 2;

    pub fn chat_entry_type(&self) -> i32 {
        self.chat_entry_type.unwrap_or(0)
    }

    pub fn clear_chat_entry_type(&mut self) {
        self.chat_entry_type = ::std::option::Option::None;
    }

    pub fn has_chat_entry_type(&self) -> bool {
        self.chat_entry_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_entry_type(&mut self, v: i32) {
        self.chat_entry_type = ::std::option::Option::Some(v);
    }

    // optional bool from_limited_account = 3;

    pub fn from_limited_account(&self) -> bool {
        self.from_limited_account.unwrap_or(false)
    }

    pub fn clear_from_limited_account(&mut self) {
        self.from_limited_account = ::std::option::Option::None;
    }

    pub fn has_from_limited_account(&self) -> bool {
        self.from_limited_account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_limited_account(&mut self, v: bool) {
        self.from_limited_account = ::std::option::Option::Some(v);
    }

    // optional bytes message = 4;

    pub fn message(&self) -> &[u8] {
        match self.message.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::vec::Vec<u8>) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::vec::Vec<u8> {
        self.message.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed32 rtime32_server_timestamp = 5;

    pub fn rtime32_server_timestamp(&self) -> u32 {
        self.rtime32_server_timestamp.unwrap_or(0)
    }

    pub fn clear_rtime32_server_timestamp(&mut self) {
        self.rtime32_server_timestamp = ::std::option::Option::None;
    }

    pub fn has_rtime32_server_timestamp(&self) -> bool {
        self.rtime32_server_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_server_timestamp(&mut self, v: u32) {
        self.rtime32_server_timestamp = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientFriendMsgIncoming {
    const NAME: &'static str = "CMsgClientFriendMsgIncoming";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid_from = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.chat_entry_type = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.from_limited_account = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    self.message = ::std::option::Option::Some(is.read_bytes()?);
                },
                45 => {
                    self.rtime32_server_timestamp = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_from {
            my_size += 1 + 8;
        }
        if let Some(v) = self.chat_entry_type {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.from_limited_account {
            my_size += 1 + 1;
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.rtime32_server_timestamp {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid_from {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.chat_entry_type {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.from_limited_account {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.rtime32_server_timestamp {
            os.write_fixed32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientFriendMsgIncoming {
        CMsgClientFriendMsgIncoming::new()
    }

    fn clear(&mut self) {
        self.steamid_from = ::std::option::Option::None;
        self.chat_entry_type = ::std::option::Option::None;
        self.from_limited_account = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.rtime32_server_timestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientFriendMsgIncoming {
        static instance: CMsgClientFriendMsgIncoming = CMsgClientFriendMsgIncoming {
            steamid_from: ::std::option::Option::None,
            chat_entry_type: ::std::option::Option::None,
            from_limited_account: ::std::option::Option::None,
            message: ::std::option::Option::None,
            rtime32_server_timestamp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientAddFriend)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientAddFriend {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientAddFriend.steamid_to_add)
    pub steamid_to_add: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientAddFriend.accountname_or_email_to_add)
    pub accountname_or_email_to_add: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientAddFriend.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientAddFriend {
    fn default() -> &'a CMsgClientAddFriend {
        <CMsgClientAddFriend as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAddFriend {
    pub fn new() -> CMsgClientAddFriend {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_to_add = 1;

    pub fn steamid_to_add(&self) -> u64 {
        self.steamid_to_add.unwrap_or(0)
    }

    pub fn clear_steamid_to_add(&mut self) {
        self.steamid_to_add = ::std::option::Option::None;
    }

    pub fn has_steamid_to_add(&self) -> bool {
        self.steamid_to_add.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_to_add(&mut self, v: u64) {
        self.steamid_to_add = ::std::option::Option::Some(v);
    }

    // optional string accountname_or_email_to_add = 2;

    pub fn accountname_or_email_to_add(&self) -> &str {
        match self.accountname_or_email_to_add.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_accountname_or_email_to_add(&mut self) {
        self.accountname_or_email_to_add = ::std::option::Option::None;
    }

    pub fn has_accountname_or_email_to_add(&self) -> bool {
        self.accountname_or_email_to_add.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountname_or_email_to_add(&mut self, v: ::std::string::String) {
        self.accountname_or_email_to_add = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accountname_or_email_to_add(&mut self) -> &mut ::std::string::String {
        if self.accountname_or_email_to_add.is_none() {
            self.accountname_or_email_to_add = ::std::option::Option::Some(::std::string::String::new());
        }
        self.accountname_or_email_to_add.as_mut().unwrap()
    }

    // Take field
    pub fn take_accountname_or_email_to_add(&mut self) -> ::std::string::String {
        self.accountname_or_email_to_add.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientAddFriend {
    const NAME: &'static str = "CMsgClientAddFriend";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid_to_add = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    self.accountname_or_email_to_add = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_to_add {
            my_size += 1 + 8;
        }
        if let Some(v) = self.accountname_or_email_to_add.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid_to_add {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.accountname_or_email_to_add.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientAddFriend {
        CMsgClientAddFriend::new()
    }

    fn clear(&mut self) {
        self.steamid_to_add = ::std::option::Option::None;
        self.accountname_or_email_to_add = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientAddFriend {
        static instance: CMsgClientAddFriend = CMsgClientAddFriend {
            steamid_to_add: ::std::option::Option::None,
            accountname_or_email_to_add: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientAddFriendResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientAddFriendResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientAddFriendResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientAddFriendResponse.steam_id_added)
    pub steam_id_added: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientAddFriendResponse.persona_name_added)
    pub persona_name_added: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientAddFriendResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientAddFriendResponse {
    fn default() -> &'a CMsgClientAddFriendResponse {
        <CMsgClientAddFriendResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAddFriendResponse {
    pub fn new() -> CMsgClientAddFriendResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_added = 2;

    pub fn steam_id_added(&self) -> u64 {
        self.steam_id_added.unwrap_or(0)
    }

    pub fn clear_steam_id_added(&mut self) {
        self.steam_id_added = ::std::option::Option::None;
    }

    pub fn has_steam_id_added(&self) -> bool {
        self.steam_id_added.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_added(&mut self, v: u64) {
        self.steam_id_added = ::std::option::Option::Some(v);
    }

    // optional string persona_name_added = 3;

    pub fn persona_name_added(&self) -> &str {
        match self.persona_name_added.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_persona_name_added(&mut self) {
        self.persona_name_added = ::std::option::Option::None;
    }

    pub fn has_persona_name_added(&self) -> bool {
        self.persona_name_added.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_name_added(&mut self, v: ::std::string::String) {
        self.persona_name_added = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persona_name_added(&mut self) -> &mut ::std::string::String {
        if self.persona_name_added.is_none() {
            self.persona_name_added = ::std::option::Option::Some(::std::string::String::new());
        }
        self.persona_name_added.as_mut().unwrap()
    }

    // Take field
    pub fn take_persona_name_added(&mut self) -> ::std::string::String {
        self.persona_name_added.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientAddFriendResponse {
    const NAME: &'static str = "CMsgClientAddFriendResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                17 => {
                    self.steam_id_added = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    self.persona_name_added = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.steam_id_added {
            my_size += 1 + 8;
        }
        if let Some(v) = self.persona_name_added.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.steam_id_added {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.persona_name_added.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientAddFriendResponse {
        CMsgClientAddFriendResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.steam_id_added = ::std::option::Option::None;
        self.persona_name_added = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientAddFriendResponse {
        static instance: CMsgClientAddFriendResponse = CMsgClientAddFriendResponse {
            eresult: ::std::option::Option::None,
            steam_id_added: ::std::option::Option::None,
            persona_name_added: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientRemoveFriend)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRemoveFriend {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRemoveFriend.friendid)
    pub friendid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRemoveFriend.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRemoveFriend {
    fn default() -> &'a CMsgClientRemoveFriend {
        <CMsgClientRemoveFriend as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRemoveFriend {
    pub fn new() -> CMsgClientRemoveFriend {
        ::std::default::Default::default()
    }

    // optional fixed64 friendid = 1;

    pub fn friendid(&self) -> u64 {
        self.friendid.unwrap_or(0)
    }

    pub fn clear_friendid(&mut self) {
        self.friendid = ::std::option::Option::None;
    }

    pub fn has_friendid(&self) -> bool {
        self.friendid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friendid(&mut self, v: u64) {
        self.friendid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientRemoveFriend {
    const NAME: &'static str = "CMsgClientRemoveFriend";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.friendid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.friendid {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.friendid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRemoveFriend {
        CMsgClientRemoveFriend::new()
    }

    fn clear(&mut self) {
        self.friendid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRemoveFriend {
        static instance: CMsgClientRemoveFriend = CMsgClientRemoveFriend {
            friendid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientHideFriend)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientHideFriend {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientHideFriend.friendid)
    pub friendid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientHideFriend.hide)
    pub hide: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientHideFriend.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientHideFriend {
    fn default() -> &'a CMsgClientHideFriend {
        <CMsgClientHideFriend as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientHideFriend {
    pub fn new() -> CMsgClientHideFriend {
        ::std::default::Default::default()
    }

    // optional fixed64 friendid = 1;

    pub fn friendid(&self) -> u64 {
        self.friendid.unwrap_or(0)
    }

    pub fn clear_friendid(&mut self) {
        self.friendid = ::std::option::Option::None;
    }

    pub fn has_friendid(&self) -> bool {
        self.friendid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friendid(&mut self, v: u64) {
        self.friendid = ::std::option::Option::Some(v);
    }

    // optional bool hide = 2;

    pub fn hide(&self) -> bool {
        self.hide.unwrap_or(false)
    }

    pub fn clear_hide(&mut self) {
        self.hide = ::std::option::Option::None;
    }

    pub fn has_hide(&self) -> bool {
        self.hide.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hide(&mut self, v: bool) {
        self.hide = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientHideFriend {
    const NAME: &'static str = "CMsgClientHideFriend";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.friendid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.hide = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.friendid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.hide {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.friendid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.hide {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientHideFriend {
        CMsgClientHideFriend::new()
    }

    fn clear(&mut self) {
        self.friendid = ::std::option::Option::None;
        self.hide = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientHideFriend {
        static instance: CMsgClientHideFriend = CMsgClientHideFriend {
            friendid: ::std::option::Option::None,
            hide: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientFriendsList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientFriendsList {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientFriendsList.bincremental)
    pub bincremental: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientFriendsList.friends)
    pub friends: ::std::vec::Vec<cmsg_client_friends_list::Friend>,
    // @@protoc_insertion_point(field:CMsgClientFriendsList.max_friend_count)
    pub max_friend_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientFriendsList.active_friend_count)
    pub active_friend_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientFriendsList.friends_limit_hit)
    pub friends_limit_hit: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientFriendsList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientFriendsList {
    fn default() -> &'a CMsgClientFriendsList {
        <CMsgClientFriendsList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientFriendsList {
    pub fn new() -> CMsgClientFriendsList {
        ::std::default::Default::default()
    }

    // optional bool bincremental = 1;

    pub fn bincremental(&self) -> bool {
        self.bincremental.unwrap_or(false)
    }

    pub fn clear_bincremental(&mut self) {
        self.bincremental = ::std::option::Option::None;
    }

    pub fn has_bincremental(&self) -> bool {
        self.bincremental.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bincremental(&mut self, v: bool) {
        self.bincremental = ::std::option::Option::Some(v);
    }

    // optional uint32 max_friend_count = 3;

    pub fn max_friend_count(&self) -> u32 {
        self.max_friend_count.unwrap_or(0)
    }

    pub fn clear_max_friend_count(&mut self) {
        self.max_friend_count = ::std::option::Option::None;
    }

    pub fn has_max_friend_count(&self) -> bool {
        self.max_friend_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_friend_count(&mut self, v: u32) {
        self.max_friend_count = ::std::option::Option::Some(v);
    }

    // optional uint32 active_friend_count = 4;

    pub fn active_friend_count(&self) -> u32 {
        self.active_friend_count.unwrap_or(0)
    }

    pub fn clear_active_friend_count(&mut self) {
        self.active_friend_count = ::std::option::Option::None;
    }

    pub fn has_active_friend_count(&self) -> bool {
        self.active_friend_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_friend_count(&mut self, v: u32) {
        self.active_friend_count = ::std::option::Option::Some(v);
    }

    // optional bool friends_limit_hit = 5;

    pub fn friends_limit_hit(&self) -> bool {
        self.friends_limit_hit.unwrap_or(false)
    }

    pub fn clear_friends_limit_hit(&mut self) {
        self.friends_limit_hit = ::std::option::Option::None;
    }

    pub fn has_friends_limit_hit(&self) -> bool {
        self.friends_limit_hit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friends_limit_hit(&mut self, v: bool) {
        self.friends_limit_hit = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientFriendsList {
    const NAME: &'static str = "CMsgClientFriendsList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.bincremental = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    self.friends.push(is.read_message()?);
                },
                24 => {
                    self.max_friend_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.active_friend_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.friends_limit_hit = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.bincremental {
            my_size += 1 + 1;
        }
        for value in &self.friends {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.max_friend_count {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.active_friend_count {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.friends_limit_hit {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.bincremental {
            os.write_bool(1, v)?;
        }
        for v in &self.friends {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.max_friend_count {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.active_friend_count {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.friends_limit_hit {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientFriendsList {
        CMsgClientFriendsList::new()
    }

    fn clear(&mut self) {
        self.bincremental = ::std::option::Option::None;
        self.friends.clear();
        self.max_friend_count = ::std::option::Option::None;
        self.active_friend_count = ::std::option::Option::None;
        self.friends_limit_hit = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientFriendsList {
        static instance: CMsgClientFriendsList = CMsgClientFriendsList {
            bincremental: ::std::option::Option::None,
            friends: ::std::vec::Vec::new(),
            max_friend_count: ::std::option::Option::None,
            active_friend_count: ::std::option::Option::None,
            friends_limit_hit: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientFriendsList`
pub mod cmsg_client_friends_list {
    // @@protoc_insertion_point(message:CMsgClientFriendsList.Friend)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Friend {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientFriendsList.Friend.ulfriendid)
        pub ulfriendid: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientFriendsList.Friend.efriendrelationship)
        pub efriendrelationship: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientFriendsList.Friend.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Friend {
        fn default() -> &'a Friend {
            <Friend as ::protobuf::Message>::default_instance()
        }
    }

    impl Friend {
        pub fn new() -> Friend {
            ::std::default::Default::default()
        }

        // optional fixed64 ulfriendid = 1;

        pub fn ulfriendid(&self) -> u64 {
            self.ulfriendid.unwrap_or(0)
        }

        pub fn clear_ulfriendid(&mut self) {
            self.ulfriendid = ::std::option::Option::None;
        }

        pub fn has_ulfriendid(&self) -> bool {
            self.ulfriendid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ulfriendid(&mut self, v: u64) {
            self.ulfriendid = ::std::option::Option::Some(v);
        }

        // optional uint32 efriendrelationship = 2;

        pub fn efriendrelationship(&self) -> u32 {
            self.efriendrelationship.unwrap_or(0)
        }

        pub fn clear_efriendrelationship(&mut self) {
            self.efriendrelationship = ::std::option::Option::None;
        }

        pub fn has_efriendrelationship(&self) -> bool {
            self.efriendrelationship.is_some()
        }

        // Param is passed by value, moved
        pub fn set_efriendrelationship(&mut self, v: u32) {
            self.efriendrelationship = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Friend {
        const NAME: &'static str = "Friend";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.ulfriendid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.efriendrelationship = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.ulfriendid {
                my_size += 1 + 8;
            }
            if let Some(v) = self.efriendrelationship {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.ulfriendid {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.efriendrelationship {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Friend {
            Friend::new()
        }

        fn clear(&mut self) {
            self.ulfriendid = ::std::option::Option::None;
            self.efriendrelationship = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Friend {
            static instance: Friend = Friend {
                ulfriendid: ::std::option::Option::None,
                efriendrelationship: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientFriendsGroupsList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientFriendsGroupsList {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientFriendsGroupsList.bremoval)
    pub bremoval: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientFriendsGroupsList.bincremental)
    pub bincremental: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientFriendsGroupsList.friendGroups)
    pub friendGroups: ::std::vec::Vec<cmsg_client_friends_groups_list::FriendGroup>,
    // @@protoc_insertion_point(field:CMsgClientFriendsGroupsList.memberships)
    pub memberships: ::std::vec::Vec<cmsg_client_friends_groups_list::FriendGroupsMembership>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientFriendsGroupsList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientFriendsGroupsList {
    fn default() -> &'a CMsgClientFriendsGroupsList {
        <CMsgClientFriendsGroupsList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientFriendsGroupsList {
    pub fn new() -> CMsgClientFriendsGroupsList {
        ::std::default::Default::default()
    }

    // optional bool bremoval = 1;

    pub fn bremoval(&self) -> bool {
        self.bremoval.unwrap_or(false)
    }

    pub fn clear_bremoval(&mut self) {
        self.bremoval = ::std::option::Option::None;
    }

    pub fn has_bremoval(&self) -> bool {
        self.bremoval.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bremoval(&mut self, v: bool) {
        self.bremoval = ::std::option::Option::Some(v);
    }

    // optional bool bincremental = 2;

    pub fn bincremental(&self) -> bool {
        self.bincremental.unwrap_or(false)
    }

    pub fn clear_bincremental(&mut self) {
        self.bincremental = ::std::option::Option::None;
    }

    pub fn has_bincremental(&self) -> bool {
        self.bincremental.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bincremental(&mut self, v: bool) {
        self.bincremental = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientFriendsGroupsList {
    const NAME: &'static str = "CMsgClientFriendsGroupsList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.bremoval = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.bincremental = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.friendGroups.push(is.read_message()?);
                },
                34 => {
                    self.memberships.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.bremoval {
            my_size += 1 + 1;
        }
        if let Some(v) = self.bincremental {
            my_size += 1 + 1;
        }
        for value in &self.friendGroups {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.memberships {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.bremoval {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.bincremental {
            os.write_bool(2, v)?;
        }
        for v in &self.friendGroups {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.memberships {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientFriendsGroupsList {
        CMsgClientFriendsGroupsList::new()
    }

    fn clear(&mut self) {
        self.bremoval = ::std::option::Option::None;
        self.bincremental = ::std::option::Option::None;
        self.friendGroups.clear();
        self.memberships.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientFriendsGroupsList {
        static instance: CMsgClientFriendsGroupsList = CMsgClientFriendsGroupsList {
            bremoval: ::std::option::Option::None,
            bincremental: ::std::option::Option::None,
            friendGroups: ::std::vec::Vec::new(),
            memberships: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientFriendsGroupsList`
pub mod cmsg_client_friends_groups_list {
    // @@protoc_insertion_point(message:CMsgClientFriendsGroupsList.FriendGroup)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct FriendGroup {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientFriendsGroupsList.FriendGroup.nGroupID)
        pub nGroupID: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientFriendsGroupsList.FriendGroup.strGroupName)
        pub strGroupName: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientFriendsGroupsList.FriendGroup.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FriendGroup {
        fn default() -> &'a FriendGroup {
            <FriendGroup as ::protobuf::Message>::default_instance()
        }
    }

    impl FriendGroup {
        pub fn new() -> FriendGroup {
            ::std::default::Default::default()
        }

        // optional int32 nGroupID = 1;

        pub fn nGroupID(&self) -> i32 {
            self.nGroupID.unwrap_or(0)
        }

        pub fn clear_nGroupID(&mut self) {
            self.nGroupID = ::std::option::Option::None;
        }

        pub fn has_nGroupID(&self) -> bool {
            self.nGroupID.is_some()
        }

        // Param is passed by value, moved
        pub fn set_nGroupID(&mut self, v: i32) {
            self.nGroupID = ::std::option::Option::Some(v);
        }

        // optional string strGroupName = 2;

        pub fn strGroupName(&self) -> &str {
            match self.strGroupName.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_strGroupName(&mut self) {
            self.strGroupName = ::std::option::Option::None;
        }

        pub fn has_strGroupName(&self) -> bool {
            self.strGroupName.is_some()
        }

        // Param is passed by value, moved
        pub fn set_strGroupName(&mut self, v: ::std::string::String) {
            self.strGroupName = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_strGroupName(&mut self) -> &mut ::std::string::String {
            if self.strGroupName.is_none() {
                self.strGroupName = ::std::option::Option::Some(::std::string::String::new());
            }
            self.strGroupName.as_mut().unwrap()
        }

        // Take field
        pub fn take_strGroupName(&mut self) -> ::std::string::String {
            self.strGroupName.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::protobuf::Message for FriendGroup {
        const NAME: &'static str = "FriendGroup";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.nGroupID = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.strGroupName = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.nGroupID {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.strGroupName.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.nGroupID {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.strGroupName.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FriendGroup {
            FriendGroup::new()
        }

        fn clear(&mut self) {
            self.nGroupID = ::std::option::Option::None;
            self.strGroupName = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FriendGroup {
            static instance: FriendGroup = FriendGroup {
                nGroupID: ::std::option::Option::None,
                strGroupName: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgClientFriendsGroupsList.FriendGroupsMembership)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct FriendGroupsMembership {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientFriendsGroupsList.FriendGroupsMembership.ulSteamID)
        pub ulSteamID: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientFriendsGroupsList.FriendGroupsMembership.nGroupID)
        pub nGroupID: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientFriendsGroupsList.FriendGroupsMembership.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FriendGroupsMembership {
        fn default() -> &'a FriendGroupsMembership {
            <FriendGroupsMembership as ::protobuf::Message>::default_instance()
        }
    }

    impl FriendGroupsMembership {
        pub fn new() -> FriendGroupsMembership {
            ::std::default::Default::default()
        }

        // optional fixed64 ulSteamID = 1;

        pub fn ulSteamID(&self) -> u64 {
            self.ulSteamID.unwrap_or(0)
        }

        pub fn clear_ulSteamID(&mut self) {
            self.ulSteamID = ::std::option::Option::None;
        }

        pub fn has_ulSteamID(&self) -> bool {
            self.ulSteamID.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ulSteamID(&mut self, v: u64) {
            self.ulSteamID = ::std::option::Option::Some(v);
        }

        // optional int32 nGroupID = 2;

        pub fn nGroupID(&self) -> i32 {
            self.nGroupID.unwrap_or(0)
        }

        pub fn clear_nGroupID(&mut self) {
            self.nGroupID = ::std::option::Option::None;
        }

        pub fn has_nGroupID(&self) -> bool {
            self.nGroupID.is_some()
        }

        // Param is passed by value, moved
        pub fn set_nGroupID(&mut self, v: i32) {
            self.nGroupID = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for FriendGroupsMembership {
        const NAME: &'static str = "FriendGroupsMembership";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.ulSteamID = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.nGroupID = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.ulSteamID {
                my_size += 1 + 8;
            }
            if let Some(v) = self.nGroupID {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.ulSteamID {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.nGroupID {
                os.write_int32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FriendGroupsMembership {
            FriendGroupsMembership::new()
        }

        fn clear(&mut self) {
            self.ulSteamID = ::std::option::Option::None;
            self.nGroupID = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FriendGroupsMembership {
            static instance: FriendGroupsMembership = FriendGroupsMembership {
                ulSteamID: ::std::option::Option::None,
                nGroupID: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientPlayerNicknameList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientPlayerNicknameList {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientPlayerNicknameList.removal)
    pub removal: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientPlayerNicknameList.incremental)
    pub incremental: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientPlayerNicknameList.nicknames)
    pub nicknames: ::std::vec::Vec<cmsg_client_player_nickname_list::PlayerNickname>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientPlayerNicknameList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientPlayerNicknameList {
    fn default() -> &'a CMsgClientPlayerNicknameList {
        <CMsgClientPlayerNicknameList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPlayerNicknameList {
    pub fn new() -> CMsgClientPlayerNicknameList {
        ::std::default::Default::default()
    }

    // optional bool removal = 1;

    pub fn removal(&self) -> bool {
        self.removal.unwrap_or(false)
    }

    pub fn clear_removal(&mut self) {
        self.removal = ::std::option::Option::None;
    }

    pub fn has_removal(&self) -> bool {
        self.removal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_removal(&mut self, v: bool) {
        self.removal = ::std::option::Option::Some(v);
    }

    // optional bool incremental = 2;

    pub fn incremental(&self) -> bool {
        self.incremental.unwrap_or(false)
    }

    pub fn clear_incremental(&mut self) {
        self.incremental = ::std::option::Option::None;
    }

    pub fn has_incremental(&self) -> bool {
        self.incremental.is_some()
    }

    // Param is passed by value, moved
    pub fn set_incremental(&mut self, v: bool) {
        self.incremental = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientPlayerNicknameList {
    const NAME: &'static str = "CMsgClientPlayerNicknameList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.removal = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.incremental = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.nicknames.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.removal {
            my_size += 1 + 1;
        }
        if let Some(v) = self.incremental {
            my_size += 1 + 1;
        }
        for value in &self.nicknames {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.removal {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.incremental {
            os.write_bool(2, v)?;
        }
        for v in &self.nicknames {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientPlayerNicknameList {
        CMsgClientPlayerNicknameList::new()
    }

    fn clear(&mut self) {
        self.removal = ::std::option::Option::None;
        self.incremental = ::std::option::Option::None;
        self.nicknames.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientPlayerNicknameList {
        static instance: CMsgClientPlayerNicknameList = CMsgClientPlayerNicknameList {
            removal: ::std::option::Option::None,
            incremental: ::std::option::Option::None,
            nicknames: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientPlayerNicknameList`
pub mod cmsg_client_player_nickname_list {
    // @@protoc_insertion_point(message:CMsgClientPlayerNicknameList.PlayerNickname)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlayerNickname {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientPlayerNicknameList.PlayerNickname.steamid)
        pub steamid: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientPlayerNicknameList.PlayerNickname.nickname)
        pub nickname: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientPlayerNicknameList.PlayerNickname.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayerNickname {
        fn default() -> &'a PlayerNickname {
            <PlayerNickname as ::protobuf::Message>::default_instance()
        }
    }

    impl PlayerNickname {
        pub fn new() -> PlayerNickname {
            ::std::default::Default::default()
        }

        // optional fixed64 steamid = 1;

        pub fn steamid(&self) -> u64 {
            self.steamid.unwrap_or(0)
        }

        pub fn clear_steamid(&mut self) {
            self.steamid = ::std::option::Option::None;
        }

        pub fn has_steamid(&self) -> bool {
            self.steamid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steamid(&mut self, v: u64) {
            self.steamid = ::std::option::Option::Some(v);
        }

        // optional string nickname = 3;

        pub fn nickname(&self) -> &str {
            match self.nickname.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_nickname(&mut self) {
            self.nickname = ::std::option::Option::None;
        }

        pub fn has_nickname(&self) -> bool {
            self.nickname.is_some()
        }

        // Param is passed by value, moved
        pub fn set_nickname(&mut self, v: ::std::string::String) {
            self.nickname = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_nickname(&mut self) -> &mut ::std::string::String {
            if self.nickname.is_none() {
                self.nickname = ::std::option::Option::Some(::std::string::String::new());
            }
            self.nickname.as_mut().unwrap()
        }

        // Take field
        pub fn take_nickname(&mut self) -> ::std::string::String {
            self.nickname.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::protobuf::Message for PlayerNickname {
        const NAME: &'static str = "PlayerNickname";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    26 => {
                        self.nickname = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steamid {
                my_size += 1 + 8;
            }
            if let Some(v) = self.nickname.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.steamid {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.nickname.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayerNickname {
            PlayerNickname::new()
        }

        fn clear(&mut self) {
            self.steamid = ::std::option::Option::None;
            self.nickname = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayerNickname {
            static instance: PlayerNickname = PlayerNickname {
                steamid: ::std::option::Option::None,
                nickname: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientSetPlayerNickname)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientSetPlayerNickname {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientSetPlayerNickname.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientSetPlayerNickname.nickname)
    pub nickname: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientSetPlayerNickname.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientSetPlayerNickname {
    fn default() -> &'a CMsgClientSetPlayerNickname {
        <CMsgClientSetPlayerNickname as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientSetPlayerNickname {
    pub fn new() -> CMsgClientSetPlayerNickname {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional string nickname = 2;

    pub fn nickname(&self) -> &str {
        match self.nickname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_nickname(&mut self) {
        self.nickname = ::std::option::Option::None;
    }

    pub fn has_nickname(&self) -> bool {
        self.nickname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nickname(&mut self, v: ::std::string::String) {
        self.nickname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nickname(&mut self) -> &mut ::std::string::String {
        if self.nickname.is_none() {
            self.nickname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.nickname.as_mut().unwrap()
    }

    // Take field
    pub fn take_nickname(&mut self) -> ::std::string::String {
        self.nickname.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientSetPlayerNickname {
    const NAME: &'static str = "CMsgClientSetPlayerNickname";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    self.nickname = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.nickname.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.nickname.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientSetPlayerNickname {
        CMsgClientSetPlayerNickname::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.nickname = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientSetPlayerNickname {
        static instance: CMsgClientSetPlayerNickname = CMsgClientSetPlayerNickname {
            steamid: ::std::option::Option::None,
            nickname: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientSetPlayerNicknameResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientSetPlayerNicknameResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientSetPlayerNicknameResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientSetPlayerNicknameResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientSetPlayerNicknameResponse {
    fn default() -> &'a CMsgClientSetPlayerNicknameResponse {
        <CMsgClientSetPlayerNicknameResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientSetPlayerNicknameResponse {
    pub fn new() -> CMsgClientSetPlayerNicknameResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientSetPlayerNicknameResponse {
    const NAME: &'static str = "CMsgClientSetPlayerNicknameResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientSetPlayerNicknameResponse {
        CMsgClientSetPlayerNicknameResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientSetPlayerNicknameResponse {
        static instance: CMsgClientSetPlayerNicknameResponse = CMsgClientSetPlayerNicknameResponse {
            eresult: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientRequestFriendData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRequestFriendData {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRequestFriendData.persona_state_requested)
    pub persona_state_requested: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientRequestFriendData.friends)
    pub friends: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRequestFriendData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestFriendData {
    fn default() -> &'a CMsgClientRequestFriendData {
        <CMsgClientRequestFriendData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestFriendData {
    pub fn new() -> CMsgClientRequestFriendData {
        ::std::default::Default::default()
    }

    // optional uint32 persona_state_requested = 1;

    pub fn persona_state_requested(&self) -> u32 {
        self.persona_state_requested.unwrap_or(0)
    }

    pub fn clear_persona_state_requested(&mut self) {
        self.persona_state_requested = ::std::option::Option::None;
    }

    pub fn has_persona_state_requested(&self) -> bool {
        self.persona_state_requested.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_state_requested(&mut self, v: u32) {
        self.persona_state_requested = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientRequestFriendData {
    const NAME: &'static str = "CMsgClientRequestFriendData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.persona_state_requested = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_fixed64_into(&mut self.friends)?;
                },
                17 => {
                    self.friends.push(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.persona_state_requested {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += 9 * self.friends.len() as u64;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.persona_state_requested {
            os.write_uint32(1, v)?;
        }
        for v in &self.friends {
            os.write_fixed64(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRequestFriendData {
        CMsgClientRequestFriendData::new()
    }

    fn clear(&mut self) {
        self.persona_state_requested = ::std::option::Option::None;
        self.friends.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRequestFriendData {
        static instance: CMsgClientRequestFriendData = CMsgClientRequestFriendData {
            persona_state_requested: ::std::option::Option::None,
            friends: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientChangeStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientChangeStatus {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientChangeStatus.persona_state)
    pub persona_state: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientChangeStatus.player_name)
    pub player_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientChangeStatus.is_auto_generated_name)
    pub is_auto_generated_name: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientChangeStatus.high_priority)
    pub high_priority: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientChangeStatus.persona_set_by_user)
    pub persona_set_by_user: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientChangeStatus.persona_state_flags)
    pub persona_state_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientChangeStatus.need_persona_response)
    pub need_persona_response: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientChangeStatus.is_client_idle)
    pub is_client_idle: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientChangeStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientChangeStatus {
    fn default() -> &'a CMsgClientChangeStatus {
        <CMsgClientChangeStatus as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientChangeStatus {
    pub fn new() -> CMsgClientChangeStatus {
        ::std::default::Default::default()
    }

    // optional uint32 persona_state = 1;

    pub fn persona_state(&self) -> u32 {
        self.persona_state.unwrap_or(0)
    }

    pub fn clear_persona_state(&mut self) {
        self.persona_state = ::std::option::Option::None;
    }

    pub fn has_persona_state(&self) -> bool {
        self.persona_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_state(&mut self, v: u32) {
        self.persona_state = ::std::option::Option::Some(v);
    }

    // optional string player_name = 2;

    pub fn player_name(&self) -> &str {
        match self.player_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_player_name(&mut self) {
        self.player_name = ::std::option::Option::None;
    }

    pub fn has_player_name(&self) -> bool {
        self.player_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_name(&mut self, v: ::std::string::String) {
        self.player_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_name(&mut self) -> &mut ::std::string::String {
        if self.player_name.is_none() {
            self.player_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.player_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_name(&mut self) -> ::std::string::String {
        self.player_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_auto_generated_name = 3;

    pub fn is_auto_generated_name(&self) -> bool {
        self.is_auto_generated_name.unwrap_or(false)
    }

    pub fn clear_is_auto_generated_name(&mut self) {
        self.is_auto_generated_name = ::std::option::Option::None;
    }

    pub fn has_is_auto_generated_name(&self) -> bool {
        self.is_auto_generated_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_auto_generated_name(&mut self, v: bool) {
        self.is_auto_generated_name = ::std::option::Option::Some(v);
    }

    // optional bool high_priority = 4;

    pub fn high_priority(&self) -> bool {
        self.high_priority.unwrap_or(false)
    }

    pub fn clear_high_priority(&mut self) {
        self.high_priority = ::std::option::Option::None;
    }

    pub fn has_high_priority(&self) -> bool {
        self.high_priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_high_priority(&mut self, v: bool) {
        self.high_priority = ::std::option::Option::Some(v);
    }

    // optional bool persona_set_by_user = 5;

    pub fn persona_set_by_user(&self) -> bool {
        self.persona_set_by_user.unwrap_or(false)
    }

    pub fn clear_persona_set_by_user(&mut self) {
        self.persona_set_by_user = ::std::option::Option::None;
    }

    pub fn has_persona_set_by_user(&self) -> bool {
        self.persona_set_by_user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_set_by_user(&mut self, v: bool) {
        self.persona_set_by_user = ::std::option::Option::Some(v);
    }

    // optional uint32 persona_state_flags = 6;

    pub fn persona_state_flags(&self) -> u32 {
        self.persona_state_flags.unwrap_or(0u32)
    }

    pub fn clear_persona_state_flags(&mut self) {
        self.persona_state_flags = ::std::option::Option::None;
    }

    pub fn has_persona_state_flags(&self) -> bool {
        self.persona_state_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_state_flags(&mut self, v: u32) {
        self.persona_state_flags = ::std::option::Option::Some(v);
    }

    // optional bool need_persona_response = 7;

    pub fn need_persona_response(&self) -> bool {
        self.need_persona_response.unwrap_or(false)
    }

    pub fn clear_need_persona_response(&mut self) {
        self.need_persona_response = ::std::option::Option::None;
    }

    pub fn has_need_persona_response(&self) -> bool {
        self.need_persona_response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_need_persona_response(&mut self, v: bool) {
        self.need_persona_response = ::std::option::Option::Some(v);
    }

    // optional bool is_client_idle = 8;

    pub fn is_client_idle(&self) -> bool {
        self.is_client_idle.unwrap_or(false)
    }

    pub fn clear_is_client_idle(&mut self) {
        self.is_client_idle = ::std::option::Option::None;
    }

    pub fn has_is_client_idle(&self) -> bool {
        self.is_client_idle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_client_idle(&mut self, v: bool) {
        self.is_client_idle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientChangeStatus {
    const NAME: &'static str = "CMsgClientChangeStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.persona_state = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.player_name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.is_auto_generated_name = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.high_priority = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.persona_set_by_user = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.persona_state_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.need_persona_response = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.is_client_idle = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.persona_state {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.player_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.is_auto_generated_name {
            my_size += 1 + 1;
        }
        if let Some(v) = self.high_priority {
            my_size += 1 + 1;
        }
        if let Some(v) = self.persona_set_by_user {
            my_size += 1 + 1;
        }
        if let Some(v) = self.persona_state_flags {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.need_persona_response {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_client_idle {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.persona_state {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.player_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.is_auto_generated_name {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.high_priority {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.persona_set_by_user {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.persona_state_flags {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.need_persona_response {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.is_client_idle {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientChangeStatus {
        CMsgClientChangeStatus::new()
    }

    fn clear(&mut self) {
        self.persona_state = ::std::option::Option::None;
        self.player_name = ::std::option::Option::None;
        self.is_auto_generated_name = ::std::option::Option::None;
        self.high_priority = ::std::option::Option::None;
        self.persona_set_by_user = ::std::option::Option::None;
        self.persona_state_flags = ::std::option::Option::None;
        self.need_persona_response = ::std::option::Option::None;
        self.is_client_idle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientChangeStatus {
        static instance: CMsgClientChangeStatus = CMsgClientChangeStatus {
            persona_state: ::std::option::Option::None,
            player_name: ::std::option::Option::None,
            is_auto_generated_name: ::std::option::Option::None,
            high_priority: ::std::option::Option::None,
            persona_set_by_user: ::std::option::Option::None,
            persona_state_flags: ::std::option::Option::None,
            need_persona_response: ::std::option::Option::None,
            is_client_idle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPersonaChangeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPersonaChangeResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgPersonaChangeResponse.result)
    pub result: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPersonaChangeResponse.player_name)
    pub player_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPersonaChangeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPersonaChangeResponse {
    fn default() -> &'a CMsgPersonaChangeResponse {
        <CMsgPersonaChangeResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPersonaChangeResponse {
    pub fn new() -> CMsgPersonaChangeResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional string player_name = 2;

    pub fn player_name(&self) -> &str {
        match self.player_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_player_name(&mut self) {
        self.player_name = ::std::option::Option::None;
    }

    pub fn has_player_name(&self) -> bool {
        self.player_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_name(&mut self, v: ::std::string::String) {
        self.player_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_name(&mut self) -> &mut ::std::string::String {
        if self.player_name.is_none() {
            self.player_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.player_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_name(&mut self) -> ::std::string::String {
        self.player_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgPersonaChangeResponse {
    const NAME: &'static str = "CMsgPersonaChangeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.player_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.player_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.player_name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPersonaChangeResponse {
        CMsgPersonaChangeResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.player_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPersonaChangeResponse {
        static instance: CMsgPersonaChangeResponse = CMsgPersonaChangeResponse {
            result: ::std::option::Option::None,
            player_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientPersonaState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientPersonaState {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientPersonaState.status_flags)
    pub status_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientPersonaState.friends)
    pub friends: ::std::vec::Vec<cmsg_client_persona_state::Friend>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientPersonaState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientPersonaState {
    fn default() -> &'a CMsgClientPersonaState {
        <CMsgClientPersonaState as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPersonaState {
    pub fn new() -> CMsgClientPersonaState {
        ::std::default::Default::default()
    }

    // optional uint32 status_flags = 1;

    pub fn status_flags(&self) -> u32 {
        self.status_flags.unwrap_or(0)
    }

    pub fn clear_status_flags(&mut self) {
        self.status_flags = ::std::option::Option::None;
    }

    pub fn has_status_flags(&self) -> bool {
        self.status_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status_flags(&mut self, v: u32) {
        self.status_flags = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientPersonaState {
    const NAME: &'static str = "CMsgClientPersonaState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.friends.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status_flags {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.friends {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status_flags {
            os.write_uint32(1, v)?;
        }
        for v in &self.friends {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientPersonaState {
        CMsgClientPersonaState::new()
    }

    fn clear(&mut self) {
        self.status_flags = ::std::option::Option::None;
        self.friends.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientPersonaState {
        static instance: CMsgClientPersonaState = CMsgClientPersonaState {
            status_flags: ::std::option::Option::None,
            friends: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientPersonaState`
pub mod cmsg_client_persona_state {
    // @@protoc_insertion_point(message:CMsgClientPersonaState.Friend)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Friend {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.friendid)
        pub friendid: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.persona_state)
        pub persona_state: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.game_played_app_id)
        pub game_played_app_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.game_server_ip)
        pub game_server_ip: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.game_server_port)
        pub game_server_port: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.persona_state_flags)
        pub persona_state_flags: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.online_session_instances)
        pub online_session_instances: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.persona_set_by_user)
        pub persona_set_by_user: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.player_name)
        pub player_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.query_port)
        pub query_port: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.steamid_source)
        pub steamid_source: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.avatar_hash)
        pub avatar_hash: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.last_logoff)
        pub last_logoff: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.last_logon)
        pub last_logon: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.last_seen_online)
        pub last_seen_online: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.clan_rank)
        pub clan_rank: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.game_name)
        pub game_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.gameid)
        pub gameid: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.game_data_blob)
        pub game_data_blob: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.clan_data)
        pub clan_data: ::protobuf::MessageField<friend::ClanData>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.clan_tag)
        pub clan_tag: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.rich_presence)
        pub rich_presence: ::std::vec::Vec<friend::KV>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.broadcast_id)
        pub broadcast_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.game_lobby_id)
        pub game_lobby_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.watching_broadcast_accountid)
        pub watching_broadcast_accountid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.watching_broadcast_appid)
        pub watching_broadcast_appid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.watching_broadcast_viewers)
        pub watching_broadcast_viewers: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.watching_broadcast_title)
        pub watching_broadcast_title: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.is_community_banned)
        pub is_community_banned: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.player_name_pending_review)
        pub player_name_pending_review: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.avatar_pending_review)
        pub avatar_pending_review: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientPersonaState.Friend.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Friend {
        fn default() -> &'a Friend {
            <Friend as ::protobuf::Message>::default_instance()
        }
    }

    impl Friend {
        pub fn new() -> Friend {
            ::std::default::Default::default()
        }

        // optional fixed64 friendid = 1;

        pub fn friendid(&self) -> u64 {
            self.friendid.unwrap_or(0)
        }

        pub fn clear_friendid(&mut self) {
            self.friendid = ::std::option::Option::None;
        }

        pub fn has_friendid(&self) -> bool {
            self.friendid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_friendid(&mut self, v: u64) {
            self.friendid = ::std::option::Option::Some(v);
        }

        // optional uint32 persona_state = 2;

        pub fn persona_state(&self) -> u32 {
            self.persona_state.unwrap_or(0)
        }

        pub fn clear_persona_state(&mut self) {
            self.persona_state = ::std::option::Option::None;
        }

        pub fn has_persona_state(&self) -> bool {
            self.persona_state.is_some()
        }

        // Param is passed by value, moved
        pub fn set_persona_state(&mut self, v: u32) {
            self.persona_state = ::std::option::Option::Some(v);
        }

        // optional uint32 game_played_app_id = 3;

        pub fn game_played_app_id(&self) -> u32 {
            self.game_played_app_id.unwrap_or(0)
        }

        pub fn clear_game_played_app_id(&mut self) {
            self.game_played_app_id = ::std::option::Option::None;
        }

        pub fn has_game_played_app_id(&self) -> bool {
            self.game_played_app_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_played_app_id(&mut self, v: u32) {
            self.game_played_app_id = ::std::option::Option::Some(v);
        }

        // optional uint32 game_server_ip = 4;

        pub fn game_server_ip(&self) -> u32 {
            self.game_server_ip.unwrap_or(0)
        }

        pub fn clear_game_server_ip(&mut self) {
            self.game_server_ip = ::std::option::Option::None;
        }

        pub fn has_game_server_ip(&self) -> bool {
            self.game_server_ip.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_server_ip(&mut self, v: u32) {
            self.game_server_ip = ::std::option::Option::Some(v);
        }

        // optional uint32 game_server_port = 5;

        pub fn game_server_port(&self) -> u32 {
            self.game_server_port.unwrap_or(0)
        }

        pub fn clear_game_server_port(&mut self) {
            self.game_server_port = ::std::option::Option::None;
        }

        pub fn has_game_server_port(&self) -> bool {
            self.game_server_port.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_server_port(&mut self, v: u32) {
            self.game_server_port = ::std::option::Option::Some(v);
        }

        // optional uint32 persona_state_flags = 6;

        pub fn persona_state_flags(&self) -> u32 {
            self.persona_state_flags.unwrap_or(0)
        }

        pub fn clear_persona_state_flags(&mut self) {
            self.persona_state_flags = ::std::option::Option::None;
        }

        pub fn has_persona_state_flags(&self) -> bool {
            self.persona_state_flags.is_some()
        }

        // Param is passed by value, moved
        pub fn set_persona_state_flags(&mut self, v: u32) {
            self.persona_state_flags = ::std::option::Option::Some(v);
        }

        // optional uint32 online_session_instances = 7;

        pub fn online_session_instances(&self) -> u32 {
            self.online_session_instances.unwrap_or(0)
        }

        pub fn clear_online_session_instances(&mut self) {
            self.online_session_instances = ::std::option::Option::None;
        }

        pub fn has_online_session_instances(&self) -> bool {
            self.online_session_instances.is_some()
        }

        // Param is passed by value, moved
        pub fn set_online_session_instances(&mut self, v: u32) {
            self.online_session_instances = ::std::option::Option::Some(v);
        }

        // optional bool persona_set_by_user = 10;

        pub fn persona_set_by_user(&self) -> bool {
            self.persona_set_by_user.unwrap_or(false)
        }

        pub fn clear_persona_set_by_user(&mut self) {
            self.persona_set_by_user = ::std::option::Option::None;
        }

        pub fn has_persona_set_by_user(&self) -> bool {
            self.persona_set_by_user.is_some()
        }

        // Param is passed by value, moved
        pub fn set_persona_set_by_user(&mut self, v: bool) {
            self.persona_set_by_user = ::std::option::Option::Some(v);
        }

        // optional string player_name = 15;

        pub fn player_name(&self) -> &str {
            match self.player_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_player_name(&mut self) {
            self.player_name = ::std::option::Option::None;
        }

        pub fn has_player_name(&self) -> bool {
            self.player_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_name(&mut self, v: ::std::string::String) {
            self.player_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_player_name(&mut self) -> &mut ::std::string::String {
            if self.player_name.is_none() {
                self.player_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.player_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_player_name(&mut self) -> ::std::string::String {
            self.player_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 query_port = 20;

        pub fn query_port(&self) -> u32 {
            self.query_port.unwrap_or(0)
        }

        pub fn clear_query_port(&mut self) {
            self.query_port = ::std::option::Option::None;
        }

        pub fn has_query_port(&self) -> bool {
            self.query_port.is_some()
        }

        // Param is passed by value, moved
        pub fn set_query_port(&mut self, v: u32) {
            self.query_port = ::std::option::Option::Some(v);
        }

        // optional fixed64 steamid_source = 25;

        pub fn steamid_source(&self) -> u64 {
            self.steamid_source.unwrap_or(0)
        }

        pub fn clear_steamid_source(&mut self) {
            self.steamid_source = ::std::option::Option::None;
        }

        pub fn has_steamid_source(&self) -> bool {
            self.steamid_source.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steamid_source(&mut self, v: u64) {
            self.steamid_source = ::std::option::Option::Some(v);
        }

        // optional bytes avatar_hash = 31;

        pub fn avatar_hash(&self) -> &[u8] {
            match self.avatar_hash.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_avatar_hash(&mut self) {
            self.avatar_hash = ::std::option::Option::None;
        }

        pub fn has_avatar_hash(&self) -> bool {
            self.avatar_hash.is_some()
        }

        // Param is passed by value, moved
        pub fn set_avatar_hash(&mut self, v: ::std::vec::Vec<u8>) {
            self.avatar_hash = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_avatar_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.avatar_hash.is_none() {
                self.avatar_hash = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.avatar_hash.as_mut().unwrap()
        }

        // Take field
        pub fn take_avatar_hash(&mut self) -> ::std::vec::Vec<u8> {
            self.avatar_hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional uint32 last_logoff = 45;

        pub fn last_logoff(&self) -> u32 {
            self.last_logoff.unwrap_or(0)
        }

        pub fn clear_last_logoff(&mut self) {
            self.last_logoff = ::std::option::Option::None;
        }

        pub fn has_last_logoff(&self) -> bool {
            self.last_logoff.is_some()
        }

        // Param is passed by value, moved
        pub fn set_last_logoff(&mut self, v: u32) {
            self.last_logoff = ::std::option::Option::Some(v);
        }

        // optional uint32 last_logon = 46;

        pub fn last_logon(&self) -> u32 {
            self.last_logon.unwrap_or(0)
        }

        pub fn clear_last_logon(&mut self) {
            self.last_logon = ::std::option::Option::None;
        }

        pub fn has_last_logon(&self) -> bool {
            self.last_logon.is_some()
        }

        // Param is passed by value, moved
        pub fn set_last_logon(&mut self, v: u32) {
            self.last_logon = ::std::option::Option::Some(v);
        }

        // optional uint32 last_seen_online = 47;

        pub fn last_seen_online(&self) -> u32 {
            self.last_seen_online.unwrap_or(0)
        }

        pub fn clear_last_seen_online(&mut self) {
            self.last_seen_online = ::std::option::Option::None;
        }

        pub fn has_last_seen_online(&self) -> bool {
            self.last_seen_online.is_some()
        }

        // Param is passed by value, moved
        pub fn set_last_seen_online(&mut self, v: u32) {
            self.last_seen_online = ::std::option::Option::Some(v);
        }

        // optional uint32 clan_rank = 50;

        pub fn clan_rank(&self) -> u32 {
            self.clan_rank.unwrap_or(0)
        }

        pub fn clear_clan_rank(&mut self) {
            self.clan_rank = ::std::option::Option::None;
        }

        pub fn has_clan_rank(&self) -> bool {
            self.clan_rank.is_some()
        }

        // Param is passed by value, moved
        pub fn set_clan_rank(&mut self, v: u32) {
            self.clan_rank = ::std::option::Option::Some(v);
        }

        // optional string game_name = 55;

        pub fn game_name(&self) -> &str {
            match self.game_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_game_name(&mut self) {
            self.game_name = ::std::option::Option::None;
        }

        pub fn has_game_name(&self) -> bool {
            self.game_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_name(&mut self, v: ::std::string::String) {
            self.game_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_game_name(&mut self) -> &mut ::std::string::String {
            if self.game_name.is_none() {
                self.game_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.game_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_game_name(&mut self) -> ::std::string::String {
            self.game_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional fixed64 gameid = 56;

        pub fn gameid(&self) -> u64 {
            self.gameid.unwrap_or(0)
        }

        pub fn clear_gameid(&mut self) {
            self.gameid = ::std::option::Option::None;
        }

        pub fn has_gameid(&self) -> bool {
            self.gameid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gameid(&mut self, v: u64) {
            self.gameid = ::std::option::Option::Some(v);
        }

        // optional bytes game_data_blob = 60;

        pub fn game_data_blob(&self) -> &[u8] {
            match self.game_data_blob.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_game_data_blob(&mut self) {
            self.game_data_blob = ::std::option::Option::None;
        }

        pub fn has_game_data_blob(&self) -> bool {
            self.game_data_blob.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_data_blob(&mut self, v: ::std::vec::Vec<u8>) {
            self.game_data_blob = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_game_data_blob(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.game_data_blob.is_none() {
                self.game_data_blob = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.game_data_blob.as_mut().unwrap()
        }

        // Take field
        pub fn take_game_data_blob(&mut self) -> ::std::vec::Vec<u8> {
            self.game_data_blob.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional string clan_tag = 65;

        pub fn clan_tag(&self) -> &str {
            match self.clan_tag.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_clan_tag(&mut self) {
            self.clan_tag = ::std::option::Option::None;
        }

        pub fn has_clan_tag(&self) -> bool {
            self.clan_tag.is_some()
        }

        // Param is passed by value, moved
        pub fn set_clan_tag(&mut self, v: ::std::string::String) {
            self.clan_tag = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_clan_tag(&mut self) -> &mut ::std::string::String {
            if self.clan_tag.is_none() {
                self.clan_tag = ::std::option::Option::Some(::std::string::String::new());
            }
            self.clan_tag.as_mut().unwrap()
        }

        // Take field
        pub fn take_clan_tag(&mut self) -> ::std::string::String {
            self.clan_tag.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional fixed64 broadcast_id = 72;

        pub fn broadcast_id(&self) -> u64 {
            self.broadcast_id.unwrap_or(0)
        }

        pub fn clear_broadcast_id(&mut self) {
            self.broadcast_id = ::std::option::Option::None;
        }

        pub fn has_broadcast_id(&self) -> bool {
            self.broadcast_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_broadcast_id(&mut self, v: u64) {
            self.broadcast_id = ::std::option::Option::Some(v);
        }

        // optional fixed64 game_lobby_id = 73;

        pub fn game_lobby_id(&self) -> u64 {
            self.game_lobby_id.unwrap_or(0)
        }

        pub fn clear_game_lobby_id(&mut self) {
            self.game_lobby_id = ::std::option::Option::None;
        }

        pub fn has_game_lobby_id(&self) -> bool {
            self.game_lobby_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_lobby_id(&mut self, v: u64) {
            self.game_lobby_id = ::std::option::Option::Some(v);
        }

        // optional uint32 watching_broadcast_accountid = 74;

        pub fn watching_broadcast_accountid(&self) -> u32 {
            self.watching_broadcast_accountid.unwrap_or(0)
        }

        pub fn clear_watching_broadcast_accountid(&mut self) {
            self.watching_broadcast_accountid = ::std::option::Option::None;
        }

        pub fn has_watching_broadcast_accountid(&self) -> bool {
            self.watching_broadcast_accountid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_watching_broadcast_accountid(&mut self, v: u32) {
            self.watching_broadcast_accountid = ::std::option::Option::Some(v);
        }

        // optional uint32 watching_broadcast_appid = 75;

        pub fn watching_broadcast_appid(&self) -> u32 {
            self.watching_broadcast_appid.unwrap_or(0)
        }

        pub fn clear_watching_broadcast_appid(&mut self) {
            self.watching_broadcast_appid = ::std::option::Option::None;
        }

        pub fn has_watching_broadcast_appid(&self) -> bool {
            self.watching_broadcast_appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_watching_broadcast_appid(&mut self, v: u32) {
            self.watching_broadcast_appid = ::std::option::Option::Some(v);
        }

        // optional uint32 watching_broadcast_viewers = 76;

        pub fn watching_broadcast_viewers(&self) -> u32 {
            self.watching_broadcast_viewers.unwrap_or(0)
        }

        pub fn clear_watching_broadcast_viewers(&mut self) {
            self.watching_broadcast_viewers = ::std::option::Option::None;
        }

        pub fn has_watching_broadcast_viewers(&self) -> bool {
            self.watching_broadcast_viewers.is_some()
        }

        // Param is passed by value, moved
        pub fn set_watching_broadcast_viewers(&mut self, v: u32) {
            self.watching_broadcast_viewers = ::std::option::Option::Some(v);
        }

        // optional string watching_broadcast_title = 77;

        pub fn watching_broadcast_title(&self) -> &str {
            match self.watching_broadcast_title.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_watching_broadcast_title(&mut self) {
            self.watching_broadcast_title = ::std::option::Option::None;
        }

        pub fn has_watching_broadcast_title(&self) -> bool {
            self.watching_broadcast_title.is_some()
        }

        // Param is passed by value, moved
        pub fn set_watching_broadcast_title(&mut self, v: ::std::string::String) {
            self.watching_broadcast_title = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_watching_broadcast_title(&mut self) -> &mut ::std::string::String {
            if self.watching_broadcast_title.is_none() {
                self.watching_broadcast_title = ::std::option::Option::Some(::std::string::String::new());
            }
            self.watching_broadcast_title.as_mut().unwrap()
        }

        // Take field
        pub fn take_watching_broadcast_title(&mut self) -> ::std::string::String {
            self.watching_broadcast_title.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool is_community_banned = 78;

        pub fn is_community_banned(&self) -> bool {
            self.is_community_banned.unwrap_or(false)
        }

        pub fn clear_is_community_banned(&mut self) {
            self.is_community_banned = ::std::option::Option::None;
        }

        pub fn has_is_community_banned(&self) -> bool {
            self.is_community_banned.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_community_banned(&mut self, v: bool) {
            self.is_community_banned = ::std::option::Option::Some(v);
        }

        // optional bool player_name_pending_review = 79;

        pub fn player_name_pending_review(&self) -> bool {
            self.player_name_pending_review.unwrap_or(false)
        }

        pub fn clear_player_name_pending_review(&mut self) {
            self.player_name_pending_review = ::std::option::Option::None;
        }

        pub fn has_player_name_pending_review(&self) -> bool {
            self.player_name_pending_review.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_name_pending_review(&mut self, v: bool) {
            self.player_name_pending_review = ::std::option::Option::Some(v);
        }

        // optional bool avatar_pending_review = 80;

        pub fn avatar_pending_review(&self) -> bool {
            self.avatar_pending_review.unwrap_or(false)
        }

        pub fn clear_avatar_pending_review(&mut self) {
            self.avatar_pending_review = ::std::option::Option::None;
        }

        pub fn has_avatar_pending_review(&self) -> bool {
            self.avatar_pending_review.is_some()
        }

        // Param is passed by value, moved
        pub fn set_avatar_pending_review(&mut self, v: bool) {
            self.avatar_pending_review = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Friend {
        const NAME: &'static str = "Friend";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.friendid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.persona_state = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.game_played_app_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.game_server_ip = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.game_server_port = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.persona_state_flags = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.online_session_instances = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    80 => {
                        self.persona_set_by_user = ::std::option::Option::Some(is.read_bool()?);
                    },
                    122 => {
                        self.player_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    160 => {
                        self.query_port = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    201 => {
                        self.steamid_source = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    250 => {
                        self.avatar_hash = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    360 => {
                        self.last_logoff = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    368 => {
                        self.last_logon = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    376 => {
                        self.last_seen_online = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    400 => {
                        self.clan_rank = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    442 => {
                        self.game_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    449 => {
                        self.gameid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    482 => {
                        self.game_data_blob = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    514 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.clan_data)?;
                    },
                    522 => {
                        self.clan_tag = ::std::option::Option::Some(is.read_string()?);
                    },
                    570 => {
                        self.rich_presence.push(is.read_message()?);
                    },
                    577 => {
                        self.broadcast_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    585 => {
                        self.game_lobby_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    592 => {
                        self.watching_broadcast_accountid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    600 => {
                        self.watching_broadcast_appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    608 => {
                        self.watching_broadcast_viewers = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    618 => {
                        self.watching_broadcast_title = ::std::option::Option::Some(is.read_string()?);
                    },
                    624 => {
                        self.is_community_banned = ::std::option::Option::Some(is.read_bool()?);
                    },
                    632 => {
                        self.player_name_pending_review = ::std::option::Option::Some(is.read_bool()?);
                    },
                    640 => {
                        self.avatar_pending_review = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.friendid {
                my_size += 1 + 8;
            }
            if let Some(v) = self.persona_state {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.game_played_app_id {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.game_server_ip {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.game_server_port {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.persona_state_flags {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.online_session_instances {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.persona_set_by_user {
                my_size += 1 + 1;
            }
            if let Some(v) = self.player_name.as_ref() {
                my_size += ::protobuf::rt::string_size(15, &v);
            }
            if let Some(v) = self.query_port {
                my_size += ::protobuf::rt::uint32_size(20, v);
            }
            if let Some(v) = self.steamid_source {
                my_size += 2 + 8;
            }
            if let Some(v) = self.avatar_hash.as_ref() {
                my_size += ::protobuf::rt::bytes_size(31, &v);
            }
            if let Some(v) = self.last_logoff {
                my_size += ::protobuf::rt::uint32_size(45, v);
            }
            if let Some(v) = self.last_logon {
                my_size += ::protobuf::rt::uint32_size(46, v);
            }
            if let Some(v) = self.last_seen_online {
                my_size += ::protobuf::rt::uint32_size(47, v);
            }
            if let Some(v) = self.clan_rank {
                my_size += ::protobuf::rt::uint32_size(50, v);
            }
            if let Some(v) = self.game_name.as_ref() {
                my_size += ::protobuf::rt::string_size(55, &v);
            }
            if let Some(v) = self.gameid {
                my_size += 2 + 8;
            }
            if let Some(v) = self.game_data_blob.as_ref() {
                my_size += ::protobuf::rt::bytes_size(60, &v);
            }
            if let Some(v) = self.clan_data.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.clan_tag.as_ref() {
                my_size += ::protobuf::rt::string_size(65, &v);
            }
            for value in &self.rich_presence {
                let len = value.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.broadcast_id {
                my_size += 2 + 8;
            }
            if let Some(v) = self.game_lobby_id {
                my_size += 2 + 8;
            }
            if let Some(v) = self.watching_broadcast_accountid {
                my_size += ::protobuf::rt::uint32_size(74, v);
            }
            if let Some(v) = self.watching_broadcast_appid {
                my_size += ::protobuf::rt::uint32_size(75, v);
            }
            if let Some(v) = self.watching_broadcast_viewers {
                my_size += ::protobuf::rt::uint32_size(76, v);
            }
            if let Some(v) = self.watching_broadcast_title.as_ref() {
                my_size += ::protobuf::rt::string_size(77, &v);
            }
            if let Some(v) = self.is_community_banned {
                my_size += 2 + 1;
            }
            if let Some(v) = self.player_name_pending_review {
                my_size += 2 + 1;
            }
            if let Some(v) = self.avatar_pending_review {
                my_size += 2 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.friendid {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.persona_state {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.game_played_app_id {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.game_server_ip {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.game_server_port {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.persona_state_flags {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.online_session_instances {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.persona_set_by_user {
                os.write_bool(10, v)?;
            }
            if let Some(v) = self.player_name.as_ref() {
                os.write_string(15, v)?;
            }
            if let Some(v) = self.query_port {
                os.write_uint32(20, v)?;
            }
            if let Some(v) = self.steamid_source {
                os.write_fixed64(25, v)?;
            }
            if let Some(v) = self.avatar_hash.as_ref() {
                os.write_bytes(31, v)?;
            }
            if let Some(v) = self.last_logoff {
                os.write_uint32(45, v)?;
            }
            if let Some(v) = self.last_logon {
                os.write_uint32(46, v)?;
            }
            if let Some(v) = self.last_seen_online {
                os.write_uint32(47, v)?;
            }
            if let Some(v) = self.clan_rank {
                os.write_uint32(50, v)?;
            }
            if let Some(v) = self.game_name.as_ref() {
                os.write_string(55, v)?;
            }
            if let Some(v) = self.gameid {
                os.write_fixed64(56, v)?;
            }
            if let Some(v) = self.game_data_blob.as_ref() {
                os.write_bytes(60, v)?;
            }
            if let Some(v) = self.clan_data.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(64, v, os)?;
            }
            if let Some(v) = self.clan_tag.as_ref() {
                os.write_string(65, v)?;
            }
            for v in &self.rich_presence {
                ::protobuf::rt::write_message_field_with_cached_size(71, v, os)?;
            };
            if let Some(v) = self.broadcast_id {
                os.write_fixed64(72, v)?;
            }
            if let Some(v) = self.game_lobby_id {
                os.write_fixed64(73, v)?;
            }
            if let Some(v) = self.watching_broadcast_accountid {
                os.write_uint32(74, v)?;
            }
            if let Some(v) = self.watching_broadcast_appid {
                os.write_uint32(75, v)?;
            }
            if let Some(v) = self.watching_broadcast_viewers {
                os.write_uint32(76, v)?;
            }
            if let Some(v) = self.watching_broadcast_title.as_ref() {
                os.write_string(77, v)?;
            }
            if let Some(v) = self.is_community_banned {
                os.write_bool(78, v)?;
            }
            if let Some(v) = self.player_name_pending_review {
                os.write_bool(79, v)?;
            }
            if let Some(v) = self.avatar_pending_review {
                os.write_bool(80, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Friend {
            Friend::new()
        }

        fn clear(&mut self) {
            self.friendid = ::std::option::Option::None;
            self.persona_state = ::std::option::Option::None;
            self.game_played_app_id = ::std::option::Option::None;
            self.game_server_ip = ::std::option::Option::None;
            self.game_server_port = ::std::option::Option::None;
            self.persona_state_flags = ::std::option::Option::None;
            self.online_session_instances = ::std::option::Option::None;
            self.persona_set_by_user = ::std::option::Option::None;
            self.player_name = ::std::option::Option::None;
            self.query_port = ::std::option::Option::None;
            self.steamid_source = ::std::option::Option::None;
            self.avatar_hash = ::std::option::Option::None;
            self.last_logoff = ::std::option::Option::None;
            self.last_logon = ::std::option::Option::None;
            self.last_seen_online = ::std::option::Option::None;
            self.clan_rank = ::std::option::Option::None;
            self.game_name = ::std::option::Option::None;
            self.gameid = ::std::option::Option::None;
            self.game_data_blob = ::std::option::Option::None;
            self.clan_data.clear();
            self.clan_tag = ::std::option::Option::None;
            self.rich_presence.clear();
            self.broadcast_id = ::std::option::Option::None;
            self.game_lobby_id = ::std::option::Option::None;
            self.watching_broadcast_accountid = ::std::option::Option::None;
            self.watching_broadcast_appid = ::std::option::Option::None;
            self.watching_broadcast_viewers = ::std::option::Option::None;
            self.watching_broadcast_title = ::std::option::Option::None;
            self.is_community_banned = ::std::option::Option::None;
            self.player_name_pending_review = ::std::option::Option::None;
            self.avatar_pending_review = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Friend {
            static instance: Friend = Friend {
                friendid: ::std::option::Option::None,
                persona_state: ::std::option::Option::None,
                game_played_app_id: ::std::option::Option::None,
                game_server_ip: ::std::option::Option::None,
                game_server_port: ::std::option::Option::None,
                persona_state_flags: ::std::option::Option::None,
                online_session_instances: ::std::option::Option::None,
                persona_set_by_user: ::std::option::Option::None,
                player_name: ::std::option::Option::None,
                query_port: ::std::option::Option::None,
                steamid_source: ::std::option::Option::None,
                avatar_hash: ::std::option::Option::None,
                last_logoff: ::std::option::Option::None,
                last_logon: ::std::option::Option::None,
                last_seen_online: ::std::option::Option::None,
                clan_rank: ::std::option::Option::None,
                game_name: ::std::option::Option::None,
                gameid: ::std::option::Option::None,
                game_data_blob: ::std::option::Option::None,
                clan_data: ::protobuf::MessageField::none(),
                clan_tag: ::std::option::Option::None,
                rich_presence: ::std::vec::Vec::new(),
                broadcast_id: ::std::option::Option::None,
                game_lobby_id: ::std::option::Option::None,
                watching_broadcast_accountid: ::std::option::Option::None,
                watching_broadcast_appid: ::std::option::Option::None,
                watching_broadcast_viewers: ::std::option::Option::None,
                watching_broadcast_title: ::std::option::Option::None,
                is_community_banned: ::std::option::Option::None,
                player_name_pending_review: ::std::option::Option::None,
                avatar_pending_review: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `Friend`
    pub mod friend {
        // @@protoc_insertion_point(message:CMsgClientPersonaState.Friend.ClanData)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ClanData {
            // message fields
            // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.ClanData.ogg_app_id)
            pub ogg_app_id: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.ClanData.chat_group_id)
            pub chat_group_id: ::std::option::Option<u64>,
            // special fields
            // @@protoc_insertion_point(special_field:CMsgClientPersonaState.Friend.ClanData.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ClanData {
            fn default() -> &'a ClanData {
                <ClanData as ::protobuf::Message>::default_instance()
            }
        }

        impl ClanData {
            pub fn new() -> ClanData {
                ::std::default::Default::default()
            }

            // optional uint32 ogg_app_id = 1;

            pub fn ogg_app_id(&self) -> u32 {
                self.ogg_app_id.unwrap_or(0)
            }

            pub fn clear_ogg_app_id(&mut self) {
                self.ogg_app_id = ::std::option::Option::None;
            }

            pub fn has_ogg_app_id(&self) -> bool {
                self.ogg_app_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_ogg_app_id(&mut self, v: u32) {
                self.ogg_app_id = ::std::option::Option::Some(v);
            }

            // optional uint64 chat_group_id = 2;

            pub fn chat_group_id(&self) -> u64 {
                self.chat_group_id.unwrap_or(0)
            }

            pub fn clear_chat_group_id(&mut self) {
                self.chat_group_id = ::std::option::Option::None;
            }

            pub fn has_chat_group_id(&self) -> bool {
                self.chat_group_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_chat_group_id(&mut self, v: u64) {
                self.chat_group_id = ::std::option::Option::Some(v);
            }
        }

        impl ::protobuf::Message for ClanData {
            const NAME: &'static str = "ClanData";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.ogg_app_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        16 => {
                            self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.ogg_app_id {
                    my_size += ::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.chat_group_id {
                    my_size += ::protobuf::rt::uint64_size(2, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.ogg_app_id {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.chat_group_id {
                    os.write_uint64(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ClanData {
                ClanData::new()
            }

            fn clear(&mut self) {
                self.ogg_app_id = ::std::option::Option::None;
                self.chat_group_id = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ClanData {
                static instance: ClanData = ClanData {
                    ogg_app_id: ::std::option::Option::None,
                    chat_group_id: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        // @@protoc_insertion_point(message:CMsgClientPersonaState.Friend.KV)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct KV {
            // message fields
            // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.KV.key)
            pub key: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:CMsgClientPersonaState.Friend.KV.value)
            pub value: ::std::option::Option<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:CMsgClientPersonaState.Friend.KV.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a KV {
            fn default() -> &'a KV {
                <KV as ::protobuf::Message>::default_instance()
            }
        }

        impl KV {
            pub fn new() -> KV {
                ::std::default::Default::default()
            }

            // optional string key = 1;

            pub fn key(&self) -> &str {
                match self.key.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_key(&mut self) {
                self.key = ::std::option::Option::None;
            }

            pub fn has_key(&self) -> bool {
                self.key.is_some()
            }

            // Param is passed by value, moved
            pub fn set_key(&mut self, v: ::std::string::String) {
                self.key = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_key(&mut self) -> &mut ::std::string::String {
                if self.key.is_none() {
                    self.key = ::std::option::Option::Some(::std::string::String::new());
                }
                self.key.as_mut().unwrap()
            }

            // Take field
            pub fn take_key(&mut self) -> ::std::string::String {
                self.key.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional string value = 2;

            pub fn value(&self) -> &str {
                match self.value.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_value(&mut self) {
                self.value = ::std::option::Option::None;
            }

            pub fn has_value(&self) -> bool {
                self.value.is_some()
            }

            // Param is passed by value, moved
            pub fn set_value(&mut self, v: ::std::string::String) {
                self.value = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_value(&mut self) -> &mut ::std::string::String {
                if self.value.is_none() {
                    self.value = ::std::option::Option::Some(::std::string::String::new());
                }
                self.value.as_mut().unwrap()
            }

            // Take field
            pub fn take_value(&mut self) -> ::std::string::String {
                self.value.take().unwrap_or_else(|| ::std::string::String::new())
            }
        }

        impl ::protobuf::Message for KV {
            const NAME: &'static str = "KV";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.key = ::std::option::Option::Some(is.read_string()?);
                        },
                        18 => {
                            self.value = ::std::option::Option::Some(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.key.as_ref() {
                    my_size += ::protobuf::rt::string_size(1, &v);
                }
                if let Some(v) = self.value.as_ref() {
                    my_size += ::protobuf::rt::string_size(2, &v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.key.as_ref() {
                    os.write_string(1, v)?;
                }
                if let Some(v) = self.value.as_ref() {
                    os.write_string(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> KV {
                KV::new()
            }

            fn clear(&mut self) {
                self.key = ::std::option::Option::None;
                self.value = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static KV {
                static instance: KV = KV {
                    key: ::std::option::Option::None,
                    value: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientFriendProfileInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientFriendProfileInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientFriendProfileInfo.steamid_friend)
    pub steamid_friend: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientFriendProfileInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientFriendProfileInfo {
    fn default() -> &'a CMsgClientFriendProfileInfo {
        <CMsgClientFriendProfileInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientFriendProfileInfo {
    pub fn new() -> CMsgClientFriendProfileInfo {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_friend = 1;

    pub fn steamid_friend(&self) -> u64 {
        self.steamid_friend.unwrap_or(0)
    }

    pub fn clear_steamid_friend(&mut self) {
        self.steamid_friend = ::std::option::Option::None;
    }

    pub fn has_steamid_friend(&self) -> bool {
        self.steamid_friend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_friend(&mut self, v: u64) {
        self.steamid_friend = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientFriendProfileInfo {
    const NAME: &'static str = "CMsgClientFriendProfileInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid_friend = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_friend {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid_friend {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientFriendProfileInfo {
        CMsgClientFriendProfileInfo::new()
    }

    fn clear(&mut self) {
        self.steamid_friend = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientFriendProfileInfo {
        static instance: CMsgClientFriendProfileInfo = CMsgClientFriendProfileInfo {
            steamid_friend: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientFriendProfileInfoResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientFriendProfileInfoResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientFriendProfileInfoResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientFriendProfileInfoResponse.steamid_friend)
    pub steamid_friend: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientFriendProfileInfoResponse.time_created)
    pub time_created: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientFriendProfileInfoResponse.real_name)
    pub real_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientFriendProfileInfoResponse.city_name)
    pub city_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientFriendProfileInfoResponse.state_name)
    pub state_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientFriendProfileInfoResponse.country_name)
    pub country_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientFriendProfileInfoResponse.headline)
    pub headline: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientFriendProfileInfoResponse.summary)
    pub summary: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientFriendProfileInfoResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientFriendProfileInfoResponse {
    fn default() -> &'a CMsgClientFriendProfileInfoResponse {
        <CMsgClientFriendProfileInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientFriendProfileInfoResponse {
    pub fn new() -> CMsgClientFriendProfileInfoResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid_friend = 2;

    pub fn steamid_friend(&self) -> u64 {
        self.steamid_friend.unwrap_or(0)
    }

    pub fn clear_steamid_friend(&mut self) {
        self.steamid_friend = ::std::option::Option::None;
    }

    pub fn has_steamid_friend(&self) -> bool {
        self.steamid_friend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_friend(&mut self, v: u64) {
        self.steamid_friend = ::std::option::Option::Some(v);
    }

    // optional uint32 time_created = 3;

    pub fn time_created(&self) -> u32 {
        self.time_created.unwrap_or(0)
    }

    pub fn clear_time_created(&mut self) {
        self.time_created = ::std::option::Option::None;
    }

    pub fn has_time_created(&self) -> bool {
        self.time_created.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_created(&mut self, v: u32) {
        self.time_created = ::std::option::Option::Some(v);
    }

    // optional string real_name = 4;

    pub fn real_name(&self) -> &str {
        match self.real_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_real_name(&mut self) {
        self.real_name = ::std::option::Option::None;
    }

    pub fn has_real_name(&self) -> bool {
        self.real_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_real_name(&mut self, v: ::std::string::String) {
        self.real_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_real_name(&mut self) -> &mut ::std::string::String {
        if self.real_name.is_none() {
            self.real_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.real_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_real_name(&mut self) -> ::std::string::String {
        self.real_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string city_name = 5;

    pub fn city_name(&self) -> &str {
        match self.city_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_city_name(&mut self) {
        self.city_name = ::std::option::Option::None;
    }

    pub fn has_city_name(&self) -> bool {
        self.city_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_city_name(&mut self, v: ::std::string::String) {
        self.city_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_city_name(&mut self) -> &mut ::std::string::String {
        if self.city_name.is_none() {
            self.city_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.city_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_city_name(&mut self) -> ::std::string::String {
        self.city_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string state_name = 6;

    pub fn state_name(&self) -> &str {
        match self.state_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_state_name(&mut self) {
        self.state_name = ::std::option::Option::None;
    }

    pub fn has_state_name(&self) -> bool {
        self.state_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state_name(&mut self, v: ::std::string::String) {
        self.state_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state_name(&mut self) -> &mut ::std::string::String {
        if self.state_name.is_none() {
            self.state_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.state_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_state_name(&mut self) -> ::std::string::String {
        self.state_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string country_name = 7;

    pub fn country_name(&self) -> &str {
        match self.country_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_country_name(&mut self) {
        self.country_name = ::std::option::Option::None;
    }

    pub fn has_country_name(&self) -> bool {
        self.country_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country_name(&mut self, v: ::std::string::String) {
        self.country_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_name(&mut self) -> &mut ::std::string::String {
        if self.country_name.is_none() {
            self.country_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.country_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_country_name(&mut self) -> ::std::string::String {
        self.country_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string headline = 8;

    pub fn headline(&self) -> &str {
        match self.headline.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_headline(&mut self) {
        self.headline = ::std::option::Option::None;
    }

    pub fn has_headline(&self) -> bool {
        self.headline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_headline(&mut self, v: ::std::string::String) {
        self.headline = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_headline(&mut self) -> &mut ::std::string::String {
        if self.headline.is_none() {
            self.headline = ::std::option::Option::Some(::std::string::String::new());
        }
        self.headline.as_mut().unwrap()
    }

    // Take field
    pub fn take_headline(&mut self) -> ::std::string::String {
        self.headline.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string summary = 9;

    pub fn summary(&self) -> &str {
        match self.summary.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_summary(&mut self) {
        self.summary = ::std::option::Option::None;
    }

    pub fn has_summary(&self) -> bool {
        self.summary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_summary(&mut self, v: ::std::string::String) {
        self.summary = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_summary(&mut self) -> &mut ::std::string::String {
        if self.summary.is_none() {
            self.summary = ::std::option::Option::Some(::std::string::String::new());
        }
        self.summary.as_mut().unwrap()
    }

    // Take field
    pub fn take_summary(&mut self) -> ::std::string::String {
        self.summary.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientFriendProfileInfoResponse {
    const NAME: &'static str = "CMsgClientFriendProfileInfoResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                17 => {
                    self.steamid_friend = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.time_created = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.real_name = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.city_name = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.state_name = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.country_name = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.headline = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.summary = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.steamid_friend {
            my_size += 1 + 8;
        }
        if let Some(v) = self.time_created {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.real_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.city_name.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.state_name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.country_name.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.headline.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.summary.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.steamid_friend {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.time_created {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.real_name.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.city_name.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.state_name.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.country_name.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.headline.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.summary.as_ref() {
            os.write_string(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientFriendProfileInfoResponse {
        CMsgClientFriendProfileInfoResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.steamid_friend = ::std::option::Option::None;
        self.time_created = ::std::option::Option::None;
        self.real_name = ::std::option::Option::None;
        self.city_name = ::std::option::Option::None;
        self.state_name = ::std::option::Option::None;
        self.country_name = ::std::option::Option::None;
        self.headline = ::std::option::Option::None;
        self.summary = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientFriendProfileInfoResponse {
        static instance: CMsgClientFriendProfileInfoResponse = CMsgClientFriendProfileInfoResponse {
            eresult: ::std::option::Option::None,
            steamid_friend: ::std::option::Option::None,
            time_created: ::std::option::Option::None,
            real_name: ::std::option::Option::None,
            city_name: ::std::option::Option::None,
            state_name: ::std::option::Option::None,
            country_name: ::std::option::Option::None,
            headline: ::std::option::Option::None,
            summary: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientCreateFriendsGroup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientCreateFriendsGroup {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientCreateFriendsGroup.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientCreateFriendsGroup.groupname)
    pub groupname: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientCreateFriendsGroup.steamid_friends)
    pub steamid_friends: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientCreateFriendsGroup.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientCreateFriendsGroup {
    fn default() -> &'a CMsgClientCreateFriendsGroup {
        <CMsgClientCreateFriendsGroup as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientCreateFriendsGroup {
    pub fn new() -> CMsgClientCreateFriendsGroup {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional string groupname = 2;

    pub fn groupname(&self) -> &str {
        match self.groupname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_groupname(&mut self) {
        self.groupname = ::std::option::Option::None;
    }

    pub fn has_groupname(&self) -> bool {
        self.groupname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupname(&mut self, v: ::std::string::String) {
        self.groupname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groupname(&mut self) -> &mut ::std::string::String {
        if self.groupname.is_none() {
            self.groupname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.groupname.as_mut().unwrap()
    }

    // Take field
    pub fn take_groupname(&mut self) -> ::std::string::String {
        self.groupname.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientCreateFriendsGroup {
    const NAME: &'static str = "CMsgClientCreateFriendsGroup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    self.groupname = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    is.read_repeated_packed_fixed64_into(&mut self.steamid_friends)?;
                },
                25 => {
                    self.steamid_friends.push(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.groupname.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += 9 * self.steamid_friends.len() as u64;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.groupname.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.steamid_friends {
            os.write_fixed64(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientCreateFriendsGroup {
        CMsgClientCreateFriendsGroup::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.groupname = ::std::option::Option::None;
        self.steamid_friends.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientCreateFriendsGroup {
        static instance: CMsgClientCreateFriendsGroup = CMsgClientCreateFriendsGroup {
            steamid: ::std::option::Option::None,
            groupname: ::std::option::Option::None,
            steamid_friends: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientCreateFriendsGroupResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientCreateFriendsGroupResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientCreateFriendsGroupResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientCreateFriendsGroupResponse.groupid)
    pub groupid: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientCreateFriendsGroupResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientCreateFriendsGroupResponse {
    fn default() -> &'a CMsgClientCreateFriendsGroupResponse {
        <CMsgClientCreateFriendsGroupResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientCreateFriendsGroupResponse {
    pub fn new() -> CMsgClientCreateFriendsGroupResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional int32 groupid = 2;

    pub fn groupid(&self) -> i32 {
        self.groupid.unwrap_or(0)
    }

    pub fn clear_groupid(&mut self) {
        self.groupid = ::std::option::Option::None;
    }

    pub fn has_groupid(&self) -> bool {
        self.groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupid(&mut self, v: i32) {
        self.groupid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientCreateFriendsGroupResponse {
    const NAME: &'static str = "CMsgClientCreateFriendsGroupResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.groupid = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.groupid {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.groupid {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientCreateFriendsGroupResponse {
        CMsgClientCreateFriendsGroupResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.groupid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientCreateFriendsGroupResponse {
        static instance: CMsgClientCreateFriendsGroupResponse = CMsgClientCreateFriendsGroupResponse {
            eresult: ::std::option::Option::None,
            groupid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientDeleteFriendsGroup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientDeleteFriendsGroup {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientDeleteFriendsGroup.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientDeleteFriendsGroup.groupid)
    pub groupid: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientDeleteFriendsGroup.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientDeleteFriendsGroup {
    fn default() -> &'a CMsgClientDeleteFriendsGroup {
        <CMsgClientDeleteFriendsGroup as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientDeleteFriendsGroup {
    pub fn new() -> CMsgClientDeleteFriendsGroup {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional int32 groupid = 2;

    pub fn groupid(&self) -> i32 {
        self.groupid.unwrap_or(0)
    }

    pub fn clear_groupid(&mut self) {
        self.groupid = ::std::option::Option::None;
    }

    pub fn has_groupid(&self) -> bool {
        self.groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupid(&mut self, v: i32) {
        self.groupid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientDeleteFriendsGroup {
    const NAME: &'static str = "CMsgClientDeleteFriendsGroup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.groupid = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.groupid {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.groupid {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientDeleteFriendsGroup {
        CMsgClientDeleteFriendsGroup::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.groupid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientDeleteFriendsGroup {
        static instance: CMsgClientDeleteFriendsGroup = CMsgClientDeleteFriendsGroup {
            steamid: ::std::option::Option::None,
            groupid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientDeleteFriendsGroupResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientDeleteFriendsGroupResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientDeleteFriendsGroupResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientDeleteFriendsGroupResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientDeleteFriendsGroupResponse {
    fn default() -> &'a CMsgClientDeleteFriendsGroupResponse {
        <CMsgClientDeleteFriendsGroupResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientDeleteFriendsGroupResponse {
    pub fn new() -> CMsgClientDeleteFriendsGroupResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientDeleteFriendsGroupResponse {
    const NAME: &'static str = "CMsgClientDeleteFriendsGroupResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientDeleteFriendsGroupResponse {
        CMsgClientDeleteFriendsGroupResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientDeleteFriendsGroupResponse {
        static instance: CMsgClientDeleteFriendsGroupResponse = CMsgClientDeleteFriendsGroupResponse {
            eresult: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientManageFriendsGroup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientManageFriendsGroup {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientManageFriendsGroup.groupid)
    pub groupid: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientManageFriendsGroup.groupname)
    pub groupname: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientManageFriendsGroup.steamid_friends_added)
    pub steamid_friends_added: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CMsgClientManageFriendsGroup.steamid_friends_removed)
    pub steamid_friends_removed: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientManageFriendsGroup.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientManageFriendsGroup {
    fn default() -> &'a CMsgClientManageFriendsGroup {
        <CMsgClientManageFriendsGroup as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientManageFriendsGroup {
    pub fn new() -> CMsgClientManageFriendsGroup {
        ::std::default::Default::default()
    }

    // optional int32 groupid = 1;

    pub fn groupid(&self) -> i32 {
        self.groupid.unwrap_or(0)
    }

    pub fn clear_groupid(&mut self) {
        self.groupid = ::std::option::Option::None;
    }

    pub fn has_groupid(&self) -> bool {
        self.groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupid(&mut self, v: i32) {
        self.groupid = ::std::option::Option::Some(v);
    }

    // optional string groupname = 2;

    pub fn groupname(&self) -> &str {
        match self.groupname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_groupname(&mut self) {
        self.groupname = ::std::option::Option::None;
    }

    pub fn has_groupname(&self) -> bool {
        self.groupname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupname(&mut self, v: ::std::string::String) {
        self.groupname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groupname(&mut self) -> &mut ::std::string::String {
        if self.groupname.is_none() {
            self.groupname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.groupname.as_mut().unwrap()
    }

    // Take field
    pub fn take_groupname(&mut self) -> ::std::string::String {
        self.groupname.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientManageFriendsGroup {
    const NAME: &'static str = "CMsgClientManageFriendsGroup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.groupid = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.groupname = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    is.read_repeated_packed_fixed64_into(&mut self.steamid_friends_added)?;
                },
                25 => {
                    self.steamid_friends_added.push(is.read_fixed64()?);
                },
                34 => {
                    is.read_repeated_packed_fixed64_into(&mut self.steamid_friends_removed)?;
                },
                33 => {
                    self.steamid_friends_removed.push(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.groupid {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.groupname.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += 9 * self.steamid_friends_added.len() as u64;
        my_size += 9 * self.steamid_friends_removed.len() as u64;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.groupid {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.groupname.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.steamid_friends_added {
            os.write_fixed64(3, *v)?;
        };
        for v in &self.steamid_friends_removed {
            os.write_fixed64(4, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientManageFriendsGroup {
        CMsgClientManageFriendsGroup::new()
    }

    fn clear(&mut self) {
        self.groupid = ::std::option::Option::None;
        self.groupname = ::std::option::Option::None;
        self.steamid_friends_added.clear();
        self.steamid_friends_removed.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientManageFriendsGroup {
        static instance: CMsgClientManageFriendsGroup = CMsgClientManageFriendsGroup {
            groupid: ::std::option::Option::None,
            groupname: ::std::option::Option::None,
            steamid_friends_added: ::std::vec::Vec::new(),
            steamid_friends_removed: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientManageFriendsGroupResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientManageFriendsGroupResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientManageFriendsGroupResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientManageFriendsGroupResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientManageFriendsGroupResponse {
    fn default() -> &'a CMsgClientManageFriendsGroupResponse {
        <CMsgClientManageFriendsGroupResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientManageFriendsGroupResponse {
    pub fn new() -> CMsgClientManageFriendsGroupResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientManageFriendsGroupResponse {
    const NAME: &'static str = "CMsgClientManageFriendsGroupResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientManageFriendsGroupResponse {
        CMsgClientManageFriendsGroupResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientManageFriendsGroupResponse {
        static instance: CMsgClientManageFriendsGroupResponse = CMsgClientManageFriendsGroupResponse {
            eresult: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientAddFriendToGroup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientAddFriendToGroup {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientAddFriendToGroup.groupid)
    pub groupid: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientAddFriendToGroup.steamiduser)
    pub steamiduser: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientAddFriendToGroup.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientAddFriendToGroup {
    fn default() -> &'a CMsgClientAddFriendToGroup {
        <CMsgClientAddFriendToGroup as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAddFriendToGroup {
    pub fn new() -> CMsgClientAddFriendToGroup {
        ::std::default::Default::default()
    }

    // optional int32 groupid = 1;

    pub fn groupid(&self) -> i32 {
        self.groupid.unwrap_or(0)
    }

    pub fn clear_groupid(&mut self) {
        self.groupid = ::std::option::Option::None;
    }

    pub fn has_groupid(&self) -> bool {
        self.groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupid(&mut self, v: i32) {
        self.groupid = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamiduser = 2;

    pub fn steamiduser(&self) -> u64 {
        self.steamiduser.unwrap_or(0)
    }

    pub fn clear_steamiduser(&mut self) {
        self.steamiduser = ::std::option::Option::None;
    }

    pub fn has_steamiduser(&self) -> bool {
        self.steamiduser.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamiduser(&mut self, v: u64) {
        self.steamiduser = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientAddFriendToGroup {
    const NAME: &'static str = "CMsgClientAddFriendToGroup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.groupid = ::std::option::Option::Some(is.read_int32()?);
                },
                17 => {
                    self.steamiduser = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.groupid {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.steamiduser {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.groupid {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.steamiduser {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientAddFriendToGroup {
        CMsgClientAddFriendToGroup::new()
    }

    fn clear(&mut self) {
        self.groupid = ::std::option::Option::None;
        self.steamiduser = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientAddFriendToGroup {
        static instance: CMsgClientAddFriendToGroup = CMsgClientAddFriendToGroup {
            groupid: ::std::option::Option::None,
            steamiduser: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientAddFriendToGroupResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientAddFriendToGroupResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientAddFriendToGroupResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientAddFriendToGroupResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientAddFriendToGroupResponse {
    fn default() -> &'a CMsgClientAddFriendToGroupResponse {
        <CMsgClientAddFriendToGroupResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAddFriendToGroupResponse {
    pub fn new() -> CMsgClientAddFriendToGroupResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientAddFriendToGroupResponse {
    const NAME: &'static str = "CMsgClientAddFriendToGroupResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientAddFriendToGroupResponse {
        CMsgClientAddFriendToGroupResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientAddFriendToGroupResponse {
        static instance: CMsgClientAddFriendToGroupResponse = CMsgClientAddFriendToGroupResponse {
            eresult: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientRemoveFriendFromGroup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRemoveFriendFromGroup {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRemoveFriendFromGroup.groupid)
    pub groupid: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientRemoveFriendFromGroup.steamiduser)
    pub steamiduser: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRemoveFriendFromGroup.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRemoveFriendFromGroup {
    fn default() -> &'a CMsgClientRemoveFriendFromGroup {
        <CMsgClientRemoveFriendFromGroup as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRemoveFriendFromGroup {
    pub fn new() -> CMsgClientRemoveFriendFromGroup {
        ::std::default::Default::default()
    }

    // optional int32 groupid = 1;

    pub fn groupid(&self) -> i32 {
        self.groupid.unwrap_or(0)
    }

    pub fn clear_groupid(&mut self) {
        self.groupid = ::std::option::Option::None;
    }

    pub fn has_groupid(&self) -> bool {
        self.groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupid(&mut self, v: i32) {
        self.groupid = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamiduser = 2;

    pub fn steamiduser(&self) -> u64 {
        self.steamiduser.unwrap_or(0)
    }

    pub fn clear_steamiduser(&mut self) {
        self.steamiduser = ::std::option::Option::None;
    }

    pub fn has_steamiduser(&self) -> bool {
        self.steamiduser.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamiduser(&mut self, v: u64) {
        self.steamiduser = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientRemoveFriendFromGroup {
    const NAME: &'static str = "CMsgClientRemoveFriendFromGroup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.groupid = ::std::option::Option::Some(is.read_int32()?);
                },
                17 => {
                    self.steamiduser = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.groupid {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.steamiduser {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.groupid {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.steamiduser {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRemoveFriendFromGroup {
        CMsgClientRemoveFriendFromGroup::new()
    }

    fn clear(&mut self) {
        self.groupid = ::std::option::Option::None;
        self.steamiduser = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRemoveFriendFromGroup {
        static instance: CMsgClientRemoveFriendFromGroup = CMsgClientRemoveFriendFromGroup {
            groupid: ::std::option::Option::None,
            steamiduser: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientRemoveFriendFromGroupResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRemoveFriendFromGroupResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRemoveFriendFromGroupResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRemoveFriendFromGroupResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRemoveFriendFromGroupResponse {
    fn default() -> &'a CMsgClientRemoveFriendFromGroupResponse {
        <CMsgClientRemoveFriendFromGroupResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRemoveFriendFromGroupResponse {
    pub fn new() -> CMsgClientRemoveFriendFromGroupResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientRemoveFriendFromGroupResponse {
    const NAME: &'static str = "CMsgClientRemoveFriendFromGroupResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRemoveFriendFromGroupResponse {
        CMsgClientRemoveFriendFromGroupResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRemoveFriendFromGroupResponse {
        static instance: CMsgClientRemoveFriendFromGroupResponse = CMsgClientRemoveFriendFromGroupResponse {
            eresult: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientGetEmoticonList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGetEmoticonList {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetEmoticonList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetEmoticonList {
    fn default() -> &'a CMsgClientGetEmoticonList {
        <CMsgClientGetEmoticonList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetEmoticonList {
    pub fn new() -> CMsgClientGetEmoticonList {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientGetEmoticonList {
    const NAME: &'static str = "CMsgClientGetEmoticonList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetEmoticonList {
        CMsgClientGetEmoticonList::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetEmoticonList {
        static instance: CMsgClientGetEmoticonList = CMsgClientGetEmoticonList {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientEmoticonList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientEmoticonList {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientEmoticonList.emoticons)
    pub emoticons: ::std::vec::Vec<cmsg_client_emoticon_list::Emoticon>,
    // @@protoc_insertion_point(field:CMsgClientEmoticonList.stickers)
    pub stickers: ::std::vec::Vec<cmsg_client_emoticon_list::Sticker>,
    // @@protoc_insertion_point(field:CMsgClientEmoticonList.effects)
    pub effects: ::std::vec::Vec<cmsg_client_emoticon_list::Effect>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientEmoticonList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientEmoticonList {
    fn default() -> &'a CMsgClientEmoticonList {
        <CMsgClientEmoticonList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientEmoticonList {
    pub fn new() -> CMsgClientEmoticonList {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientEmoticonList {
    const NAME: &'static str = "CMsgClientEmoticonList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.emoticons.push(is.read_message()?);
                },
                18 => {
                    self.stickers.push(is.read_message()?);
                },
                26 => {
                    self.effects.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.emoticons {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.stickers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.effects {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.emoticons {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.stickers {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.effects {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientEmoticonList {
        CMsgClientEmoticonList::new()
    }

    fn clear(&mut self) {
        self.emoticons.clear();
        self.stickers.clear();
        self.effects.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientEmoticonList {
        static instance: CMsgClientEmoticonList = CMsgClientEmoticonList {
            emoticons: ::std::vec::Vec::new(),
            stickers: ::std::vec::Vec::new(),
            effects: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientEmoticonList`
pub mod cmsg_client_emoticon_list {
    // @@protoc_insertion_point(message:CMsgClientEmoticonList.Emoticon)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Emoticon {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientEmoticonList.Emoticon.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientEmoticonList.Emoticon.count)
        pub count: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientEmoticonList.Emoticon.time_last_used)
        pub time_last_used: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientEmoticonList.Emoticon.use_count)
        pub use_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientEmoticonList.Emoticon.time_received)
        pub time_received: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientEmoticonList.Emoticon.appid)
        pub appid: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientEmoticonList.Emoticon.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Emoticon {
        fn default() -> &'a Emoticon {
            <Emoticon as ::protobuf::Message>::default_instance()
        }
    }

    impl Emoticon {
        pub fn new() -> Emoticon {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 count = 2;

        pub fn count(&self) -> i32 {
            self.count.unwrap_or(0)
        }

        pub fn clear_count(&mut self) {
            self.count = ::std::option::Option::None;
        }

        pub fn has_count(&self) -> bool {
            self.count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_count(&mut self, v: i32) {
            self.count = ::std::option::Option::Some(v);
        }

        // optional uint32 time_last_used = 3;

        pub fn time_last_used(&self) -> u32 {
            self.time_last_used.unwrap_or(0)
        }

        pub fn clear_time_last_used(&mut self) {
            self.time_last_used = ::std::option::Option::None;
        }

        pub fn has_time_last_used(&self) -> bool {
            self.time_last_used.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_last_used(&mut self, v: u32) {
            self.time_last_used = ::std::option::Option::Some(v);
        }

        // optional uint32 use_count = 4;

        pub fn use_count(&self) -> u32 {
            self.use_count.unwrap_or(0)
        }

        pub fn clear_use_count(&mut self) {
            self.use_count = ::std::option::Option::None;
        }

        pub fn has_use_count(&self) -> bool {
            self.use_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_use_count(&mut self, v: u32) {
            self.use_count = ::std::option::Option::Some(v);
        }

        // optional uint32 time_received = 5;

        pub fn time_received(&self) -> u32 {
            self.time_received.unwrap_or(0)
        }

        pub fn clear_time_received(&mut self) {
            self.time_received = ::std::option::Option::None;
        }

        pub fn has_time_received(&self) -> bool {
            self.time_received.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_received(&mut self, v: u32) {
            self.time_received = ::std::option::Option::Some(v);
        }

        // optional uint32 appid = 6;

        pub fn appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Emoticon {
        const NAME: &'static str = "Emoticon";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.time_last_used = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.use_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.time_received = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.count {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.time_last_used {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.use_count {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.time_received {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.appid {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.count {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.time_last_used {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.use_count {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.time_received {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.appid {
                os.write_uint32(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Emoticon {
            Emoticon::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.count = ::std::option::Option::None;
            self.time_last_used = ::std::option::Option::None;
            self.use_count = ::std::option::Option::None;
            self.time_received = ::std::option::Option::None;
            self.appid = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Emoticon {
            static instance: Emoticon = Emoticon {
                name: ::std::option::Option::None,
                count: ::std::option::Option::None,
                time_last_used: ::std::option::Option::None,
                use_count: ::std::option::Option::None,
                time_received: ::std::option::Option::None,
                appid: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgClientEmoticonList.Sticker)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Sticker {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientEmoticonList.Sticker.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientEmoticonList.Sticker.count)
        pub count: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientEmoticonList.Sticker.time_received)
        pub time_received: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientEmoticonList.Sticker.appid)
        pub appid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientEmoticonList.Sticker.time_last_used)
        pub time_last_used: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientEmoticonList.Sticker.use_count)
        pub use_count: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientEmoticonList.Sticker.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Sticker {
        fn default() -> &'a Sticker {
            <Sticker as ::protobuf::Message>::default_instance()
        }
    }

    impl Sticker {
        pub fn new() -> Sticker {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 count = 2;

        pub fn count(&self) -> i32 {
            self.count.unwrap_or(0)
        }

        pub fn clear_count(&mut self) {
            self.count = ::std::option::Option::None;
        }

        pub fn has_count(&self) -> bool {
            self.count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_count(&mut self, v: i32) {
            self.count = ::std::option::Option::Some(v);
        }

        // optional uint32 time_received = 3;

        pub fn time_received(&self) -> u32 {
            self.time_received.unwrap_or(0)
        }

        pub fn clear_time_received(&mut self) {
            self.time_received = ::std::option::Option::None;
        }

        pub fn has_time_received(&self) -> bool {
            self.time_received.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_received(&mut self, v: u32) {
            self.time_received = ::std::option::Option::Some(v);
        }

        // optional uint32 appid = 4;

        pub fn appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }

        // optional uint32 time_last_used = 5;

        pub fn time_last_used(&self) -> u32 {
            self.time_last_used.unwrap_or(0)
        }

        pub fn clear_time_last_used(&mut self) {
            self.time_last_used = ::std::option::Option::None;
        }

        pub fn has_time_last_used(&self) -> bool {
            self.time_last_used.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_last_used(&mut self, v: u32) {
            self.time_last_used = ::std::option::Option::Some(v);
        }

        // optional uint32 use_count = 6;

        pub fn use_count(&self) -> u32 {
            self.use_count.unwrap_or(0)
        }

        pub fn clear_use_count(&mut self) {
            self.use_count = ::std::option::Option::None;
        }

        pub fn has_use_count(&self) -> bool {
            self.use_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_use_count(&mut self, v: u32) {
            self.use_count = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Sticker {
        const NAME: &'static str = "Sticker";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.time_received = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.time_last_used = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.use_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.count {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.time_received {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.appid {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.time_last_used {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.use_count {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.count {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.time_received {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.appid {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.time_last_used {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.use_count {
                os.write_uint32(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Sticker {
            Sticker::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.count = ::std::option::Option::None;
            self.time_received = ::std::option::Option::None;
            self.appid = ::std::option::Option::None;
            self.time_last_used = ::std::option::Option::None;
            self.use_count = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Sticker {
            static instance: Sticker = Sticker {
                name: ::std::option::Option::None,
                count: ::std::option::Option::None,
                time_received: ::std::option::Option::None,
                appid: ::std::option::Option::None,
                time_last_used: ::std::option::Option::None,
                use_count: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgClientEmoticonList.Effect)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Effect {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientEmoticonList.Effect.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientEmoticonList.Effect.count)
        pub count: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientEmoticonList.Effect.time_received)
        pub time_received: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientEmoticonList.Effect.infinite_use)
        pub infinite_use: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgClientEmoticonList.Effect.appid)
        pub appid: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientEmoticonList.Effect.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Effect {
        fn default() -> &'a Effect {
            <Effect as ::protobuf::Message>::default_instance()
        }
    }

    impl Effect {
        pub fn new() -> Effect {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 count = 2;

        pub fn count(&self) -> i32 {
            self.count.unwrap_or(0)
        }

        pub fn clear_count(&mut self) {
            self.count = ::std::option::Option::None;
        }

        pub fn has_count(&self) -> bool {
            self.count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_count(&mut self, v: i32) {
            self.count = ::std::option::Option::Some(v);
        }

        // optional uint32 time_received = 3;

        pub fn time_received(&self) -> u32 {
            self.time_received.unwrap_or(0)
        }

        pub fn clear_time_received(&mut self) {
            self.time_received = ::std::option::Option::None;
        }

        pub fn has_time_received(&self) -> bool {
            self.time_received.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_received(&mut self, v: u32) {
            self.time_received = ::std::option::Option::Some(v);
        }

        // optional bool infinite_use = 4;

        pub fn infinite_use(&self) -> bool {
            self.infinite_use.unwrap_or(false)
        }

        pub fn clear_infinite_use(&mut self) {
            self.infinite_use = ::std::option::Option::None;
        }

        pub fn has_infinite_use(&self) -> bool {
            self.infinite_use.is_some()
        }

        // Param is passed by value, moved
        pub fn set_infinite_use(&mut self, v: bool) {
            self.infinite_use = ::std::option::Option::Some(v);
        }

        // optional uint32 appid = 5;

        pub fn appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Effect {
        const NAME: &'static str = "Effect";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.time_received = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.infinite_use = ::std::option::Option::Some(is.read_bool()?);
                    },
                    40 => {
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.count {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.time_received {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.infinite_use {
                my_size += 1 + 1;
            }
            if let Some(v) = self.appid {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.count {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.time_received {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.infinite_use {
                os.write_bool(4, v)?;
            }
            if let Some(v) = self.appid {
                os.write_uint32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Effect {
            Effect::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.count = ::std::option::Option::None;
            self.time_received = ::std::option::Option::None;
            self.infinite_use = ::std::option::Option::None;
            self.appid = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Effect {
            static instance: Effect = Effect {
                name: ::std::option::Option::None,
                count: ::std::option::Option::None,
                time_received: ::std::option::Option::None,
                infinite_use: ::std::option::Option::None,
                appid: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}
#[allow(unused_imports)]
use crate::steammessages_base::*;
impl crate::RpcMessage for CMsgClientFriendMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientFriendMsg {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientFriendMsg;
}
impl crate::RpcMessage for CMsgClientFriendMsgIncoming {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientFriendMsgIncoming {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientFriendMsgIncoming;
}
impl crate::RpcMessage for CMsgClientAddFriend {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientAddFriend {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientAddFriend;
}
impl crate::RpcMessage for CMsgClientAddFriendResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientAddFriendResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientAddFriendResponse;
}
impl crate::RpcMessage for CMsgClientRemoveFriend {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientRemoveFriend {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientRemoveFriend;
}
impl crate::RpcMessage for CMsgClientHideFriend {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientHideFriend {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientHideFriend;
}
impl crate::RpcMessage for CMsgClientFriendsList {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientFriendsList {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientFriendsList;
}
impl crate::RpcMessage for CMsgClientFriendsGroupsList {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientFriendsGroupsList {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientFriendsGroupsList;
}
impl crate::RpcMessage for CMsgClientPlayerNicknameList {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientPlayerNicknameList {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientPlayerNicknameList;
}
impl crate::RpcMessage for CMsgClientSetPlayerNickname {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgClientSetPlayerNicknameResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgClientRequestFriendData {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientRequestFriendData {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientRequestFriendData;
}
impl crate::RpcMessage for CMsgClientChangeStatus {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientChangeStatus {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientChangeStatus;
}
impl crate::RpcMessage for CMsgPersonaChangeResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgClientPersonaState {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientPersonaState {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientPersonaState;
}
impl crate::RpcMessage for CMsgClientFriendProfileInfo {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientFriendProfileInfo {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientFriendProfileInfo;
}
impl crate::RpcMessage for CMsgClientFriendProfileInfoResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientFriendProfileInfoResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientFriendProfileInfoResponse;
}
impl crate::RpcMessage for CMsgClientCreateFriendsGroup {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgClientCreateFriendsGroupResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgClientDeleteFriendsGroup {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgClientDeleteFriendsGroupResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgClientManageFriendsGroup {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgClientManageFriendsGroupResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgClientAddFriendToGroup {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgClientAddFriendToGroupResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgClientRemoveFriendFromGroup {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgClientRemoveFriendFromGroupResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgClientGetEmoticonList {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientGetEmoticonList {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientGetEmoticonList;
}
impl crate::RpcMessage for CMsgClientEmoticonList {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientEmoticonList {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientEmoticonList;
}
